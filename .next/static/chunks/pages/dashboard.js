/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/dashboard"],{

/***/ "./node_modules/ag-charts-community/dist/package/main.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgChart: function() { return /* binding */ AgChart; },\n/* harmony export */   AgCharts: function() { return /* binding */ AgCharts; },\n/* harmony export */   AgErrorBarSupportedSeriesTypes: function() { return /* binding */ AgErrorBarSupportedSeriesTypes; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   _ModuleSupport: function() { return /* binding */ moduleSupport; },\n/* harmony export */   _Scale: function() { return /* binding */ sparklinesScale; },\n/* harmony export */   _Scene: function() { return /* binding */ integratedChartsScene; },\n/* harmony export */   _Theme: function() { return /* binding */ integratedChartsTheme; },\n/* harmony export */   _Util: function() { return /* binding */ sparklinesUtil; },\n/* harmony export */   __FORCE_MODULE_DETECTION: function() { return /* binding */ __FORCE_MODULE_DETECTION$1; },\n/* harmony export */   time: function() { return /* binding */ index; }\n/* harmony export */ });\nconst AgErrorBarSupportedSeriesTypes = ['bar', 'line', 'scatter'];\n\n/**\r\n * Internal Use Only: Used to ensure this file is treated as a module until we can use moduleDetection flag in Ts v4.7\r\n */\r\nconst __FORCE_MODULE_DETECTION$1 = 0;\n\n/**\r\n * The interval methods don't mutate Date parameters.\r\n */\r\nclass TimeInterval {\r\n    constructor(_encode, _decode, _rangeCallback) {\r\n        this._encode = _encode;\r\n        this._decode = _decode;\r\n        this._rangeCallback = _rangeCallback;\r\n    }\r\n    /**\r\n     * Returns a new date representing the latest interval boundary date before or equal to date.\r\n     * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\r\n     * @param date\r\n     */\r\n    floor(date) {\r\n        const d = new Date(date);\r\n        const e = this._encode(d);\r\n        return this._decode(e);\r\n    }\r\n    /**\r\n     * Returns a new date representing the earliest interval boundary date after or equal to date.\r\n     * @param date\r\n     */\r\n    ceil(date) {\r\n        const d = new Date(Number(date) - 1);\r\n        const e = this._encode(d);\r\n        return this._decode(e + 1);\r\n    }\r\n    /**\r\n     * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\r\n     * @param start Range start.\r\n     * @param stop Range end.\r\n     * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\r\n     */\r\n    range(start, stop, extend) {\r\n        var _a;\r\n        const rangeCallback = (_a = this._rangeCallback) === null || _a === void 0 ? void 0 : _a.call(this, start, stop);\r\n        const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));\r\n        const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\r\n        if (e1 < e0) {\r\n            return [];\r\n        }\r\n        const range = [];\r\n        for (let e = e0; e <= e1; e++) {\r\n            const d = this._decode(e);\r\n            range.push(d);\r\n        }\r\n        rangeCallback === null || rangeCallback === void 0 ? void 0 : rangeCallback();\r\n        return range;\r\n    }\r\n}\r\nclass CountableTimeInterval extends TimeInterval {\r\n    getOffset(snapTo, step) {\r\n        const s = typeof snapTo === 'number' || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\r\n        return Math.floor(s) % step;\r\n    }\r\n    /**\r\n     * Returns a filtered view of this interval representing every step'th date.\r\n     * It can be a number of minutes, hours, days etc.\r\n     * Must be a positive integer.\r\n     * @param step\r\n     */\r\n    every(step, options) {\r\n        let offset = 0;\r\n        let rangeCallback;\r\n        const { snapTo = 'start' } = options !== null && options !== void 0 ? options : {};\r\n        if (typeof snapTo === 'string') {\r\n            const initialOffset = offset;\r\n            rangeCallback = (start, stop) => {\r\n                const s = snapTo === 'start' ? start : stop;\r\n                offset = this.getOffset(s, step);\r\n                return () => (offset = initialOffset);\r\n            };\r\n        }\r\n        else if (typeof snapTo === 'number') {\r\n            offset = this.getOffset(new Date(snapTo), step);\r\n        }\r\n        else if (snapTo instanceof Date) {\r\n            offset = this.getOffset(snapTo, step);\r\n        }\r\n        const encode = (date) => {\r\n            const e = this._encode(date);\r\n            return Math.floor((e - offset) / step);\r\n        };\r\n        const decode = (encoded) => {\r\n            return this._decode(encoded * step + offset);\r\n        };\r\n        return new TimeInterval(encode, decode, rangeCallback);\r\n    }\r\n}\n\nfunction encode$b(date) {\r\n    return date.getTime();\r\n}\r\nfunction decode$b(encoded) {\r\n    return new Date(encoded);\r\n}\r\nconst millisecond = new CountableTimeInterval(encode$b, decode$b);\n\n// Common time unit sizes in milliseconds.\r\nnew Date(0).getFullYear();\r\nconst durationSecond = 1000;\r\nconst durationMinute = durationSecond * 60;\r\nconst durationHour = durationMinute * 60;\r\nconst durationDay = durationHour * 24;\r\nconst durationWeek = durationDay * 7;\r\nconst durationMonth = durationDay * 30;\r\nconst durationYear = durationDay * 365;\n\nconst offset$2 = new Date().getTimezoneOffset() * durationMinute;\r\nfunction encode$a(date) {\r\n    return Math.floor((date.getTime() - offset$2) / durationSecond);\r\n}\r\nfunction decode$a(encoded) {\r\n    return new Date(offset$2 + encoded * durationSecond);\r\n}\r\nconst second = new CountableTimeInterval(encode$a, decode$a);\n\nconst offset$1 = new Date().getTimezoneOffset() * durationMinute;\r\nfunction encode$9(date) {\r\n    return Math.floor((date.getTime() - offset$1) / durationMinute);\r\n}\r\nfunction decode$9(encoded) {\r\n    return new Date(offset$1 + encoded * durationMinute);\r\n}\r\nconst minute = new CountableTimeInterval(encode$9, decode$9);\n\nconst offset = new Date().getTimezoneOffset() * durationMinute;\r\nfunction encode$8(date) {\r\n    return Math.floor((date.getTime() - offset) / durationHour);\r\n}\r\nfunction decode$8(encoded) {\r\n    return new Date(offset + encoded * durationHour);\r\n}\r\nconst hour = new CountableTimeInterval(encode$8, decode$8);\n\nfunction encode$7(date) {\r\n    const tzOffsetMs = date.getTimezoneOffset() * 60000;\r\n    return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\r\n}\r\nfunction decode$7(encoded) {\r\n    const d = new Date(1970, 0, 1);\r\n    d.setDate(d.getDate() + encoded);\r\n    return d;\r\n}\r\nconst day = new CountableTimeInterval(encode$7, decode$7);\n\n// Set date to n-th day of the week.\r\nfunction weekday(n) {\r\n    const base = new Date(2023, 0, 1 + n).getTime();\r\n    function encode(date) {\r\n        const dateMs = date.getTime();\r\n        return Math.floor((dateMs - base) / durationWeek);\r\n    }\r\n    function decode(encoded) {\r\n        const d = new Date(base);\r\n        d.setDate(d.getDate() + encoded * 7);\r\n        return d;\r\n    }\r\n    return new CountableTimeInterval(encode, decode);\r\n}\r\nconst sunday = weekday(0);\r\nconst monday = weekday(1);\r\nconst tuesday = weekday(2);\r\nconst wednesday = weekday(3);\r\nconst thursday = weekday(4);\r\nconst friday = weekday(5);\r\nconst saturday = weekday(6);\n\nfunction encode$6(date) {\r\n    return date.getFullYear() * 12 + date.getMonth();\r\n}\r\nfunction decode$6(encoded) {\r\n    const year = Math.floor(encoded / 12);\r\n    const month = encoded - year * 12;\r\n    return new Date(year, month, 1);\r\n}\r\nconst month = new CountableTimeInterval(encode$6, decode$6);\n\nfunction encode$5(date) {\r\n    return date.getFullYear();\r\n}\r\nfunction decode$5(encoded) {\r\n    // Note: assigning years through the constructor\r\n    // will break for years 0 - 99 AD (will turn 1900's).\r\n    const d = new Date();\r\n    d.setFullYear(encoded);\r\n    d.setMonth(0, 1);\r\n    d.setHours(0, 0, 0, 0);\r\n    return d;\r\n}\r\nconst year = new CountableTimeInterval(encode$5, decode$5);\n\nfunction encode$4(date) {\r\n    return Math.floor(date.getTime() / durationMinute);\r\n}\r\nfunction decode$4(encoded) {\r\n    return new Date(encoded * durationMinute);\r\n}\r\nconst utcMinute = new CountableTimeInterval(encode$4, decode$4);\n\nfunction encode$3(date) {\r\n    return Math.floor(date.getTime() / durationHour);\r\n}\r\nfunction decode$3(encoded) {\r\n    return new Date(encoded * durationHour);\r\n}\r\nconst utcHour = new CountableTimeInterval(encode$3, decode$3);\n\nfunction encode$2(date) {\r\n    return Math.floor(date.getTime() / durationDay);\r\n}\r\nfunction decode$2(encoded) {\r\n    const d = new Date(0);\r\n    d.setUTCDate(d.getUTCDate() + encoded);\r\n    d.setUTCHours(0, 0, 0, 0);\r\n    return d;\r\n}\r\nconst utcDay = new CountableTimeInterval(encode$2, decode$2);\n\nfunction encode$1(date) {\r\n    return date.getUTCFullYear() * 12 + date.getUTCMonth();\r\n}\r\nfunction decode$1(encoded) {\r\n    const year = Math.floor(encoded / 12);\r\n    const month = encoded - year * 12;\r\n    return new Date(Date.UTC(year, month, 1));\r\n}\r\nconst utcMonth = new CountableTimeInterval(encode$1, decode$1);\n\nfunction encode(date) {\r\n    return date.getUTCFullYear();\r\n}\r\nfunction decode(encoded) {\r\n    // Note: assigning years through the constructor\r\n    // will break for years 0 - 99 AD (will turn 1900's).\r\n    const d = new Date();\r\n    d.setUTCFullYear(encoded);\r\n    d.setUTCMonth(0, 1);\r\n    d.setUTCHours(0, 0, 0, 0);\r\n    return d;\r\n}\r\nconst utcYear = new CountableTimeInterval(encode, decode);\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    millisecond: millisecond,\n    second: second,\n    minute: minute,\n    hour: hour,\n    day: day,\n    sunday: sunday,\n    monday: monday,\n    tuesday: tuesday,\n    wednesday: wednesday,\n    thursday: thursday,\n    friday: friday,\n    saturday: saturday,\n    month: month,\n    year: year,\n    utcMinute: utcMinute,\n    utcHour: utcHour,\n    utcDay: utcDay,\n    utcMonth: utcMonth,\n    utcYear: utcYear\n});\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst enterpriseModule = {\r\n    isEnterprise: false,\r\n};\n\nclass BaseModuleInstance {\r\n    constructor() {\r\n        this.destroyFns = [];\r\n    }\r\n    destroy() {\r\n        for (const destroyFn of this.destroyFns) {\r\n            destroyFn();\r\n        }\r\n    }\r\n}\r\nconst REGISTERED_MODULES = [];\r\nfunction registerModule(module) {\r\n    const otherModule = REGISTERED_MODULES.find((other) => {\r\n        return (module.type === other.type &&\r\n            module.optionsKey === other.optionsKey &&\r\n            module.identifier === other.identifier);\r\n    });\r\n    if (otherModule) {\r\n        if (module.packageType === 'enterprise' && otherModule.packageType === 'community') {\r\n            // Replace the community module with an enterprise version\r\n            const index = REGISTERED_MODULES.indexOf(otherModule);\r\n            REGISTERED_MODULES.splice(index, 1, module);\r\n        }\r\n    }\r\n    else {\r\n        // Simply register the module\r\n        REGISTERED_MODULES.push(module);\r\n    }\r\n}\r\nfunction hasRegisteredEnterpriseModules() {\r\n    return REGISTERED_MODULES.some((m) => m.packageType === 'enterprise');\r\n}\r\nconst MODULE_CONFLICTS = new Map();\r\nfunction registerModuleConflicts(source, targets) {\r\n    MODULE_CONFLICTS.set(source, targets);\r\n}\n\nfunction extent(values) {\r\n    const { length } = values;\r\n    if (length === 0) {\r\n        return undefined;\r\n    }\r\n    let min = Infinity;\r\n    let max = -Infinity;\r\n    for (let i = 0; i < length; i++) {\r\n        let v = values[i];\r\n        if (v instanceof Date) {\r\n            v = v.getTime();\r\n        }\r\n        if (typeof v !== 'number') {\r\n            continue;\r\n        }\r\n        if (v < min) {\r\n            min = v;\r\n        }\r\n        if (v > max) {\r\n            max = v;\r\n        }\r\n    }\r\n    const extent = [min, max];\r\n    if (extent.some((v) => !isFinite(v))) {\r\n        return undefined;\r\n    }\r\n    return extent;\r\n}\r\nfunction normalisedExtent(d, min, max) {\r\n    return normalisedExtentWithMetadata(d, min, max).extent;\r\n}\r\nfunction normalisedExtentWithMetadata(d, min, max) {\r\n    var _a;\r\n    let clipped = false;\r\n    if (d.length > 2) {\r\n        d = (_a = extent(d)) !== null && _a !== void 0 ? _a : [NaN, NaN];\r\n    }\r\n    if (!isNaN(min)) {\r\n        clipped || (clipped = min > d[0]);\r\n        d = [min, d[1]];\r\n    }\r\n    if (!isNaN(max)) {\r\n        clipped || (clipped = max < d[1]);\r\n        d = [d[0], max];\r\n    }\r\n    if (d[0] > d[1]) {\r\n        d = [];\r\n    }\r\n    return { extent: d, clipped };\r\n}\r\nfunction arraysEqual(a, b) {\r\n    if (a == null || b == null || a.length !== b.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n        if (Array.isArray(a[i]) && Array.isArray(b[i])) {\r\n            if (!arraysEqual(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (a[i] !== b[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction toArray(value) {\r\n    if (typeof value === 'undefined') {\r\n        return [];\r\n    }\r\n    return Array.isArray(value) ? value : [value];\r\n}\n\nconst doOnceFlags = {};\r\n/**\r\n * If the key was passed before, then doesn't execute the func\r\n */\r\nfunction doOnce(func, key) {\r\n    if (doOnceFlags[key]) {\r\n        return;\r\n    }\r\n    func();\r\n    doOnceFlags[key] = true;\r\n}\n\n/* eslint-disable no-console */\r\nconst Logger = {\r\n    log(...logContent) {\r\n        console.log(...logContent);\r\n    },\r\n    warn(message, ...logContent) {\r\n        console.warn(`AG Charts - ${message}`, ...logContent);\r\n    },\r\n    error(message, ...logContent) {\r\n        if (typeof message === 'object') {\r\n            console.error(`AG Charts error`, message, ...logContent);\r\n        }\r\n        else {\r\n            console.error(`AG Charts - ${message}`, ...logContent);\r\n        }\r\n    },\r\n    table(...logContent) {\r\n        console.table(...logContent);\r\n    },\r\n    warnOnce(message, ...logContent) {\r\n        doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\r\n    },\r\n    errorOnce(message, ...logContent) {\r\n        doOnce(() => Logger.error(message, ...logContent), `Logger.warn: ${message}`);\r\n    },\r\n};\n\nfunction windowValue(name) {\r\n    /**\r\n     * Redeclaration of window that is safe for use with Gatsby server-side (webpack) compilation.\r\n     */\r\n    const WINDOW = typeof window !== 'undefined'\r\n        ? window\r\n        : // typeof global !== 'undefined' ? (global as any) :\r\n            undefined;\r\n    return WINDOW === null || WINDOW === void 0 ? void 0 : WINDOW[name];\r\n}\n\nconst LONG_TIME_PERIOD_THRESHOLD = 2000;\r\nlet timeOfLastLog = Date.now();\r\nconst logTimeGap = () => {\r\n    const timeSinceLastLog = Date.now() - timeOfLastLog;\r\n    if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\r\n        const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\r\n        Logger.log(`**** ${prettyDuration}s since last log message ****`);\r\n    }\r\n    timeOfLastLog = Date.now();\r\n};\r\nconst Debug = {\r\n    create(...debugSelectors) {\r\n        return (...logContent) => {\r\n            if (Debug.check(...debugSelectors)) {\r\n                if (typeof logContent[0] === 'function') {\r\n                    logContent = toArray(logContent[0]());\r\n                }\r\n                logTimeGap();\r\n                Logger.log(...logContent);\r\n            }\r\n        };\r\n    },\r\n    check(...debugSelectors) {\r\n        if (debugSelectors.length === 0) {\r\n            debugSelectors.push(true);\r\n        }\r\n        const chartDebug = toArray(windowValue('agChartsDebug'));\r\n        return chartDebug.some((selector) => debugSelectors.includes(selector));\r\n    },\r\n};\n\nconst BREAK_TRANSFORM_CHAIN = Symbol('BREAK');\r\nconst CONFIG_KEY = '__decorator_config';\r\nfunction initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey) {\r\n    if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\r\n        Object.defineProperty(target, CONFIG_KEY, { value: {} });\r\n    }\r\n    const config = target[CONFIG_KEY];\r\n    if (config[propertyKey] != null) {\r\n        return config[propertyKey];\r\n    }\r\n    config[propertyKey] = { setters: [], getters: [] };\r\n    const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\r\n    const prevSet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set;\r\n    const prevGet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.get;\r\n    const getter = function () {\r\n        var _a, _b;\r\n        let value = prevGet ? prevGet.call(this) : this[valueStoreKey];\r\n        for (const transformFn of (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.getters) !== null && _b !== void 0 ? _b : []) {\r\n            value = transformFn(this, propertyKeyOrSymbol, value);\r\n            if (value === BREAK_TRANSFORM_CHAIN) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    const setter = function (value) {\r\n        var _a, _b;\r\n        const setters = (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.setters) !== null && _b !== void 0 ? _b : [];\r\n        let oldValue;\r\n        if (setters.some((f) => f.length > 2)) {\r\n            // Lazily retrieve old value.\r\n            oldValue = prevGet ? prevGet.call(this) : this[valueStoreKey];\r\n        }\r\n        for (const transformFn of setters) {\r\n            value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\r\n            if (value === BREAK_TRANSFORM_CHAIN) {\r\n                return;\r\n            }\r\n        }\r\n        if (prevSet) {\r\n            prevSet.call(this, value);\r\n        }\r\n        else {\r\n            this[valueStoreKey] = value;\r\n        }\r\n    };\r\n    Object.defineProperty(target, propertyKeyOrSymbol, {\r\n        set: setter,\r\n        get: getter,\r\n        enumerable: true,\r\n        configurable: false,\r\n    });\r\n    return config[propertyKey];\r\n}\r\nfunction addTransformToInstanceProperty(setTransform, getTransform) {\r\n    return (target, propertyKeyOrSymbol) => {\r\n        const propertyKey = propertyKeyOrSymbol.toString();\r\n        const valueStoreKey = `__${propertyKey}`;\r\n        const { getters, setters } = initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey);\r\n        setters.push(setTransform);\r\n        if (getTransform) {\r\n            getters.unshift(getTransform);\r\n        }\r\n    };\r\n}\r\nfunction isDecoratedObject(target) {\r\n    return typeof target !== 'undefined' && CONFIG_KEY in target;\r\n}\r\nfunction listDecoratedProperties(target) {\r\n    const targets = new Set();\r\n    while (isDecoratedObject(target)) {\r\n        targets.add(target === null || target === void 0 ? void 0 : target[CONFIG_KEY]);\r\n        target = Object.getPrototypeOf(target);\r\n    }\r\n    return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\r\n}\r\nfunction extractDecoratedProperties(target) {\r\n    return listDecoratedProperties(target).reduce((result, key) => {\r\n        var _a;\r\n        result[key] = (_a = target[key]) !== null && _a !== void 0 ? _a : null;\r\n        return result;\r\n    }, {});\r\n}\n\nfunction createDeprecationWarning() {\r\n    return (key, message) => {\r\n        const msg = [`Property [${key}] is deprecated.`, message].filter((v) => v != null).join(' ');\r\n        Logger.warnOnce(msg);\r\n    };\r\n}\n\nconst CLASS_INSTANCE_TYPE = 'class-instance';\r\n/**\r\n * Performs a JSON-diff between a source and target JSON structure.\r\n *\r\n * On a per property basis, takes the target property value where:\r\n * - types are different.\r\n * - type is primitive.\r\n * - type is array and length or content have changed.\r\n *\r\n * Recurses for object types.\r\n *\r\n * @param source starting point for diff\r\n * @param target target for diff vs. source\r\n *\r\n * @returns `null` if no differences, or an object with the subset of properties that have changed.\r\n */\r\nfunction jsonDiff(source, target) {\r\n    const sourceType = classify(source);\r\n    const targetType = classify(target);\r\n    if (targetType === 'array') {\r\n        const targetArray = target;\r\n        if (sourceType !== 'array' || source.length !== targetArray.length) {\r\n            return [...targetArray];\r\n        }\r\n        if (targetArray.some((targetElement, i) => jsonDiff(source === null || source === void 0 ? void 0 : source[i], targetElement) != null)) {\r\n            return [...targetArray];\r\n        }\r\n        return null;\r\n    }\r\n    if (targetType === 'primitive') {\r\n        if (sourceType !== 'primitive') {\r\n            return Object.assign({}, target);\r\n        }\r\n        if (source !== target) {\r\n            return target;\r\n        }\r\n        return null;\r\n    }\r\n    const lhs = source || {};\r\n    const rhs = target || {};\r\n    const allProps = new Set([...Object.keys(lhs), ...Object.keys(rhs)]);\r\n    let propsChangedCount = 0;\r\n    const result = {};\r\n    for (const prop of allProps) {\r\n        // Cheap-and-easy equality check.\r\n        if (lhs[prop] === rhs[prop]) {\r\n            continue;\r\n        }\r\n        const take = (v) => {\r\n            result[prop] = v;\r\n            propsChangedCount++;\r\n        };\r\n        const lhsType = classify(lhs[prop]);\r\n        const rhsType = classify(rhs[prop]);\r\n        if (lhsType !== rhsType) {\r\n            // Types changed, just take RHS.\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === 'primitive' || rhsType === null) {\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === 'array' && lhs[prop].length !== rhs[prop].length) {\r\n            // Arrays are different sizes, so just take target array.\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === CLASS_INSTANCE_TYPE) {\r\n            // Don't try to do anything tricky with array diffs!\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === 'function' && lhs[prop] !== rhs[prop]) {\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        const diff = jsonDiff(lhs[prop], rhs[prop]);\r\n        if (diff !== null) {\r\n            take(diff);\r\n        }\r\n    }\r\n    return propsChangedCount === 0 ? null : result;\r\n}\r\n/**\r\n * Special value used by `jsonMerge` to signal that a property should be removed from the merged\r\n * output.\r\n */\r\nconst DELETE = Symbol('<delete-property>');\r\nconst NOT_SPECIFIED = Symbol('<unspecified-property>');\r\n/**\r\n * Merge together the provide JSON object structures, with the precedence of application running\r\n * from higher indexes to lower indexes.\r\n *\r\n * Deep-clones all objects to avoid mutation of the inputs changing the output object. For arrays,\r\n * just performs a deep-clone of the entire array, no merging of elements attempted.\r\n *\r\n * @param json all json objects to merge\r\n * @param opts merge options\r\n * @param opts.avoidDeepClone contains a list of properties where deep clones should be avoided\r\n *\r\n * @returns the combination of all the json inputs\r\n */\r\nfunction jsonMerge(json, opts) {\r\n    var _a;\r\n    const avoidDeepClone = (_a = opts === null || opts === void 0 ? void 0 : opts.avoidDeepClone) !== null && _a !== void 0 ? _a : [];\r\n    const jsonTypes = json.map((v) => classify(v));\r\n    if (jsonTypes.some((v) => v === 'array')) {\r\n        // Clone final array.\r\n        const finalValue = json[json.length - 1];\r\n        if (Array.isArray(finalValue)) {\r\n            return finalValue.map((v) => {\r\n                const type = classify(v);\r\n                if (type === 'array')\r\n                    return jsonMerge([[], v], opts);\r\n                if (type === 'object')\r\n                    return jsonMerge([{}, v], opts);\r\n                return v;\r\n            });\r\n        }\r\n        return finalValue;\r\n    }\r\n    const result = {};\r\n    const props = new Set(json.map((v) => (v != null ? Object.keys(v) : [])).reduce((r, n) => r.concat(n), []));\r\n    for (const nextProp of props) {\r\n        const values = json\r\n            .map((j) => {\r\n            if (j != null && typeof j === 'object' && nextProp in j) {\r\n                return j[nextProp];\r\n            }\r\n            return NOT_SPECIFIED;\r\n        })\r\n            .filter((v) => v !== NOT_SPECIFIED);\r\n        if (values.length === 0) {\r\n            continue;\r\n        }\r\n        const lastValue = values[values.length - 1];\r\n        if (lastValue === DELETE) {\r\n            continue;\r\n        }\r\n        const types = values.map((v) => classify(v));\r\n        const type = types[0];\r\n        if (types.some((t) => t !== type)) {\r\n            // Short-circuit if mismatching types.\r\n            result[nextProp] = lastValue;\r\n            continue;\r\n        }\r\n        if ((type === 'array' || type === 'object') && !avoidDeepClone.includes(nextProp)) {\r\n            result[nextProp] = jsonMerge(values, opts);\r\n        }\r\n        else if (type === 'array') {\r\n            // Arrays need to be shallow copied to avoid external mutation and allow jsonDiff to\r\n            // detect changes.\r\n            result[nextProp] = [...lastValue];\r\n        }\r\n        else {\r\n            // Just directly assign/overwrite.\r\n            result[nextProp] = lastValue;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Recursively apply a JSON object into a class-hierarchy, optionally instantiating certain classes\r\n * by property name.\r\n *\r\n * @param target to apply source JSON properties into\r\n * @param source to be applied\r\n * @param params\r\n * @param params.path path for logging/error purposes, to aid with pinpointing problems\r\n * @param params.matcherPath path for pattern matching, to lookup allowedTypes override.\r\n * @param params.skip property names to skip from the source\r\n * @param params.constructors dictionary of property name to class constructors for properties that\r\n *                            require object construction\r\n * @param params.constructedArrays map stores arrays which items should be initialised\r\n *                                 using a class constructor\r\n * @param params.allowedTypes overrides by path for allowed property types\r\n */\r\nfunction jsonApply(target, source, params = {}) {\r\n    var _a, _b, _c;\r\n    const { path = undefined, matcherPath = path ? path.replace(/(\\[[0-9+]+])/i, '[]') : undefined, skip = [], constructors = {}, constructedArrays = new WeakMap(), allowedTypes = {}, idx, } = params;\r\n    if (target == null) {\r\n        throw new Error(`AG Charts - target is uninitialised: ${path !== null && path !== void 0 ? path : '<root>'}`);\r\n    }\r\n    if (source == null) {\r\n        return target;\r\n    }\r\n    const targetAny = target;\r\n    if (idx != null && '_declarationOrder' in targetAny) {\r\n        targetAny['_declarationOrder'] = idx;\r\n    }\r\n    const targetType = classify(target);\r\n    for (const property in source) {\r\n        const propertyMatcherPath = `${matcherPath ? matcherPath + '.' : ''}${property}`;\r\n        if (skip.indexOf(propertyMatcherPath) >= 0) {\r\n            continue;\r\n        }\r\n        const newValue = source[property];\r\n        const propertyPath = `${path ? path + '.' : ''}${property}`;\r\n        const targetClass = targetAny.constructor;\r\n        const currentValue = targetAny[property];\r\n        let ctr = (_a = constructors[propertyMatcherPath]) !== null && _a !== void 0 ? _a : constructors[property];\r\n        try {\r\n            const currentValueType = classify(currentValue);\r\n            const newValueType = classify(newValue);\r\n            if (targetType === CLASS_INSTANCE_TYPE &&\r\n                !(property in target || Object.prototype.hasOwnProperty.call(targetAny, property))) {\r\n                Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - property is unknown`);\r\n                continue;\r\n            }\r\n            const allowableTypes = (_b = allowedTypes[propertyMatcherPath]) !== null && _b !== void 0 ? _b : [currentValueType];\r\n            if (currentValueType === CLASS_INSTANCE_TYPE && newValueType === 'object') {\r\n                // Allowed, this is the common case! - do not error.\r\n            }\r\n            else if (currentValueType != null && newValueType != null && !allowableTypes.includes(newValueType)) {\r\n                Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - can't apply type of [${newValueType}], allowed types are: [${allowableTypes}]`);\r\n                continue;\r\n            }\r\n            if (newValueType === 'array') {\r\n                ctr = (_c = ctr !== null && ctr !== void 0 ? ctr : constructedArrays.get(currentValue)) !== null && _c !== void 0 ? _c : constructors[`${propertyMatcherPath}[]`];\r\n                if (ctr != null) {\r\n                    const newValueArray = newValue;\r\n                    targetAny[property] = newValueArray.map((v, idx) => jsonApply(new ctr(), v, Object.assign(Object.assign({}, params), { path: propertyPath, matcherPath: propertyMatcherPath + '[]', idx })));\r\n                }\r\n                else {\r\n                    targetAny[property] = newValue;\r\n                }\r\n            }\r\n            else if (newValueType === CLASS_INSTANCE_TYPE) {\r\n                targetAny[property] = newValue;\r\n            }\r\n            else if (newValueType === 'object') {\r\n                if (currentValue != null) {\r\n                    jsonApply(currentValue, newValue, Object.assign(Object.assign({}, params), { path: propertyPath, matcherPath: propertyMatcherPath, idx: undefined }));\r\n                }\r\n                else if (ctr != null) {\r\n                    targetAny[property] = jsonApply(new ctr(), newValue, Object.assign(Object.assign({}, params), { path: propertyPath, matcherPath: propertyMatcherPath, idx: undefined }));\r\n                }\r\n                else {\r\n                    targetAny[property] = newValue;\r\n                }\r\n            }\r\n            else {\r\n                targetAny[property] = newValue;\r\n            }\r\n        }\r\n        catch (error) {\r\n            Logger.warn(`unable to set [${propertyPath}] in [${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name}]; nested error is: ${error.message}`);\r\n        }\r\n    }\r\n    return target;\r\n}\r\n/**\r\n * Walk the given JSON object graphs, invoking the visit() callback for every object encountered.\r\n * Arrays are descended into without a callback, however their elements will have the visit()\r\n * callback invoked if they are objects.\r\n *\r\n * @param json to traverse\r\n * @param visit callback for each non-primitive and non-array object found\r\n * @param opts\r\n * @param opts.skip property names to skip when walking\r\n * @param jsons to traverse in parallel\r\n */\r\nfunction jsonWalk(json, visit, opts, ...jsons) {\r\n    const jsonType = classify(json);\r\n    const { skip = [] } = opts !== null && opts !== void 0 ? opts : {};\r\n    if (jsonType === 'array') {\r\n        visit(jsonType, json, ...jsons);\r\n        json.forEach((element, index) => {\r\n            jsonWalk(element, visit, opts, ...(jsons !== null && jsons !== void 0 ? jsons : []).map((o) => o === null || o === void 0 ? void 0 : o[index]));\r\n        });\r\n        return;\r\n    }\r\n    if (jsonType !== 'object') {\r\n        return;\r\n    }\r\n    visit(jsonType, json, ...jsons);\r\n    for (const property in json) {\r\n        if (skip.includes(property)) {\r\n            continue;\r\n        }\r\n        const value = json[property];\r\n        const otherValues = jsons === null || jsons === void 0 ? void 0 : jsons.map((o) => o === null || o === void 0 ? void 0 : o[property]);\r\n        const valueType = classify(value);\r\n        if (valueType === 'object' || valueType === 'array') {\r\n            jsonWalk(value, visit, opts, ...otherValues);\r\n        }\r\n    }\r\n}\r\nconst isBrowser = typeof window !== 'undefined';\r\n/**\r\n * Classify the type of value to assist with handling for merge purposes.\r\n */\r\nfunction classify(value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (isBrowser && value instanceof HTMLElement) {\r\n        return 'primitive';\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return 'array';\r\n    }\r\n    if (value instanceof Date) {\r\n        return 'primitive';\r\n    }\r\n    if (typeof value === 'object' && value.constructor === Object) {\r\n        return 'object';\r\n    }\r\n    if (typeof value === 'function') {\r\n        return 'function';\r\n    }\r\n    if (typeof value === 'object' && value.constructor != null) {\r\n        return CLASS_INSTANCE_TYPE;\r\n    }\r\n    return 'primitive';\r\n}\n\nconst twoPi = Math.PI * 2;\r\n/**\r\n * Normalize the given angle to be in the [0, 2π) interval.\r\n * @param radians Angle in radians.\r\n */\r\nfunction normalizeAngle360(radians) {\r\n    radians %= twoPi;\r\n    radians += twoPi;\r\n    radians %= twoPi;\r\n    return radians;\r\n}\r\nfunction normalizeAngle360Inclusive(radians) {\r\n    radians %= twoPi;\r\n    radians += twoPi;\r\n    if (radians !== twoPi) {\r\n        radians %= twoPi;\r\n    }\r\n    return radians;\r\n}\r\n/**\r\n * Normalize the given angle to be in the [-π, π) interval.\r\n * @param radians Angle in radians.\r\n */\r\nfunction normalizeAngle180(radians) {\r\n    radians %= twoPi;\r\n    if (radians < -Math.PI) {\r\n        radians += twoPi;\r\n    }\r\n    else if (radians >= Math.PI) {\r\n        radians -= twoPi;\r\n    }\r\n    return radians;\r\n}\r\nfunction toRadians(degrees) {\r\n    return (degrees / 180) * Math.PI;\r\n}\r\nfunction toDegrees(radians) {\r\n    return (radians / Math.PI) * 180;\r\n}\r\n/**\r\n * Returns a rotation angle between two other angles.\r\n * @param angle0 Angle in radians.\r\n * @param angle1 Angle in radians.\r\n * @returns Angle in radians.\r\n */\r\nfunction angleBetween(angle0, angle1) {\r\n    angle0 = normalizeAngle360(angle0);\r\n    angle1 = normalizeAngle360(angle1);\r\n    return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\r\n}\n\nfunction clamp$1(x, min, max) {\r\n    return Math.max(min, Math.min(max, x));\r\n}\r\n/**\r\n * Maps a discrete domain to a continuous numeric range.\r\n */\r\nclass BandScale {\r\n    constructor() {\r\n        this.type = 'band';\r\n        this.cache = null;\r\n        this.cacheProps = ['_domain', 'range', '_paddingInner', '_paddingOuter', 'round', 'interval'];\r\n        /**\r\n         * Maps datum to its index in the {@link domain} array.\r\n         * Used to check for duplicate datums (not allowed).\r\n         */\r\n        this.index = new Map();\r\n        /**\r\n         * The output range values for datum at each index.\r\n         */\r\n        this.ordinalRange = [];\r\n        /**\r\n         * Contains unique datums only. Since `{}` is used in place of `Map`\r\n         * for IE11 compatibility, the datums are converted `toString` before\r\n         * the uniqueness check.\r\n         */\r\n        this._domain = [];\r\n        this.range = [0, 1];\r\n        this._bandwidth = 1;\r\n        this._rawBandwidth = 1;\r\n        /**\r\n         * The ratio of the range that is reserved for space between bands.\r\n         */\r\n        this._paddingInner = 0;\r\n        /**\r\n         * The ratio of the range that is reserved for space before the first\r\n         * and after the last band.\r\n         */\r\n        this._paddingOuter = 0;\r\n        this.round = false;\r\n    }\r\n    didChange() {\r\n        const { cache } = this;\r\n        const didChange = !cache || this.cacheProps.some((p) => this[p] !== cache[p]);\r\n        if (didChange) {\r\n            this.cache = {};\r\n            this.cacheProps.forEach((p) => (this.cache[p] = this[p]));\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    refresh() {\r\n        if (this.didChange()) {\r\n            this.update();\r\n        }\r\n    }\r\n    set domain(values) {\r\n        const domain = [];\r\n        this.index = new Map();\r\n        const index = this.index;\r\n        // In case one wants to have duplicate domain values, for example, two 'Italy' categories,\r\n        // one should use objects rather than strings for domain values like so:\r\n        // { toString: () => 'Italy' }\r\n        // { toString: () => 'Italy' }\r\n        values.forEach((value) => {\r\n            if (index.get(value) === undefined) {\r\n                index.set(value, domain.push(value) - 1);\r\n            }\r\n        });\r\n        this._domain = domain;\r\n    }\r\n    get domain() {\r\n        return this._domain;\r\n    }\r\n    ticks() {\r\n        this.refresh();\r\n        const { interval = 1 } = this;\r\n        const step = Math.abs(Math.round(interval));\r\n        return this._domain.filter((_, i) => i % step === 0);\r\n    }\r\n    convert(d) {\r\n        this.refresh();\r\n        const i = this.index.get(d);\r\n        if (i === undefined) {\r\n            return NaN;\r\n        }\r\n        const r = this.ordinalRange[i];\r\n        if (r === undefined) {\r\n            return NaN;\r\n        }\r\n        return r;\r\n    }\r\n    invert(position) {\r\n        this.refresh();\r\n        const index = this.ordinalRange.findIndex((p) => p === position);\r\n        return this.domain[index];\r\n    }\r\n    get bandwidth() {\r\n        this.refresh();\r\n        return this._bandwidth;\r\n    }\r\n    get rawBandwidth() {\r\n        this.refresh();\r\n        return this._rawBandwidth;\r\n    }\r\n    set padding(value) {\r\n        value = clamp$1(value, 0, 1);\r\n        this._paddingInner = value;\r\n        this._paddingOuter = value;\r\n    }\r\n    get padding() {\r\n        return this._paddingInner;\r\n    }\r\n    set paddingInner(value) {\r\n        this._paddingInner = clamp$1(value, 0, 1);\r\n    }\r\n    get paddingInner() {\r\n        return this._paddingInner;\r\n    }\r\n    set paddingOuter(value) {\r\n        this._paddingOuter = clamp$1(value, 0, 1);\r\n    }\r\n    get paddingOuter() {\r\n        return this._paddingOuter;\r\n    }\r\n    update() {\r\n        const count = this._domain.length;\r\n        if (count === 0) {\r\n            return;\r\n        }\r\n        const round = this.round;\r\n        const paddingInner = this._paddingInner;\r\n        const paddingOuter = this._paddingOuter;\r\n        const [r0, r1] = this.range;\r\n        const width = r1 - r0;\r\n        const rawStep = width / Math.max(1, count + 2 * paddingOuter - paddingInner);\r\n        const step = round ? Math.floor(rawStep) : rawStep;\r\n        const fullBandWidth = step * (count - paddingInner);\r\n        const x0 = r0 + (width - fullBandWidth) / 2;\r\n        const start = round ? Math.round(x0) : x0;\r\n        const bw = step * (1 - paddingInner);\r\n        const bandwidth = round ? Math.round(bw) : bw;\r\n        const rawBandwidth = rawStep * (1 - paddingInner);\r\n        const values = [];\r\n        for (let i = 0; i < count; i++) {\r\n            values.push(start + step * i);\r\n        }\r\n        this._bandwidth = bandwidth;\r\n        this._rawBandwidth = rawBandwidth;\r\n        this.ordinalRange = values;\r\n    }\r\n}\n\nfunction clamp(min, value, max) {\r\n    return Math.min(max, Math.max(min, value));\r\n}\r\nfunction isEqual(a, b, epsilon = 1e-10) {\r\n    return Math.abs(a - b) < epsilon;\r\n}\r\nfunction isNegative(a) {\r\n    return Math.sign(a) < 0 || Object.is(a, -0);\r\n}\r\nfunction round$1(value, decimals = 2) {\r\n    const pow = Math.pow(10, decimals);\r\n    return Math.round(value * pow) / pow;\r\n}\r\n/**\r\n * `Number.toFixed(n)` always formats a number so that it has `n` digits after the decimal point.\r\n * For example, `Number(0.00003427).toFixed(2)` returns `0.00`.\r\n * That's not very helpful, because all the meaningful information is lost.\r\n * In this case we would want the formatted value to have at least two significant digits: `0.000034`,\r\n * not two fraction digits.\r\n * @param value\r\n * @param fractionOrSignificantDigits\r\n */\r\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\r\n    const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\r\n    if (power >= 0 || !isFinite(power)) {\r\n        return value.toFixed(fractionOrSignificantDigits); // fraction digits\r\n    }\r\n    return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits); // significant digits\r\n}\r\n/**\r\n * Returns the mathematically correct n modulus of m. For context, the JS % operator is remainder\r\n * NOT modulus, which is why this is needed.\r\n */\r\nfunction mod(n, m) {\r\n    if (n >= 0) {\r\n        return Math.floor(n % m);\r\n    }\r\n    return Math.floor((n % m) + m);\r\n}\n\nclass Color {\r\n    /**\r\n     * Every color component should be in the [0, 1] range.\r\n     * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\r\n     * So, when animating colors, if the source or target color components are already near\r\n     * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\r\n     * component value to end up outside of that range mid-animation. For this reason the constructor\r\n     * performs range checking/constraining.\r\n     * @param r Red component.\r\n     * @param g Green component.\r\n     * @param b Blue component.\r\n     * @param a Alpha (opacity) component.\r\n     */\r\n    constructor(r, g, b, a = 1) {\r\n        // NaN is treated as 0\r\n        this.r = clamp(0, r || 0, 1);\r\n        this.g = clamp(0, g || 0, 1);\r\n        this.b = clamp(0, b || 0, 1);\r\n        this.a = clamp(0, a || 0, 1);\r\n    }\r\n    /**\r\n     * A color string can be in one of the following formats to be valid:\r\n     * - #rgb\r\n     * - #rrggbb\r\n     * - rgb(r, g, b)\r\n     * - rgba(r, g, b, a)\r\n     * - CSS color name such as 'white', 'orange', 'cyan', etc.\r\n     */\r\n    static validColorString(str) {\r\n        if (str.indexOf('#') >= 0) {\r\n            return !!Color.parseHex(str);\r\n        }\r\n        if (str.indexOf('rgb') >= 0) {\r\n            return !!Color.stringToRgba(str);\r\n        }\r\n        return !!Color.nameToHex[str.toLowerCase()];\r\n    }\r\n    /**\r\n     * The given string can be in one of the following formats:\r\n     * - #rgb\r\n     * - #rrggbb\r\n     * - rgb(r, g, b)\r\n     * - rgba(r, g, b, a)\r\n     * - CSS color name such as 'white', 'orange', 'cyan', etc.\r\n     * @param str\r\n     */\r\n    static fromString(str) {\r\n        // hexadecimal notation\r\n        if (str.indexOf('#') >= 0) {\r\n            // there can be some leading whitespace\r\n            return Color.fromHexString(str);\r\n        }\r\n        // color name\r\n        const hex = Color.nameToHex[str.toLowerCase()];\r\n        if (hex) {\r\n            return Color.fromHexString(hex);\r\n        }\r\n        // rgb(a) notation\r\n        if (str.indexOf('rgb') >= 0) {\r\n            return Color.fromRgbaString(str);\r\n        }\r\n        throw new Error(`Invalid color string: '${str}'`);\r\n    }\r\n    static tryParseFromString(str) {\r\n        try {\r\n            return Color.fromString(str);\r\n        }\r\n        catch (e) {\r\n            Logger.warnOnce(`invalid color string: '${str}'.`);\r\n            return Color.fromArray([0, 0, 0]);\r\n        }\r\n    }\r\n    // See https://drafts.csswg.org/css-color/#hex-notation\r\n    static parseHex(input) {\r\n        input = input.replace(/ /g, '').slice(1);\r\n        let parts;\r\n        switch (input.length) {\r\n            case 6:\r\n            case 8:\r\n                parts = [];\r\n                for (let i = 0; i < input.length; i += 2) {\r\n                    parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\r\n                }\r\n                break;\r\n            case 3:\r\n            case 4:\r\n                parts = input\r\n                    .split('')\r\n                    .map((p) => parseInt(p, 16))\r\n                    .map((p) => p + p * 16);\r\n                break;\r\n        }\r\n        if ((parts === null || parts === void 0 ? void 0 : parts.length) >= 3 && parts.every((p) => p >= 0)) {\r\n            if (parts.length === 3) {\r\n                parts.push(255);\r\n            }\r\n            return parts;\r\n        }\r\n    }\r\n    static fromHexString(str) {\r\n        const values = Color.parseHex(str);\r\n        if (values) {\r\n            const [r, g, b, a] = values;\r\n            return new Color(r / 255, g / 255, b / 255, a / 255);\r\n        }\r\n        throw new Error(`Malformed hexadecimal color string: '${str}'`);\r\n    }\r\n    static stringToRgba(str) {\r\n        // Find positions of opening and closing parentheses.\r\n        let [po, pc] = [NaN, NaN];\r\n        for (let i = 0; i < str.length; i++) {\r\n            const c = str[i];\r\n            if (!po && c === '(') {\r\n                po = i;\r\n            }\r\n            else if (c === ')') {\r\n                pc = i;\r\n                break;\r\n            }\r\n        }\r\n        const contents = po && pc && str.substring(po + 1, pc);\r\n        if (!contents) {\r\n            return;\r\n        }\r\n        const parts = contents.split(',');\r\n        const rgba = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            let value = parseFloat(part);\r\n            if (isNaN(value)) {\r\n                return;\r\n            }\r\n            if (part.indexOf('%') >= 0) {\r\n                // percentage r, g, or b value\r\n                value = Math.max(0, Math.min(100, value));\r\n                value /= 100;\r\n            }\r\n            else {\r\n                if (i === 3) {\r\n                    // alpha component\r\n                    value = Math.max(0, Math.min(1, value));\r\n                }\r\n                else {\r\n                    // absolute r, g, or b value\r\n                    value = Math.max(0, Math.min(255, value));\r\n                    value /= 255;\r\n                }\r\n            }\r\n            rgba.push(value);\r\n        }\r\n        return rgba;\r\n    }\r\n    static fromRgbaString(str) {\r\n        const rgba = Color.stringToRgba(str);\r\n        if (rgba) {\r\n            if (rgba.length === 3) {\r\n                return new Color(rgba[0], rgba[1], rgba[2]);\r\n            }\r\n            else if (rgba.length === 4) {\r\n                return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);\r\n            }\r\n        }\r\n        throw new Error(`Malformed rgb/rgba color string: '${str}'`);\r\n    }\r\n    static fromArray(arr) {\r\n        if (arr.length === 4) {\r\n            return new Color(arr[0], arr[1], arr[2], arr[3]);\r\n        }\r\n        if (arr.length === 3) {\r\n            return new Color(arr[0], arr[1], arr[2]);\r\n        }\r\n        throw new Error('The given array should contain 3 or 4 color components (numbers).');\r\n    }\r\n    static fromHSB(h, s, b, alpha = 1) {\r\n        const rgb = Color.HSBtoRGB(h, s, b);\r\n        return new Color(rgb[0], rgb[1], rgb[2], alpha);\r\n    }\r\n    static fromHSL(h, s, l, alpha = 1) {\r\n        const rgb = Color.HSLtoRGB(h, s, l);\r\n        return new Color(rgb[0], rgb[1], rgb[2], alpha);\r\n    }\r\n    static padHex(str) {\r\n        // Can't use `padStart(2, '0')` here because of IE.\r\n        return str.length === 1 ? '0' + str : str;\r\n    }\r\n    toHexString() {\r\n        let hex = '#' +\r\n            Color.padHex(Math.round(this.r * 255).toString(16)) +\r\n            Color.padHex(Math.round(this.g * 255).toString(16)) +\r\n            Color.padHex(Math.round(this.b * 255).toString(16));\r\n        if (this.a < 1) {\r\n            hex += Color.padHex(Math.round(this.a * 255).toString(16));\r\n        }\r\n        return hex;\r\n    }\r\n    toRgbaString(fractionDigits = 3) {\r\n        const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\r\n        const k = Math.pow(10, fractionDigits);\r\n        if (this.a !== 1) {\r\n            components.push(Math.round(this.a * k) / k);\r\n            return `rgba(${components.join(', ')})`;\r\n        }\r\n        return `rgb(${components.join(', ')})`;\r\n    }\r\n    toString() {\r\n        if (this.a === 1) {\r\n            return this.toHexString();\r\n        }\r\n        return this.toRgbaString();\r\n    }\r\n    toHSB() {\r\n        return Color.RGBtoHSB(this.r, this.g, this.b);\r\n    }\r\n    static RGBtoHSL(r, g, b) {\r\n        const min = Math.min(r, g, b);\r\n        const max = Math.max(r, g, b);\r\n        const l = (max + min) / 2;\r\n        let h;\r\n        let s;\r\n        if (max === min) {\r\n            // Achromatic\r\n            h = NaN;\r\n            s = 0;\r\n        }\r\n        else {\r\n            const delta = max - min;\r\n            s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\r\n            if (max === r) {\r\n                h = (g - b) / delta + (g < b ? 6 : 0);\r\n            }\r\n            else if (max === g) {\r\n                h = (b - r) / delta + 2;\r\n            }\r\n            else {\r\n                h = (r - g) / delta + 4;\r\n            }\r\n            h *= 360 / 6;\r\n        }\r\n        return [h, s, l];\r\n    }\r\n    static HSLtoRGB(h, s, l) {\r\n        if (s === 0) {\r\n            // Achromatic\r\n            return [l, l, l];\r\n        }\r\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        const p = 2 * l - q;\r\n        function hueToRgb(t) {\r\n            if (t < 0)\r\n                t += 1;\r\n            if (t > 1)\r\n                t -= 1;\r\n            if (t < 1 / 6)\r\n                return p + (q - p) * 6 * t;\r\n            if (t < 1 / 2)\r\n                return q;\r\n            if (t < 2 / 3)\r\n                return p + (q - p) * (2 / 3 - t) * 6;\r\n            return p;\r\n        }\r\n        const r = hueToRgb(h / 360 + 1 / 3);\r\n        const g = hueToRgb(h / 360);\r\n        const b = hueToRgb(h / 360 - 1 / 3);\r\n        return [r, g, b];\r\n    }\r\n    /**\r\n     * Converts the given RGB triple to an array of HSB (HSV) components.\r\n     * The hue component will be `NaN` for achromatic colors.\r\n     */\r\n    static RGBtoHSB(r, g, b) {\r\n        const min = Math.min(r, g, b);\r\n        const max = Math.max(r, g, b);\r\n        const S = max !== 0 ? (max - min) / max : 0;\r\n        let H = NaN;\r\n        // min == max, means all components are the same\r\n        // and the color is a shade of gray with no hue (H is NaN)\r\n        if (min !== max) {\r\n            const delta = max - min;\r\n            const rc = (max - r) / delta;\r\n            const gc = (max - g) / delta;\r\n            const bc = (max - b) / delta;\r\n            if (r === max) {\r\n                H = bc - gc;\r\n            }\r\n            else if (g === max) {\r\n                H = 2.0 + rc - bc;\r\n            }\r\n            else {\r\n                H = 4.0 + gc - rc;\r\n            }\r\n            H /= 6.0;\r\n            if (H < 0) {\r\n                H = H + 1.0;\r\n            }\r\n        }\r\n        return [H * 360, S, max];\r\n    }\r\n    /**\r\n     * Converts the given HSB (HSV) triple to an array of RGB components.\r\n     */\r\n    static HSBtoRGB(H, S, B) {\r\n        if (isNaN(H)) {\r\n            H = 0;\r\n        }\r\n        H = (((H % 360) + 360) % 360) / 360; // normalize hue to [0, 360] interval, then scale to [0, 1]\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        if (S === 0) {\r\n            r = g = b = B;\r\n        }\r\n        else {\r\n            const h = (H - Math.floor(H)) * 6;\r\n            const f = h - Math.floor(h);\r\n            const p = B * (1 - S);\r\n            const q = B * (1 - S * f);\r\n            const t = B * (1 - S * (1 - f));\r\n            switch (h >> 0 // discard the floating point part of the number\r\n            ) {\r\n                case 0:\r\n                    r = B;\r\n                    g = t;\r\n                    b = p;\r\n                    break;\r\n                case 1:\r\n                    r = q;\r\n                    g = B;\r\n                    b = p;\r\n                    break;\r\n                case 2:\r\n                    r = p;\r\n                    g = B;\r\n                    b = t;\r\n                    break;\r\n                case 3:\r\n                    r = p;\r\n                    g = q;\r\n                    b = B;\r\n                    break;\r\n                case 4:\r\n                    r = t;\r\n                    g = p;\r\n                    b = B;\r\n                    break;\r\n                case 5:\r\n                    r = B;\r\n                    g = p;\r\n                    b = q;\r\n                    break;\r\n            }\r\n        }\r\n        return [r, g, b];\r\n    }\r\n    derive(hueShift, saturationFactor, brightnessFactor, opacityFactor) {\r\n        const hsb = Color.RGBtoHSB(this.r, this.g, this.b);\r\n        let b = hsb[2];\r\n        if (b == 0 && brightnessFactor > 1.0) {\r\n            b = 0.05;\r\n        }\r\n        const h = (((hsb[0] + hueShift) % 360) + 360) % 360;\r\n        const s = Math.max(Math.min(hsb[1] * saturationFactor, 1.0), 0.0);\r\n        b = Math.max(Math.min(b * brightnessFactor, 1.0), 0.0);\r\n        const a = Math.max(Math.min(this.a * opacityFactor, 1.0), 0.0);\r\n        const rgba = Color.HSBtoRGB(h, s, b);\r\n        rgba.push(a);\r\n        return Color.fromArray(rgba);\r\n    }\r\n    brighter() {\r\n        return this.derive(0, 1.0, 1.0 / 0.7, 1.0);\r\n    }\r\n    darker() {\r\n        return this.derive(0, 1.0, 0.7, 1.0);\r\n    }\r\n    static interpolate(color, other) {\r\n        const c0 = Color.tryParseFromString(color);\r\n        const c1 = Color.tryParseFromString(other);\r\n        return (t) => {\r\n            const i = (x, y) => x * (1 - t) + y * t;\r\n            const c = new Color(i(c0.r, c1.r), i(c0.g, c1.g), i(c0.b, c1.b), i(c0.a, c1.a));\r\n            return c.toString();\r\n        };\r\n    }\r\n}\r\n/**\r\n * CSS Color Module Level 4:\r\n * https://drafts.csswg.org/css-color/#named-colors\r\n */\r\nColor.nameToHex = Object.freeze({\r\n    aliceblue: '#F0F8FF',\r\n    antiquewhite: '#FAEBD7',\r\n    aqua: '#00FFFF',\r\n    aquamarine: '#7FFFD4',\r\n    azure: '#F0FFFF',\r\n    beige: '#F5F5DC',\r\n    bisque: '#FFE4C4',\r\n    black: '#000000',\r\n    blanchedalmond: '#FFEBCD',\r\n    blue: '#0000FF',\r\n    blueviolet: '#8A2BE2',\r\n    brown: '#A52A2A',\r\n    burlywood: '#DEB887',\r\n    cadetblue: '#5F9EA0',\r\n    chartreuse: '#7FFF00',\r\n    chocolate: '#D2691E',\r\n    coral: '#FF7F50',\r\n    cornflowerblue: '#6495ED',\r\n    cornsilk: '#FFF8DC',\r\n    crimson: '#DC143C',\r\n    cyan: '#00FFFF',\r\n    darkblue: '#00008B',\r\n    darkcyan: '#008B8B',\r\n    darkgoldenrod: '#B8860B',\r\n    darkgray: '#A9A9A9',\r\n    darkgreen: '#006400',\r\n    darkgrey: '#A9A9A9',\r\n    darkkhaki: '#BDB76B',\r\n    darkmagenta: '#8B008B',\r\n    darkolivegreen: '#556B2F',\r\n    darkorange: '#FF8C00',\r\n    darkorchid: '#9932CC',\r\n    darkred: '#8B0000',\r\n    darksalmon: '#E9967A',\r\n    darkseagreen: '#8FBC8F',\r\n    darkslateblue: '#483D8B',\r\n    darkslategray: '#2F4F4F',\r\n    darkslategrey: '#2F4F4F',\r\n    darkturquoise: '#00CED1',\r\n    darkviolet: '#9400D3',\r\n    deeppink: '#FF1493',\r\n    deepskyblue: '#00BFFF',\r\n    dimgray: '#696969',\r\n    dimgrey: '#696969',\r\n    dodgerblue: '#1E90FF',\r\n    firebrick: '#B22222',\r\n    floralwhite: '#FFFAF0',\r\n    forestgreen: '#228B22',\r\n    fuchsia: '#FF00FF',\r\n    gainsboro: '#DCDCDC',\r\n    ghostwhite: '#F8F8FF',\r\n    gold: '#FFD700',\r\n    goldenrod: '#DAA520',\r\n    gray: '#808080',\r\n    green: '#008000',\r\n    greenyellow: '#ADFF2F',\r\n    grey: '#808080',\r\n    honeydew: '#F0FFF0',\r\n    hotpink: '#FF69B4',\r\n    indianred: '#CD5C5C',\r\n    indigo: '#4B0082',\r\n    ivory: '#FFFFF0',\r\n    khaki: '#F0E68C',\r\n    lavender: '#E6E6FA',\r\n    lavenderblush: '#FFF0F5',\r\n    lawngreen: '#7CFC00',\r\n    lemonchiffon: '#FFFACD',\r\n    lightblue: '#ADD8E6',\r\n    lightcoral: '#F08080',\r\n    lightcyan: '#E0FFFF',\r\n    lightgoldenrodyellow: '#FAFAD2',\r\n    lightgray: '#D3D3D3',\r\n    lightgreen: '#90EE90',\r\n    lightgrey: '#D3D3D3',\r\n    lightpink: '#FFB6C1',\r\n    lightsalmon: '#FFA07A',\r\n    lightseagreen: '#20B2AA',\r\n    lightskyblue: '#87CEFA',\r\n    lightslategray: '#778899',\r\n    lightslategrey: '#778899',\r\n    lightsteelblue: '#B0C4DE',\r\n    lightyellow: '#FFFFE0',\r\n    lime: '#00FF00',\r\n    limegreen: '#32CD32',\r\n    linen: '#FAF0E6',\r\n    magenta: '#FF00FF',\r\n    maroon: '#800000',\r\n    mediumaquamarine: '#66CDAA',\r\n    mediumblue: '#0000CD',\r\n    mediumorchid: '#BA55D3',\r\n    mediumpurple: '#9370DB',\r\n    mediumseagreen: '#3CB371',\r\n    mediumslateblue: '#7B68EE',\r\n    mediumspringgreen: '#00FA9A',\r\n    mediumturquoise: '#48D1CC',\r\n    mediumvioletred: '#C71585',\r\n    midnightblue: '#191970',\r\n    mintcream: '#F5FFFA',\r\n    mistyrose: '#FFE4E1',\r\n    moccasin: '#FFE4B5',\r\n    navajowhite: '#FFDEAD',\r\n    navy: '#000080',\r\n    oldlace: '#FDF5E6',\r\n    olive: '#808000',\r\n    olivedrab: '#6B8E23',\r\n    orange: '#FFA500',\r\n    orangered: '#FF4500',\r\n    orchid: '#DA70D6',\r\n    palegoldenrod: '#EEE8AA',\r\n    palegreen: '#98FB98',\r\n    paleturquoise: '#AFEEEE',\r\n    palevioletred: '#DB7093',\r\n    papayawhip: '#FFEFD5',\r\n    peachpuff: '#FFDAB9',\r\n    peru: '#CD853F',\r\n    pink: '#FFC0CB',\r\n    plum: '#DDA0DD',\r\n    powderblue: '#B0E0E6',\r\n    purple: '#800080',\r\n    rebeccapurple: '#663399',\r\n    red: '#FF0000',\r\n    rosybrown: '#BC8F8F',\r\n    royalblue: '#4169E1',\r\n    saddlebrown: '#8B4513',\r\n    salmon: '#FA8072',\r\n    sandybrown: '#F4A460',\r\n    seagreen: '#2E8B57',\r\n    seashell: '#FFF5EE',\r\n    sienna: '#A0522D',\r\n    silver: '#C0C0C0',\r\n    skyblue: '#87CEEB',\r\n    slateblue: '#6A5ACD',\r\n    slategray: '#708090',\r\n    slategrey: '#708090',\r\n    snow: '#FFFAFA',\r\n    springgreen: '#00FF7F',\r\n    steelblue: '#4682B4',\r\n    tan: '#D2B48C',\r\n    teal: '#008080',\r\n    thistle: '#D8BFD8',\r\n    tomato: '#FF6347',\r\n    transparent: '#00000000',\r\n    turquoise: '#40E0D0',\r\n    violet: '#EE82EE',\r\n    wheat: '#F5DEB3',\r\n    white: '#FFFFFF',\r\n    whitesmoke: '#F5F5F5',\r\n    yellow: '#FFFF00',\r\n    yellowgreen: '#9ACD32',\r\n});\n\n/* eslint-disable sonarjs/no-duplicate-string */\r\nfunction Validate(predicate) {\r\n    return addTransformToInstanceProperty((target, prop, v) => {\r\n        var _a, _b, _c;\r\n        if (predicate(v, { target })) {\r\n            return v;\r\n        }\r\n        const cleanKey = prop.toString().replace(/^_*/, '');\r\n        let targetClass = (_b = (_a = target.constructor) === null || _a === void 0 ? void 0 : _a.className) !== null && _b !== void 0 ? _b : (_c = target.constructor) === null || _c === void 0 ? void 0 : _c.name;\r\n        if ((targetClass === null || targetClass === void 0 ? void 0 : targetClass.length) < 3) {\r\n            targetClass = null;\r\n        }\r\n        const targetClassName = targetClass ? `of [${targetClass}] ` : '';\r\n        if (predicate.message) {\r\n            Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${stringify(v)}]; ${predicate.message}, ignoring.`);\r\n        }\r\n        else {\r\n            Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${stringify(v)}], ignoring.`);\r\n        }\r\n        return BREAK_TRANSFORM_CHAIN;\r\n    });\r\n}\r\nfunction stringify(value) {\r\n    if (typeof value === 'number' && isNaN(value))\r\n        return 'NaN';\r\n    if (value === Infinity)\r\n        return 'Infinity';\r\n    if (value === -Infinity)\r\n        return '-Infinity';\r\n    return JSON.stringify(value);\r\n}\r\nfunction predicateWithMessage(predicate, message) {\r\n    predicate.message = message;\r\n    return predicate;\r\n}\r\nconst OPTIONAL = (v, ctx, predicate) => v === undefined || predicate(v, ctx);\r\nconst ARRAY = (length, predicate) => {\r\n    return predicateWithMessage((v, ctx) => Array.isArray(v) &&\r\n        (length ? v.length === length : true) &&\r\n        (predicate ? v.every((e) => predicate(e, ctx)) : true), `expecting an Array`);\r\n};\r\nconst OPT_ARRAY = (length) => {\r\n    return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, ARRAY(length)), 'expecting an optional Array');\r\n};\r\nconst NON_EMPTY_ARRAY = predicateWithMessage((v) => Array.isArray(v) && v.length > 0, `expecting a non-empty Array`);\r\nconst OPT_NON_EMPTY_ARRAY = () => {\r\n    return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NON_EMPTY_ARRAY), 'expecting an optional non-empty Array');\r\n};\r\nconst AND = (...predicates) => {\r\n    return predicateWithMessage((v, ctx) => predicates.every((p) => p(v, ctx)), predicates\r\n        .map((p) => p.message)\r\n        .filter((m) => m != null)\r\n        .join(' AND '));\r\n};\r\nconst OR = (...predicates) => {\r\n    return predicateWithMessage((v, ctx) => predicates.some((p) => p(v, ctx)), predicates\r\n        .map((p) => p.message)\r\n        .filter((m) => m != null)\r\n        .join(' OR '));\r\n};\r\nconst isComparable = (v) => {\r\n    return v != null && !isNaN(v);\r\n};\r\nconst LESS_THAN = (otherField) => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField], `expected to be less than ${otherField}`);\r\nconst GREATER_THAN = (otherField) => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField], `expected to be greater than ${otherField}`);\r\nconst FUNCTION = predicateWithMessage((v) => typeof v === 'function', 'expecting a Function');\r\nconst OPT_FUNCTION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FUNCTION), `expecting an optional Function`);\r\nconst BOOLEAN = predicateWithMessage((v) => v === true || v === false, 'expecting a Boolean');\r\nconst OPT_BOOLEAN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN), 'expecting an optional Boolean');\r\nconst STRING = predicateWithMessage((v) => typeof v === 'string', 'expecting a String');\r\nconst OPT_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING), 'expecting an optional String');\r\nconst DATE = predicateWithMessage((v) => v instanceof Date && !isNaN(+v), 'expecting a Date object');\r\nconst OPT_DATE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATE), 'expecting an optional Date');\r\nconst DATE_ARRAY = predicateWithMessage(ARRAY(undefined, DATE), 'expecting an Array of Date objects');\r\nconst DATETIME_MS = NUMBER$1(0);\r\nconst OPT_DATETIME_MS = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATETIME_MS), 'expecting an optional number');\r\nconst OPT_DATE_OR_DATETIME_MS = OR(OPT_DATE, OPT_DATETIME_MS);\r\nconst colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\r\nconst COLOR_STRING = predicateWithMessage((v) => {\r\n    if (typeof v !== 'string') {\r\n        return false;\r\n    }\r\n    return Color.validColorString(v);\r\n}, `expecting a color String. ${colorMessage}`);\r\nconst OPT_COLOR_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING), `expecting an optional color String. ${colorMessage}`);\r\nconst COLOR_STRING_ARRAY = predicateWithMessage(ARRAY(undefined, COLOR_STRING), `expecting an Array of color strings. ${colorMessage}`);\r\nconst OPT_COLOR_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING_ARRAY), `expecting an optional Array of color strings. ${colorMessage}`);\r\nfunction numberMessage(prefix = `expecting a finite Number`, min, max) {\r\n    let message = prefix;\r\n    if (min !== undefined && max !== undefined) {\r\n        message += ` between ${min} and ${max} inclusive`;\r\n    }\r\n    else if (min !== undefined) {\r\n        message += ` greater than or equal to ${min}`;\r\n    }\r\n    else if (max !== undefined) {\r\n        message += ` less than or equal to ${max}`;\r\n    }\r\n    return message;\r\n}\r\nfunction NUMBER$1(min, max) {\r\n    const message = numberMessage(undefined, min, max);\r\n    return predicateWithMessage((v) => typeof v === 'number' &&\r\n        Number.isFinite(v) &&\r\n        (min !== undefined ? v >= min : true) &&\r\n        (max !== undefined ? v <= max : true), message);\r\n}\r\nfunction OPT_NUMBER(min, max) {\r\n    const message = numberMessage('expecting an optional finite Number', min, max);\r\n    return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER$1(min, max)), message);\r\n}\r\nfunction NUMBER_OR_NAN(min, max) {\r\n    // Can be NaN or finite number\r\n    const message = numberMessage(undefined, min, max);\r\n    return predicateWithMessage((v) => typeof v === 'number' &&\r\n        (isNaN(v) ||\r\n            (Number.isFinite(v) && (min !== undefined ? v >= min : true) && (max !== undefined ? v <= max : true))), message);\r\n}\r\nconst NUMBER_ARRAY = predicateWithMessage(ARRAY(undefined, NUMBER$1()), 'expecting an Array of numbers');\r\nconst OPT_NUMBER_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER_ARRAY), 'expecting an optional Array of numbers');\r\nconst STRING_ARRAY = predicateWithMessage(ARRAY(undefined, STRING), 'expecting an Array of strings');\r\nconst OPT_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING_ARRAY), 'expecting an optional Array of strings');\r\nfunction STRING_UNION(...values) {\r\n    const message = `expecting one of: ${values.join(', ')}`;\r\n    return predicateWithMessage((v) => typeof v === 'string' && values.indexOf(v) >= 0, message);\r\n}\r\nconst BOOLEAN_ARRAY = predicateWithMessage(ARRAY(undefined, BOOLEAN), 'expecting an Array of boolean values');\r\nconst OPT_BOOLEAN_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN_ARRAY), 'expecting an optional Array of boolean values');\r\nconst FONT_WEIGHTS = ['normal', 'bold', 'bolder', 'lighter'];\r\nconst FONT_STYLE = predicateWithMessage((v) => v === 'normal' || v === 'italic' || v === 'oblique', `expecting a font style keyword such as 'normal', 'italic' or 'oblique'`);\r\nconst OPT_FONT_STYLE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_STYLE), `expecting an optional font style keyword such as 'normal', 'italic' or 'oblique'`);\r\nconst FONT_WEIGHT = predicateWithMessage((v) => FONT_WEIGHTS.includes(v) || (typeof v === 'number' && isFinite(v)), `expecting a font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);\r\nconst OPT_FONT_WEIGHT = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_WEIGHT), `expecting an optional font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);\r\nconst LINE_DASH = predicateWithMessage(ARRAY(undefined, NUMBER$1(0)), 'expecting an Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');\r\nconst OPT_LINE_DASH = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_DASH), 'expecting an optional Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');\r\nconst LINE_CAPS = ['butt', 'round', 'square'];\r\nconst LINE_CAP = predicateWithMessage((v) => LINE_CAPS.includes(v), `expecting a line cap keyword such as 'butt', 'round' or 'square'`);\r\nconst OPT_LINE_CAP = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_CAP), `expecting an optional line cap keyword such as 'butt', 'round' or 'square'`);\r\nconst LINE_JOINS = ['round', 'bevel', 'miter'];\r\nconst LINE_JOIN = predicateWithMessage((v) => LINE_JOINS.includes(v), `expecting a line join keyword such as 'round', 'bevel' or 'miter'`);\r\nconst OPT_LINE_JOIN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_JOIN), `expecting an optional line join keyword such as 'round', 'bevel' or 'miter'`);\r\nconst POSITIONS = ['top', 'right', 'bottom', 'left'];\r\nconst POSITION = predicateWithMessage((v) => POSITIONS.includes(v), `expecting a position keyword such as 'top', 'right', 'bottom' or 'left`);\r\nconst INTERACTION_RANGES = ['exact', 'nearest'];\r\nconst INTERACTION_RANGE = predicateWithMessage((v) => (typeof v === 'number' && Number.isFinite(v)) || INTERACTION_RANGES.includes(v), `expecting an interaction range of 'exact', 'nearest' or a number`);\r\nconst TEXT_WRAPS = ['never', 'always', 'hyphenate', 'on-space'];\r\nconst TEXT_WRAP = predicateWithMessage((v) => TEXT_WRAPS.includes(v), `expecting a text wrap strategy keyword such as 'never', 'always', 'hyphenate', or 'on-space'`);\r\nconst OVERFLOW_STRAGEGIES = ['ellipsis', 'hide'];\r\nconst OVERFLOW_STRATEGY = predicateWithMessage((v) => OVERFLOW_STRAGEGIES.includes(v), `expecting an overflow strategy keyword such as 'ellipsis', or 'hide'`);\r\nconst TEXT_ALIGNS = ['left', 'center', 'right'];\r\nconst TEXT_ALIGN = predicateWithMessage((v) => TEXT_ALIGNS.includes(v), `expecting a text align keyword such as 'left', 'center', or 'right'`);\r\nconst VERTICAL_ALIGNS = ['top', 'middle', 'bottom'];\r\nconst VERTICAL_ALIGN = predicateWithMessage((v) => VERTICAL_ALIGNS.includes(v), `expecting a text align keyword such as 'top', 'middle', or 'bottom'`);\r\nconst DIRECTIONS = ['horizontal', 'vertical'];\r\nconst DIRECTION = predicateWithMessage((v) => DIRECTIONS.includes(v), `expecting a direction keyword such as 'horizontal' or 'vertical'`);\r\nconst OPT_DIRECTION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DIRECTION), `expecting an optional direction keyword such as 'horizontal' or 'vertical'`);\n\nvar ChartAxisDirection;\r\n(function (ChartAxisDirection) {\r\n    ChartAxisDirection[\"X\"] = \"x\";\r\n    ChartAxisDirection[\"Y\"] = \"y\";\r\n})(ChartAxisDirection || (ChartAxisDirection = {}));\n\nvar RedrawType;\r\n(function (RedrawType) {\r\n    RedrawType[RedrawType[\"NONE\"] = 0] = \"NONE\";\r\n    // Canvas doesn't need clearing, an incremental re-rerender is sufficient.\r\n    RedrawType[RedrawType[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\r\n    // Group needs clearing, a semi-incremental re-render is sufficient.\r\n    RedrawType[RedrawType[\"MINOR\"] = 2] = \"MINOR\";\r\n    // Canvas needs to be cleared for these redraw types.\r\n    RedrawType[RedrawType[\"MAJOR\"] = 3] = \"MAJOR\";\r\n})(RedrawType || (RedrawType = {}));\r\n/** @returns true if new Function() is disabled in the current execution context. */\r\nfunction functionConstructorAvailable() {\r\n    try {\r\n        new Function('return true');\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\nconst STRING_FUNCTION_USEABLE = functionConstructorAvailable();\r\nfunction SceneChangeDetection(opts) {\r\n    const { changeCb, convertor } = opts !== null && opts !== void 0 ? opts : {};\r\n    return function (target, key) {\r\n        // `target` is either a constructor (static member) or prototype (instance member)\r\n        const privateKey = `__${key}`;\r\n        if (target[key]) {\r\n            return;\r\n        }\r\n        if (STRING_FUNCTION_USEABLE && changeCb == null && convertor == null) {\r\n            prepareFastGetSet(target, key, privateKey, opts);\r\n        }\r\n        else {\r\n            prepareSlowGetSet(target, key, privateKey, opts);\r\n        }\r\n    };\r\n}\r\nfunction prepareFastGetSet(target, key, privateKey, opts) {\r\n    const { redraw = RedrawType.TRIVIAL, type = 'normal', checkDirtyOnAssignment = false } = opts !== null && opts !== void 0 ? opts : {};\r\n    // Optimised code-path.\r\n    // Remove all conditional logic from runtime - generate a setter with the exact necessary\r\n    // steps, as these setters are called a LOT during update cycles.\r\n    const setterJs = new Function('value', `\n        const oldValue = this.${privateKey};\n        if (value !== oldValue) {\n            this.${privateKey} = value;\n            ${type === 'normal' ? `this.markDirty(this, ${redraw});` : ''}\n            ${type === 'transform' ? `this.markDirtyTransform(${redraw});` : ''}\n            ${type === 'path'\r\n        ? `if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, ${redraw}); }`\r\n        : ''}\n            ${type === 'font'\r\n        ? `if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, ${redraw}); }`\r\n        : ''}\n        }\n        ${checkDirtyOnAssignment\r\n        ? `if (value != null && value._dirty > ${RedrawType.NONE}) { this.markDirty(value, value._dirty); }`\r\n        : ''}\n`);\r\n    const getterJs = new Function(`return this.${privateKey};`);\r\n    Object.defineProperty(target, key, {\r\n        set: setterJs,\r\n        get: getterJs,\r\n        enumerable: true,\r\n        configurable: true,\r\n    });\r\n}\r\nfunction prepareSlowGetSet(target, key, privateKey, opts) {\r\n    const { redraw = RedrawType.TRIVIAL, type = 'normal', changeCb, convertor, checkDirtyOnAssignment = false, } = opts !== null && opts !== void 0 ? opts : {};\r\n    // Unoptimised but 'safe' code-path, for environments with CSP headers and no 'unsafe-eval'.\r\n    // We deliberately do not support debug branches found in the optimised path above, since\r\n    // for large data-set series performance deteriorates with every extra branch here.\r\n    const setter = function (value) {\r\n        const oldValue = this[privateKey];\r\n        value = convertor ? convertor(value) : value;\r\n        if (value !== oldValue) {\r\n            this[privateKey] = value;\r\n            if (type === 'normal')\r\n                this.markDirty(this, redraw);\r\n            if (type === 'transform')\r\n                this.markDirtyTransform(redraw);\r\n            if (type === 'path' && !this._dirtyPath) {\r\n                this._dirtyPath = true;\r\n                this.markDirty(this, redraw);\r\n            }\r\n            if (type === 'font' && !this._dirtyFont) {\r\n                this._dirtyFont = true;\r\n                this.markDirty(this, redraw);\r\n            }\r\n            if (changeCb)\r\n                changeCb(this);\r\n        }\r\n        if (checkDirtyOnAssignment && value != null && value._dirty > RedrawType.NONE)\r\n            this.markDirty(value, value._dirty);\r\n    };\r\n    const getter = function () {\r\n        return this[privateKey];\r\n    };\r\n    Object.defineProperty(target, key, {\r\n        set: setter,\r\n        get: getter,\r\n        enumerable: true,\r\n        configurable: true,\r\n    });\r\n}\r\nclass ChangeDetectable {\r\n    constructor() {\r\n        this._dirty = RedrawType.MAJOR;\r\n    }\r\n    markDirty(_source, type = RedrawType.TRIVIAL) {\r\n        if (this._dirty > type) {\r\n            return;\r\n        }\r\n        this._dirty = type;\r\n    }\r\n    markClean(_opts) {\r\n        this._dirty = RedrawType.NONE;\r\n    }\r\n    isDirty() {\r\n        return this._dirty > RedrawType.NONE;\r\n    }\r\n}\n\nconst ID_MAP = {};\r\nfunction resetIds() {\r\n    for (const key in ID_MAP) {\r\n        delete ID_MAP[key];\r\n    }\r\n}\r\nfunction createId(instance) {\r\n    var _a;\r\n    const constructor = instance.constructor;\r\n    const className = Object.prototype.hasOwnProperty.call(constructor, 'className')\r\n        ? constructor.className\r\n        : constructor.name;\r\n    if (!className) {\r\n        throw new Error(`The ${constructor} is missing the 'className' property.`);\r\n    }\r\n    const nextId = ((_a = ID_MAP[className]) !== null && _a !== void 0 ? _a : 0) + 1;\r\n    ID_MAP[className] = nextId;\r\n    return className + '-' + nextId;\r\n}\n\nfunction nearestSquared(point, objects, maxDistanceSquared = Infinity) {\r\n    const result = { nearest: undefined, distanceSquared: maxDistanceSquared };\r\n    for (const obj of objects) {\r\n        const thisDistance = obj.distanceSquared(point);\r\n        if (thisDistance === 0) {\r\n            return { nearest: obj, distanceSquared: 0 };\r\n        }\r\n        else if (thisDistance < result.distanceSquared) {\r\n            result.nearest = obj;\r\n            result.distanceSquared = thisDistance;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction nearestSquaredInContainer(point, container, maxDistanceSquared = Infinity) {\r\n    const tpoint = container.transformPoint(point.x, point.y);\r\n    const result = { nearest: undefined, distanceSquared: maxDistanceSquared };\r\n    for (const child of container.children) {\r\n        const { nearest, distanceSquared } = child.nearestSquared(tpoint, result.distanceSquared);\r\n        if (distanceSquared === 0) {\r\n            return { nearest, distanceSquared };\r\n        }\r\n        else if (distanceSquared < result.distanceSquared) {\r\n            result.nearest = nearest;\r\n            result.distanceSquared = distanceSquared;\r\n        }\r\n    }\r\n    return result;\r\n}\n\nclass BBox {\r\n    constructor(x, y, width, height) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    clone() {\r\n        const { x, y, width, height } = this;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    equals(other) {\r\n        return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\r\n    }\r\n    containsPoint(x, y) {\r\n        return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\r\n    }\r\n    collidesBBox(other) {\r\n        return (this.x < other.x + other.width &&\r\n            this.x + this.width > other.x &&\r\n            this.y < other.y + other.height &&\r\n            this.y + this.height > other.y);\r\n    }\r\n    isInfinite() {\r\n        return (Math.abs(this.x) === Infinity ||\r\n            Math.abs(this.y) === Infinity ||\r\n            Math.abs(this.width) === Infinity ||\r\n            Math.abs(this.height) === Infinity);\r\n    }\r\n    distanceSquared(point) {\r\n        if (this.containsPoint(point.x, point.y)) {\r\n            return 0;\r\n        }\r\n        const dx = point.x - Math.max(this.x, Math.min(point.x, this.x + this.width));\r\n        const dy = point.y - Math.max(this.y, Math.min(point.y, this.y + this.height));\r\n        return dx * dx + dy * dy;\r\n    }\r\n    static nearestBox(point, boxes) {\r\n        return nearestSquared(point, boxes);\r\n    }\r\n    shrink(amount, position) {\r\n        const apply = (pos, amt) => {\r\n            switch (pos) {\r\n                case 'top':\r\n                    this.y += amt;\r\n                // eslint-disable-next-line no-fallthrough\r\n                case 'bottom':\r\n                    this.height -= amt;\r\n                    break;\r\n                case 'left':\r\n                    this.x += amt;\r\n                // eslint-disable-next-line no-fallthrough\r\n                case 'right':\r\n                    this.width -= amt;\r\n                    break;\r\n                case 'vertical':\r\n                    this.y += amt;\r\n                    this.height -= amt * 2;\r\n                    break;\r\n                case 'horizontal':\r\n                    this.x += amt;\r\n                    this.width -= amt * 2;\r\n                    break;\r\n                case undefined:\r\n                    this.x += amt;\r\n                    this.width -= amt * 2;\r\n                    this.y += amt;\r\n                    this.height -= amt * 2;\r\n                    break;\r\n                // Unknown position - do nothing.\r\n            }\r\n        };\r\n        if (typeof amount === 'number') {\r\n            apply(position, amount);\r\n        }\r\n        else {\r\n            Object.entries(amount).forEach(([pos, amt]) => apply(pos, amt));\r\n        }\r\n        return this;\r\n    }\r\n    grow(amount, position) {\r\n        if (typeof amount === 'number') {\r\n            this.shrink(-amount, position);\r\n        }\r\n        else {\r\n            const paddingCopy = Object.assign({}, amount);\r\n            for (const key in paddingCopy) {\r\n                paddingCopy[key] *= -1;\r\n            }\r\n            this.shrink(paddingCopy);\r\n        }\r\n        return this;\r\n    }\r\n    static merge(boxes) {\r\n        let left = Infinity;\r\n        let top = Infinity;\r\n        let right = -Infinity;\r\n        let bottom = -Infinity;\r\n        boxes.forEach((box) => {\r\n            if (box.x < left) {\r\n                left = box.x;\r\n            }\r\n            if (box.y < top) {\r\n                top = box.y;\r\n            }\r\n            if (box.x + box.width > right) {\r\n                right = box.x + box.width;\r\n            }\r\n            if (box.y + box.height > bottom) {\r\n                bottom = box.y + box.height;\r\n            }\r\n        });\r\n        return new BBox(left, top, right - left, bottom - top);\r\n    }\r\n}\r\nBBox.zero = new BBox(0, 0, 0, 0);\n\n/**\r\n * As of Jan 8, 2019, Firefox still doesn't implement\r\n * `getTransform(): DOMMatrix;`\r\n * `setTransform(transform?: DOMMatrix2DInit)`\r\n * in the `CanvasRenderingContext2D`.\r\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\r\n * IE11 and Edge 44 also don't have the support.\r\n * Thus this class, to keep track of the current transform and\r\n * combine transformations.\r\n * Standards:\r\n * https://html.spec.whatwg.org/dev/canvas.html\r\n * https://www.w3.org/TR/geometry-1/\r\n */\r\nclass Matrix {\r\n    get e() {\r\n        return [...this.elements];\r\n    }\r\n    constructor(elements = [1, 0, 0, 1, 0, 0]) {\r\n        this.elements = elements;\r\n    }\r\n    setElements(elements) {\r\n        const e = this.elements;\r\n        // `this.elements = elements.slice()` is 4-5 times slower\r\n        // (in Chrome 71 and FF 64) than manually copying elements,\r\n        // since slicing allocates new memory.\r\n        // The performance of passing parameters individually\r\n        // vs as an array is about the same in both browsers, so we\r\n        // go with a single (array of elements) parameter, because\r\n        // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\r\n        // calls give us roughly the same performance, versus\r\n        // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\r\n        // where the spread operator causes a 20-30x performance drop\r\n        // (30x when compiled to ES5's `.apply(this, elements)`\r\n        //  20x when used natively).\r\n        e[0] = elements[0];\r\n        e[1] = elements[1];\r\n        e[2] = elements[2];\r\n        e[3] = elements[3];\r\n        e[4] = elements[4];\r\n        e[5] = elements[5];\r\n        return this;\r\n    }\r\n    get identity() {\r\n        const e = this.elements;\r\n        return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\r\n    }\r\n    /**\r\n     * Performs the AxB matrix multiplication and saves the result\r\n     * to `C`, if given, or to `A` otherwise.\r\n     */\r\n    AxB(A, B, C) {\r\n        const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\r\n        C = C !== null && C !== void 0 ? C : A;\r\n        C[0] = a;\r\n        C[1] = b;\r\n        C[2] = c;\r\n        C[3] = d;\r\n        C[4] = e;\r\n        C[5] = f;\r\n    }\r\n    /**\r\n     * The `other` matrix gets post-multiplied to the current matrix.\r\n     * Returns the current matrix.\r\n     * @param other\r\n     */\r\n    multiplySelf(other) {\r\n        this.AxB(this.elements, other.elements);\r\n        return this;\r\n    }\r\n    /**\r\n     * The `other` matrix gets post-multiplied to the current matrix.\r\n     * Returns a new matrix.\r\n     * @param other\r\n     */\r\n    multiply(other) {\r\n        const elements = new Array(6);\r\n        this.AxB(this.elements, other.elements, elements);\r\n        return new Matrix(elements);\r\n    }\r\n    preMultiplySelf(other) {\r\n        this.AxB(other.elements, this.elements, this.elements);\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns the inverse of this matrix as a new matrix.\r\n     */\r\n    inverse() {\r\n        const el = this.elements;\r\n        let a = el[0], b = el[1], c = el[2], d = el[3];\r\n        const e = el[4], f = el[5];\r\n        const rD = 1 / (a * d - b * c); // reciprocal of determinant\r\n        a *= rD;\r\n        b *= rD;\r\n        c *= rD;\r\n        d *= rD;\r\n        return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\r\n    }\r\n    /**\r\n     * Save the inverse of this matrix to the given matrix.\r\n     */\r\n    inverseTo(other) {\r\n        const el = this.elements;\r\n        let a = el[0], b = el[1], c = el[2], d = el[3];\r\n        const e = el[4], f = el[5];\r\n        const rD = 1 / (a * d - b * c); // reciprocal of determinant\r\n        a *= rD;\r\n        b *= rD;\r\n        c *= rD;\r\n        d *= rD;\r\n        other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\r\n        return this;\r\n    }\r\n    invertSelf() {\r\n        const el = this.elements;\r\n        let a = el[0], b = el[1], c = el[2], d = el[3];\r\n        const e = el[4], f = el[5];\r\n        const rD = 1 / (a * d - b * c); // reciprocal of determinant\r\n        a *= rD;\r\n        b *= rD;\r\n        c *= rD;\r\n        d *= rD;\r\n        el[0] = d;\r\n        el[1] = -b;\r\n        el[2] = -c;\r\n        el[3] = a;\r\n        el[4] = c * f - d * e;\r\n        el[5] = b * e - a * f;\r\n        return this;\r\n    }\r\n    transformPoint(x, y) {\r\n        const e = this.elements;\r\n        return {\r\n            x: x * e[0] + y * e[2] + e[4],\r\n            y: x * e[1] + y * e[3] + e[5],\r\n        };\r\n    }\r\n    transformBBox(bbox, target) {\r\n        const elements = this.elements;\r\n        const xx = elements[0];\r\n        const xy = elements[1];\r\n        const yx = elements[2];\r\n        const yy = elements[3];\r\n        const h_w = bbox.width * 0.5;\r\n        const h_h = bbox.height * 0.5;\r\n        const cx = bbox.x + h_w;\r\n        const cy = bbox.y + h_h;\r\n        const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\r\n        const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\r\n        if (!target) {\r\n            target = new BBox(0, 0, 0, 0);\r\n        }\r\n        target.x = cx * xx + cy * yx + elements[4] - w;\r\n        target.y = cx * xy + cy * yy + elements[5] - h;\r\n        target.width = w + w;\r\n        target.height = h + h;\r\n        return target;\r\n    }\r\n    toContext(ctx) {\r\n        // It's fair to say that matrix multiplications are not cheap.\r\n        // However, updating path definitions on every frame isn't either, so\r\n        // it may be cheaper to just translate paths. It's also fair to\r\n        // say, that most paths will have to be re-rendered anyway, say\r\n        // rectangle paths in a bar chart, where an animation would happen when\r\n        // the data set changes and existing bars are morphed into new ones.\r\n        // Or a pie chart, where old sectors are also morphed into new ones.\r\n        // Same for the line chart. The only plausible case where translating\r\n        // existing paths would be enough, is the scatter chart, where marker\r\n        // icons, typically circles, stay the same size. But if circle radii\r\n        // are bound to some data points, even circle paths would have to be\r\n        // updated. And thus it makes sense to optimize for fewer matrix\r\n        // transforms, where transform matrices of paths are mostly identity\r\n        // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\r\n        // are used to define a path at specific coordinates. And only groups\r\n        // are used to collectively apply a transform to a set of nodes.\r\n        // If the matrix is mostly identity (95% of the time),\r\n        // the `if (this.isIdentity)` check can make this call 3-4 times\r\n        // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\r\n        if (this.identity) {\r\n            return;\r\n        }\r\n        const e = this.elements;\r\n        ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\r\n    }\r\n    static flyweight(sourceMatrix) {\r\n        return Matrix.instance.setElements(sourceMatrix.elements);\r\n    }\r\n    static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\r\n        // Assume that centers of scaling and rotation are at the origin.\r\n        const [bbcx, bbcy] = [0, 0];\r\n        const sx = scalingX;\r\n        const sy = scalingY;\r\n        let scx;\r\n        let scy;\r\n        if (sx === 1 && sy === 1) {\r\n            scx = 0;\r\n            scy = 0;\r\n        }\r\n        else {\r\n            scx = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.scalingCenterX;\r\n            scy = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.scalingCenterY;\r\n        }\r\n        const r = rotation;\r\n        const cos = Math.cos(r);\r\n        const sin = Math.sin(r);\r\n        let rcx;\r\n        let rcy;\r\n        if (r === 0) {\r\n            rcx = 0;\r\n            rcy = 0;\r\n        }\r\n        else {\r\n            rcx = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.rotationCenterX;\r\n            rcy = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.rotationCenterY;\r\n        }\r\n        const tx = translationX;\r\n        const ty = translationY;\r\n        // The transform matrix `M` is a result of the following transformations:\r\n        // 1) translate the center of scaling to the origin\r\n        // 2) scale\r\n        // 3) translate back\r\n        // 4) translate the center of rotation to the origin\r\n        // 5) rotate\r\n        // 6) translate back\r\n        // 7) translate\r\n        //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\r\n        //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\r\n        // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\r\n        //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\r\n        // Translation after steps 1-4 above:\r\n        const tx4 = scx * (1 - sx) - rcx;\r\n        const ty4 = scy * (1 - sy) - rcy;\r\n        matrix.setElements([\r\n            cos * sx,\r\n            sin * sx,\r\n            -sin * sy,\r\n            cos * sy,\r\n            cos * tx4 - sin * ty4 + rcx + tx,\r\n            sin * tx4 + cos * ty4 + rcy + ty,\r\n        ]);\r\n        return matrix;\r\n    }\r\n    static fromContext(ctx) {\r\n        const domMatrix = ctx.getTransform();\r\n        return new Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\r\n    }\r\n}\r\nMatrix.instance = new Matrix();\n\nvar PointerEvents;\r\n(function (PointerEvents) {\r\n    PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\r\n    PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\r\n})(PointerEvents || (PointerEvents = {}));\r\nconst zIndexChangedCallback = (o) => {\r\n    if (o.parent) {\r\n        o.parent.dirtyZIndex = true;\r\n    }\r\n    o.zIndexChanged();\r\n};\r\n/**\r\n * Abstract scene graph node.\r\n * Each node can have zero or one parent and belong to zero or one scene.\r\n */\r\nclass Node extends ChangeDetectable {\r\n    /**\r\n     * Some arbitrary data bound to the node.\r\n     */\r\n    get datum() {\r\n        var _a, _b;\r\n        return (_a = this._datum) !== null && _a !== void 0 ? _a : (_b = this._parent) === null || _b === void 0 ? void 0 : _b.datum;\r\n    }\r\n    get previousDatum() {\r\n        return this._previousDatum;\r\n    }\r\n    set datum(datum) {\r\n        if (this._datum !== datum)\r\n            this._previousDatum = this._datum;\r\n        this._datum = datum;\r\n    }\r\n    _setLayerManager(value) {\r\n        this._layerManager = value;\r\n        this._debug = value === null || value === void 0 ? void 0 : value.debug;\r\n        for (const child of this._children) {\r\n            child._setLayerManager(value);\r\n        }\r\n        for (const child of this._virtualChildren) {\r\n            child._setLayerManager(value);\r\n        }\r\n    }\r\n    get layerManager() {\r\n        return this._layerManager;\r\n    }\r\n    get parent() {\r\n        return this._parent;\r\n    }\r\n    get children() {\r\n        if (this._virtualChildren.length === 0)\r\n            return this._children;\r\n        const result = [...this._children];\r\n        for (const next of this._virtualChildren) {\r\n            result.push(...next.children);\r\n        }\r\n        return result;\r\n    }\r\n    get virtualChildren() {\r\n        return this._virtualChildren;\r\n    }\r\n    hasVirtualChildren() {\r\n        return this._virtualChildren.length > 0;\r\n    }\r\n    setProperties(styles, pickKeys) {\r\n        const keys = pickKeys !== null && pickKeys !== void 0 ? pickKeys : Object.keys(styles);\r\n        for (const key of keys) {\r\n            this[key] = styles[key];\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Appends one or more new node instances to this parent.\r\n     * If one needs to:\r\n     * - move a child to the end of the list of children\r\n     * - move a child from one parent to another (including parents in other scenes)\r\n     * one should use the {@link insertBefore} method instead.\r\n     * @param nodes A node or nodes to append.\r\n     */\r\n    append(nodes) {\r\n        // Passing a single parameter to an open-ended version of `append`\r\n        // would be 30-35% slower than this.\r\n        if (!Array.isArray(nodes)) {\r\n            nodes = [nodes];\r\n        }\r\n        for (const node of nodes) {\r\n            if (node.parent) {\r\n                throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\r\n            }\r\n            if (node.layerManager) {\r\n                throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);\r\n            }\r\n            if (this.childSet[node.id]) {\r\n                // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\r\n                throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);\r\n            }\r\n            if (node.isVirtual) {\r\n                this._virtualChildren.push(node);\r\n            }\r\n            else {\r\n                this._children.push(node);\r\n            }\r\n            this.childSet[node.id] = true;\r\n            node._parent = this;\r\n            node._setLayerManager(this.layerManager);\r\n        }\r\n        this.dirtyZIndex = true;\r\n        this.markDirty(this, RedrawType.MAJOR);\r\n    }\r\n    appendChild(node) {\r\n        this.append(node);\r\n        return node;\r\n    }\r\n    removeChild(node) {\r\n        const error = () => {\r\n            throw new Error(`The node to be removed is not a child of this node.`);\r\n        };\r\n        if (node.parent !== this) {\r\n            error();\r\n        }\r\n        if (node.isVirtual) {\r\n            const i = this._virtualChildren.indexOf(node);\r\n            if (i < 0)\r\n                error();\r\n            this._virtualChildren.splice(i, 1);\r\n        }\r\n        else {\r\n            const i = this._children.indexOf(node);\r\n            if (i < 0)\r\n                error();\r\n            this._children.splice(i, 1);\r\n        }\r\n        delete this.childSet[node.id];\r\n        node._parent = undefined;\r\n        node._setLayerManager();\r\n        this.dirtyZIndex = true;\r\n        this.markDirty(node, RedrawType.MAJOR);\r\n        return node;\r\n    }\r\n    calculateCumulativeMatrix() {\r\n        this.computeTransformMatrix();\r\n        const matrix = Matrix.flyweight(this.matrix);\r\n        let parent = this.parent;\r\n        while (parent) {\r\n            parent.computeTransformMatrix();\r\n            matrix.preMultiplySelf(parent.matrix);\r\n            parent = parent.parent;\r\n        }\r\n        return matrix;\r\n    }\r\n    transformPoint(x, y) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.invertSelf().transformPoint(x, y);\r\n    }\r\n    inverseTransformPoint(x, y) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.transformPoint(x, y);\r\n    }\r\n    transformBBox(bbox) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.invertSelf().transformBBox(bbox);\r\n    }\r\n    inverseTransformBBox(bbox) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.transformBBox(bbox);\r\n    }\r\n    markDirtyTransform() {\r\n        this.dirtyTransform = true;\r\n        this.markDirty(this, RedrawType.MAJOR);\r\n    }\r\n    constructor({ isVirtual, tag } = {}) {\r\n        super();\r\n        /** Unique number to allow creation order to be easily determined. */\r\n        this.serialNumber = Node._nextSerialNumber++;\r\n        /**\r\n         * Unique node ID in the form `ClassName-NaturalNumber`.\r\n         */\r\n        this.id = createId(this);\r\n        /**\r\n         * To simplify the type system (especially in Selections) we don't have the `Parent` node\r\n         * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\r\n         * But we still need to distinguish regular leaf nodes from container leafs somehow.\r\n         */\r\n        this.isContainerNode = false;\r\n        this._virtualChildren = [];\r\n        this._children = [];\r\n        // Used to check for duplicate nodes.\r\n        this.childSet = {}; // new Set<Node>()\r\n        // These matrices may need to have package level visibility\r\n        // for performance optimization purposes.\r\n        this.matrix = new Matrix();\r\n        this.inverseMatrix = new Matrix();\r\n        this.dirtyTransform = false;\r\n        this.scalingX = 1;\r\n        this.scalingY = 1;\r\n        /**\r\n         * The center of scaling.\r\n         * The default value of `null` means the scaling center will be\r\n         * determined automatically, as the center of the bounding box\r\n         * of a node.\r\n         */\r\n        this.scalingCenterX = null;\r\n        this.scalingCenterY = null;\r\n        this.rotationCenterX = null;\r\n        this.rotationCenterY = null;\r\n        /**\r\n         * Rotation angle in radians.\r\n         * The value is set as is. No normalization to the [-180, 180) or [0, 360)\r\n         * interval is performed.\r\n         */\r\n        this.rotation = 0;\r\n        this.translationX = 0;\r\n        this.translationY = 0;\r\n        this.visible = true;\r\n        this.dirtyZIndex = false;\r\n        this.zIndex = 0;\r\n        /** Discriminators for render order within a zIndex. */\r\n        this.zIndexSubOrder = undefined;\r\n        this.pointerEvents = PointerEvents.All;\r\n        this.isVirtual = isVirtual !== null && isVirtual !== void 0 ? isVirtual : false;\r\n        this.tag = tag !== null && tag !== void 0 ? tag : NaN;\r\n    }\r\n    containsPoint(_x, _y) {\r\n        return false;\r\n    }\r\n    /**\r\n     * Hit testing method.\r\n     * Recursively checks if the given point is inside this node or any of its children.\r\n     * Returns the first matching node or `undefined`.\r\n     * Nodes that render later (show on top) are hit tested first.\r\n     */\r\n    pickNode(x, y) {\r\n        var _a;\r\n        if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\r\n            return;\r\n        }\r\n        const children = this.children;\r\n        if (children.length > 1000) {\r\n            // Try to optimise which children to interrogate; BBox calculation is an approximation\r\n            // for more complex shapes, so discarding items based on this will save a lot of\r\n            // processing when the point is nowhere near the child.\r\n            for (let i = children.length - 1; i >= 0; i--) {\r\n                const child = children[i];\r\n                const containsPoint = (_a = child.computeTransformedBBox()) === null || _a === void 0 ? void 0 : _a.containsPoint(x, y);\r\n                const hit = containsPoint ? child.pickNode(x, y) : undefined;\r\n                if (hit) {\r\n                    return hit;\r\n                }\r\n            }\r\n        }\r\n        else if (children.length) {\r\n            // Nodes added later should be hit-tested first,\r\n            // as they are rendered on top of the previously added nodes.\r\n            for (let i = children.length - 1; i >= 0; i--) {\r\n                const hit = children[i].pickNode(x, y);\r\n                if (hit) {\r\n                    return hit;\r\n                }\r\n            }\r\n        }\r\n        else if (!this.isContainerNode) {\r\n            // a leaf node, but not a container leaf\r\n            return this;\r\n        }\r\n    }\r\n    findNodes(predicate) {\r\n        const result = predicate(this) ? [this] : [];\r\n        for (const child of this.children) {\r\n            const childResult = child.findNodes(predicate);\r\n            if (childResult) {\r\n                result.push(...childResult);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    computeBBox() {\r\n        return;\r\n    }\r\n    computeTransformedBBox() {\r\n        const bbox = this.computeBBox();\r\n        if (!bbox) {\r\n            return undefined;\r\n        }\r\n        this.computeTransformMatrix();\r\n        const matrix = Matrix.flyweight(this.matrix);\r\n        let parent = this.parent;\r\n        while (parent) {\r\n            parent.computeTransformMatrix();\r\n            matrix.preMultiplySelf(parent.matrix);\r\n            parent = parent.parent;\r\n        }\r\n        matrix.transformBBox(bbox, bbox);\r\n        return bbox;\r\n    }\r\n    computeTransformMatrix() {\r\n        if (!this.dirtyTransform) {\r\n            return;\r\n        }\r\n        const { matrix, scalingX, scalingY, rotation, translationX, translationY, scalingCenterX, scalingCenterY, rotationCenterX, rotationCenterY, } = this;\r\n        Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\r\n            scalingCenterX,\r\n            scalingCenterY,\r\n            rotationCenterX,\r\n            rotationCenterY,\r\n        });\r\n        matrix.inverseTo(this.inverseMatrix);\r\n        this.dirtyTransform = false;\r\n    }\r\n    render(renderCtx) {\r\n        const { stats } = renderCtx;\r\n        this._dirty = RedrawType.NONE;\r\n        if (stats)\r\n            stats.nodesRendered++;\r\n    }\r\n    clearBBox(ctx) {\r\n        const bbox = this.computeBBox();\r\n        if (bbox == null) {\r\n            return;\r\n        }\r\n        const { x, y, width, height } = bbox;\r\n        const topLeft = this.transformPoint(x, y);\r\n        const bottomRight = this.transformPoint(x + width, y + height);\r\n        ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\r\n    }\r\n    markDirty(_source, type = RedrawType.TRIVIAL, parentType = type) {\r\n        if (this._dirty > type) {\r\n            return;\r\n        }\r\n        if (this._dirty === type && type === parentType) {\r\n            return;\r\n        }\r\n        this._dirty = type;\r\n        if (this.parent) {\r\n            this.parent.markDirty(this, parentType);\r\n        }\r\n        else if (this.layerManager) {\r\n            this.layerManager.markDirty();\r\n        }\r\n    }\r\n    get dirty() {\r\n        return this._dirty;\r\n    }\r\n    markClean(opts) {\r\n        const { force = false, recursive = true } = opts !== null && opts !== void 0 ? opts : {};\r\n        if (this._dirty === RedrawType.NONE && !force) {\r\n            return;\r\n        }\r\n        this._dirty = RedrawType.NONE;\r\n        if (recursive !== false) {\r\n            for (const child of this._virtualChildren) {\r\n                child.markClean({ force });\r\n            }\r\n        }\r\n        if (recursive === true) {\r\n            for (const child of this._children) {\r\n                child.markClean({ force });\r\n            }\r\n        }\r\n    }\r\n    visibilityChanged() {\r\n        // Override point for sub-classes to react to visibility changes.\r\n    }\r\n    get nodeCount() {\r\n        let count = 1;\r\n        let dirtyCount = this._dirty >= RedrawType.NONE || this.dirtyTransform ? 1 : 0;\r\n        let visibleCount = this.visible ? 1 : 0;\r\n        const countChild = (child) => {\r\n            const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;\r\n            count += childCount;\r\n            visibleCount += childVisibleCount;\r\n            dirtyCount += childDirtyCount;\r\n        };\r\n        for (const child of this._children) {\r\n            countChild(child);\r\n        }\r\n        for (const child of this._virtualChildren) {\r\n            countChild(child);\r\n        }\r\n        return { count, visibleCount, dirtyCount };\r\n    }\r\n    zIndexChanged() {\r\n        // Override point for sub-classes.\r\n    }\r\n}\r\nNode._nextSerialNumber = 0;\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"scalingX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"scalingY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"scalingCenterX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"scalingCenterY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"rotationCenterX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"rotationCenterY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"translationX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"translationY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR, changeCb: (o) => o.visibilityChanged() }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Node.prototype, \"visible\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.TRIVIAL,\r\n        changeCb: zIndexChangedCallback,\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"zIndex\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.TRIVIAL,\r\n        changeCb: zIndexChangedCallback,\r\n    })\r\n    /** Discriminators for render order within a zIndex. */\r\n    ,\r\n    __metadata(\"design:type\", Array)\r\n], Node.prototype, \"zIndexSubOrder\", void 0);\n\nclass DropShadow extends ChangeDetectable {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.enabled = true;\r\n        this.color = 'rgba(0, 0, 0, 0.5)';\r\n        this.xOffset = 0;\r\n        this.yOffset = 0;\r\n        this.blur = 5;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"xOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"yOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"blur\", void 0);\n\nconst MOBILE = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];\r\nfunction isDesktop() {\r\n    if (typeof navigator === 'undefined') {\r\n        return true;\r\n    }\r\n    const userAgent = navigator.userAgent;\r\n    return !MOBILE.some((r) => r.test(userAgent));\r\n}\n\n/**\r\n * Wraps the native Canvas element and overrides its CanvasRenderingContext2D to\r\n * provide resolution independent rendering based on `window.devicePixelRatio`.\r\n */\r\nclass HdpiCanvas {\r\n    // The width/height attributes of the Canvas element default to\r\n    // 300/150 according to w3.org.\r\n    constructor(opts) {\r\n        this._enabled = true;\r\n        // `NaN` is deliberate here, so that overrides are always applied\r\n        // and the `resetTransform` inside the `resize` method works in IE11.\r\n        this._pixelRatio = NaN;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        const { document, window, width = 600, height = 300, domLayer = false, zIndex = 0, name = undefined, overrideDevicePixelRatio = undefined, } = opts;\r\n        this.document = document;\r\n        this.window = window;\r\n        HdpiCanvas.document = document;\r\n        // Create canvas and immediately apply width + height to avoid out-of-memory\r\n        // errors on iOS/iPadOS Safari.\r\n        this.element = document.createElement('canvas');\r\n        this.element.width = width;\r\n        this.element.height = height;\r\n        this.realContext = this.element.getContext('2d');\r\n        this.imageSource = this.realContext.canvas;\r\n        const { style } = this.element;\r\n        style.userSelect = 'none';\r\n        style.display = 'block';\r\n        if (domLayer) {\r\n            style.position = 'absolute';\r\n            style.zIndex = String(zIndex);\r\n            style.top = '0';\r\n            style.left = '0';\r\n            style.pointerEvents = 'none';\r\n            style.opacity = `1`;\r\n            if (name) {\r\n                this.element.id = name;\r\n            }\r\n        }\r\n        this.context = this.setPixelRatio(overrideDevicePixelRatio);\r\n        this.resize(width, height);\r\n    }\r\n    set container(value) {\r\n        if (this._container !== value) {\r\n            this.remove();\r\n            if (value) {\r\n                value.appendChild(this.element);\r\n            }\r\n            this._container = value;\r\n        }\r\n    }\r\n    get container() {\r\n        return this._container;\r\n    }\r\n    set enabled(value) {\r\n        this.element.style.display = value ? 'block' : 'none';\r\n        this._enabled = !!value;\r\n    }\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    remove() {\r\n        const { parentNode } = this.element;\r\n        if (parentNode != null) {\r\n            parentNode.removeChild(this.element);\r\n        }\r\n    }\r\n    destroy() {\r\n        this.element.remove();\r\n        // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.\r\n        // See https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n        this.element.width = 0;\r\n        this.element.height = 0;\r\n        this.context.clearRect(0, 0, 0, 0);\r\n        Object.freeze(this);\r\n    }\r\n    snapshot() {\r\n        // No-op for compatibility with HdpiOffscreenCanvas.\r\n    }\r\n    clear() {\r\n        this.context.save();\r\n        this.context.resetTransform();\r\n        this.context.clearRect(0, 0, this.width, this.height);\r\n        this.context.restore();\r\n    }\r\n    toImage() {\r\n        const img = this.document.createElement('img');\r\n        img.src = this.getDataURL();\r\n        return img;\r\n    }\r\n    getDataURL(type) {\r\n        return this.element.toDataURL(type);\r\n    }\r\n    /**\r\n     * @param fileName The name of the downloaded file.\r\n     * @param fileFormat The file format, the default is `image/png`\r\n     */\r\n    download(fileName, fileFormat = 'image/png') {\r\n        fileName = (fileName !== null && fileName !== void 0 ? fileName : '').trim() || 'image';\r\n        const dataUrl = this.getDataURL(fileFormat);\r\n        const document = this.document;\r\n        const a = document.createElement('a');\r\n        a.href = dataUrl;\r\n        a.download = fileName;\r\n        a.style.display = 'none';\r\n        document.body.appendChild(a); // required for the `click` to work in Firefox\r\n        a.click();\r\n        document.body.removeChild(a);\r\n    }\r\n    get pixelRatio() {\r\n        return this._pixelRatio;\r\n    }\r\n    /**\r\n     * Changes the pixel ratio of the Canvas element to the given value,\r\n     * or uses the window.devicePixelRatio (default), then resizes the Canvas\r\n     * element accordingly (default).\r\n     */\r\n    setPixelRatio(ratio) {\r\n        let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : this.window.devicePixelRatio;\r\n        if (!isDesktop()) {\r\n            // Mobile browsers have stricter memory limits, we reduce rendering resolution to\r\n            // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they\r\n            // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n            pixelRatio = 1;\r\n        }\r\n        this._pixelRatio = pixelRatio;\r\n        return HdpiCanvas.overrideScale(this.realContext, pixelRatio);\r\n    }\r\n    set pixelated(value) {\r\n        this.element.style.imageRendering = value ? 'pixelated' : 'auto';\r\n    }\r\n    get pixelated() {\r\n        return this.element.style.imageRendering === 'pixelated';\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    resize(width, height) {\r\n        if (!(width > 0 && height > 0)) {\r\n            return;\r\n        }\r\n        const { element, context, pixelRatio } = this;\r\n        element.width = Math.round(width * pixelRatio);\r\n        element.height = Math.round(height * pixelRatio);\r\n        element.style.width = width + 'px';\r\n        element.style.height = height + 'px';\r\n        context.resetTransform();\r\n        this._width = width;\r\n        this._height = height;\r\n    }\r\n    static get textMeasuringContext() {\r\n        if (this._textMeasuringContext) {\r\n            return this._textMeasuringContext;\r\n        }\r\n        const canvas = this.document.createElement('canvas');\r\n        this._textMeasuringContext = canvas.getContext('2d');\r\n        return this._textMeasuringContext;\r\n    }\r\n    static get svgText() {\r\n        if (this._svgText) {\r\n            return this._svgText;\r\n        }\r\n        const xmlns = 'http://www.w3.org/2000/svg';\r\n        const svg = document.createElementNS(xmlns, 'svg');\r\n        svg.setAttribute('width', '100');\r\n        svg.setAttribute('height', '100');\r\n        // Add a descriptive class name in case someone sees this SVG element\r\n        // in devtools and wonders about its purpose:\r\n        if (svg.classList) {\r\n            svg.classList.add('text-measuring-svg');\r\n        }\r\n        else {\r\n            svg.setAttribute('class', 'text-measuring-svg');\r\n        }\r\n        svg.style.position = 'absolute';\r\n        svg.style.top = '-1000px';\r\n        svg.style.visibility = 'hidden';\r\n        const svgText = document.createElementNS(xmlns, 'text');\r\n        svgText.setAttribute('x', '0');\r\n        svgText.setAttribute('y', '30');\r\n        svgText.setAttribute('text', 'black');\r\n        svg.appendChild(svgText);\r\n        document.body.appendChild(svg);\r\n        this._svgText = svgText;\r\n        return svgText;\r\n    }\r\n    static get has() {\r\n        if (this._has) {\r\n            return this._has;\r\n        }\r\n        const isChrome = typeof navigator === 'undefined' || navigator.userAgent.indexOf('Chrome') > -1;\r\n        const isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') > -1;\r\n        const isSafari = !isChrome && typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') > -1;\r\n        this._has = Object.freeze({\r\n            textMetrics: this.textMeasuringContext.measureText('test').actualBoundingBoxDescent !== undefined &&\r\n                // Firefox implemented advanced TextMetrics object in v74:\r\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1102584\r\n                // but it's buggy, so we'll keep using the SVG for text measurement in Firefox for now.\r\n                !isFirefox &&\r\n                !isSafari,\r\n            getTransform: this.textMeasuringContext.getTransform !== undefined,\r\n        });\r\n        return this._has;\r\n    }\r\n    static measureText(text, font, textBaseline, textAlign) {\r\n        const ctx = this.textMeasuringContext;\r\n        ctx.font = font;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.textAlign = textAlign;\r\n        return ctx.measureText(text);\r\n    }\r\n    /**\r\n     * Returns the width and height of the measured text.\r\n     * @param text The single-line text to measure.\r\n     * @param font The font shorthand string.\r\n     */\r\n    static getTextSize(text, font) {\r\n        if (this.has.textMetrics) {\r\n            const ctx = this.textMeasuringContext;\r\n            ctx.font = font;\r\n            const metrics = ctx.measureText(text);\r\n            return {\r\n                width: metrics.width,\r\n                height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,\r\n            };\r\n        }\r\n        else {\r\n            return this.measureSvgText(text, font);\r\n        }\r\n    }\r\n    static measureSvgText(text, font) {\r\n        const cache = this.textSizeCache;\r\n        const fontCache = cache[font];\r\n        // Note: consider not caching the size of numeric strings.\r\n        // For example: if (isNaN(+text)) { // skip\r\n        if (fontCache) {\r\n            const size = fontCache[text];\r\n            if (size) {\r\n                return size;\r\n            }\r\n        }\r\n        else {\r\n            cache[font] = {};\r\n        }\r\n        const svgText = this.svgText;\r\n        svgText.style.font = font;\r\n        svgText.textContent = text;\r\n        // `getBBox` returns an instance of `SVGRect` with the same `width` and `height`\r\n        // measurements as `DOMRect` instance returned by the `getBoundingClientRect`.\r\n        // But the `SVGRect` instance has half the properties of the `DOMRect`,\r\n        // so we use the `getBBox` method.\r\n        const bbox = svgText.getBBox();\r\n        const size = {\r\n            width: bbox.width,\r\n            height: bbox.height,\r\n        };\r\n        cache[font][text] = size;\r\n        return size;\r\n    }\r\n    static overrideScale(ctx, scale) {\r\n        let depth = 0;\r\n        const overrides = {\r\n            save() {\r\n                this.$save();\r\n                depth++;\r\n            },\r\n            restore() {\r\n                if (depth > 0) {\r\n                    this.$restore();\r\n                    depth--;\r\n                }\r\n                else {\r\n                    throw new Error('AG Charts - Unable to restore() past depth 0');\r\n                }\r\n            },\r\n            setTransform(a, b, c, d, e, f) {\r\n                if (typeof a === 'object') {\r\n                    this.$setTransform(a);\r\n                }\r\n                else {\r\n                    this.$setTransform(a * scale, b * scale, c * scale, d * scale, e * scale, f * scale);\r\n                }\r\n            },\r\n            resetTransform() {\r\n                // As of Jan 8, 2019, `resetTransform` is still an \"experimental technology\",\r\n                // and doesn't work in IE11 and Edge 44.\r\n                this.$setTransform(scale, 0, 0, scale, 0, 0);\r\n            },\r\n            verifyDepthZero() {\r\n                if (depth !== 0) {\r\n                    throw new Error('AG Charts - Save/restore depth is non-zero: ' + depth);\r\n                }\r\n            },\r\n        };\r\n        for (const name in overrides) {\r\n            if (Object.prototype.hasOwnProperty.call(overrides, name)) {\r\n                // Save native methods under prefixed names,\r\n                // if this hasn't been done by the previous overrides already.\r\n                if (!ctx['$' + name]) {\r\n                    ctx['$' + name] = ctx[name];\r\n                }\r\n                // Replace native methods with overrides,\r\n                // or previous overrides with the new ones.\r\n                ctx[name] = overrides[name];\r\n            }\r\n        }\r\n        return ctx;\r\n    }\r\n}\r\nHdpiCanvas.document = globalThis.document;\r\nHdpiCanvas.textSizeCache = {};\n\nclass Gradient {\r\n    constructor() {\r\n        this.stops = [];\r\n    }\r\n}\n\nclass LinearGradient extends Gradient {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.angle = 0;\r\n    }\r\n    createGradient(ctx, bbox) {\r\n        // Gradient 0° angle starts at top according to CSS spec\r\n        const angleOffset = 90;\r\n        const { stops, angle } = this;\r\n        const radians = normalizeAngle360(toRadians(angle + angleOffset));\r\n        const cos = Math.cos(radians);\r\n        const sin = Math.sin(radians);\r\n        const w = bbox.width;\r\n        const h = bbox.height;\r\n        const cx = bbox.x + w * 0.5;\r\n        const cy = bbox.y + h * 0.5;\r\n        if (w > 0 && h > 0) {\r\n            const diagonal = Math.sqrt(h * h + w * w) / 2;\r\n            const diagonalAngle = Math.atan2(h, w);\r\n            let quarteredAngle;\r\n            if (radians < Math.PI / 2) {\r\n                quarteredAngle = radians;\r\n            }\r\n            else if (radians < Math.PI) {\r\n                quarteredAngle = Math.PI - radians;\r\n            }\r\n            else if (radians < (3 * Math.PI) / 2) {\r\n                quarteredAngle = radians - Math.PI;\r\n            }\r\n            else {\r\n                quarteredAngle = 2 * Math.PI - radians;\r\n            }\r\n            const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\r\n            const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\r\n            stops.forEach((stop) => {\r\n                gradient.addColorStop(stop.offset, stop.color);\r\n            });\r\n            return gradient;\r\n        }\r\n        return 'black';\r\n    }\r\n}\n\nconst LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((.*?)deg,\\s*(.*?)\\s*\\)$/i;\r\nclass Shape extends Node {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.fill = Shape.defaultStyles.fill;\r\n        /**\r\n         * Note that `strokeStyle = null` means invisible stroke,\r\n         * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\r\n         * For example, a rect shape with an invisible stroke may not align to the pixel grid\r\n         * properly because the stroke affects the rules of alignment, and arc shapes forming\r\n         * a pie chart will have a gap between them if they have an invisible stroke, whereas\r\n         * there would be not gap if there was no stroke at all.\r\n         * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\r\n         * unless specific looks that is achieved by having an invisible stroke is desired.\r\n         */\r\n        this.stroke = Shape.defaultStyles.stroke;\r\n        this.strokeWidth = Shape.defaultStyles.strokeWidth;\r\n        this.lineDash = Shape.defaultStyles.lineDash;\r\n        this.lineDashOffset = Shape.defaultStyles.lineDashOffset;\r\n        this.lineCap = Shape.defaultStyles.lineCap;\r\n        this.lineJoin = Shape.defaultStyles.lineJoin;\r\n        this.opacity = Shape.defaultStyles.opacity;\r\n        this.fillShadow = Shape.defaultStyles.fillShadow;\r\n    }\r\n    /**\r\n     * Restores the default styles introduced by this subclass.\r\n     */\r\n    restoreOwnStyles() {\r\n        const styles = this.constructor.defaultStyles;\r\n        const keys = Object.getOwnPropertyNames(styles);\r\n        // getOwnPropertyNames is about 2.5 times faster than\r\n        // for..in with the hasOwnProperty check and in this\r\n        // case, where most properties are inherited, can be\r\n        // more than an order of magnitude faster.\r\n        for (let i = 0, n = keys.length; i < n; i++) {\r\n            const key = keys[i];\r\n            this[key] = styles[key];\r\n        }\r\n    }\r\n    updateGradient() {\r\n        const { fill } = this;\r\n        let linearGradientMatch;\r\n        if ((fill === null || fill === void 0 ? void 0 : fill.startsWith('linear-gradient')) && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\r\n            const angle = parseFloat(linearGradientMatch[1]);\r\n            const colors = [];\r\n            const colorsPart = linearGradientMatch[2];\r\n            const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\r\n            let c;\r\n            while ((c = colorRegex.exec(colorsPart))) {\r\n                colors.push(c[0]);\r\n            }\r\n            this.gradient = new LinearGradient();\r\n            this.gradient.angle = angle;\r\n            this.gradient.stops = colors.map((color, index) => {\r\n                const offset = index / (colors.length - 1);\r\n                return { offset, color };\r\n            });\r\n        }\r\n        else {\r\n            this.gradient = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a device-pixel aligned coordinate (or length if length is supplied).\r\n     *\r\n     * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\r\n     * of a device pixel.\r\n     */\r\n    align(start, length) {\r\n        var _a, _b, _c;\r\n        const pixelRatio = (_c = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas) === null || _b === void 0 ? void 0 : _b.pixelRatio) !== null && _c !== void 0 ? _c : 1;\r\n        const alignedStart = Math.round(start * pixelRatio) / pixelRatio;\r\n        if (length == undefined) {\r\n            return alignedStart;\r\n        }\r\n        if (length === 0) {\r\n            return 0;\r\n        }\r\n        if (length < 1) {\r\n            // Avoid hiding crisp shapes\r\n            return Math.ceil(length * pixelRatio) / pixelRatio;\r\n        }\r\n        // Account for the rounding of alignedStart by increasing length to compensate before\r\n        // alignment.\r\n        return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;\r\n    }\r\n    fillStroke(ctx) {\r\n        this.renderFill(ctx);\r\n        this.renderStroke(ctx);\r\n    }\r\n    renderFill(ctx) {\r\n        if (this.fill) {\r\n            const { globalAlpha } = ctx;\r\n            this.applyFill(ctx);\r\n            this.applyFillAlpha(ctx);\r\n            this.applyShadow(ctx);\r\n            ctx.fill();\r\n            ctx.globalAlpha = globalAlpha;\r\n        }\r\n        ctx.shadowColor = 'rgba(0, 0, 0, 0)';\r\n    }\r\n    applyFill(ctx) {\r\n        if (this.gradient) {\r\n            ctx.fillStyle = this.gradient.createGradient(ctx, this.computeBBox());\r\n        }\r\n        else {\r\n            ctx.fillStyle = this.fill;\r\n        }\r\n    }\r\n    applyFillAlpha(ctx) {\r\n        const { globalAlpha } = ctx;\r\n        ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\r\n    }\r\n    applyShadow(ctx) {\r\n        var _a, _b;\r\n        // The canvas context scaling (depends on the device's pixel ratio)\r\n        // has no effect on shadows, so we have to account for the pixel ratio\r\n        // manually here.\r\n        const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;\r\n        const fillShadow = this.fillShadow;\r\n        if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {\r\n            ctx.shadowColor = fillShadow.color;\r\n            ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\r\n            ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\r\n            ctx.shadowBlur = fillShadow.blur * pixelRatio;\r\n        }\r\n    }\r\n    renderStroke(ctx) {\r\n        if (this.stroke && this.strokeWidth) {\r\n            const { globalAlpha } = ctx;\r\n            ctx.strokeStyle = this.stroke;\r\n            ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\r\n            ctx.lineWidth = this.strokeWidth;\r\n            if (this.lineDash) {\r\n                ctx.setLineDash(this.lineDash);\r\n            }\r\n            if (this.lineDashOffset) {\r\n                ctx.lineDashOffset = this.lineDashOffset;\r\n            }\r\n            if (this.lineCap) {\r\n                ctx.lineCap = this.lineCap;\r\n            }\r\n            if (this.lineJoin) {\r\n                ctx.lineJoin = this.lineJoin;\r\n            }\r\n            ctx.stroke();\r\n            ctx.globalAlpha = globalAlpha;\r\n        }\r\n    }\r\n    containsPoint(x, y) {\r\n        return this.isPointInPath(x, y);\r\n    }\r\n}\r\n/**\r\n * Defaults for style properties. Note that properties that affect the position\r\n * and shape of the node are not considered style properties, for example:\r\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\r\n * Can be used to reset to the original styling after some custom styling\r\n * has been applied (using the `restoreOwnStyles` method).\r\n * These static defaults are meant to be inherited by subclasses.\r\n */\r\nShape.defaultStyles = Object.assign({}, {\r\n    fill: 'black',\r\n    stroke: undefined,\r\n    strokeWidth: 0,\r\n    lineDash: undefined,\r\n    lineDashOffset: 0,\r\n    lineCap: undefined,\r\n    lineJoin: undefined,\r\n    opacity: 1,\r\n    fillShadow: undefined,\r\n});\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR, changeCb: (s) => s.updateGradient() }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"fill\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", String)\r\n], Shape.prototype, \"lineCap\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", String)\r\n], Shape.prototype, \"lineJoin\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.MINOR,\r\n        convertor: (v) => Math.min(1, Math.max(0, v)),\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"opacity\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR, checkDirtyOnAssignment: true }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"fillShadow\", void 0);\n\nconst ellipsis = '\\u2026';\r\nfunction SceneFontChangeDetection(opts) {\r\n    const { redraw = RedrawType.MAJOR, changeCb } = opts !== null && opts !== void 0 ? opts : {};\r\n    return SceneChangeDetection({ redraw, type: 'font', changeCb });\r\n}\r\nclass Text extends Shape {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.lines = [];\r\n        this.text = undefined;\r\n        this._dirtyFont = true;\r\n        this.fontSize = 10;\r\n        this.fontFamily = 'sans-serif';\r\n        this.textAlign = Text.defaultStyles.textAlign;\r\n        this.textBaseline = Text.defaultStyles.textBaseline;\r\n        // TextMetrics are used if lineHeight is not defined.\r\n        this.lineHeight = undefined;\r\n    }\r\n    _setLines() {\r\n        this.lines = splitText(this.text);\r\n    }\r\n    get font() {\r\n        if (this._font == null || this._dirtyFont) {\r\n            this._dirtyFont = false;\r\n            this._font = getFont(this);\r\n        }\r\n        return this._font;\r\n    }\r\n    computeBBox() {\r\n        return HdpiCanvas.has.textMetrics\r\n            ? getPreciseBBox(this.lines, this.x, this.y, this)\r\n            : getApproximateBBox(this.lines, this.x, this.y, this);\r\n    }\r\n    getLineHeight(line) {\r\n        var _a, _b;\r\n        if (this.lineHeight)\r\n            return this.lineHeight;\r\n        if (HdpiCanvas.has.textMetrics) {\r\n            const metrics = HdpiCanvas.measureText(line, this.font, this.textBaseline, this.textAlign);\r\n            return (((_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent) +\r\n                ((_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent));\r\n        }\r\n        return HdpiCanvas.getTextSize(line, this.font).height;\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return bbox ? bbox.containsPoint(point.x, point.y) : false;\r\n    }\r\n    render(renderCtx) {\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        if (!this.lines.length || !this.layerManager) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        const { fill, stroke, strokeWidth } = this;\r\n        ctx.font = this.font;\r\n        ctx.textAlign = this.textAlign;\r\n        ctx.textBaseline = this.textBaseline;\r\n        const pixelRatio = this.layerManager.canvas.pixelRatio || 1;\r\n        const { globalAlpha } = ctx;\r\n        if (fill) {\r\n            ctx.fillStyle = fill;\r\n            ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\r\n            const { fillShadow } = this;\r\n            if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {\r\n                ctx.shadowColor = fillShadow.color;\r\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\r\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\r\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\r\n            }\r\n            this.renderLines((line, x, y) => ctx.fillText(line, x, y));\r\n        }\r\n        if (stroke && strokeWidth) {\r\n            ctx.strokeStyle = stroke;\r\n            ctx.lineWidth = strokeWidth;\r\n            ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\r\n            const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\r\n            if (lineDash) {\r\n                ctx.setLineDash(lineDash);\r\n            }\r\n            if (lineDashOffset) {\r\n                ctx.lineDashOffset = lineDashOffset;\r\n            }\r\n            if (lineCap) {\r\n                ctx.lineCap = lineCap;\r\n            }\r\n            if (lineJoin) {\r\n                ctx.lineJoin = lineJoin;\r\n            }\r\n            this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\r\n        }\r\n        super.render(renderCtx);\r\n    }\r\n    renderLines(renderCallback) {\r\n        const { lines, x, y } = this;\r\n        const lineHeights = this.lines.map((line) => this.getLineHeight(line));\r\n        const totalHeight = lineHeights.reduce((a, b) => a + b, 0);\r\n        let offsetY = -(totalHeight - lineHeights[0]) * getVerticalOffset(this.textBaseline);\r\n        for (let i = 0; i < lines.length; i++) {\r\n            renderCallback(lines[i], x, y + offsetY);\r\n            offsetY += lineHeights[i];\r\n        }\r\n    }\r\n    static wrap(text, maxWidth, maxHeight, textProps, wrapping, overflow = 'ellipsis') {\r\n        var _a;\r\n        const canOverflow = overflow !== 'hide';\r\n        const font = getFont(textProps);\r\n        const measurer = createTextMeasurer(font);\r\n        const lines = text.split(/\\r?\\n/g);\r\n        if (lines.length === 0) {\r\n            return '';\r\n        }\r\n        if (wrapping === 'never') {\r\n            return (_a = Text.truncateLine(lines[0], maxWidth, measurer, canOverflow ? 'auto' : 'never')) !== null && _a !== void 0 ? _a : '';\r\n        }\r\n        const result = [];\r\n        let cumulativeHeight = 0;\r\n        for (const line of lines) {\r\n            const wrappedLine = Text.wrapLine(line, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow);\r\n            if (wrappedLine == null) {\r\n                return '';\r\n            }\r\n            result.push(wrappedLine.result);\r\n            cumulativeHeight = wrappedLine.cumulativeHeight;\r\n            if (wrappedLine.truncated) {\r\n                break;\r\n            }\r\n        }\r\n        return result.join('\\n').trim();\r\n    }\r\n    static wrapLine(text, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {\r\n        text = text.trim();\r\n        if (!text) {\r\n            return { result: '', truncated: false, cumulativeHeight };\r\n        }\r\n        const initialSize = measurer.size(text);\r\n        if (initialSize.width <= maxWidth) {\r\n            // Text fits into a single line\r\n            return {\r\n                result: text,\r\n                truncated: false,\r\n                cumulativeHeight: cumulativeHeight + initialSize.height,\r\n            };\r\n        }\r\n        if (initialSize.height > maxHeight || measurer.width('W') > maxWidth) {\r\n            // Not enough space for a single line or character\r\n            return canOverflow ? { result: '', truncated: true, cumulativeHeight } : undefined;\r\n        }\r\n        const words = text.split(/\\s+/g);\r\n        const wrapResult = Text.wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow);\r\n        if (wrapResult == null) {\r\n            return undefined;\r\n        }\r\n        cumulativeHeight = wrapResult.cumulativeHeight;\r\n        let { lines } = wrapResult;\r\n        if (!(wrapResult.wordsBrokenOrTruncated || wrapResult.linesTruncated)) {\r\n            // If no word breaks or truncations, try the balanced wrapping\r\n            const linesCount = wrapResult.lines.length;\r\n            const balanced = Text.wrapLineBalanced(words, maxWidth, measurer, linesCount);\r\n            if (balanced.length === lines.length) {\r\n                // Some lines can't be balanced properly because of unusually long words\r\n                lines = balanced;\r\n            }\r\n        }\r\n        const wrappedText = lines.map((ln) => ln.join(' ')).join('\\n');\r\n        return { result: wrappedText, truncated: wrapResult.linesTruncated, cumulativeHeight };\r\n    }\r\n    static breakWord(word, firstLineWidth, maxWidth, hyphens, measurer) {\r\n        const isPunctuationAt = (index) => Text.punctuationMarks.includes(word[index]);\r\n        const h = hyphens ? measurer.width('-') : 0;\r\n        const breaks = [];\r\n        let partWidth = 0;\r\n        let p = 0;\r\n        for (let i = 0; i < word.length; i++) {\r\n            const c = word[i];\r\n            const w = measurer.width(c);\r\n            const limit = p === 0 ? firstLineWidth : maxWidth;\r\n            if (partWidth + w + h > limit) {\r\n                breaks.push(i);\r\n                partWidth = 0;\r\n                p++;\r\n            }\r\n            partWidth += w;\r\n        }\r\n        const parts = [];\r\n        let start = 0;\r\n        for (const index of breaks) {\r\n            let part = word.substring(start, index);\r\n            if (hyphens && part.length > 0 && !isPunctuationAt(index - 1) && !isPunctuationAt(index)) {\r\n                part += '-';\r\n            }\r\n            parts.push(part);\r\n            start = index;\r\n        }\r\n        parts.push(word.substring(start));\r\n        return parts;\r\n    }\r\n    static truncateLine(text, maxWidth, measurer, ellipsisMode) {\r\n        text = text.trimEnd();\r\n        const lineWidth = measurer.width(text);\r\n        if (lineWidth > maxWidth && ellipsisMode === 'never') {\r\n            return undefined;\r\n        }\r\n        else if (lineWidth <= maxWidth && ellipsisMode !== 'force') {\r\n            return text;\r\n        }\r\n        const ellipsisWidth = measurer.width(ellipsis);\r\n        let trunc = text;\r\n        let truncWidth = lineWidth;\r\n        while (trunc.length > 0 && truncWidth + ellipsisWidth > maxWidth) {\r\n            // Ensure there is no space between the ellipsis and last letter\r\n            trunc = trunc.slice(0, -1).trimEnd();\r\n            truncWidth = measurer.width(trunc);\r\n        }\r\n        if (truncWidth + ellipsisWidth <= maxWidth) {\r\n            return `${trunc}${ellipsis}`;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    static wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {\r\n        const { fontSize = 0, lineHeight = fontSize * Text.defaultLineHeightRatio } = textProps;\r\n        const breakWord = wrapping === 'always' || wrapping === 'hyphenate';\r\n        const hyphenate = wrapping === 'hyphenate';\r\n        const spaceWidth = measurer.width(' ');\r\n        let wordsBrokenOrTruncated = false;\r\n        let linesTruncated = false;\r\n        const lines = [];\r\n        let currentLine = [];\r\n        let lineWidth = 0;\r\n        const getReturnValue = () => ({\r\n            lines,\r\n            linesTruncated,\r\n            wordsBrokenOrTruncated,\r\n            cumulativeHeight,\r\n        });\r\n        const truncateLastLine = () => {\r\n            if (!canOverflow) {\r\n                return undefined;\r\n            }\r\n            const lastLine = currentLine.join(' ');\r\n            const trunc = Text.truncateLine(lastLine, maxWidth, measurer, 'force');\r\n            if (trunc == null) {\r\n                return undefined;\r\n            }\r\n            currentLine.splice(0, currentLine.length, trunc);\r\n            linesTruncated = true;\r\n            return getReturnValue();\r\n        };\r\n        const addNewLine = () => {\r\n            const expectedHeight = cumulativeHeight + lineHeight;\r\n            if (expectedHeight >= maxHeight) {\r\n                return false;\r\n            }\r\n            // Add new line\r\n            currentLine = [];\r\n            lineWidth = 0;\r\n            cumulativeHeight = expectedHeight;\r\n            lines.push(currentLine);\r\n            return true;\r\n        };\r\n        if (!addNewLine()) {\r\n            return truncateLastLine();\r\n        }\r\n        for (let i = 0; i < words.length; i++) {\r\n            const word = words[i];\r\n            const wordWidth = measurer.width(word);\r\n            const expectedSpaceWidth = currentLine.length === 0 ? 0 : spaceWidth;\r\n            const expectedLineWidth = lineWidth + expectedSpaceWidth + wordWidth;\r\n            if (expectedLineWidth <= maxWidth) {\r\n                // If the word fits, add it to the current line\r\n                currentLine.push(word);\r\n                lineWidth = expectedLineWidth;\r\n                continue;\r\n            }\r\n            if (wordWidth <= maxWidth) {\r\n                // If the word is not too long, put it onto new line\r\n                if (!addNewLine()) {\r\n                    return truncateLastLine();\r\n                }\r\n                currentLine.push(word);\r\n                lineWidth = wordWidth;\r\n                continue;\r\n            }\r\n            // Handle a long word\r\n            wordsBrokenOrTruncated = true;\r\n            if (breakWord) {\r\n                // Break the word into parts\r\n                const availWidth = maxWidth - lineWidth - expectedSpaceWidth;\r\n                const parts = Text.breakWord(word, availWidth, maxWidth, hyphenate, measurer);\r\n                for (let p = 0; p < parts.length; p++) {\r\n                    const part = parts[p];\r\n                    part && currentLine.push(part);\r\n                    if (p === parts.length - 1) {\r\n                        lineWidth = measurer.width(part);\r\n                    }\r\n                    else if (!addNewLine()) {\r\n                        return truncateLastLine();\r\n                    }\r\n                }\r\n            }\r\n            else if (canOverflow) {\r\n                // Truncate the word\r\n                if (!addNewLine()) {\r\n                    return truncateLastLine();\r\n                }\r\n                const trunc = Text.truncateLine(word, maxWidth, measurer, 'force');\r\n                if (trunc == null) {\r\n                    return undefined;\r\n                }\r\n                currentLine.push(trunc);\r\n                if (i < words.length - 1) {\r\n                    linesTruncated = true;\r\n                }\r\n                break;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n        return getReturnValue();\r\n    }\r\n    static wrapLineBalanced(words, maxWidth, measurer, linesCount) {\r\n        const totalWordsWidth = words.reduce((sum, w) => sum + measurer.width(w), 0);\r\n        const spaceWidth = measurer.width(' ');\r\n        const totalSpaceWidth = spaceWidth * (words.length - linesCount - 2);\r\n        const averageLineWidth = (totalWordsWidth + totalSpaceWidth) / linesCount;\r\n        const lines = [];\r\n        let currentLine = [];\r\n        let lineWidth = measurer.width(words[0]);\r\n        let newLine = true;\r\n        for (const word of words) {\r\n            const width = measurer.width(word);\r\n            if (newLine) {\r\n                // New line\r\n                currentLine = [];\r\n                currentLine.push(word);\r\n                lineWidth = width;\r\n                newLine = false;\r\n                lines.push(currentLine);\r\n                continue;\r\n            }\r\n            const expectedLineWidth = lineWidth + spaceWidth + width;\r\n            if (expectedLineWidth <= averageLineWidth) {\r\n                // Keep adding words to the line\r\n                currentLine.push(word);\r\n                lineWidth = expectedLineWidth;\r\n            }\r\n            else if (expectedLineWidth <= maxWidth) {\r\n                // Add the last word to the line\r\n                currentLine.push(word);\r\n                newLine = true;\r\n            }\r\n            else {\r\n                // Put the word onto the next line\r\n                currentLine = [word];\r\n                lineWidth = width;\r\n                lines.push(currentLine);\r\n            }\r\n        }\r\n        return lines;\r\n    }\r\n    setFont(props) {\r\n        this.fontFamily = props.fontFamily;\r\n        this.fontSize = props.fontSize;\r\n        this.fontStyle = props.fontStyle;\r\n        this.fontWeight = props.fontWeight;\r\n    }\r\n    setAlign(props) {\r\n        this.textAlign = props.textAlign;\r\n        this.textBaseline = props.textBaseline;\r\n    }\r\n}\r\nText.className = 'Text';\r\n// The default line spacing for document editors is usually 1.15\r\nText.defaultLineHeightRatio = 1.15;\r\nText.defaultStyles = Object.assign({}, Shape.defaultStyles, {\r\n    textAlign: 'start',\r\n    fontStyle: undefined,\r\n    fontWeight: undefined,\r\n    fontSize: 10,\r\n    fontFamily: 'sans-serif',\r\n    textBaseline: 'alphabetic',\r\n});\r\nText.ellipsis = ellipsis;\r\nText.punctuationMarks = ['.', ',', '-', ':', ';', '!', '?', `'`, '\"', '(', ')'];\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"x\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"y\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR, changeCb: (o) => o._setLines() }),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"text\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"textAlign\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"textBaseline\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"lineHeight\", void 0);\r\nfunction createTextMeasurer(font) {\r\n    const cache = new Map();\r\n    const getTextSize = (text) => HdpiCanvas.getTextSize(text, font);\r\n    const getLineWidth = (text) => {\r\n        if (cache.has(text)) {\r\n            return cache.get(text);\r\n        }\r\n        const { width } = getTextSize(text);\r\n        cache.set(text, width);\r\n        return width;\r\n    };\r\n    return { size: getTextSize, width: getLineWidth };\r\n}\r\nfunction getFont(fontProps) {\r\n    const { fontFamily, fontSize, fontStyle, fontWeight } = fontProps;\r\n    return [fontStyle !== null && fontStyle !== void 0 ? fontStyle : '', fontWeight !== null && fontWeight !== void 0 ? fontWeight : '', fontSize + 'px', fontFamily].join(' ').trim();\r\n}\r\nfunction measureText(lines, x, y, textProps) {\r\n    return HdpiCanvas.has.textMetrics\r\n        ? getPreciseBBox(lines, x, y, textProps)\r\n        : getApproximateBBox(lines, x, y, textProps);\r\n}\r\nfunction getPreciseBBox(lines, x, y, textProps) {\r\n    var _a, _b;\r\n    let left = 0;\r\n    let top = 0;\r\n    let width = 0;\r\n    let height = 0;\r\n    // Distance between first and last base lines.\r\n    let baselineDistance = 0;\r\n    const font = getFont(textProps);\r\n    const { lineHeight, textBaseline = Text.defaultStyles.textBaseline, textAlign = Text.defaultStyles.textAlign, } = textProps;\r\n    for (let i = 0; i < lines.length; i++) {\r\n        const metrics = HdpiCanvas.measureText(lines[i], font, textBaseline, textAlign);\r\n        left = Math.max(left, metrics.actualBoundingBoxLeft);\r\n        width = Math.max(width, metrics.width);\r\n        if (i == 0) {\r\n            top += metrics.actualBoundingBoxAscent;\r\n            height += metrics.actualBoundingBoxAscent;\r\n        }\r\n        else {\r\n            baselineDistance += (_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent;\r\n        }\r\n        if (i == lines.length - 1) {\r\n            height += metrics.actualBoundingBoxDescent;\r\n        }\r\n        else {\r\n            baselineDistance += (_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent;\r\n        }\r\n    }\r\n    if (lineHeight !== undefined) {\r\n        baselineDistance = (lines.length - 1) * lineHeight;\r\n    }\r\n    height += baselineDistance;\r\n    top += baselineDistance * getVerticalOffset(textBaseline);\r\n    return new BBox(x - left, y - top, width, height);\r\n}\r\nfunction getApproximateBBox(lines, x, y, textProps) {\r\n    let width = 0;\r\n    let firstLineHeight = 0;\r\n    // Distance between first and last base lines.\r\n    let baselineDistance = 0;\r\n    const font = getFont(textProps);\r\n    const { lineHeight, textBaseline = Text.defaultStyles.textBaseline, textAlign = Text.defaultStyles.textAlign, } = textProps;\r\n    if (lines.length > 0) {\r\n        const lineSize = HdpiCanvas.getTextSize(lines[0], font);\r\n        width = lineSize.width;\r\n        firstLineHeight = lineSize.height;\r\n    }\r\n    for (let i = 1; i < lines.length; i++) {\r\n        const lineSize = HdpiCanvas.getTextSize(lines[i], font);\r\n        width = Math.max(width, lineSize.width);\r\n        baselineDistance += lineHeight !== null && lineHeight !== void 0 ? lineHeight : lineSize.height;\r\n    }\r\n    switch (textAlign) {\r\n        case 'end':\r\n        case 'right':\r\n            x -= width;\r\n            break;\r\n        case 'center':\r\n            x -= width / 2;\r\n    }\r\n    switch (textBaseline) {\r\n        case 'alphabetic':\r\n            y -= firstLineHeight * 0.7 + baselineDistance * 0.5;\r\n            break;\r\n        case 'middle':\r\n            y -= firstLineHeight * 0.45 + baselineDistance * 0.5;\r\n            break;\r\n        case 'ideographic':\r\n            y -= firstLineHeight + baselineDistance;\r\n            break;\r\n        case 'hanging':\r\n            y -= firstLineHeight * 0.2 + baselineDistance * 0.5;\r\n            break;\r\n        case 'bottom':\r\n            y -= firstLineHeight + baselineDistance;\r\n            break;\r\n    }\r\n    return new BBox(x, y, width, firstLineHeight + baselineDistance);\r\n}\r\nfunction getVerticalOffset(textBaseline) {\r\n    switch (textBaseline) {\r\n        case 'top':\r\n        case 'hanging':\r\n            return 0;\r\n        case 'bottom':\r\n        case 'alphabetic':\r\n        case 'ideographic':\r\n            return 1;\r\n        case 'middle':\r\n            return 0.5;\r\n    }\r\n}\r\nfunction splitText(text) {\r\n    return typeof text === 'string' ? text.split(/\\r?\\n/g) : [];\r\n}\n\nfunction ProxyOnWrite(proxyProperty) {\r\n    return addTransformToInstanceProperty((target, _, value) => {\r\n        target[proxyProperty] = value;\r\n        return value;\r\n    });\r\n}\r\nfunction ProxyPropertyOnWrite(childName, childProperty) {\r\n    return addTransformToInstanceProperty((target, key, value) => {\r\n        target[childName][childProperty !== null && childProperty !== void 0 ? childProperty : key] = value;\r\n        return value;\r\n    });\r\n}\r\n/**\r\n * Allows side-effects to be triggered on property write.\r\n *\r\n * @param opts.newValue called when a new value is set - never called for undefined values.\r\n * @param opts.oldValue called with the old value before a new value is set - never called for\r\n *                      undefined values.\r\n * @param opts.changeValue called on any change to the value - always called.\r\n */\r\nfunction ActionOnSet(opts) {\r\n    const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\r\n    return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\r\n        if (newValue !== oldValue) {\r\n            if (oldValue !== undefined) {\r\n                oldValueFn === null || oldValueFn === void 0 ? void 0 : oldValueFn.call(target, oldValue);\r\n            }\r\n            if (newValue !== undefined) {\r\n                newValueFn === null || newValueFn === void 0 ? void 0 : newValueFn.call(target, newValue);\r\n            }\r\n            changeValueFn === null || changeValueFn === void 0 ? void 0 : changeValueFn.call(target, newValue, oldValue);\r\n        }\r\n        return newValue;\r\n    });\r\n}\n\nclass Caption {\r\n    constructor() {\r\n        this.node = new Text();\r\n        this.enabled = false;\r\n        this.text = undefined;\r\n        this.fontSize = 10;\r\n        this.fontFamily = 'sans-serif';\r\n        this.maxWidth = undefined;\r\n        this.maxHeight = undefined;\r\n        this.wrapping = 'always';\r\n        const node = this.node;\r\n        node.textAlign = 'center';\r\n        node.pointerEvents = PointerEvents.None;\r\n    }\r\n    computeTextWrap(containerWidth, containerHeight) {\r\n        var _a, _b;\r\n        const { text, wrapping } = this;\r\n        const maxWidth = Math.min((_a = this.maxWidth) !== null && _a !== void 0 ? _a : Infinity, containerWidth);\r\n        const maxHeight = (_b = this.maxHeight) !== null && _b !== void 0 ? _b : containerHeight;\r\n        if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\r\n            this.node.text = text;\r\n            return;\r\n        }\r\n        const wrapped = Text.wrap(text !== null && text !== void 0 ? text : '', maxWidth, maxHeight, this, wrapping);\r\n        this.node.text = wrapped;\r\n    }\r\n}\r\nCaption.SMALL_PADDING = 10;\r\nCaption.LARGE_PADDING = 20;\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", String)\r\n], Caption.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", String)\r\n], Caption.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    ProxyPropertyOnWrite('node', 'fill'),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"spacing\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"lineHeight\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"maxHeight\", void 0);\r\n__decorate([\r\n    Validate(TEXT_WRAP),\r\n    __metadata(\"design:type\", String)\r\n], Caption.prototype, \"wrapping\", void 0);\n\nclass AxisTitle {\r\n    constructor() {\r\n        this.enabled = false;\r\n        this.text = undefined;\r\n        this.spacing = Caption.SMALL_PADDING;\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 10;\r\n        this.fontFamily = 'sans-serif';\r\n        this.wrapping = 'always';\r\n        this.formatter = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisTitle.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTitle.prototype, \"spacing\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTitle.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(TEXT_WRAP),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"wrapping\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], AxisTitle.prototype, \"formatter\", void 0);\n\n/**\r\n * Zip two arrays into an object of keys and values, or an object of keys with a single value.\r\n */\r\nfunction zipObject(keys, values) {\r\n    const zipped = {};\r\n    if (Array.isArray(values)) {\r\n        for (let i = 0; i < keys.length; i++) {\r\n            zipped[`${keys[i]}`] = values[i];\r\n        }\r\n    }\r\n    else {\r\n        for (let i = 0; i < keys.length; i++) {\r\n            zipped[`${keys[i]}`] = values;\r\n        }\r\n    }\r\n    return zipped;\r\n}\n\nfunction interpolateNumber(a, b) {\r\n    return (d) => Number(a) * (1 - d) + Number(b) * d;\r\n}\r\nfunction interpolateColor(a, b) {\r\n    if (typeof a === 'string') {\r\n        try {\r\n            a = Color.fromString(a);\r\n        }\r\n        catch (e) {\r\n            a = Color.fromArray([0, 0, 0]);\r\n        }\r\n    }\r\n    if (typeof b === 'string') {\r\n        try {\r\n            b = Color.fromString(b);\r\n        }\r\n        catch (e) {\r\n            b = Color.fromArray([0, 0, 0]);\r\n        }\r\n    }\r\n    const red = interpolateNumber(a.r, b.r);\r\n    const green = interpolateNumber(a.g, b.g);\r\n    const blue = interpolateNumber(a.b, b.b);\r\n    const alpha = interpolateNumber(a.a, b.a);\r\n    return (d) => Color.fromArray([red(d), green(d), blue(d), alpha(d)]).toRgbaString();\r\n}\n\nconst linear = (n) => n;\r\nconst easeIn = (n) => 1 - Math.cos((n * Math.PI) / 2);\r\nconst easeOut = (n) => Math.sin((n * Math.PI) / 2);\r\nconst easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\r\nconst easeInQuad = (n) => n * n;\r\nconst easeOutQuad = (n) => 1 - Math.pow((1 - n), 2);\r\nconst easeInOutQuad = (n) => (n < 0.5 ? 2 * n * n : 1 - Math.pow((-2 * n + 2), 2) / 2);\n\nvar easing = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    linear: linear,\n    easeIn: easeIn,\n    easeOut: easeOut,\n    easeInOut: easeInOut,\n    easeInQuad: easeInQuad,\n    easeOutQuad: easeOutQuad,\n    easeInOutQuad: easeInOutQuad\n});\n\nconst QUICK_TRANSITION = 0.2;\r\nconst INITIAL_LOAD = {\r\n    animationDuration: 1,\r\n    animationDelay: 0,\r\n};\r\nconst REMOVE_PHASE = {\r\n    animationDuration: 0.25,\r\n    animationDelay: 0,\r\n};\r\nconst UPDATE_PHASE = {\r\n    animationDuration: 0.5,\r\n    animationDelay: 0.25,\r\n};\r\nconst ADD_PHASE = {\r\n    animationDuration: 0.25,\r\n    animationDelay: 0.75,\r\n};\r\nconst LABEL_PHASE = {\r\n    animationDuration: QUICK_TRANSITION,\r\n    animationDelay: 1,\r\n};\r\nvar RepeatType;\r\n(function (RepeatType) {\r\n    RepeatType[\"Loop\"] = \"loop\";\r\n    RepeatType[\"Reverse\"] = \"reverse\";\r\n})(RepeatType || (RepeatType = {}));\r\nfunction isNodeArray(array) {\r\n    return array.every((n) => n instanceof Node);\r\n}\r\nclass Animation {\r\n    constructor(opts) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\r\n        this.elapsed = 0;\r\n        this.iteration = 0;\r\n        this.isPlaying = false;\r\n        this.isReverse = false;\r\n        // animation configuration\r\n        this.id = opts.id;\r\n        this.groupId = opts.groupId;\r\n        this.autoplay = (_a = opts.autoplay) !== null && _a !== void 0 ? _a : true;\r\n        this.delay = (_b = opts.delay) !== null && _b !== void 0 ? _b : 0;\r\n        this.duration = (_c = opts.duration) !== null && _c !== void 0 ? _c : 1000;\r\n        this.ease = (_d = opts.ease) !== null && _d !== void 0 ? _d : linear;\r\n        this.repeat = (_e = opts.repeat) !== null && _e !== void 0 ? _e : 0;\r\n        this.repeatType = (_f = opts.repeatType) !== null && _f !== void 0 ? _f : RepeatType.Loop;\r\n        // user defined event listeners\r\n        this.onComplete = opts.onComplete;\r\n        this.onPlay = opts.onPlay;\r\n        this.onStop = opts.onStop;\r\n        this.onRepeat = opts.onRepeat;\r\n        this.onUpdate = opts.onUpdate;\r\n        // animation interpolator based on `from` & `to` types\r\n        this.interpolate = this.createInterpolator(opts.from, opts.to);\r\n        if (opts.skip === true) {\r\n            (_g = this.onUpdate) === null || _g === void 0 ? void 0 : _g.call(this, opts.to, false, this);\r\n            (_h = this.onStop) === null || _h === void 0 ? void 0 : _h.call(this, this);\r\n            (_j = this.onComplete) === null || _j === void 0 ? void 0 : _j.call(this, this);\r\n        }\r\n        else if (this.autoplay) {\r\n            this.play();\r\n            // Initialise the animation immediately without requesting a frame to prevent flashes\r\n            (_k = this.onUpdate) === null || _k === void 0 ? void 0 : _k.call(this, opts.from, true, this);\r\n        }\r\n    }\r\n    play() {\r\n        var _a;\r\n        if (!this.isPlaying) {\r\n            this.isPlaying = true;\r\n            (_a = this.onPlay) === null || _a === void 0 ? void 0 : _a.call(this, this);\r\n        }\r\n        return this;\r\n    }\r\n    pause() {\r\n        if (this.isPlaying) {\r\n            this.isPlaying = false;\r\n        }\r\n        return this;\r\n    }\r\n    stop() {\r\n        var _a;\r\n        if (this.isPlaying) {\r\n            this.isPlaying = false;\r\n            (_a = this.onStop) === null || _a === void 0 ? void 0 : _a.call(this, this);\r\n        }\r\n        return this;\r\n    }\r\n    reset(opts) {\r\n        const deltaState = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\r\n        this.interpolate = this.createInterpolator(deltaState, opts.to);\r\n        this.elapsed = 0;\r\n        this.iteration = 0;\r\n        if (typeof opts.delay === 'number') {\r\n            this.delay = opts.delay;\r\n        }\r\n        if (typeof opts.duration === 'number') {\r\n            this.duration = opts.duration;\r\n        }\r\n        if (typeof opts.ease === 'function') {\r\n            this.ease = opts.ease;\r\n        }\r\n        return this;\r\n    }\r\n    update(time) {\r\n        var _a, _b, _c;\r\n        this.elapsed += time;\r\n        if (this.elapsed <= this.delay) {\r\n            return this;\r\n        }\r\n        const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\r\n        (_a = this.onUpdate) === null || _a === void 0 ? void 0 : _a.call(this, value, false, this);\r\n        if (this.elapsed - this.delay >= this.duration) {\r\n            if (this.iteration < this.repeat) {\r\n                this.iteration++;\r\n                this.elapsed = ((this.elapsed - this.delay) % this.duration) + this.delay;\r\n                if (this.repeatType === RepeatType.Reverse) {\r\n                    this.isReverse = !this.isReverse;\r\n                }\r\n                (_b = this.onRepeat) === null || _b === void 0 ? void 0 : _b.call(this, this);\r\n            }\r\n            else {\r\n                this.stop();\r\n                (_c = this.onComplete) === null || _c === void 0 ? void 0 : _c.call(this, this);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    get delta() {\r\n        return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\r\n    }\r\n    createInterpolator(from, to) {\r\n        if (typeof to !== 'object') {\r\n            return this.interpolateValue(from, to);\r\n        }\r\n        const interpolatorEntries = Object.keys(to).map((key) => [\r\n            key,\r\n            this.interpolateValue(from[key], to[key]),\r\n        ]);\r\n        return (d) => {\r\n            const result = {};\r\n            for (const [key, interpolator] of interpolatorEntries) {\r\n                result[key] = interpolator(d);\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    interpolateValue(a, b) {\r\n        try {\r\n            switch (typeof a) {\r\n                case 'number':\r\n                    return interpolateNumber(a, b);\r\n                case 'string':\r\n                    return interpolateColor(a, b);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Error-case handled below.\r\n        }\r\n        throw new Error(`Unable to interpolate values: ${a}, ${b}`);\r\n    }\r\n}\n\nconst NODE_UPDATE_PHASES = ['removed', 'updated', 'added'];\r\nconst FROM_TO_MIXINS = {\r\n    added: ADD_PHASE,\r\n    updated: UPDATE_PHASE,\r\n    removed: REMOVE_PHASE,\r\n    unknown: INITIAL_LOAD,\r\n};\r\n/**\r\n * Implements a per-node \"to/from\" animation, with support for detection of added/moved/removed\r\n * nodes.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param selections contains nodes to be animated\r\n * @param fromFn callback to determine per-node starting properties\r\n * @param toFn callback to determine per-node final properties\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n * @param getDatumId optional per-datum 'id' generation function for diff calculation - must be\r\n *                   specified iff diff is specified\r\n * @param diff optional diff from a DataModel to use to detect added/moved/removed cases\r\n */\r\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff) {\r\n    const { defaultDuration } = animationManager;\r\n    const { fromFn, toFn, intermediateFn } = fns;\r\n    const isNodes = isNodeArray(selectionsOrNodes);\r\n    const nodes = isNodes ? selectionsOrNodes : [];\r\n    const selections = !isNodes ? selectionsOrNodes : [];\r\n    // Dynamic case with varying add/update/remove behavior.\r\n    const ids = { added: {}, removed: {} };\r\n    if (getDatumId && diff) {\r\n        ids.added = zipObject(diff.added, true);\r\n        ids.removed = zipObject(diff.removed, true);\r\n    }\r\n    const processNodes = (liveNodes, nodes) => {\r\n        var _a, _b;\r\n        let prevFromProps;\r\n        let liveNodeIndex = 0;\r\n        let nodeIndex = 0;\r\n        for (const node of nodes) {\r\n            const isLive = liveNodes[liveNodeIndex] === node;\r\n            const ctx = {\r\n                last: nodeIndex >= nodes.length - 1,\r\n                lastLive: liveNodeIndex >= liveNodes.length - 1,\r\n                prev: nodes[nodeIndex - 1],\r\n                prevFromProps,\r\n                prevLive: liveNodes[liveNodeIndex - 1],\r\n                next: nodes[nodeIndex + 1],\r\n                nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)],\r\n            };\r\n            const animationId = `${groupId}_${subId}_${node.id}`;\r\n            animationManager.stopByAnimationId(animationId);\r\n            let status = 'unknown';\r\n            if (!isLive) {\r\n                status = 'removed';\r\n            }\r\n            else if (getDatumId && diff) {\r\n                status = calculateStatus(node, node.datum, getDatumId, ids);\r\n            }\r\n            const _c = fromFn(node, node.datum, status, ctx), { animationDelay: delay, animationDuration: duration, start = {}, finish = {} } = _c, from = __rest(_c, [\"animationDelay\", \"animationDuration\", \"start\", \"finish\"]);\r\n            const _d = toFn(node, node.datum, status, ctx), { animationDelay: toDelay, animationDuration: toDuration, start: toStart = {}, finish: toFinish = {} } = _d, to = __rest(_d, [\"animationDelay\", \"animationDuration\", \"start\", \"finish\"]);\r\n            animationManager.animate({\r\n                id: animationId,\r\n                groupId,\r\n                from: from,\r\n                to: to,\r\n                ease: easeOut,\r\n                onPlay: () => {\r\n                    node.setProperties(Object.assign(Object.assign({}, start), toStart));\r\n                },\r\n                onUpdate(props) {\r\n                    node.setProperties(props);\r\n                    if (intermediateFn) {\r\n                        node.setProperties(intermediateFn(node, node.datum, status, ctx));\r\n                    }\r\n                },\r\n                onStop: () => {\r\n                    node.setProperties(Object.assign(Object.assign(Object.assign({}, to), finish), toFinish));\r\n                },\r\n                duration: ((_a = duration !== null && duration !== void 0 ? duration : toDuration) !== null && _a !== void 0 ? _a : 1) * defaultDuration,\r\n                delay: ((_b = delay !== null && delay !== void 0 ? delay : toDelay) !== null && _b !== void 0 ? _b : 0) * defaultDuration,\r\n            });\r\n            if (isLive) {\r\n                liveNodeIndex++;\r\n            }\r\n            nodeIndex++;\r\n            prevFromProps = from;\r\n        }\r\n    };\r\n    let selectionIndex = 0;\r\n    for (const selection of selections) {\r\n        const nodes = selection.nodes();\r\n        const liveNodes = nodes.filter((n) => !selection.isGarbage(n));\r\n        processNodes(liveNodes, nodes);\r\n        // Only perform selection cleanup once.\r\n        animationManager.animate({\r\n            id: `${groupId}_${subId}_selection_${selectionIndex}`,\r\n            groupId,\r\n            from: 0,\r\n            to: 1,\r\n            ease: easeOut,\r\n            onStop() {\r\n                selection.cleanup();\r\n            },\r\n        });\r\n        selectionIndex++;\r\n    }\r\n    processNodes(nodes, nodes);\r\n}\r\n/**\r\n * Implements a batch \"to/from\" animation.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param selectionsOrNodes contains nodes to be animated\r\n * @param from node starting properties\r\n * @param to node final properties\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n */\r\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from, to, extraOpts = {}) {\r\n    const isNodes = isNodeArray(selectionsOrNodes);\r\n    const nodes = isNodes ? selectionsOrNodes : [];\r\n    const selections = !isNodes ? selectionsOrNodes : [];\r\n    const { animationDelay = 0, animationDuration = 1, start = {}, finish = {} } = extraOpts;\r\n    const { defaultDuration } = animationManager;\r\n    // Simple static to/from case, we can batch updates.\r\n    animationManager.animate({\r\n        id: `${groupId}_${subId}`,\r\n        groupId,\r\n        from,\r\n        to,\r\n        ease: easeOut,\r\n        onPlay: () => {\r\n            for (const node of nodes) {\r\n                node.setProperties(start);\r\n            }\r\n            for (const selection of selections) {\r\n                for (const node of selection.nodes()) {\r\n                    node.setProperties(start);\r\n                }\r\n            }\r\n        },\r\n        onUpdate(props) {\r\n            for (const node of nodes) {\r\n                node.setProperties(props);\r\n            }\r\n            for (const selection of selections) {\r\n                for (const node of selection.nodes()) {\r\n                    node.setProperties(props);\r\n                }\r\n            }\r\n        },\r\n        onStop: () => {\r\n            for (const node of nodes) {\r\n                node.setProperties(Object.assign(Object.assign({}, to), finish));\r\n            }\r\n            for (const selection of selections) {\r\n                for (const node of selection.nodes()) {\r\n                    node.setProperties(Object.assign(Object.assign({}, to), finish));\r\n                }\r\n            }\r\n        },\r\n        duration: animationDuration * defaultDuration,\r\n        delay: animationDelay * defaultDuration,\r\n    });\r\n}\r\nfunction calculateStatus(node, datum, getDatumId, ids) {\r\n    const id = getDatumId(node, datum);\r\n    if (ids.added[id]) {\r\n        return 'added';\r\n    }\r\n    else if (ids.removed[id]) {\r\n        return 'removed';\r\n    }\r\n    return 'updated';\r\n}\n\nvar fromToMotion$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    NODE_UPDATE_PHASES: NODE_UPDATE_PHASES,\n    FROM_TO_MIXINS: FROM_TO_MIXINS,\n    fromToMotion: fromToMotion,\n    staticFromToMotion: staticFromToMotion\n});\n\nconst group = (content) => `(${content})`;\r\nconst optionalGroup = (content) => `${group(content)}?`;\r\nconst nonCapturingGroup = (content) => optionalGroup(`?:${content}`);\r\nconst formatRegEx = (() => {\r\n    const fill = '.';\r\n    const align = '[<>=^]';\r\n    const sign = '[+\\\\-( ]';\r\n    const symbol = '[$€£¥₣₹#]';\r\n    const zero = '0';\r\n    const width = '\\\\d+';\r\n    const comma = ',';\r\n    const precision = '\\\\d+';\r\n    const tilde = '~';\r\n    const type = '[%a-z]';\r\n    return new RegExp([\r\n        '^',\r\n        nonCapturingGroup(`${optionalGroup(fill)}${group(align)}`),\r\n        optionalGroup(sign),\r\n        optionalGroup(symbol),\r\n        optionalGroup(zero),\r\n        optionalGroup(width),\r\n        optionalGroup(comma),\r\n        nonCapturingGroup(`\\\\.${group(precision)}`),\r\n        optionalGroup(tilde),\r\n        optionalGroup(type),\r\n        '$',\r\n    ].join(''), 'i');\r\n})();\r\nconst surroundedRegEx = (() => {\r\n    const prefix = '.*?';\r\n    const content = '.+?';\r\n    const suffix = '.*?';\r\n    return new RegExp(['^', group(prefix), `#\\\\{${group(content)}\\\\}`, group(suffix), '$'].join(''));\r\n})();\r\nfunction parseFormatter(formatter) {\r\n    let prefix;\r\n    let suffix;\r\n    const surrounded = surroundedRegEx.exec(formatter);\r\n    if (surrounded) {\r\n        [, prefix, formatter, suffix] = surrounded;\r\n    }\r\n    const match = formatRegEx.exec(formatter);\r\n    if (!match) {\r\n        throw new Error(`The number formatter is invalid: ${formatter}`);\r\n    }\r\n    const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;\r\n    return {\r\n        fill,\r\n        align,\r\n        sign,\r\n        symbol,\r\n        zero,\r\n        width: parseInt(width),\r\n        comma,\r\n        precision: parseInt(precision),\r\n        trim: Boolean(trim),\r\n        type,\r\n        prefix,\r\n        suffix,\r\n    };\r\n}\r\nfunction format(formatter) {\r\n    const options = typeof formatter === 'string' ? parseFormatter(formatter) : formatter;\r\n    const { fill, align, sign = '-', symbol, zero, width, comma, type, prefix = '', suffix = '', precision } = options;\r\n    let { trim } = options;\r\n    const precisionIsNaN = precision === undefined || isNaN(precision);\r\n    let formatBody;\r\n    if (!type) {\r\n        formatBody = decimalTypes['g'];\r\n        trim = true;\r\n    }\r\n    else if (type in decimalTypes && type in integerTypes) {\r\n        formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\r\n    }\r\n    else if (type in decimalTypes) {\r\n        formatBody = decimalTypes[type];\r\n    }\r\n    else if (type in integerTypes) {\r\n        formatBody = integerTypes[type];\r\n    }\r\n    else {\r\n        throw new Error(`The number formatter type is invalid: ${type}`);\r\n    }\r\n    let formatterPrecision;\r\n    if (precision == null || precisionIsNaN) {\r\n        formatterPrecision = type ? 6 : 12;\r\n    }\r\n    else {\r\n        formatterPrecision = precision;\r\n    }\r\n    return (n) => {\r\n        let result = formatBody(n, formatterPrecision);\r\n        if (trim) {\r\n            result = removeTrailingZeros(result);\r\n        }\r\n        if (comma) {\r\n            result = insertSeparator(result, comma);\r\n        }\r\n        result = addSign(n, result, sign);\r\n        if (symbol && symbol !== '#') {\r\n            result = `${symbol}${result}`;\r\n        }\r\n        if (symbol === '#' && type === 'x') {\r\n            result = `0x${result}`;\r\n        }\r\n        if (type === 's') {\r\n            result = `${result}${getSIPrefix(n)}`;\r\n        }\r\n        if (type === '%' || type === 'p') {\r\n            result = `${result}%`;\r\n        }\r\n        if (width != null && !isNaN(width)) {\r\n            result = addPadding(result, width, fill !== null && fill !== void 0 ? fill : zero, align);\r\n        }\r\n        result = `${prefix}${result}${suffix}`;\r\n        return result;\r\n    };\r\n}\r\nconst absFloor = (n) => Math.floor(Math.abs(n));\r\nconst integerTypes = {\r\n    b: (n) => absFloor(n).toString(2),\r\n    c: (n) => String.fromCharCode(n),\r\n    d: (n) => Math.round(Math.abs(n)).toFixed(0),\r\n    o: (n) => absFloor(n).toString(8),\r\n    x: (n) => absFloor(n).toString(16),\r\n    X: (n) => integerTypes.x(n).toUpperCase(),\r\n    n: (n) => integerTypes.d(n),\r\n    '%': (n) => `${absFloor(n * 100).toFixed(0)}`,\r\n};\r\nconst decimalTypes = {\r\n    e: (n, f) => Math.abs(n).toExponential(f),\r\n    E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\r\n    f: (n, f) => Math.abs(n).toFixed(f),\r\n    F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\r\n    g: (n, f) => {\r\n        if (n === 0) {\r\n            return '0';\r\n        }\r\n        const a = Math.abs(n);\r\n        const p = Math.floor(Math.log10(a));\r\n        if (p >= -4 && p < f) {\r\n            return a.toFixed(f - 1 - p);\r\n        }\r\n        return a.toExponential(f - 1);\r\n    },\r\n    G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\r\n    n: (n, f) => decimalTypes.g(n, f),\r\n    p: (n, f) => decimalTypes.r(n * 100, f),\r\n    r: (n, f) => {\r\n        if (n === 0) {\r\n            return '0';\r\n        }\r\n        const a = Math.abs(n);\r\n        const p = Math.floor(Math.log10(a));\r\n        const q = p - (f - 1);\r\n        if (q <= 0) {\r\n            return a.toFixed(-q);\r\n        }\r\n        const x = Math.pow(10, q);\r\n        return (Math.round(a / x) * x).toFixed();\r\n    },\r\n    s: (n, f) => {\r\n        const p = getSIPrefixPower(n);\r\n        return decimalTypes.r(n / Math.pow(10, p), f);\r\n    },\r\n    '%': (n, f) => decimalTypes.f(n * 100, f),\r\n};\r\nfunction removeTrailingZeros(numString) {\r\n    return numString.replace(/\\.0+$/, '').replace(/(\\.[1-9])0+$/, '$1');\r\n}\r\nfunction insertSeparator(numString, separator) {\r\n    let dotIndex = numString.indexOf('.');\r\n    if (dotIndex < 0) {\r\n        dotIndex = numString.length;\r\n    }\r\n    const integerChars = numString.substring(0, dotIndex).split('');\r\n    const fractionalPart = numString.substring(dotIndex);\r\n    for (let i = integerChars.length - 3; i > 0; i -= 3) {\r\n        integerChars.splice(i, 0, separator);\r\n    }\r\n    return `${integerChars.join('')}${fractionalPart}`;\r\n}\r\nfunction getSIPrefix(n) {\r\n    return siPrefixes[getSIPrefixPower(n)];\r\n}\r\nfunction getSIPrefixPower(n) {\r\n    const power = Math.log10(Math.abs(n));\r\n    const p = Math.floor(power / 3) * 3;\r\n    return Math.max(minSIPrefix, Math.min(maxSIPrefix, p));\r\n}\r\nconst minSIPrefix = -24;\r\nconst maxSIPrefix = 24;\r\nconst siPrefixes = {\r\n    [minSIPrefix]: 'y',\r\n    [-21]: 'z',\r\n    [-18]: 'a',\r\n    [-15]: 'f',\r\n    [-12]: 'p',\r\n    [-9]: 'n',\r\n    [-6]: 'µ',\r\n    [-3]: 'm',\r\n    [0]: '',\r\n    [3]: 'k',\r\n    [6]: 'M',\r\n    [9]: 'G',\r\n    [12]: 'T',\r\n    [15]: 'P',\r\n    [18]: 'E',\r\n    [21]: 'Z',\r\n    [maxSIPrefix]: 'Y',\r\n};\r\nconst minusSign = '\\u2212';\r\nfunction addSign(num, numString, signType = '') {\r\n    if (signType === '(') {\r\n        return num >= 0 ? numString : `(${numString})`;\r\n    }\r\n    const plusSign = signType === '+' ? '+' : '';\r\n    return `${num >= 0 ? plusSign : minusSign}${numString}`;\r\n}\r\nfunction addPadding(numString, width, fill = ' ', align = '>') {\r\n    let result = numString;\r\n    if (align === '>' || !align) {\r\n        result = result.padStart(width, fill);\r\n    }\r\n    else if (align === '<') {\r\n        result = result.padEnd(width, fill);\r\n    }\r\n    else if (align === '^') {\r\n        const padWidth = Math.max(0, width - result.length);\r\n        const padLeft = Math.ceil(padWidth / 2);\r\n        const padRight = Math.floor(padWidth / 2);\r\n        result = result.padStart(padLeft + result.length, fill);\r\n        result = result.padEnd(padRight + result.length, fill);\r\n    }\r\n    return result;\r\n}\r\nfunction tickFormat(ticks, formatter) {\r\n    const options = parseFormatter(formatter !== null && formatter !== void 0 ? formatter : ',f');\r\n    const { precision } = options;\r\n    if (precision == null || isNaN(precision)) {\r\n        if (options.type === 'f' || options.type === '%') {\r\n            options.precision = Math.max(...ticks.map((x) => {\r\n                if (typeof x !== 'number' || x === 0) {\r\n                    return 0;\r\n                }\r\n                const l = Math.floor(Math.log10(Math.abs(x)));\r\n                const digits = options.type ? 6 : 12;\r\n                const exp = x.toExponential(digits - 1).replace(/\\.?0+e/, 'e');\r\n                const dotIndex = exp.indexOf('.');\r\n                if (dotIndex < 0) {\r\n                    return l >= 0 ? 0 : -l;\r\n                }\r\n                const s = exp.indexOf('e') - dotIndex;\r\n                return Math.max(0, s - l - 1);\r\n            }));\r\n        }\r\n        else if (!options.type || options.type in decimalTypes) {\r\n            options.precision = Math.max(...ticks.map((x) => {\r\n                if (typeof x !== 'number') {\r\n                    return 0;\r\n                }\r\n                const exp = x.toExponential((options.type ? 6 : 12) - 1).replace(/\\.?0+e/, 'e');\r\n                return exp.substring(0, exp.indexOf('e')).replace('.', '').length;\r\n            }));\r\n        }\r\n    }\r\n    const f = format(options);\r\n    return (n) => f(Number(n));\r\n}\n\nfunction ticks (start, stop, count, minCount, maxCount) {\r\n    if (count < 2) {\r\n        return range$1(start, stop, stop - start);\r\n    }\r\n    const step = tickStep(start, stop, count, minCount, maxCount);\r\n    if (isNaN(step)) {\r\n        return new NumericTicks(0);\r\n    }\r\n    start = Math.ceil(start / step) * step;\r\n    stop = Math.floor(stop / step) * step;\r\n    return range$1(start, stop, step);\r\n}\r\nconst tickMultipliers = [1, 2, 5, 10];\r\nfunction tickStep(a, b, count, minCount = 0, maxCount = Infinity) {\r\n    const rawStep = (b - a) / count;\r\n    const power = Math.floor(Math.log10(rawStep));\r\n    const step = Math.pow(10, power);\r\n    const m = tickMultipliers\r\n        .map((multiplier) => {\r\n        const s = multiplier * step;\r\n        const c = Math.ceil((b - a) / s);\r\n        const isWithinBounds = c >= minCount && c <= maxCount;\r\n        const diffCount = Math.abs(c - count);\r\n        return { multiplier, isWithinBounds, diffCount };\r\n    })\r\n        .sort((a, b) => {\r\n        if (a.isWithinBounds !== b.isWithinBounds) {\r\n            return a.isWithinBounds ? -1 : 1;\r\n        }\r\n        return a.diffCount - b.diffCount;\r\n    })[0].multiplier;\r\n    if (!m || isNaN(m)) {\r\n        return NaN;\r\n    }\r\n    return m * step;\r\n}\r\nfunction singleTickDomain(a, b) {\r\n    const power = Math.floor(Math.log10(b - a));\r\n    const step = Math.pow(10, power);\r\n    return tickMultipliers\r\n        .map((multiplier) => {\r\n        const s = multiplier * step;\r\n        const start = Math.floor(a / s) * s;\r\n        const end = Math.ceil(b / s) * s;\r\n        const error = 1 - (b - a) / (end - start);\r\n        const domain = [start, end];\r\n        return { error, domain };\r\n    })\r\n        .sort((a, b) => a.error - b.error)[0].domain;\r\n}\r\nclass NumericTicks extends Array {\r\n    constructor(fractionDigits, elements) {\r\n        super();\r\n        if (elements) {\r\n            for (let i = 0, n = elements.length; i < n; i++) {\r\n                this[i] = elements[i];\r\n            }\r\n        }\r\n        this.fractionDigits = fractionDigits;\r\n    }\r\n}\r\nfunction range$1(start, stop, step) {\r\n    const countDigits = (expNo) => {\r\n        var _a, _b;\r\n        const parts = expNo.split('e');\r\n        return Math.max(((_b = (_a = parts[0].split('.')[1]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) - Number(parts[1]), 0);\r\n    };\r\n    const fractionalDigits = countDigits((step % 1).toExponential());\r\n    const f = Math.pow(10, fractionalDigits);\r\n    const n = Math.ceil((stop - start) / step);\r\n    const values = new NumericTicks(fractionalDigits);\r\n    for (let i = 0; i <= n; i++) {\r\n        const value = start + step * i;\r\n        values.push(Math.round(value * f) / f);\r\n    }\r\n    return values;\r\n}\n\nclass ContinuousScale {\r\n    static is(value) {\r\n        return value instanceof ContinuousScale;\r\n    }\r\n    constructor(domain, range) {\r\n        this.domain = domain;\r\n        this.range = range;\r\n        this.nice = false;\r\n        this.tickCount = ContinuousScale.defaultTickCount;\r\n        this.minTickCount = 0;\r\n        this.maxTickCount = Infinity;\r\n        this.niceDomain = [];\r\n        this.defaultClampMode = 'raw';\r\n        this.cache = null;\r\n        this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'minTickCount', 'maxTickCount'];\r\n    }\r\n    transform(x) {\r\n        return x;\r\n    }\r\n    transformInvert(x) {\r\n        return x;\r\n    }\r\n    calcBandwidth(smallestInterval = 1) {\r\n        const domain = this.getDomain();\r\n        const maxRange = Math.max(...this.range);\r\n        const intervals = (domain[1] - domain[0]) / smallestInterval + 1;\r\n        // The number of intervals/bands is used to determine the width of individual bands by dividing the available range.\r\n        // Allow a maximum number of bands to ensure the step does not fall below 1 pixel.\r\n        // This means there could be some overlap of the bands in the chart.\r\n        const maxBands = Math.floor(maxRange); // A minimum of 1px per bar/column means the maximum number of bands will equal the available range\r\n        const bands = Math.min(intervals, maxBands);\r\n        return maxRange / Math.max(1, bands);\r\n    }\r\n    fromDomain(d) {\r\n        if (typeof d === 'number') {\r\n            return d;\r\n        }\r\n        else if (d instanceof Date) {\r\n            return d.getTime();\r\n        }\r\n        return NaN;\r\n    }\r\n    getDomain() {\r\n        if (this.nice) {\r\n            this.refresh();\r\n            if (this.niceDomain.length) {\r\n                return this.niceDomain;\r\n            }\r\n        }\r\n        return this.domain;\r\n    }\r\n    convert(x, opts) {\r\n        var _a;\r\n        const clampMode = (_a = opts === null || opts === void 0 ? void 0 : opts.clampMode) !== null && _a !== void 0 ? _a : this.defaultClampMode;\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return NaN;\r\n        }\r\n        this.refresh();\r\n        const domain = this.getDomain().map((d) => this.transform(d));\r\n        const [d0, d1] = domain;\r\n        const { range } = this;\r\n        const [r0, r1] = range;\r\n        x = this.transform(x);\r\n        if (clampMode === 'clamped') {\r\n            if (x < d0) {\r\n                return r0;\r\n            }\r\n            else if (x > d1) {\r\n                return r1;\r\n            }\r\n        }\r\n        if (d0 === d1) {\r\n            return (r0 + r1) / 2;\r\n        }\r\n        else if (x === d0) {\r\n            return r0;\r\n        }\r\n        else if (x === d1) {\r\n            return r1;\r\n        }\r\n        return (r0 + ((this.fromDomain(x) - this.fromDomain(d0)) / (this.fromDomain(d1) - this.fromDomain(d0))) * (r1 - r0));\r\n    }\r\n    invert(x) {\r\n        this.refresh();\r\n        const domain = this.getDomain().map((d) => this.transform(d));\r\n        const [d0, d1] = domain;\r\n        const { range } = this;\r\n        const [r0, r1] = range;\r\n        const isReversed = r0 > r1;\r\n        const rMin = isReversed ? r1 : r0;\r\n        const rMax = isReversed ? r0 : r1;\r\n        let d;\r\n        if (x < rMin) {\r\n            return isReversed ? d1 : d0;\r\n        }\r\n        else if (x > rMax) {\r\n            return isReversed ? d0 : d1;\r\n        }\r\n        else if (r0 === r1) {\r\n            d = this.toDomain((this.fromDomain(d0) + this.fromDomain(d1)) / 2);\r\n        }\r\n        else {\r\n            d = this.toDomain(this.fromDomain(d0) + ((x - r0) / (r1 - r0)) * (this.fromDomain(d1) - this.fromDomain(d0)));\r\n        }\r\n        return this.transformInvert(d);\r\n    }\r\n    didChange() {\r\n        const { cache } = this;\r\n        const didChange = !cache || this.cacheProps.some((p) => this[p] !== cache[p]);\r\n        if (didChange) {\r\n            this.cache = {};\r\n            this.cacheProps.forEach((p) => (this.cache[p] = this[p]));\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    refresh() {\r\n        if (this.didChange()) {\r\n            this.update();\r\n        }\r\n    }\r\n    getPixelRange() {\r\n        const range = this.range.slice().sort((a, b) => a - b);\r\n        return range[1] - range[0];\r\n    }\r\n    isDenseInterval({ start, stop, interval, count, }) {\r\n        const domain = stop - start;\r\n        const availableRange = this.getPixelRange();\r\n        const step = typeof interval === 'number' ? interval : 1;\r\n        count !== null && count !== void 0 ? count : (count = domain / step);\r\n        if (count >= availableRange) {\r\n            Logger.warn(`the configured tick interval results in more than 1 tick per pixel, ignoring. Supply a larger tick interval or omit this configuration.`);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nContinuousScale.defaultTickCount = 5;\r\nContinuousScale.defaultMaxTickCount = 6;\n\n/**\r\n * Maps continuous domain to a continuous range.\r\n */\r\nclass LinearScale extends ContinuousScale {\r\n    constructor() {\r\n        super([0, 1], [0, 1]);\r\n        this.type = 'linear';\r\n    }\r\n    toDomain(d) {\r\n        return d;\r\n    }\r\n    ticks() {\r\n        var _a;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\r\n        if (!this.domain || this.domain.length < 2 || count < 1 || this.domain.some((d) => !isFinite(d))) {\r\n            return [];\r\n        }\r\n        this.refresh();\r\n        const [d0, d1] = this.getDomain();\r\n        const { interval } = this;\r\n        if (interval) {\r\n            const step = Math.abs(interval);\r\n            if (!this.isDenseInterval({ start: d0, stop: d1, interval: step })) {\r\n                return range$1(d0, d1, step);\r\n            }\r\n        }\r\n        return ticks(d0, d1, count, this.minTickCount, this.maxTickCount);\r\n    }\r\n    update() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return;\r\n        }\r\n        if (this.nice) {\r\n            this.updateNiceDomain();\r\n        }\r\n    }\r\n    getTickStep(start, stop) {\r\n        var _a, _b;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\r\n        return (_b = this.interval) !== null && _b !== void 0 ? _b : tickStep(start, stop, count, this.minTickCount, this.maxTickCount);\r\n    }\r\n    /**\r\n     * Extends the domain so that it starts and ends on nice round values.\r\n     */\r\n    updateNiceDomain() {\r\n        var _a;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\r\n        let [start, stop] = this.domain;\r\n        if (count < 1) {\r\n            this.niceDomain = [start, stop];\r\n            return;\r\n        }\r\n        if (count === 1) {\r\n            this.niceDomain = singleTickDomain(start, stop);\r\n            return;\r\n        }\r\n        const maxAttempts = 4;\r\n        let prev0 = start;\r\n        let prev1 = stop;\r\n        for (let i = 0; i < maxAttempts; i++) {\r\n            const step = this.getTickStep(start, stop);\r\n            const [d0, d1] = this.domain;\r\n            if (step >= 1) {\r\n                start = Math.floor(d0 / step) * step;\r\n                stop = Math.ceil(d1 / step) * step;\r\n            }\r\n            else {\r\n                // Prevent floating point error\r\n                const s = 1 / step;\r\n                start = Math.floor(d0 * s) / s;\r\n                stop = Math.ceil(d1 * s) / s;\r\n            }\r\n            if (start === prev0 && stop === prev1) {\r\n                break;\r\n            }\r\n            prev0 = start;\r\n            prev1 = stop;\r\n        }\r\n        this.niceDomain = [start, stop];\r\n    }\r\n    tickFormat({ ticks, specifier }) {\r\n        return tickFormat(ticks !== null && ticks !== void 0 ? ticks : this.ticks(), specifier);\r\n    }\r\n}\n\nfunction ascendingStringNumberUndefined(a, b) {\r\n    let diff = 0;\r\n    if (typeof a === 'number' && typeof b === 'number') {\r\n        diff = a - b;\r\n    }\r\n    else if (typeof a === 'string' && typeof b === 'string') {\r\n        diff = a.localeCompare(b);\r\n    }\r\n    else if (a == null && b == null) ;\r\n    else if (a == null) {\r\n        diff = -1;\r\n    }\r\n    else if (b == null) {\r\n        diff = 1;\r\n    }\r\n    else {\r\n        diff = String(a).localeCompare(String(b));\r\n    }\r\n    return diff;\r\n}\r\nfunction compoundAscending(a, b, comparator) {\r\n    const toLiteral = (v) => {\r\n        if (typeof v === 'function') {\r\n            return v();\r\n        }\r\n        return v;\r\n    };\r\n    for (const idx in a) {\r\n        const diff = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\r\n        if (diff !== 0) {\r\n            return diff;\r\n        }\r\n    }\r\n    return 0;\r\n}\n\nclass Group extends Node {\r\n    zIndexChanged() {\r\n        var _a;\r\n        if (this.layer) {\r\n            (_a = this._layerManager) === null || _a === void 0 ? void 0 : _a.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\r\n        }\r\n    }\r\n    isLayer() {\r\n        return this.layer != null;\r\n    }\r\n    constructor(opts) {\r\n        var _a;\r\n        super({ isVirtual: opts === null || opts === void 0 ? void 0 : opts.isVirtual });\r\n        this.opts = opts;\r\n        this.opacity = 1;\r\n        this.lastBBox = undefined;\r\n        const { zIndex, zIndexSubOrder } = opts !== null && opts !== void 0 ? opts : {};\r\n        this.isContainerNode = true;\r\n        if (zIndex !== undefined) {\r\n            this.zIndex = zIndex;\r\n        }\r\n        if (zIndexSubOrder !== undefined) {\r\n            this.zIndexSubOrder = zIndexSubOrder;\r\n        }\r\n        this.name = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.name;\r\n    }\r\n    _setLayerManager(scene) {\r\n        var _a, _b;\r\n        if (this._layerManager && this.layer) {\r\n            this._layerManager.removeLayer(this.layer);\r\n            this.layer = undefined;\r\n        }\r\n        if (this.layer) {\r\n            throw new Error('AG Charts - unable to deregister scene rendering layer!');\r\n        }\r\n        super._setLayerManager(scene);\r\n        if (scene && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.layer)) {\r\n            const { zIndex, zIndexSubOrder, name } = (_b = this.opts) !== null && _b !== void 0 ? _b : {};\r\n            const getComputedOpacity = () => this.getComputedOpacity();\r\n            const getVisibility = () => this.getVisibility();\r\n            this.layer = scene.addLayer({\r\n                zIndex,\r\n                zIndexSubOrder,\r\n                name,\r\n                getComputedOpacity,\r\n                getVisibility,\r\n            });\r\n        }\r\n    }\r\n    getComputedOpacity() {\r\n        let opacity = 1;\r\n        let node = this;\r\n        do {\r\n            if (node instanceof Group) {\r\n                opacity *= node.opacity;\r\n            }\r\n        } while ((node = node.parent));\r\n        return opacity;\r\n    }\r\n    getVisibility() {\r\n        let node = this;\r\n        let visible = this.visible;\r\n        while ((node = node.parent)) {\r\n            if (node.visible) {\r\n                continue;\r\n            }\r\n            visible = node.visible;\r\n        }\r\n        return visible;\r\n    }\r\n    visibilityChanged() {\r\n        if (this.layer) {\r\n            this.layer.enabled = this.visible;\r\n        }\r\n    }\r\n    markDirty(source, type = RedrawType.TRIVIAL) {\r\n        if (this.isVirtual) {\r\n            // Always percolate directly for virtual nodes - they don't exist for rendering purposes.\r\n            super.markDirty(source, type);\r\n            return;\r\n        }\r\n        // Downgrade dirty-ness percolated to parent in special cases.\r\n        let parentType = type;\r\n        if (type < RedrawType.MINOR || this.layer != null) {\r\n            parentType = RedrawType.TRIVIAL;\r\n        }\r\n        super.markDirty(source, type, parentType);\r\n    }\r\n    // We consider a group to be boundless, thus any point belongs to it.\r\n    containsPoint(_x, _y) {\r\n        return true;\r\n    }\r\n    computeBBox() {\r\n        this.computeTransformMatrix();\r\n        return Group.computeBBox(this.children);\r\n    }\r\n    computeTransformedBBox() {\r\n        return this.computeBBox();\r\n    }\r\n    render(renderCtx) {\r\n        var _a, _b;\r\n        const { opts: { name = undefined } = {}, _debug: debug = () => { } } = this;\r\n        const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;\r\n        let { ctx, forceRender, clipBBox } = renderCtx;\r\n        const { resized, stats } = renderCtx;\r\n        const canvasCtxTransform = ctx.getTransform();\r\n        const isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;\r\n        let isChildDirty = isDirty;\r\n        let isChildLayerDirty = false;\r\n        for (const child of children) {\r\n            isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= RedrawType.TRIVIAL);\r\n            isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= RedrawType.TRIVIAL);\r\n            if (isChildDirty) {\r\n                break;\r\n            }\r\n        }\r\n        if (name) {\r\n            debug({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });\r\n        }\r\n        if (dirtyTransform) {\r\n            forceRender = 'dirtyTransform';\r\n        }\r\n        else if (layer) {\r\n            // If bounding-box of a layer changes, force re-render.\r\n            const currentBBox = this.computeBBox();\r\n            if (this.lastBBox === undefined || !this.lastBBox.equals(currentBBox)) {\r\n                forceRender = 'dirtyTransform';\r\n                this.lastBBox = currentBBox;\r\n            }\r\n        }\r\n        if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\r\n            if (name && stats) {\r\n                debug({ name, result: 'skipping', renderCtx, counts: this.nodeCount, group: this });\r\n            }\r\n            if (layer && stats) {\r\n                stats.layersSkipped++;\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            }\r\n            this.markClean({ recursive: false });\r\n            // Nothing to do.\r\n            return;\r\n        }\r\n        const groupVisible = this.visible;\r\n        if (layer) {\r\n            // Switch context to the canvas layer we use for this group.\r\n            ctx = layer.context;\r\n            ctx.save();\r\n            ctx.resetTransform();\r\n            if (forceRender !== 'dirtyTransform') {\r\n                forceRender = isChildDirty || dirtyZIndex;\r\n            }\r\n            if (forceRender)\r\n                layer.clear();\r\n            if (clipBBox) {\r\n                // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play\r\n                const { width, height, x, y } = clipBBox;\r\n                debug(() => ({\r\n                    name,\r\n                    clipBBox,\r\n                    ctxTransform: ctx.getTransform(),\r\n                    renderCtx,\r\n                    group: this,\r\n                }));\r\n                this.clipCtx(ctx, x, y, width, height);\r\n            }\r\n            ctx.setTransform(canvasCtxTransform);\r\n        }\r\n        else {\r\n            // Only apply opacity if this isn't a distinct layer - opacity will be applied\r\n            // at composition time.\r\n            ctx.globalAlpha *= this.opacity;\r\n        }\r\n        // A group can have `scaling`, `rotation`, `translation` properties\r\n        // that are applied to the canvas context before children are rendered,\r\n        // so all children can be transformed at once.\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        if (clipRect) {\r\n            // clipRect is in the group's coordinate space\r\n            const { x, y, width, height } = clipRect;\r\n            ctx.save();\r\n            debug(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));\r\n            this.clipCtx(ctx, x, y, width, height);\r\n            // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play\r\n            clipBBox = this.matrix.transformBBox(clipRect);\r\n        }\r\n        const hasVirtualChildren = this.hasVirtualChildren();\r\n        if (dirtyZIndex) {\r\n            this.sortChildren(children);\r\n            if (forceRender !== 'dirtyTransform')\r\n                forceRender = true;\r\n        }\r\n        else if (hasVirtualChildren) {\r\n            this.sortChildren(children);\r\n        }\r\n        // Reduce churn if renderCtx is identical.\r\n        const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\r\n        const childRenderContext = renderContextChanged ? Object.assign(Object.assign({}, renderCtx), { ctx, forceRender, clipBBox }) : renderCtx;\r\n        // Render visible children.\r\n        let skipped = 0;\r\n        for (const child of children) {\r\n            if (!child.visible || !groupVisible) {\r\n                // Skip invisible children, but make sure their dirty flag is reset.\r\n                child.markClean();\r\n                if (stats)\r\n                    skipped += child.nodeCount.count;\r\n                continue;\r\n            }\r\n            if (!forceRender && child.dirty === RedrawType.NONE) {\r\n                // Skip children that don't need to be redrawn.\r\n                if (stats)\r\n                    skipped += child.nodeCount.count;\r\n                continue;\r\n            }\r\n            // Render marks this node (and children) as clean - no need to explicitly markClean().\r\n            ctx.save();\r\n            child.render(childRenderContext);\r\n            ctx.restore();\r\n        }\r\n        if (stats)\r\n            stats.nodesSkipped += skipped;\r\n        // Render marks this node as clean - no need to explicitly markClean().\r\n        super.render(renderCtx);\r\n        if (clipRect) {\r\n            ctx.restore();\r\n        }\r\n        if (hasVirtualChildren) {\r\n            // Mark virtual nodes as clean and their virtual children - all other nodes have already\r\n            // been visited and marked clean.\r\n            for (const child of this.virtualChildren) {\r\n                child.markClean({ recursive: 'virtual' });\r\n            }\r\n        }\r\n        if (layer) {\r\n            if (stats)\r\n                stats.layersRendered++;\r\n            ctx.restore();\r\n            if (forceRender)\r\n                layer.snapshot();\r\n            // Check for save/restore depth of zero!\r\n            (_b = (_a = layer.context).verifyDepthZero) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n        if (name && stats) {\r\n            debug({ name, result: 'rendered', skipped, renderCtx, counts: this.nodeCount, group: this });\r\n        }\r\n    }\r\n    sortChildren(children) {\r\n        this.dirtyZIndex = false;\r\n        children.sort((a, b) => {\r\n            var _a, _b;\r\n            return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.serialNumber], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.serialNumber], ascendingStringNumberUndefined);\r\n        });\r\n    }\r\n    clipCtx(ctx, x, y, width, height) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x + width, y);\r\n        ctx.lineTo(x + width, y + height);\r\n        ctx.lineTo(x, y + height);\r\n        ctx.closePath();\r\n        ctx.clip();\r\n    }\r\n    static computeBBox(nodes) {\r\n        let left = Infinity;\r\n        let right = -Infinity;\r\n        let top = Infinity;\r\n        let bottom = -Infinity;\r\n        nodes.forEach((n) => {\r\n            if (!n.visible) {\r\n                return;\r\n            }\r\n            const bbox = n.computeTransformedBBox();\r\n            if (!bbox) {\r\n                return;\r\n            }\r\n            const x = bbox.x;\r\n            const y = bbox.y;\r\n            if (x < left) {\r\n                left = x;\r\n            }\r\n            if (y < top) {\r\n                top = y;\r\n            }\r\n            if (x + bbox.width > right) {\r\n                right = x + bbox.width;\r\n            }\r\n            if (y + bbox.height > bottom) {\r\n                bottom = y + bbox.height;\r\n            }\r\n        });\r\n        return new BBox(left, top, right - left, bottom - top);\r\n    }\r\n    /**\r\n     * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\r\n     * sets this group's clipRect to the transformed bbox.\r\n     * @param bbox clipRect bbox in the canvas coordinate space.\r\n     */\r\n    setClipRectInGroupCoordinateSpace(bbox) {\r\n        this.clipRect = bbox ? this.transformBBox(bbox) : undefined;\r\n    }\r\n}\r\nGroup.className = 'Group';\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.MAJOR,\r\n        convertor: (v) => Math.min(1, Math.max(0, v)),\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Group.prototype, \"opacity\", void 0);\n\nclass Selection {\r\n    static select(parent, classOrFactory, garbageCollection = true) {\r\n        return new Selection(parent, classOrFactory, garbageCollection);\r\n    }\r\n    static selectAll(parent, predicate) {\r\n        const results = [];\r\n        const traverse = (node) => {\r\n            if (predicate(node)) {\r\n                results.push(node);\r\n            }\r\n            node.children.forEach(traverse);\r\n        };\r\n        traverse(parent);\r\n        return results;\r\n    }\r\n    static selectByClass(node, Class) {\r\n        return Selection.selectAll(node, (node) => node instanceof Class);\r\n    }\r\n    static selectByTag(node, tag) {\r\n        return Selection.selectAll(node, (node) => node.tag === tag);\r\n    }\r\n    constructor(parentNode, classOrFactory, autoCleanup = true) {\r\n        this.parentNode = parentNode;\r\n        this.autoCleanup = autoCleanup;\r\n        this.garbageBin = new Set();\r\n        this._nodesMap = new Map();\r\n        this._nodes = [];\r\n        this.data = [];\r\n        this.debug = Debug.create(true, 'scene', 'scene:selections');\r\n        this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory)\r\n            ? () => new classOrFactory()\r\n            : classOrFactory;\r\n    }\r\n    createNode(datum, initializer, idx) {\r\n        const node = this.nodeFactory(datum);\r\n        node.datum = datum;\r\n        initializer === null || initializer === void 0 ? void 0 : initializer(node);\r\n        if (idx != null) {\r\n            this._nodes.splice(idx, 0, node);\r\n        }\r\n        else {\r\n            this._nodes.push(node);\r\n        }\r\n        this.parentNode.appendChild(node);\r\n        return node;\r\n    }\r\n    /**\r\n     * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\r\n     * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\r\n     * of the array.\r\n     */\r\n    update(data, initializer, getDatumId) {\r\n        if (this.garbageBin.size > 0) {\r\n            this.debug(`Selection - update() called with pending garbage: ${data}`);\r\n        }\r\n        if (getDatumId) {\r\n            const dataMap = new Map(data.map((datum, idx) => [getDatumId(datum), [datum, idx]]));\r\n            for (const [node, datumId] of this._nodesMap.entries()) {\r\n                if (dataMap.has(datumId)) {\r\n                    const [newDatum] = dataMap.get(datumId);\r\n                    node.datum = newDatum;\r\n                    this.garbageBin.delete(node);\r\n                    dataMap.delete(datumId);\r\n                }\r\n                else {\r\n                    this.garbageBin.add(node);\r\n                }\r\n            }\r\n            for (const [datumId, [datum, idx]] of dataMap.entries()) {\r\n                this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\r\n            }\r\n        }\r\n        else {\r\n            const maxLength = Math.max(data.length, this.data.length);\r\n            for (let i = 0; i < maxLength; i++) {\r\n                if (i >= data.length) {\r\n                    this.garbageBin.add(this._nodes[i]);\r\n                }\r\n                else if (i >= this._nodes.length) {\r\n                    this.createNode(data[i], initializer);\r\n                }\r\n                else {\r\n                    this._nodes[i].datum = data[i];\r\n                    this.garbageBin.delete(this._nodes[i]);\r\n                }\r\n            }\r\n        }\r\n        this.data = data.slice();\r\n        if (this.autoCleanup) {\r\n            this.cleanup();\r\n        }\r\n        return this;\r\n    }\r\n    cleanup() {\r\n        if (this.garbageBin.size === 0) {\r\n            return this;\r\n        }\r\n        this._nodes = this._nodes.filter((node) => {\r\n            if (this.garbageBin.has(node)) {\r\n                this._nodesMap.delete(node);\r\n                this.garbageBin.delete(node);\r\n                this.parentNode.removeChild(node);\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        return this;\r\n    }\r\n    clear() {\r\n        this.update([]);\r\n        return this;\r\n    }\r\n    isGarbage(node) {\r\n        return this.garbageBin.has(node);\r\n    }\r\n    hasGarbage() {\r\n        return this.garbageBin.size > 0;\r\n    }\r\n    each(iterate) {\r\n        this._nodes.forEach((node, i) => iterate(node, node.datum, i));\r\n        return this;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        for (let index = 0; index < this._nodes.length; index++) {\r\n            const node = this._nodes[index];\r\n            const datum = this._nodes[index].datum;\r\n            yield { node, datum, index };\r\n        }\r\n    }\r\n    select(predicate) {\r\n        return Selection.selectAll(this.parentNode, predicate);\r\n    }\r\n    selectByClass(Class) {\r\n        return Selection.selectByClass(this.parentNode, Class);\r\n    }\r\n    selectByTag(tag) {\r\n        return Selection.selectByTag(this.parentNode, tag);\r\n    }\r\n    nodes() {\r\n        return this._nodes;\r\n    }\r\n}\n\nclass Line extends Shape {\r\n    constructor(opts = {}) {\r\n        super(opts);\r\n        this.x1 = 0;\r\n        this.y1 = 0;\r\n        this.x2 = 0;\r\n        this.y2 = 0;\r\n        this.restoreOwnStyles();\r\n    }\r\n    set x(value) {\r\n        this.x1 = value;\r\n        this.x2 = value;\r\n    }\r\n    set y(value) {\r\n        this.y1 = value;\r\n        this.y2 = value;\r\n    }\r\n    computeBBox() {\r\n        return new BBox(Math.min(this.x1, this.x2), Math.min(this.y1, this.y2), Math.abs(this.x2 - this.x1), Math.abs(this.y2 - this.y1));\r\n    }\r\n    isPointInPath(px, py) {\r\n        if (this.x1 === this.x2 || this.y1 === this.y2) {\r\n            const { x, y } = this.transformPoint(px, py);\r\n            return this.computeBBox()\r\n                .grow(this.strokeWidth / 2)\r\n                .containsPoint(x, y);\r\n        }\r\n        return false;\r\n    }\r\n    render(renderCtx) {\r\n        var _a;\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        let { x1, y1, x2, y2 } = this;\r\n        // Align to the pixel grid if the line is strictly vertical\r\n        // or horizontal (but not both, i.e. a dot).\r\n        if (x1 === x2) {\r\n            const x = Math.round(x1) + (Math.floor(this.strokeWidth) % 2) / 2;\r\n            x1 = x;\r\n            x2 = x;\r\n        }\r\n        else if (y1 === y2) {\r\n            const y = Math.round(y1) + (Math.floor(this.strokeWidth) % 2) / 2;\r\n            y1 = y;\r\n            y2 = y;\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        this.fillStroke(ctx);\r\n        (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nLine.className = 'Line';\r\nLine.defaultStyles = Object.assign({}, Shape.defaultStyles, {\r\n    fill: undefined,\r\n    strokeWidth: 1,\r\n});\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"x1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"y1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"x2\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"y2\", void 0);\n\n/**\r\n * Finds the roots of a parametric linear equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n */\r\nfunction linearRoot(a, b) {\r\n    const t = -b / a;\r\n    return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\r\n}\r\n/**\r\n * Finds the roots of a parametric quadratic equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n */\r\nfunction quadraticRoots(a, b, c) {\r\n    if (a === 0) {\r\n        return linearRoot(b, c);\r\n    }\r\n    const D = b * b - 4 * a * c; // The polynomial's discriminant.\r\n    const roots = [];\r\n    if (D === 0) {\r\n        // A single real root.\r\n        const t = -b / (2 * a);\r\n        if (t >= 0 && t <= 1) {\r\n            roots.push(t);\r\n        }\r\n    }\r\n    else if (D > 0) {\r\n        // A pair of distinct real roots.\r\n        const rD = Math.sqrt(D);\r\n        const t1 = (-b - rD) / (2 * a);\r\n        const t2 = (-b + rD) / (2 * a);\r\n        if (t1 >= 0 && t1 <= 1) {\r\n            roots.push(t1);\r\n        }\r\n        if (t2 >= 0 && t2 <= 1) {\r\n            roots.push(t2);\r\n        }\r\n    }\r\n    // else -> Complex roots.\r\n    return roots;\r\n}\r\n/**\r\n * Finds the roots of a parametric cubic equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n * Returns an array of parametric intersection locations along the cubic,\r\n * excluding out-of-bounds intersections (before or after the end point\r\n * or in the imaginary plane).\r\n * An adaptation of http://www.particleincell.com/blog/2013/cubic-line-intersection/\r\n */\r\nfunction cubicRoots(a, b, c, d) {\r\n    if (a === 0) {\r\n        return quadraticRoots(b, c, d);\r\n    }\r\n    const A = b / a;\r\n    const B = c / a;\r\n    const C = d / a;\r\n    const Q = (3 * B - A * A) / 9;\r\n    const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\r\n    const D = Q * Q * Q + R * R; // The polynomial's discriminant.\r\n    const third = 1 / 3;\r\n    const roots = [];\r\n    if (D >= 0) {\r\n        // Complex or duplicate roots.\r\n        const rD = Math.sqrt(D);\r\n        const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\r\n        const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\r\n        const Im = Math.abs((Math.sqrt(3) * (S - T)) / 2); // Complex part of the root pair.\r\n        const t = -third * A + (S + T); // A real root.\r\n        if (t >= 0 && t <= 1) {\r\n            roots.push(t);\r\n        }\r\n        if (Im === 0) {\r\n            const t = -third * A - (S + T) / 2; // The real part of a complex root.\r\n            if (t >= 0 && t <= 1) {\r\n                roots.push(t);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // Distinct real roots.\r\n        const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\r\n        const thirdA = third * A;\r\n        const twoSqrtQ = 2 * Math.sqrt(-Q);\r\n        const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\r\n        const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\r\n        const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\r\n        if (t1 >= 0 && t1 <= 1) {\r\n            roots.push(t1);\r\n        }\r\n        if (t2 >= 0 && t2 <= 1) {\r\n            roots.push(t2);\r\n        }\r\n        if (t3 >= 0 && t3 <= 1) {\r\n            roots.push(t3);\r\n        }\r\n    }\r\n    return roots;\r\n}\n\n/**\r\n * Returns the intersection point for the given pair of line segments, or null,\r\n * if the segments are parallel or don't intersect.\r\n * Based on http://paulbourke.net/geometry/pointlineplane/\r\n */\r\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\r\n    const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\r\n    if (d === 0) {\r\n        // The lines are parallel.\r\n        return null;\r\n    }\r\n    const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\r\n    const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\r\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\r\n        return {\r\n            x: ax1 + ua * (ax2 - ax1),\r\n            y: ay1 + ua * (ay2 - ay1),\r\n        };\r\n    }\r\n    return null; // The intersection point is outside either or both segments.\r\n}\r\n/**\r\n * Returns intersection points of the given cubic curve and the line segment.\r\n * Takes in x/y components of cubic control points and line segment start/end points\r\n * as parameters.\r\n */\r\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\r\n    const intersections = [];\r\n    // Find line equation coefficients.\r\n    const A = y1 - y2;\r\n    const B = x2 - x1;\r\n    const C = x1 * (y2 - y1) - y1 * (x2 - x1);\r\n    // Find cubic Bezier curve equation coefficients from control points.\r\n    const bx = bezierCoefficients(px1, px2, px3, px4);\r\n    const by = bezierCoefficients(py1, py2, py3, py4);\r\n    const a = A * bx[0] + B * by[0]; // t^3\r\n    const b = A * bx[1] + B * by[1]; // t^2\r\n    const c = A * bx[2] + B * by[2]; // t\r\n    const d = A * bx[3] + B * by[3] + C; // 1\r\n    const roots = cubicRoots(a, b, c, d);\r\n    // Verify that the roots are within bounds of the linear segment.\r\n    for (const t of roots) {\r\n        const tt = t * t;\r\n        const ttt = t * tt;\r\n        // Find the cartesian plane coordinates for the parametric root `t`.\r\n        const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\r\n        const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\r\n        // The parametric cubic roots we found are intersection points\r\n        // with an infinite line, and so the x/y coordinates above are as well.\r\n        // Make sure the x/y is also within the bounds of the given segment.\r\n        let s;\r\n        if (x1 !== x2) {\r\n            s = (x - x1) / (x2 - x1);\r\n        }\r\n        else {\r\n            // the line is vertical\r\n            s = (y - y1) / (y2 - y1);\r\n        }\r\n        if (s >= 0 && s <= 1) {\r\n            intersections.push({ x, y });\r\n        }\r\n    }\r\n    return intersections;\r\n}\r\n/**\r\n * Returns the given coordinates vector multiplied by the coefficient matrix\r\n * of the parametric cubic Bézier equation.\r\n */\r\nfunction bezierCoefficients(P1, P2, P3, P4) {\r\n    return [\r\n        // Bézier expressed as matrix operations:\r\n        -P1 + 3 * P2 - 3 * P3 + P4,\r\n        3 * P1 - 6 * P2 + 3 * P3,\r\n        -3 * P1 + 3 * P2,\r\n        P1, //                 | 1  0  0  0| |P4|\r\n    ];\r\n}\r\n/**\r\n * Returns intersection points of the arc and the line segment.\r\n * Takes in arc parameters and line segment start/end points.\r\n */\r\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\r\n    // Solving the quadratic equation:\r\n    // 1. y = k * x + y0\r\n    // 2. (x - cx)^2 + (y - cy)^2 = r^2\r\n    const k = (y2 - y1) / (x2 - x1);\r\n    const y0 = y1 - k * x1;\r\n    const a = Math.pow(k, 2) + 1;\r\n    const b = 2 * (k * (y0 - cy) - cx);\r\n    const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\r\n    const d = Math.pow(b, 2) - 4 * a * c;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    const i1x = (-b + Math.sqrt(d)) / 2 / a;\r\n    const i2x = (-b - Math.sqrt(d)) / 2 / a;\r\n    const intersections = [];\r\n    [i1x, i2x].forEach((x) => {\r\n        const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\r\n        if (!isXInsideLine) {\r\n            return;\r\n        }\r\n        const y = k * x + y0;\r\n        const a1 = normalizeAngle360(startAngle);\r\n        let a2 = normalizeAngle360(endAngle);\r\n        let a = normalizeAngle360(Math.atan2(y, x));\r\n        // Order angles clockwise after the start angle\r\n        if (a2 <= a1) {\r\n            a2 += 2 * Math.PI;\r\n        }\r\n        if (a < a1) {\r\n            a += 2 * Math.PI;\r\n        }\r\n        if (counterClockwise !== (a >= a1 && a <= a2)) {\r\n            intersections.push({ x, y });\r\n        }\r\n    });\r\n    return intersections;\r\n}\n\nfunction isPointInSector(x, y, sector) {\r\n    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n    const { innerRadius, outerRadius } = sector;\r\n    if (sector.startAngle === sector.endAngle ||\r\n        radius < Math.min(innerRadius, outerRadius) ||\r\n        radius > Math.max(innerRadius, outerRadius)) {\r\n        return false;\r\n    }\r\n    const startAngle = normalizeAngle180(sector.startAngle);\r\n    const endAngle = normalizeAngle180(sector.endAngle);\r\n    const angle = Math.atan2(y, x);\r\n    // Sector can cross axis start\r\n    return startAngle < endAngle\r\n        ? angle <= endAngle && angle >= startAngle\r\n        : (angle <= endAngle && angle >= -Math.PI) || (angle >= startAngle && angle <= Math.PI);\r\n}\r\nfunction lineCollidesSector(line, sector) {\r\n    const { startAngle, endAngle, innerRadius, outerRadius } = sector;\r\n    const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\r\n    const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\r\n    const innerStart = innerRadius === 0\r\n        ? { x: 0, y: 0 }\r\n        : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\r\n    const innerEnd = innerRadius === 0\r\n        ? { x: 0, y: 0 }\r\n        : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\r\n    return (segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerStart.x, outerStart.y, innerStart.x, innerStart.y) != null ||\r\n        segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerEnd.x, outerEnd.y, innerEnd.x, innerEnd.y) != null ||\r\n        arcIntersections(0, 0, outerRadius, startAngle, endAngle, true, line.start.x, line.start.y, line.end.x, line.end.y).length > 0);\r\n}\r\nfunction boxCollidesSector(box, sector) {\r\n    const topLeft = { x: box.x, y: box.y };\r\n    const topRight = { x: box.x + box.width, y: box.y };\r\n    const bottomLeft = { x: box.x, y: box.y + box.height };\r\n    const bottomRight = { x: box.x + box.width, y: box.y + box.height };\r\n    return (lineCollidesSector({ start: topLeft, end: topRight }, sector) ||\r\n        lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector));\r\n}\n\nvar Command;\r\n(function (Command) {\r\n    Command[Command[\"Move\"] = 0] = \"Move\";\r\n    Command[Command[\"Line\"] = 1] = \"Line\";\r\n    Command[Command[\"Arc\"] = 2] = \"Arc\";\r\n    Command[Command[\"Curve\"] = 3] = \"Curve\";\r\n    Command[Command[\"ClosePath\"] = 4] = \"ClosePath\";\r\n})(Command || (Command = {}));\r\nclass Path2D {\r\n    constructor() {\r\n        // The methods of this class will likely be called many times per animation frame,\r\n        // and any allocation can trigger a GC cycle during animation, so we attempt\r\n        // to minimize the number of allocations.\r\n        this.previousCommands = [];\r\n        this.previousParams = [];\r\n        this.previousClosedPath = false;\r\n        this.commands = [];\r\n        this.params = [];\r\n        this._closedPath = false;\r\n    }\r\n    isDirty() {\r\n        if (this._closedPath !== this.previousClosedPath) {\r\n            return true;\r\n        }\r\n        if (this.previousCommands.length !== this.commands.length) {\r\n            return true;\r\n        }\r\n        if (this.previousParams.length !== this.params.length) {\r\n            return true;\r\n        }\r\n        for (let i = 0; i < this.commands.length; i++) {\r\n            if (this.commands[i] !== this.previousCommands[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        for (let i = 0; i < this.params.length; i++) {\r\n            if (this.params[i] !== this.previousParams[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    draw(ctx) {\r\n        const commands = this.commands;\r\n        const params = this.params;\r\n        let j = 0;\r\n        ctx.beginPath();\r\n        for (const command of commands) {\r\n            switch (command) {\r\n                case Command.Move:\r\n                    ctx.moveTo(params[j++], params[j++]);\r\n                    break;\r\n                case Command.Line:\r\n                    ctx.lineTo(params[j++], params[j++]);\r\n                    break;\r\n                case Command.Curve:\r\n                    ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);\r\n                    break;\r\n                case Command.Arc:\r\n                    ctx.arc(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++] === 1);\r\n                    break;\r\n                case Command.ClosePath:\r\n                    ctx.closePath();\r\n                    break;\r\n            }\r\n        }\r\n        if (commands.length === 0) {\r\n            ctx.closePath();\r\n        }\r\n    }\r\n    moveTo(x, y) {\r\n        if (this.xy) {\r\n            this.xy[0] = x;\r\n            this.xy[1] = y;\r\n        }\r\n        else {\r\n            this.xy = [x, y];\r\n        }\r\n        this.commands.push(Command.Move);\r\n        this.params.push(x, y);\r\n    }\r\n    lineTo(x, y) {\r\n        if (this.xy) {\r\n            this.commands.push(Command.Line);\r\n            this.params.push(x, y);\r\n            this.xy[0] = x;\r\n            this.xy[1] = y;\r\n        }\r\n        else {\r\n            this.moveTo(x, y);\r\n        }\r\n    }\r\n    rect(x, y, width, height) {\r\n        this.moveTo(x, y);\r\n        this.lineTo(x + width, y);\r\n        this.lineTo(x + width, y + height);\r\n        this.lineTo(x, y + height);\r\n        this.closePath();\r\n    }\r\n    arc(x, y, r, sAngle, eAngle, antiClockwise = false) {\r\n        const endX = x + r * Math.cos(eAngle);\r\n        const endY = y + r * Math.sin(eAngle);\r\n        if (this.xy) {\r\n            this.xy[0] = endX;\r\n            this.xy[1] = endY;\r\n        }\r\n        else {\r\n            this.xy = [endX, endY];\r\n        }\r\n        this.commands.push(Command.Arc);\r\n        this.params.push(x, y, r, sAngle, eAngle, antiClockwise ? 1 : 0);\r\n    }\r\n    cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\r\n        if (!this.xy) {\r\n            this.moveTo(cx1, cy1);\r\n        }\r\n        this.commands.push(Command.Curve);\r\n        this.params.push(cx1, cy1, cx2, cy2, x, y);\r\n        if (this.xy) {\r\n            this.xy[0] = x;\r\n            this.xy[1] = y;\r\n        }\r\n    }\r\n    get closedPath() {\r\n        return this._closedPath;\r\n    }\r\n    closePath() {\r\n        if (this.xy) {\r\n            this.xy = undefined;\r\n            this.commands.push(Command.ClosePath);\r\n            this._closedPath = true;\r\n        }\r\n    }\r\n    clear({ trackChanges } = { trackChanges: false }) {\r\n        if (trackChanges) {\r\n            this.previousCommands = this.commands;\r\n            this.previousParams = this.params;\r\n            this.previousClosedPath = this._closedPath;\r\n            this.commands = [];\r\n            this.params = [];\r\n        }\r\n        else {\r\n            this.commands.length = 0;\r\n            this.params.length = 0;\r\n        }\r\n        this.xy = undefined;\r\n        this._closedPath = false;\r\n    }\r\n    isPointInPath(x, y) {\r\n        const commands = this.commands;\r\n        const params = this.params;\r\n        const cn = commands.length;\r\n        // Hit testing using ray casting method, where the ray's origin is some point\r\n        // outside the path. In this case, an offscreen point that is remote enough, so that\r\n        // even if the path itself is large and is partially offscreen, the ray's origin\r\n        // will likely be outside the path anyway. To test if the given point is inside the\r\n        // path or not, we cast a ray from the origin to the given point and check the number\r\n        // of intersections of this segment with the path. If the number of intersections is\r\n        // even, then the ray both entered and exited the path an equal number of times,\r\n        // therefore the point is outside the path, and inside the path, if the number of\r\n        // intersections is odd. Since the path is compound, we check if the ray segment\r\n        // intersects with each of the path's segments, which can be either a line segment\r\n        // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\r\n        // points).\r\n        const ox = -10000;\r\n        const oy = -10000;\r\n        // the starting point of the  current path\r\n        let sx = NaN;\r\n        let sy = NaN;\r\n        // the previous point of the current path\r\n        let px = 0;\r\n        let py = 0;\r\n        let intersectionCount = 0;\r\n        for (let ci = 0, pi = 0; ci < cn; ci++) {\r\n            switch (commands[ci]) {\r\n                case Command.Move:\r\n                    if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\r\n                        intersectionCount++;\r\n                    }\r\n                    px = params[pi++];\r\n                    sx = px;\r\n                    py = params[pi++];\r\n                    sy = py;\r\n                    break;\r\n                case Command.Line:\r\n                    if (segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y)) {\r\n                        intersectionCount++;\r\n                    }\r\n                    px = params[pi - 2];\r\n                    py = params[pi - 1];\r\n                    break;\r\n                case Command.Curve:\r\n                    intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], ox, oy, x, y).length;\r\n                    px = params[pi - 2];\r\n                    py = params[pi - 1];\r\n                    break;\r\n                case Command.Arc:\r\n                    const cx = params[pi++];\r\n                    const cy = params[pi++];\r\n                    const r = params[pi++];\r\n                    const startAngle = params[pi++];\r\n                    const endAngle = params[pi++];\r\n                    const counterClockwise = Boolean(params[pi++]);\r\n                    intersectionCount += arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, ox, oy, x, y).length;\r\n                    px = cx + Math.cos(endAngle) * r;\r\n                    py = cy + Math.sin(endAngle) * r;\r\n                    break;\r\n                case Command.ClosePath:\r\n                    if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\r\n                        intersectionCount++;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        return intersectionCount % 2 === 1;\r\n    }\r\n    getPoints() {\r\n        const { commands, params } = this;\r\n        const coords = [];\r\n        let pi = 0;\r\n        for (let ci = 0; ci < commands.length; ci++) {\r\n            switch (commands[ci]) {\r\n                case Command.Move:\r\n                case Command.Line:\r\n                    coords.push({ x: params[pi++], y: params[pi++] });\r\n                    break;\r\n                case Command.Curve:\r\n                    pi += 4;\r\n                    coords.push({ x: params[pi++], y: params[pi++] });\r\n                    break;\r\n                case Command.Arc:\r\n                    coords.push({ x: params[pi++], y: params[pi++] });\r\n                    pi += 4;\r\n                    break;\r\n                case Command.ClosePath:\r\n                    break;\r\n            }\r\n        }\r\n        return coords;\r\n    }\r\n}\n\nfunction ScenePathChangeDetection(opts) {\r\n    const { redraw = RedrawType.MAJOR, changeCb, convertor } = opts !== null && opts !== void 0 ? opts : {};\r\n    return SceneChangeDetection({ redraw, type: 'path', convertor, changeCb });\r\n}\r\nclass Path extends Shape {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Declare a path to retain for later rendering and hit testing\r\n         * using custom Path2D class. Think of it as a TypeScript version\r\n         * of the native Path2D (with some differences) that works in all browsers.\r\n         */\r\n        this.path = new Path2D();\r\n        this.clipScalingX = 1;\r\n        this.clipScalingY = 1;\r\n        /**\r\n         * The path only has to be updated when certain attributes change.\r\n         * For example, if transform attributes (such as `translationX`)\r\n         * are changed, we don't have to update the path. The `dirtyPath` flag\r\n         * is how we keep track if the path has to be updated or not.\r\n         */\r\n        this._dirtyPath = true;\r\n    }\r\n    set dirtyPath(value) {\r\n        if (this._dirtyPath !== value) {\r\n            this._dirtyPath = value;\r\n            if (value) {\r\n                this.markDirty(this, RedrawType.MAJOR);\r\n            }\r\n        }\r\n    }\r\n    get dirtyPath() {\r\n        return this._dirtyPath;\r\n    }\r\n    checkPathDirty() {\r\n        var _a, _b, _c, _d;\r\n        if (this._dirtyPath) {\r\n            return;\r\n        }\r\n        this.dirtyPath =\r\n            this.path.isDirty() || ((_b = (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.isDirty()) !== null && _b !== void 0 ? _b : false) || ((_d = (_c = this.clipPath) === null || _c === void 0 ? void 0 : _c.isDirty()) !== null && _d !== void 0 ? _d : false);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\r\n    }\r\n    isDirtyPath() {\r\n        // Override point for more expensive dirty checks.\r\n        return false;\r\n    }\r\n    updatePath() {\r\n        // Override point for subclasses.\r\n    }\r\n    clip(ctx, op) {\r\n        const transform = ctx.getTransform();\r\n        const clipScale = this.clipScalingX !== 1 || this.clipScalingY !== 1;\r\n        if (clipScale) {\r\n            ctx.scale(this.clipScalingX, this.clipScalingY);\r\n        }\r\n        op();\r\n        if (clipScale) {\r\n            ctx.setTransform(transform);\r\n        }\r\n    }\r\n    render(renderCtx) {\r\n        var _a;\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        if (this.dirtyPath || this.isDirtyPath()) {\r\n            this.updatePath();\r\n            this.dirtyPath = false;\r\n        }\r\n        if (this.clipPath && this.clipMode != null) {\r\n            ctx.save();\r\n            if (this.clipMode === 'normal') {\r\n                this.clip(ctx, () => {\r\n                    var _a;\r\n                    // Bound the shape rendered to the clipping path.\r\n                    (_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.draw(ctx);\r\n                    ctx.clip();\r\n                });\r\n            }\r\n            if (this.clipScalingX > 0 && this.clipScalingY > 0) {\r\n                this.path.draw(ctx);\r\n                this.fillStroke(ctx);\r\n            }\r\n            if (this.clipMode === 'punch-out') {\r\n                this.clip(ctx, () => {\r\n                    var _a, _b;\r\n                    // Bound the shape rendered to the clipping path.\r\n                    (_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.draw(ctx);\r\n                    ctx.clip();\r\n                    // Fallback values, but practically these should never be used.\r\n                    const { x = -10000, y = -10000, width = 20000, height = 20000 } = (_b = this.computeBBox()) !== null && _b !== void 0 ? _b : {};\r\n                    ctx.clearRect(x, y, width, height);\r\n                });\r\n            }\r\n            ctx.restore();\r\n        }\r\n        else {\r\n            this.path.draw(ctx);\r\n            this.fillStroke(ctx);\r\n        }\r\n        (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nPath.className = 'Path';\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Path2D)\r\n], Path.prototype, \"clipPath\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Path.prototype, \"clipMode\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Object)\r\n], Path.prototype, \"clipScalingX\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Object)\r\n], Path.prototype, \"clipScalingY\", void 0);\n\nclass Sector extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.centerX = 0;\r\n        this.centerY = 0;\r\n        this.innerRadius = 10;\r\n        this.outerRadius = 20;\r\n        this.startAngle = 0;\r\n        this.endAngle = Math.PI * 2;\r\n        this.angleOffset = 0;\r\n        this.inset = 0;\r\n    }\r\n    computeBBox() {\r\n        const radius = this.outerRadius;\r\n        return new BBox(this.centerX - radius, this.centerY - radius, radius * 2, radius * 2);\r\n    }\r\n    updatePath() {\r\n        const path = this.path;\r\n        const { angleOffset, inset } = this;\r\n        const startAngle = this.startAngle + angleOffset;\r\n        const endAngle = this.endAngle + angleOffset;\r\n        const fullPie = Math.abs(this.endAngle - this.startAngle) >= 2 * Math.PI;\r\n        const centerX = this.centerX;\r\n        const centerY = this.centerY;\r\n        path.clear();\r\n        if (fullPie) {\r\n            const baseInnerRadius = this.innerRadius <= 0 ? 0 : this.innerRadius + inset;\r\n            const innerRadius = Math.min(baseInnerRadius, this.outerRadius - inset);\r\n            const outerRadius = Math.max(baseInnerRadius, this.outerRadius - inset);\r\n            path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\r\n            if (innerRadius > 0) {\r\n                path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\r\n                path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\r\n            }\r\n        }\r\n        else {\r\n            const innerRadius = Math.min(this.innerRadius + inset, this.outerRadius - inset);\r\n            const outerRadius = Math.max(this.innerRadius + inset, this.outerRadius - inset);\r\n            const innerAngleOffset = innerRadius > 0 ? inset / innerRadius : 0;\r\n            const outerAngleOffset = outerRadius > 0 ? inset / outerRadius : 0;\r\n            const sweep = Math.abs(endAngle - startAngle);\r\n            const outerAngleExceeded = sweep < 2 * outerAngleOffset;\r\n            if (outerAngleExceeded)\r\n                return;\r\n            const innerAngleExceeded = innerRadius <= inset || sweep < 2 * innerAngleOffset;\r\n            if (innerAngleExceeded) {\r\n                // Draw a wedge on a cartesian co-ordinate with radius `sweep`\r\n                // Inset from bottom - i.e. y = innerRadius\r\n                // Inset the top - i.e. y = (x - x0) * tan(sweep)\r\n                // Form a right angle from the wedge with hypotenuse x0 and an opposite side of innerRadius\r\n                // Gives x0 = inset * sin(sweep)\r\n                // y = inset = (x - inset * sin(sweep)) * tan(sweep) - solve for x\r\n                // This formula has limits (i.e. sweep being >= a quarter turn),\r\n                // but the bounds for x should be [innerRadius, outerRadius)\r\n                const x = Math.abs(sweep) < Math.PI * 0.5 ? (inset * (1 + Math.cos(sweep))) / Math.sin(sweep) : NaN;\r\n                // r = sqrt(x**2 + y**2)\r\n                let r;\r\n                if (x > 0 && x < outerRadius) {\r\n                    // Even within the formula limits, floating point precision isn't always enough,\r\n                    // so ensure we never go less than the inner radius\r\n                    r = Math.max(Math.hypot(inset, x), innerRadius);\r\n                }\r\n                else {\r\n                    // Formula limits exceeded - just use the inner radius\r\n                    r = innerRadius;\r\n                }\r\n                const midAngle = (startAngle + endAngle) * 0.5;\r\n                path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\r\n            }\r\n            else {\r\n                path.moveTo(centerX + innerRadius * Math.cos(startAngle + innerAngleOffset), centerY + innerRadius * Math.sin(startAngle + innerAngleOffset));\r\n            }\r\n            path.arc(centerX, centerY, outerRadius, startAngle + outerAngleOffset, endAngle - outerAngleOffset);\r\n            if (innerAngleExceeded) ;\r\n            else if (innerRadius > 0) {\r\n                path.arc(centerX, centerY, innerRadius, endAngle - innerAngleOffset, startAngle + innerAngleOffset, true);\r\n            }\r\n            else {\r\n                path.lineTo(centerX, centerY);\r\n            }\r\n        }\r\n        path.closePath();\r\n        this.dirtyPath = false;\r\n    }\r\n    isPointInPath(x, y) {\r\n        const { angleOffset } = this;\r\n        const startAngle = this.startAngle + angleOffset;\r\n        const endAngle = this.endAngle + angleOffset;\r\n        const innerRadius = Math.min(this.innerRadius, this.outerRadius);\r\n        const outerRadius = Math.max(this.innerRadius, this.outerRadius);\r\n        const point = this.transformPoint(x, y);\r\n        return isPointInSector(point.x, point.y, { startAngle, endAngle, innerRadius, outerRadius });\r\n    }\r\n}\r\nSector.className = 'Sector';\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"centerX\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"centerY\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"innerRadius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"outerRadius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"startAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"endAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"angleOffset\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"inset\", void 0);\n\nfunction deepMerge(target, source) {\r\n    if (isPlainObject(target) && isPlainObject(source)) {\r\n        const result = {};\r\n        Object.keys(target).forEach((key) => {\r\n            if (key in source) {\r\n                result[key] = deepMerge(target[key], source[key]);\r\n            }\r\n            else {\r\n                result[key] = target[key];\r\n            }\r\n        });\r\n        Object.keys(source).forEach((key) => {\r\n            if (!(key in target)) {\r\n                result[key] = source[key];\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    if ((Array.isArray(target) && !Array.isArray(source)) || (isObjectLike(target) && !isObjectLike(source))) {\r\n        return target;\r\n    }\r\n    return source;\r\n}\r\nfunction isObjectLike(value) {\r\n    return typeof value === 'object' && value !== null;\r\n}\r\nfunction isObject(value) {\r\n    return isObjectLike(value) && !Array.isArray(value);\r\n}\r\nfunction isPlainObject(x) {\r\n    return isObject(x) && x.constructor === Object;\r\n}\r\nfunction mergeDefaults(...sources) {\r\n    var _a;\r\n    const target = {};\r\n    for (const source of sources) {\r\n        if (!source)\r\n            continue;\r\n        const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\r\n        for (const key of keys) {\r\n            if (isObject(target[key]) && isObject(source[key])) {\r\n                target[key] = mergeDefaults(target[key], source[key]);\r\n            }\r\n            else {\r\n                (_a = target[key]) !== null && _a !== void 0 ? _a : (target[key] = source[key]);\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\r\n// Similar to Object.assign, but only copy an explicit set of keys.\r\nfunction partialAssign(keysToCopy, target, source) {\r\n    if (source === undefined) {\r\n        return target;\r\n    }\r\n    for (const key of keysToCopy) {\r\n        const value = source[key];\r\n        if (value !== undefined) {\r\n            target[key] = value;\r\n        }\r\n    }\r\n    return target;\r\n}\n\nlet element = null;\r\nfunction sanitizeHtml(text) {\r\n    if (text == null) {\r\n        return undefined;\r\n    }\r\n    else if (text === '') {\r\n        return '';\r\n    }\r\n    element !== null && element !== void 0 ? element : (element = document.createElement('div'));\r\n    element.textContent = String(text);\r\n    return element.innerHTML;\r\n}\n\nconst isString = (v) => typeof v === 'string';\r\nconst isStringObject = (v) => !!v && Object.prototype.hasOwnProperty.call(v, 'toString') && isString(v.toString());\r\nconst isDate = (v) => v instanceof Date && !isNaN(+v);\r\nfunction isDiscrete(value) {\r\n    return isString(value) || isStringObject(value);\r\n}\r\nfunction isContinuous(value) {\r\n    const isNumberObject = (v) => !!v && Object.prototype.hasOwnProperty.call(v, 'valueOf') && isNumber(v.valueOf());\r\n    const isDate = (v) => v instanceof Date && !isNaN(+v);\r\n    return isNumber(value) || isNumberObject(value) || isDate(value);\r\n}\r\nfunction checkDatum(value, isContinuousScale) {\r\n    if (isContinuousScale && isContinuous(value)) {\r\n        return value;\r\n    }\r\n    else if (!isContinuousScale) {\r\n        if (!isDiscrete(value)) {\r\n            return String(value);\r\n        }\r\n        return value;\r\n    }\r\n    return undefined;\r\n}\r\nconst isNumber = (v) => typeof v === 'number' && Number.isFinite(v);\n\nconst memorizedFns = new Map();\r\nfunction memo(params, fnGenerator) {\r\n    var _a, _b, _c;\r\n    const serialisedParams = JSON.stringify(params, null, 0);\r\n    if (!memorizedFns.has(fnGenerator)) {\r\n        memorizedFns.set(fnGenerator, new Map());\r\n    }\r\n    if (!((_a = memorizedFns.get(fnGenerator)) === null || _a === void 0 ? void 0 : _a.has(serialisedParams))) {\r\n        (_b = memorizedFns.get(fnGenerator)) === null || _b === void 0 ? void 0 : _b.set(serialisedParams, fnGenerator(params));\r\n    }\r\n    return (_c = memorizedFns.get(fnGenerator)) === null || _c === void 0 ? void 0 : _c.get(serialisedParams);\r\n}\n\nconst SMALLEST_KEY_INTERVAL = {\r\n    type: 'reducer',\r\n    property: 'smallestKeyInterval',\r\n    initialValue: Infinity,\r\n    reducer: () => {\r\n        let prevX = NaN;\r\n        return (smallestSoFar = Infinity, next) => {\r\n            const nextX = next.keys[0];\r\n            const interval = Math.abs(nextX - prevX);\r\n            prevX = nextX;\r\n            if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\r\n                return interval;\r\n            }\r\n            return smallestSoFar;\r\n        };\r\n    },\r\n};\r\nconst AGG_VALUES_EXTENT = {\r\n    type: 'processor',\r\n    property: 'aggValuesExtent',\r\n    calculate: (processedData) => {\r\n        var _a, _b, _c, _d;\r\n        const result = [...((_b = (_a = processedData.domain.aggValues) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : [0, 0])];\r\n        for (const [min, max] of (_d = (_c = processedData.domain.aggValues) === null || _c === void 0 ? void 0 : _c.slice(1)) !== null && _d !== void 0 ? _d : []) {\r\n            if (min < result[0]) {\r\n                result[0] = min;\r\n            }\r\n            if (max > result[1]) {\r\n                result[1] = max;\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n};\r\nconst SORT_DOMAIN_GROUPS = {\r\n    type: 'processor',\r\n    property: 'sortedGroupDomain',\r\n    calculate: ({ domain: { groups } }) => {\r\n        if (groups == null)\r\n            return undefined;\r\n        return [...groups].sort((a, b) => {\r\n            for (let i = 0; i < a.length; i++) {\r\n                const result = a[i] - b[i];\r\n                if (result !== 0) {\r\n                    return result;\r\n                }\r\n            }\r\n            return 0;\r\n        });\r\n    },\r\n};\r\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\r\n    const normalise = (val, extent) => {\r\n        const result = (val * normaliseTo) / extent;\r\n        if (result >= 0) {\r\n            return Math.min(normaliseTo, result);\r\n        }\r\n        return Math.max(-normaliseTo, result);\r\n    };\r\n    return () => () => (values, valueIndexes) => {\r\n        const valuesExtent = [0, 0];\r\n        for (const valueIdx of valueIndexes) {\r\n            const value = values[valueIdx];\r\n            const valIdx = value < 0 ? 0 : 1;\r\n            if (mode === 'sum') {\r\n                valuesExtent[valIdx] += value;\r\n            }\r\n            else if (valIdx === 0) {\r\n                valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], value);\r\n            }\r\n            else {\r\n                valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], value);\r\n            }\r\n        }\r\n        const extent = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\r\n        for (const valueIdx of valueIndexes) {\r\n            values[valueIdx] = normalise(values[valueIdx], extent);\r\n        }\r\n    };\r\n}\r\nfunction normaliseGroupTo(scope, matchGroupIds, normaliseTo, mode = 'sum') {\r\n    return {\r\n        scopes: [scope.id],\r\n        type: 'group-value-processor',\r\n        matchGroupIds,\r\n        adjust: memo({ normaliseTo, mode }, normaliseFnBuilder),\r\n    };\r\n}\r\nfunction normalisePropertyFnBuilder({ normaliseTo, zeroDomain, rangeMin, rangeMax, }) {\r\n    const normaliseSpan = normaliseTo[1] - normaliseTo[0];\r\n    const normalise = (val, start, span) => {\r\n        const result = normaliseTo[0] + ((val - start) / span) * normaliseSpan;\r\n        if (span === 0)\r\n            return zeroDomain;\r\n        if (result >= normaliseTo[1])\r\n            return normaliseTo[1];\r\n        if (result < normaliseTo[0])\r\n            return normaliseTo[0];\r\n        return result;\r\n    };\r\n    return () => (pData, pIdx) => {\r\n        let [start, end] = pData.domain.values[pIdx];\r\n        if (rangeMin != null)\r\n            start = rangeMin;\r\n        if (rangeMax != null)\r\n            end = rangeMax;\r\n        const span = end - start;\r\n        pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\r\n        for (const group of pData.data) {\r\n            let groupValues = group.values;\r\n            if (pData.type === 'ungrouped') {\r\n                groupValues = [groupValues];\r\n            }\r\n            for (const values of groupValues) {\r\n                values[pIdx] = normalise(values[pIdx], start, span);\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction normalisePropertyTo(scope, property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\r\n    return {\r\n        scopes: [scope.id],\r\n        type: 'property-value-processor',\r\n        property,\r\n        adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder),\r\n    };\r\n}\r\nfunction animationValidation(scope, valueKeyIds = []) {\r\n    return {\r\n        type: 'processor',\r\n        scopes: [scope.id],\r\n        property: 'animationValidation',\r\n        calculate(result) {\r\n            var _a;\r\n            const { keys, values } = result.defs;\r\n            const { input, data } = result;\r\n            let uniqueKeys = true;\r\n            let orderedKeys = true;\r\n            const valueKeys = [];\r\n            for (let k = 0; k < values.length; k++) {\r\n                if (!((_a = values[k].scopes) === null || _a === void 0 ? void 0 : _a.some((s) => s === scope.id)))\r\n                    continue;\r\n                if (!valueKeyIds.some((v) => values[k].id === v))\r\n                    continue;\r\n                valueKeys.push([k, values[k]]);\r\n            }\r\n            const processKey = (idx, def, type) => {\r\n                var _a;\r\n                if (def.valueType === 'category') {\r\n                    const keyValues = result.domain[type][idx];\r\n                    uniqueKeys && (uniqueKeys = keyValues.length === input.count);\r\n                    return;\r\n                }\r\n                let lastValue = (_a = data[0]) === null || _a === void 0 ? void 0 : _a[type][idx];\r\n                for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\r\n                    const keyValue = data[d][type][idx];\r\n                    orderedKeys && (orderedKeys = lastValue <= keyValue);\r\n                    uniqueKeys && (uniqueKeys = lastValue !== keyValue);\r\n                    lastValue = keyValue;\r\n                }\r\n            };\r\n            for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\r\n                processKey(k, keys[k], 'keys');\r\n            }\r\n            for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\r\n                const [idx, key] = valueKeys[k];\r\n                processKey(idx, key, 'values');\r\n            }\r\n            return { uniqueKeys, orderedKeys };\r\n        },\r\n    };\r\n}\r\nfunction buildGroupAccFn({ mode, separateNegative }) {\r\n    return () => () => (values, valueIndexes) => {\r\n        // Datum scope.\r\n        const acc = [0, 0];\r\n        for (const valueIdx of valueIndexes) {\r\n            const currentVal = values[valueIdx];\r\n            const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\r\n            if (typeof currentVal !== 'number' || isNaN(currentVal))\r\n                continue;\r\n            if (mode === 'normal')\r\n                acc[accIndex] += currentVal;\r\n            values[valueIdx] = acc[accIndex];\r\n            if (mode === 'trailing')\r\n                acc[accIndex] += currentVal;\r\n        }\r\n    };\r\n}\r\nfunction buildGroupWindowAccFn({ mode, sum }) {\r\n    return () => {\r\n        // Entire data-set scope.\r\n        const lastValues = [];\r\n        let firstRow = true;\r\n        return () => {\r\n            // Group scope.\r\n            return (values, valueIndexes) => {\r\n                // Datum scope.\r\n                let acc = 0;\r\n                for (const valueIdx of valueIndexes) {\r\n                    const currentVal = values[valueIdx];\r\n                    const lastValue = firstRow && sum === 'current' ? 0 : lastValues[valueIdx];\r\n                    lastValues[valueIdx] = currentVal;\r\n                    const sumValue = sum === 'current' ? currentVal : lastValue;\r\n                    if (typeof currentVal !== 'number' || isNaN(currentVal)) {\r\n                        values[valueIdx] = acc;\r\n                        continue;\r\n                    }\r\n                    if (typeof lastValue !== 'number' || isNaN(lastValue)) {\r\n                        values[valueIdx] = acc;\r\n                        continue;\r\n                    }\r\n                    if (mode === 'normal')\r\n                        acc += sumValue;\r\n                    values[valueIdx] = acc;\r\n                    if (mode === 'trailing')\r\n                        acc += sumValue;\r\n                }\r\n                firstRow = false;\r\n            };\r\n        };\r\n    };\r\n}\r\nfunction accumulateGroup(scope, matchGroupId, mode, sum, separateNegative = false) {\r\n    let adjust;\r\n    if (mode.startsWith('window')) {\r\n        const modeParam = mode.endsWith('-trailing') ? 'trailing' : 'normal';\r\n        adjust = memo({ mode: modeParam, sum }, buildGroupWindowAccFn);\r\n    }\r\n    else {\r\n        adjust = memo({ mode: mode, separateNegative }, buildGroupAccFn);\r\n    }\r\n    return {\r\n        scopes: [scope.id],\r\n        type: 'group-value-processor',\r\n        matchGroupIds: [matchGroupId],\r\n        adjust,\r\n    };\r\n}\r\nfunction diff(previousData, updateMovedDatums = true) {\r\n    return {\r\n        type: 'processor',\r\n        property: 'diff',\r\n        calculate: (processedData) => {\r\n            const diff = {\r\n                changed: false,\r\n                moved: [],\r\n                added: [],\r\n                updated: [],\r\n                removed: [],\r\n                addedIndices: [],\r\n                updatedIndices: [],\r\n                removedIndices: [],\r\n            };\r\n            const moved = new Map();\r\n            const added = new Map();\r\n            const updated = new Map();\r\n            const removed = new Map();\r\n            const addedIndices = new Map();\r\n            const updatedIndices = new Map();\r\n            const removedIndices = new Map();\r\n            for (let i = 0; i < Math.max(previousData.data.length, processedData.data.length); i++) {\r\n                const prev = previousData.data[i];\r\n                const datum = processedData.data[i];\r\n                const prevId = prev ? createDatumId(prev.keys) : '';\r\n                const datumId = datum ? createDatumId(datum.keys) : '';\r\n                if (prevId === datumId) {\r\n                    if (!arraysEqual(prev.values, datum.values)) {\r\n                        updated.set(datumId, datum);\r\n                        updatedIndices.set(datumId, i);\r\n                    }\r\n                    continue;\r\n                }\r\n                if (removed.has(datumId)) {\r\n                    if (updateMovedDatums || !arraysEqual(removed.get(datumId).values, datum.values)) {\r\n                        updated.set(datumId, datum);\r\n                        updatedIndices.set(datumId, i);\r\n                        moved.set(datumId, datum);\r\n                    }\r\n                    removed.delete(datumId);\r\n                    removedIndices.delete(datumId);\r\n                }\r\n                else if (datum) {\r\n                    added.set(datumId, datum);\r\n                    addedIndices.set(datumId, i);\r\n                }\r\n                if (added.has(prevId)) {\r\n                    if (updateMovedDatums || !arraysEqual(added.get(prevId).values, prev.values)) {\r\n                        updated.set(prevId, prev);\r\n                        updatedIndices.set(prevId, i);\r\n                        moved.set(prevId, prev);\r\n                    }\r\n                    added.delete(prevId);\r\n                    addedIndices.delete(prevId);\r\n                }\r\n                else if (prev) {\r\n                    updated.delete(prevId);\r\n                    updatedIndices.delete(prevId);\r\n                    removed.set(prevId, prev);\r\n                    removedIndices.set(prevId, i);\r\n                }\r\n            }\r\n            diff.added = Array.from(added.keys());\r\n            diff.updated = Array.from(updated.keys());\r\n            diff.removed = Array.from(removed.keys());\r\n            diff.moved = Array.from(moved.keys());\r\n            diff.addedIndices = Array.from(addedIndices.values());\r\n            diff.updatedIndices = Array.from(updatedIndices.values());\r\n            diff.removedIndices = Array.from(removedIndices.values());\r\n            diff.changed = diff.added.length > 0 || diff.updated.length > 0 || diff.removed.length > 0;\r\n            return diff;\r\n        },\r\n    };\r\n}\r\nfunction createDatumId(keys) {\r\n    return keys.join('___');\r\n}\n\nclass Label {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.color = '#464646';\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n    }\r\n    getFont() {\r\n        return getFont(this);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], Label.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], Label.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], Label.prototype, \"formatter\", void 0);\r\nfunction calculateLabelRotation(opts) {\r\n    const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\r\n    const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\r\n    const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\r\n    // Flip if the axis rotation angle is in the top hemisphere.\r\n    const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\r\n    let defaultRotation = 0;\r\n    if (opts.parallel) {\r\n        defaultRotation = (parallelFlipFlag * Math.PI) / 2;\r\n    }\r\n    else if (regularFlipFlag === -1) {\r\n        defaultRotation = Math.PI;\r\n    }\r\n    return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\r\n}\r\nfunction getLabelSpacing(minSpacing, rotated) {\r\n    if (!isNaN(minSpacing)) {\r\n        return minSpacing;\r\n    }\r\n    return rotated ? 0 : 10;\r\n}\r\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\r\n    if (parallel && !labelRotation) {\r\n        return sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom';\r\n    }\r\n    return 'middle';\r\n}\r\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\r\n    const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\r\n    const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\r\n    const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\r\n    if (parallel) {\r\n        if (labelRotation || labelAutoRotation) {\r\n            if (sideFlag * alignFlag === -1) {\r\n                return 'end';\r\n            }\r\n        }\r\n        else {\r\n            return 'center';\r\n        }\r\n    }\r\n    else if (sideFlag * regularFlipFlag === -1) {\r\n        return 'end';\r\n    }\r\n    return 'start';\r\n}\r\nfunction calculateLabelBBox(text, bbox, labelX, labelY, labelMatrix) {\r\n    // Text.computeBBox() does not take into account any of the transformations that have been applied to the label nodes, only the width and height are useful.\r\n    // Rather than taking into account all transformations including those of parent nodes which would be the result of `computeTransformedBBox()`, giving the x and y in the entire axis coordinate space,\r\n    // take into account only the rotation and translation applied to individual label nodes to get the x y coordinates of the labels relative to each other\r\n    // this makes label collision detection a lot simpler\r\n    const { width, height } = bbox;\r\n    const translatedBBox = new BBox(labelX, labelY, 0, 0);\r\n    labelMatrix.transformBBox(translatedBBox, bbox);\r\n    const { x = 0, y = 0 } = bbox;\r\n    bbox.width = width;\r\n    bbox.height = height;\r\n    return {\r\n        point: { x, y, size: 0 },\r\n        label: { width, height, text },\r\n    };\r\n}\n\n/**\r\n * Constants to declare the expected nominal zIndex for all types of layer in chart rendering.\r\n */\r\nvar Layers;\r\n(function (Layers) {\r\n    Layers[Layers[\"SERIES_BACKGROUND_ZINDEX\"] = -10] = \"SERIES_BACKGROUND_ZINDEX\";\r\n    Layers[Layers[\"AXIS_GRID_ZINDEX\"] = 0] = \"AXIS_GRID_ZINDEX\";\r\n    Layers[Layers[\"AXIS_ZINDEX\"] = 20] = \"AXIS_ZINDEX\";\r\n    Layers[Layers[\"SERIES_CROSSLINE_RANGE_ZINDEX\"] = 30] = \"SERIES_CROSSLINE_RANGE_ZINDEX\";\r\n    Layers[Layers[\"SERIES_LAYER_ZINDEX\"] = 500] = \"SERIES_LAYER_ZINDEX\";\r\n    Layers[Layers[\"AXIS_FOREGROUND_ZINDEX\"] = 750] = \"AXIS_FOREGROUND_ZINDEX\";\r\n    Layers[Layers[\"SERIES_CROSSHAIR_ZINDEX\"] = 1000] = \"SERIES_CROSSHAIR_ZINDEX\";\r\n    Layers[Layers[\"SERIES_LABEL_ZINDEX\"] = 1500] = \"SERIES_LABEL_ZINDEX\";\r\n    Layers[Layers[\"SERIES_CROSSLINE_LINE_ZINDEX\"] = 2500] = \"SERIES_CROSSLINE_LINE_ZINDEX\";\r\n    Layers[Layers[\"LEGEND_ZINDEX\"] = 3000] = \"LEGEND_ZINDEX\";\r\n})(Layers || (Layers = {}));\n\nclass Marker extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.size = 12;\r\n    }\r\n    computeBBox() {\r\n        const { x, y, size } = this;\r\n        const half = size / 2;\r\n        return new BBox(x - half, y - half, size, size);\r\n    }\r\n    applyPath(s, moves) {\r\n        const { path } = this;\r\n        let { x, y } = this;\r\n        path.clear();\r\n        for (const { x: mx, y: my, t } of moves) {\r\n            x += mx * s;\r\n            y += my * s;\r\n            if (t === 'move') {\r\n                path.moveTo(x, y);\r\n            }\r\n            else {\r\n                path.lineTo(x, y);\r\n            }\r\n        }\r\n        path.closePath();\r\n    }\r\n}\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Marker.prototype, \"x\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Marker.prototype, \"y\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection({ convertor: Math.abs }),\r\n    __metadata(\"design:type\", Number)\r\n], Marker.prototype, \"size\", void 0);\n\nclass Circle extends Marker {\r\n    updatePath() {\r\n        const { x, y, path, size } = this;\r\n        const r = size / 2;\r\n        path.clear();\r\n        path.arc(x, y, r, 0, Math.PI * 2);\r\n        path.closePath();\r\n    }\r\n}\r\nCircle.className = 'Circle';\n\nconst DEFAULT_FILLS = {\r\n    BLUE: '#5090dc',\r\n    ORANGE: '#ffa03a',\r\n    GREEN: '#459d55',\r\n    CYAN: '#34bfe1',\r\n    YELLOW: '#e1cc00',\r\n    VIOLET: '#9669cb',\r\n    GRAY: '#b5b5b5',\r\n    MAGENTA: '#bd5aa7',\r\n    BROWN: '#8a6224',\r\n    RED: '#ef5452',\r\n};\r\nconst DEFAULT_STROKES = {\r\n    BLUE: '#2b5c95',\r\n    ORANGE: '#cc6f10',\r\n    GREEN: '#1e652e',\r\n    CYAN: '#18859e',\r\n    YELLOW: '#a69400',\r\n    VIOLET: '#603c88',\r\n    GRAY: '#575757',\r\n    MAGENTA: '#7d2f6d',\r\n    BROWN: '#4f3508',\r\n    RED: '#a82529',\r\n};\n\nclass ModuleMap {\r\n    constructor(parent) {\r\n        this.modules = {};\r\n        this.parent = parent;\r\n    }\r\n    destroy() {\r\n        for (const [key, module] of Object.entries(this.modules)) {\r\n            module.instance.destroy();\r\n            delete this.modules[key];\r\n            delete this.parent[key];\r\n        }\r\n    }\r\n    addModule(module) {\r\n        if (this.modules[module.optionsKey] != null) {\r\n            throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\r\n        }\r\n        if (module.optionsKey in this.parent) {\r\n            throw new Error(`AG Charts - class already has option key '${module.optionsKey}'`);\r\n        }\r\n        if (this.moduleContext == null) {\r\n            this.moduleContext = this.parent.createModuleContext();\r\n        }\r\n        const moduleInstance = new module.instanceConstructor(Object.assign({}, this.moduleContext));\r\n        this.modules[module.optionsKey] = { instance: moduleInstance };\r\n        this.parent[module.optionsKey] = moduleInstance;\r\n    }\r\n    removeModule(module) {\r\n        var _a, _b;\r\n        (_b = (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b.destroy();\r\n        delete this.modules[module.optionsKey];\r\n        delete this.parent[module.optionsKey];\r\n    }\r\n    isModuleEnabled(module) {\r\n        return this.modules[module.optionsKey] != null;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        for (const { instance } of Object.values(this.modules)) {\r\n            yield instance;\r\n        }\r\n    }\r\n}\n\nclass Listeners {\r\n    constructor() {\r\n        this.registeredListeners = new Map();\r\n    }\r\n    addListener(eventType, handler, meta) {\r\n        const record = { symbol: Symbol(eventType), handler, meta };\r\n        if (this.registeredListeners.has(eventType)) {\r\n            this.registeredListeners.get(eventType).push(record);\r\n        }\r\n        else {\r\n            this.registeredListeners.set(eventType, [record]);\r\n        }\r\n        return () => this.removeListener(record.symbol);\r\n    }\r\n    removeListener(eventSymbol) {\r\n        for (const [type, listeners] of this.registeredListeners.entries()) {\r\n            const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\r\n            if (matchIndex >= 0) {\r\n                listeners.splice(matchIndex, 1);\r\n                if (listeners.length === 0) {\r\n                    this.registeredListeners.delete(type);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    dispatch(eventType, ...params) {\r\n        // This is a utility class to store all the results of Listeners (or do nothing\r\n        // if R = void).\r\n        class ResultArray {\r\n            constructor() {\r\n                this.results = undefined;\r\n            }\r\n            push(result) {\r\n                var _a;\r\n                if (result === undefined)\r\n                    return;\r\n                (_a = this.results) !== null && _a !== void 0 ? _a : (this.results = []);\r\n                this.results.push(result);\r\n            }\r\n        }\r\n        const results = new ResultArray();\r\n        for (const listener of this.getListenersByType(eventType)) {\r\n            try {\r\n                results.push(listener.handler(...params));\r\n            }\r\n            catch (e) {\r\n                Logger.errorOnce(e);\r\n            }\r\n        }\r\n        return results.results;\r\n    }\r\n    dispatchWrapHandlers(eventType, wrapFn, ...params) {\r\n        for (const listener of this.getListenersByType(eventType)) {\r\n            try {\r\n                wrapFn(listener.handler, listener.meta, ...params);\r\n            }\r\n            catch (e) {\r\n                Logger.errorOnce(e);\r\n            }\r\n        }\r\n    }\r\n    getListenersByType(eventType) {\r\n        var _a;\r\n        return (_a = this.registeredListeners.get(eventType)) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n}\n\nclass Observable {\r\n    constructor() {\r\n        this.eventListeners = new Map();\r\n    }\r\n    addEventListener(eventType, listener) {\r\n        if (typeof listener !== 'function') {\r\n            throw new Error('AG Charts - listener must be a Function');\r\n        }\r\n        const eventTypeListeners = this.eventListeners.get(eventType);\r\n        if (eventTypeListeners) {\r\n            eventTypeListeners.add(listener);\r\n        }\r\n        else {\r\n            this.eventListeners.set(eventType, new Set([listener]));\r\n        }\r\n    }\r\n    removeEventListener(type, listener) {\r\n        var _a;\r\n        (_a = this.eventListeners.get(type)) === null || _a === void 0 ? void 0 : _a.delete(listener);\r\n        if (this.eventListeners.size === 0) {\r\n            this.eventListeners.delete(type);\r\n        }\r\n    }\r\n    hasEventListener(type) {\r\n        return this.eventListeners.has(type);\r\n    }\r\n    clearEventListeners() {\r\n        this.eventListeners.clear();\r\n    }\r\n    fireEvent(event) {\r\n        var _a;\r\n        (_a = this.eventListeners.get(event.type)) === null || _a === void 0 ? void 0 : _a.forEach((listener) => listener(event));\r\n    }\r\n}\n\nfunction extendDomain(values, domain = [Infinity, -Infinity]) {\r\n    for (const value of values) {\r\n        if (typeof value !== 'number') {\r\n            continue;\r\n        }\r\n        if (value < domain[0]) {\r\n            domain[0] = value;\r\n        }\r\n        if (value > domain[1]) {\r\n            domain[1] = value;\r\n        }\r\n    }\r\n    return domain;\r\n}\n\nfunction sumValues(values, accumulator = [0, 0]) {\r\n    for (const value of values) {\r\n        if (typeof value !== 'number') {\r\n            continue;\r\n        }\r\n        if (value < 0) {\r\n            accumulator[0] += value;\r\n        }\r\n        if (value > 0) {\r\n            accumulator[1] += value;\r\n        }\r\n    }\r\n    return accumulator;\r\n}\r\nfunction sum(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: [matchGroupId],\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => sumValues(values),\r\n    };\r\n    return result;\r\n}\r\nfunction groupSum(scope, id, matchGroupId) {\r\n    return {\r\n        id,\r\n        scopes: [scope.id],\r\n        type: 'aggregate',\r\n        matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\r\n        aggregateFunction: (values) => sumValues(values),\r\n        groupAggregateFunction: (next, acc = [0, 0]) => {\r\n            var _a, _b;\r\n            acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\r\n            acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\r\n            return acc;\r\n        },\r\n    };\r\n}\r\nfunction range(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: [matchGroupId],\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => extendDomain(values),\r\n    };\r\n    return result;\r\n}\r\nfunction count(scope, id) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        type: 'aggregate',\r\n        aggregateFunction: () => [0, 1],\r\n    };\r\n    return result;\r\n}\r\nfunction groupCount(scope, id) {\r\n    return {\r\n        id,\r\n        scopes: [scope.id],\r\n        type: 'aggregate',\r\n        aggregateFunction: () => [0, 1],\r\n        groupAggregateFunction: (next, acc = [0, 0]) => {\r\n            var _a, _b;\r\n            acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\r\n            acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\r\n            return acc;\r\n        },\r\n    };\r\n}\r\nfunction average(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: [matchGroupId],\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => sumValues(values).map((v) => v / values.length),\r\n    };\r\n    return result;\r\n}\r\nfunction groupAverage(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => sumValues(values),\r\n        groupAggregateFunction: (next, acc = [0, 0, -1]) => {\r\n            var _a, _b;\r\n            acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\r\n            acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\r\n            acc[2]++;\r\n            return acc;\r\n        },\r\n        finalFunction: (acc = [0, 0, 0]) => {\r\n            const result = acc[0] + acc[1];\r\n            if (result >= 0) {\r\n                return [0, result / acc[2]];\r\n            }\r\n            return [result / acc[2], 0];\r\n        },\r\n    };\r\n    return result;\r\n}\r\nfunction area(scope, id, aggFn, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\r\n        type: 'aggregate',\r\n        aggregateFunction: (values, keyRange = []) => {\r\n            const keyWidth = keyRange[1] - keyRange[0];\r\n            return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\r\n        },\r\n    };\r\n    if (aggFn.groupAggregateFunction) {\r\n        result.groupAggregateFunction = aggFn.groupAggregateFunction;\r\n    }\r\n    return result;\r\n}\r\nfunction accumulatedValue(onlyPositive) {\r\n    return () => {\r\n        let value = 0;\r\n        return (datum) => {\r\n            if (typeof datum !== 'number')\r\n                return datum;\r\n            if (isNaN(datum))\r\n                return datum;\r\n            value += onlyPositive ? Math.max(0, datum) : datum;\r\n            return value;\r\n        };\r\n    };\r\n}\r\nfunction trailingAccumulatedValue() {\r\n    return () => {\r\n        let value = 0;\r\n        return (datum) => {\r\n            if (typeof datum !== 'number')\r\n                return datum;\r\n            if (isNaN(datum))\r\n                return datum;\r\n            const trailingValue = value;\r\n            value += datum;\r\n            return trailingValue;\r\n        };\r\n    };\r\n}\n\n/** Modes of matching user interactions to rendered nodes (e.g. hover or click) */\r\nvar SeriesNodePickMode;\r\n(function (SeriesNodePickMode) {\r\n    /** Pick matches based upon pick coordinates being inside a matching shape/marker. */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\r\n    /** Pick matches by nearest category/X-axis value, then distance within that category/X-value. */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_BY_MAIN_AXIS_FIRST\"] = 1] = \"NEAREST_BY_MAIN_AXIS_FIRST\";\r\n    /** Pick matches by nearest category value, then distance within that category. */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\"] = 2] = \"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\";\r\n    /** Pick matches based upon distance to ideal position */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_NODE\"] = 3] = \"NEAREST_NODE\";\r\n})(SeriesNodePickMode || (SeriesNodePickMode = {}));\r\nfunction basicContinuousCheckDatumValidation(v) {\r\n    return checkDatum(v, true) != null;\r\n}\r\nfunction basicDiscreteCheckDatumValidation(v) {\r\n    return checkDatum(v, false) != null;\r\n}\r\nfunction keyProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign({ scopes: [scope.id], property: propName, type: 'key', valueType: continuous ? 'range' : 'category', validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation }, opts);\r\n    return result;\r\n}\r\nfunction valueProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign({ scopes: [scope.id], property: propName, type: 'value', valueType: continuous ? 'range' : 'category', validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation }, opts);\r\n    return result;\r\n}\r\nfunction rangedValueProperty(scope, propName, opts = {}) {\r\n    const { min = -Infinity, max = Infinity } = opts, defOpts = __rest(opts, [\"min\", \"max\"]);\r\n    return Object.assign({ scopes: [scope.id], type: 'value', property: propName, valueType: 'range', validation: basicContinuousCheckDatumValidation, processor: () => (datum) => {\r\n            if (typeof datum !== 'number')\r\n                return datum;\r\n            if (isNaN(datum))\r\n                return datum;\r\n            return Math.min(Math.max(datum, min), max);\r\n        } }, defOpts);\r\n}\r\nfunction trailingValueProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, opts)), { processor: trailingValue() });\r\n    return result;\r\n}\r\nfunction trailingValue() {\r\n    return () => {\r\n        let value = 0;\r\n        return (datum) => {\r\n            const trailingValue = value;\r\n            value = datum;\r\n            return trailingValue;\r\n        };\r\n    };\r\n}\r\nfunction accumulativeValueProperty(scope, propName, continuous, opts = {}) {\r\n    const { onlyPositive } = opts, defOpts = __rest(opts, [\"onlyPositive\"]);\r\n    const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, defOpts)), { processor: accumulatedValue(onlyPositive) });\r\n    return result;\r\n}\r\nfunction trailingAccumulatedValueProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, opts)), { processor: trailingAccumulatedValue() });\r\n    return result;\r\n}\r\nfunction groupAccumulativeValueProperty(scope, propName, continuous, mode, sum = 'current', opts) {\r\n    return [\r\n        valueProperty(scope, propName, continuous, opts),\r\n        accumulateGroup(scope, opts.groupId, mode, sum, opts.separateNegative),\r\n    ];\r\n}\r\nclass SeriesNodeClickEvent {\r\n    constructor(type, event, { datum }, series) {\r\n        this.type = type;\r\n        this.event = event;\r\n        this.datum = datum;\r\n        this.seriesId = series.id;\r\n    }\r\n}\r\nclass SeriesItemHighlightStyle {\r\n    constructor() {\r\n        this.fill = 'yellow';\r\n        this.fillOpacity = undefined;\r\n        this.stroke = undefined;\r\n        this.strokeWidth = undefined;\r\n        this.strokeOpacity = undefined;\r\n        this.lineDash = undefined;\r\n        this.lineDashOffset = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], SeriesItemHighlightStyle.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], SeriesItemHighlightStyle.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], SeriesItemHighlightStyle.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", void 0);\r\nclass SeriesHighlightStyle {\r\n    constructor() {\r\n        this.strokeWidth = undefined;\r\n        this.dimOpacity = undefined;\r\n        this.enabled = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesHighlightStyle.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesHighlightStyle.prototype, \"dimOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], SeriesHighlightStyle.prototype, \"enabled\", void 0);\r\nclass TextHighlightStyle {\r\n    constructor() {\r\n        this.color = 'black';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], TextHighlightStyle.prototype, \"color\", void 0);\r\nclass HighlightStyle {\r\n    constructor() {\r\n        this.item = new SeriesItemHighlightStyle();\r\n        this.series = new SeriesHighlightStyle();\r\n        this.text = new TextHighlightStyle();\r\n    }\r\n}\r\nvar SeriesHighlight;\r\n(function (SeriesHighlight) {\r\n    SeriesHighlight[SeriesHighlight[\"None\"] = 0] = \"None\";\r\n    SeriesHighlight[SeriesHighlight[\"This\"] = 1] = \"This\";\r\n    SeriesHighlight[SeriesHighlight[\"Other\"] = 2] = \"Other\";\r\n})(SeriesHighlight || (SeriesHighlight = {}));\r\nclass Series extends Observable {\r\n    get type() {\r\n        var _a;\r\n        return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';\r\n    }\r\n    set data(input) {\r\n        this._data = input;\r\n        this.onDataChange();\r\n    }\r\n    get data() {\r\n        var _a;\r\n        return (_a = this._data) !== null && _a !== void 0 ? _a : this._chartData;\r\n    }\r\n    onDataChange() {\r\n        this.nodeDataRefresh = true;\r\n    }\r\n    setChartData(input) {\r\n        this._chartData = input;\r\n        if (this.data === input) {\r\n            this.onDataChange();\r\n        }\r\n    }\r\n    hasData() {\r\n        const { data } = this;\r\n        return data && (!Array.isArray(data) || data.length > 0);\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.visibleChanged();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    onSeriesGroupingChange(prev, next) {\r\n        const { id, type, visible, rootGroup, highlightGroup, annotationGroup } = this;\r\n        if (prev) {\r\n            this.ctx.seriesStateManager.deregisterSeries({ id, type });\r\n        }\r\n        if (next) {\r\n            this.ctx.seriesStateManager.registerSeries({ id, type, visible, seriesGrouping: next });\r\n        }\r\n        // Short-circuit if series isn't already attached to the scene-graph yet.\r\n        if (this.rootGroup.parent == null)\r\n            return;\r\n        this.ctx.seriesLayerManager.changeGroup({\r\n            id,\r\n            type,\r\n            rootGroup,\r\n            highlightGroup,\r\n            annotationGroup,\r\n            getGroupZIndexSubOrder: (type) => this.getGroupZIndexSubOrder(type),\r\n            seriesGrouping: next,\r\n            oldGrouping: prev,\r\n        });\r\n    }\r\n    getBandScalePadding() {\r\n        return { inner: 1, outer: 0 };\r\n    }\r\n    constructor(seriesOpts) {\r\n        super();\r\n        this.NodeClickEvent = SeriesNodeClickEvent;\r\n        this.id = createId(this);\r\n        // The group node that contains all the nodes used to render this series.\r\n        this.rootGroup = new Group({ name: 'seriesRoot', isVirtual: true });\r\n        this.axes = {\r\n            [ChartAxisDirection.X]: undefined,\r\n            [ChartAxisDirection.Y]: undefined,\r\n        };\r\n        this.directions = [ChartAxisDirection.X, ChartAxisDirection.Y];\r\n        // Flag to determine if we should recalculate node data.\r\n        this.nodeDataRefresh = true;\r\n        this._visible = true;\r\n        this.showInLegend = true;\r\n        this.cursor = 'default';\r\n        this.nodeClickRange = 'exact';\r\n        this.seriesGrouping = undefined;\r\n        this._declarationOrder = -1;\r\n        this.seriesListeners = new Listeners();\r\n        this.highlightStyle = new HighlightStyle();\r\n        this.moduleMap = new ModuleMap(this);\r\n        this.nodeDataDependencies = {};\r\n        this.ctx = seriesOpts.moduleCtx;\r\n        const { useLabelLayer = false, pickModes = [SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST], directionKeys = {}, directionNames = {}, contentGroupVirtual = true, canHaveAxes = false, } = seriesOpts;\r\n        this.directionKeys = directionKeys;\r\n        this.directionNames = directionNames;\r\n        this.canHaveAxes = canHaveAxes;\r\n        this.contentGroup = this.rootGroup.appendChild(new Group({\r\n            name: `${this.id}-content`,\r\n            layer: !contentGroupVirtual,\r\n            isVirtual: contentGroupVirtual,\r\n            zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n            zIndexSubOrder: this.getGroupZIndexSubOrder('data'),\r\n        }));\r\n        this.highlightGroup = new Group({\r\n            name: `${this.id}-highlight`,\r\n            layer: !contentGroupVirtual,\r\n            isVirtual: contentGroupVirtual,\r\n            zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n            zIndexSubOrder: this.getGroupZIndexSubOrder('highlight'),\r\n        });\r\n        this.highlightNode = this.highlightGroup.appendChild(new Group({ name: 'highlightNode', zIndex: 0 }));\r\n        this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: 'highlightLabel', zIndex: 10 }));\r\n        this.pickModes = pickModes;\r\n        this.labelGroup = this.rootGroup.appendChild(new Group({\r\n            name: `${this.id}-series-labels`,\r\n            layer: useLabelLayer,\r\n            zIndex: Layers.SERIES_LABEL_ZINDEX,\r\n        }));\r\n        this.annotationGroup = new Group({\r\n            name: `${this.id}-annotation`,\r\n            layer: !contentGroupVirtual,\r\n            isVirtual: contentGroupVirtual,\r\n            zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n            zIndexSubOrder: this.getGroupZIndexSubOrder('annotation'),\r\n        });\r\n    }\r\n    getGroupZIndexSubOrder(type, subIndex = 0) {\r\n        let mainAdjust = 0;\r\n        switch (type) {\r\n            case 'data':\r\n            case 'paths':\r\n                break;\r\n            case 'labels':\r\n                mainAdjust += 20000;\r\n                break;\r\n            case 'marker':\r\n                mainAdjust += 10000;\r\n                break;\r\n            // Following cases are in their own layer, so need to be careful to respect declarationOrder.\r\n            case 'highlight':\r\n                subIndex += 15000;\r\n                break;\r\n            case 'annotation':\r\n                mainAdjust += 15000;\r\n                break;\r\n        }\r\n        const main = () => this._declarationOrder + mainAdjust;\r\n        return [main, subIndex];\r\n    }\r\n    addListener(type, listener) {\r\n        return this.seriesListeners.addListener(type, listener);\r\n    }\r\n    dispatch(type, event) {\r\n        return this.seriesListeners.dispatch(type, event);\r\n    }\r\n    addChartEventListeners() {\r\n        return;\r\n    }\r\n    destroy() {\r\n        this.ctx.seriesStateManager.deregisterSeries(this);\r\n        this.ctx.seriesLayerManager.releaseGroup(this);\r\n    }\r\n    getDirectionValues(direction, properties) {\r\n        const resolvedDirection = this.resolveKeyDirection(direction);\r\n        const keys = properties === null || properties === void 0 ? void 0 : properties[resolvedDirection];\r\n        const values = [];\r\n        if (!keys)\r\n            return values;\r\n        const addValues = (...items) => {\r\n            for (const value of items) {\r\n                if (Array.isArray(value)) {\r\n                    addValues(...value);\r\n                }\r\n                else if (typeof value === 'object') {\r\n                    addValues(...Object.values(value));\r\n                }\r\n                else {\r\n                    values.push(value);\r\n                }\r\n            }\r\n        };\r\n        addValues(...keys.map((key) => this[key]));\r\n        return values;\r\n    }\r\n    getKeys(direction) {\r\n        return this.getDirectionValues(direction, this.directionKeys);\r\n    }\r\n    getNames(direction) {\r\n        return this.getDirectionValues(direction, this.directionNames);\r\n    }\r\n    resolveKeyDirection(direction) {\r\n        return direction;\r\n    }\r\n    // The union of the series domain ('community') and series-option domains ('enterprise').\r\n    getDomain(direction) {\r\n        var _a;\r\n        const seriesDomain = this.getSeriesDomain(direction);\r\n        const moduleDomains = (_a = this.dispatch('data-getDomain', { direction })) !== null && _a !== void 0 ? _a : [];\r\n        // Flatten the 2D moduleDomains into a 1D array and concatenate it with seriesDomain\r\n        return moduleDomains.reduce((total, current) => total.concat(current), seriesDomain);\r\n    }\r\n    // Indicate that something external changed and we should recalculate nodeData.\r\n    markNodeDataDirty() {\r\n        this.nodeDataRefresh = true;\r\n    }\r\n    visibleChanged() {\r\n        this.ctx.seriesStateManager.registerSeries(this);\r\n    }\r\n    getOpacity() {\r\n        const defaultOpacity = 1;\r\n        const { dimOpacity = 1, enabled = true } = this.highlightStyle.series;\r\n        if (!enabled || dimOpacity === defaultOpacity) {\r\n            return defaultOpacity;\r\n        }\r\n        switch (this.isItemIdHighlighted()) {\r\n            case SeriesHighlight.None:\r\n            case SeriesHighlight.This:\r\n                return defaultOpacity;\r\n            case SeriesHighlight.Other:\r\n            default:\r\n                return dimOpacity;\r\n        }\r\n    }\r\n    getStrokeWidth(defaultStrokeWidth) {\r\n        const { strokeWidth, enabled = true } = this.highlightStyle.series;\r\n        if (!enabled || strokeWidth === undefined) {\r\n            // No change in styling for highlight cases.\r\n            return defaultStrokeWidth;\r\n        }\r\n        switch (this.isItemIdHighlighted()) {\r\n            case SeriesHighlight.This:\r\n                return strokeWidth;\r\n            case SeriesHighlight.None:\r\n            case SeriesHighlight.Other:\r\n                return defaultStrokeWidth;\r\n        }\r\n    }\r\n    isItemIdHighlighted() {\r\n        var _a, _b;\r\n        const { series } = (_b = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight()) !== null && _b !== void 0 ? _b : {};\r\n        // Highlighting not active.\r\n        if (series == null) {\r\n            return SeriesHighlight.None;\r\n        }\r\n        // Highlighting active, this series not highlighted.\r\n        if (series !== this) {\r\n            return SeriesHighlight.Other;\r\n        }\r\n        return SeriesHighlight.This;\r\n    }\r\n    getModuleTooltipParams(datum) {\r\n        var _a;\r\n        const params = (_a = this.dispatch('tooltip-getParams', { datum })) !== null && _a !== void 0 ? _a : [];\r\n        return params.reduce((total, current) => {\r\n            return Object.assign(Object.assign({}, current), total);\r\n        }, {});\r\n    }\r\n    pickNode(point, limitPickModes) {\r\n        const { pickModes, visible, rootGroup } = this;\r\n        if (!visible || !rootGroup.visible) {\r\n            return;\r\n        }\r\n        for (const pickMode of pickModes) {\r\n            if (limitPickModes && !limitPickModes.includes(pickMode)) {\r\n                continue;\r\n            }\r\n            let match;\r\n            switch (pickMode) {\r\n                case SeriesNodePickMode.EXACT_SHAPE_MATCH:\r\n                    match = this.pickNodeExactShape(point);\r\n                    break;\r\n                case SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST:\r\n                case SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST:\r\n                    match = this.pickNodeMainAxisFirst(point, pickMode === SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST);\r\n                    break;\r\n                case SeriesNodePickMode.NEAREST_NODE:\r\n                    match = this.pickNodeClosestDatum(point);\r\n                    break;\r\n            }\r\n            if (match) {\r\n                return { pickMode, match: match.datum, distance: match.distance };\r\n            }\r\n        }\r\n    }\r\n    pickNodeExactShape(point) {\r\n        const match = this.contentGroup.pickNode(point.x, point.y);\r\n        return match && { datum: match.datum, distance: 0 };\r\n    }\r\n    pickNodeClosestDatum(_point) {\r\n        // Override point for subclasses - but if this is invoked, the subclass specified it wants\r\n        // to use this feature.\r\n        throw new Error('AG Charts - Series.pickNodeClosestDatum() not implemented');\r\n    }\r\n    pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\r\n        // Override point for subclasses - but if this is invoked, the subclass specified it wants\r\n        // to use this feature.\r\n        throw new Error('AG Charts - Series.pickNodeMainAxisFirst() not implemented');\r\n    }\r\n    fireNodeClickEvent(event, datum) {\r\n        this.fireEvent(new this.NodeClickEvent('nodeClick', event, datum, this));\r\n    }\r\n    fireNodeDoubleClickEvent(event, datum) {\r\n        this.fireEvent(new this.NodeClickEvent('nodeDoubleClick', event, datum, this));\r\n    }\r\n    toggleSeriesItem(itemId, enabled) {\r\n        this.visible = enabled;\r\n        this.nodeDataRefresh = true;\r\n        this.dispatch('visibility-changed', { itemId, enabled });\r\n    }\r\n    isEnabled() {\r\n        return this.visible;\r\n    }\r\n    getModuleMap() {\r\n        return this.moduleMap;\r\n    }\r\n    createModuleContext() {\r\n        return Object.assign(Object.assign({}, this.ctx), { series: this });\r\n    }\r\n    getLabelText(label, params, defaultFormatter = String) {\r\n        var _a;\r\n        if (label.formatter) {\r\n            return ((_a = this.ctx.callbackCache.call(label.formatter, Object.assign({ seriesId: this.id }, params))) !== null && _a !== void 0 ? _a : defaultFormatter(params.value));\r\n        }\r\n        return defaultFormatter(params.value);\r\n    }\r\n    getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\r\n        var _a, _b;\r\n        const defaultSize = { size: (_b = (_a = params.datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0 };\r\n        const markerStyle = mergeDefaults(defaultSize, defaultStyle);\r\n        if (marker.formatter) {\r\n            const style = this.ctx.callbackCache.call(marker.formatter, Object.assign(Object.assign(Object.assign({ seriesId: this.id }, markerStyle), params), { datum: params.datum.datum }));\r\n            return mergeDefaults(style, markerStyle);\r\n        }\r\n        return markerStyle;\r\n    }\r\n    updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {\r\n        const { point } = params.datum;\r\n        const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\r\n        const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\r\n        if (applyTranslation) {\r\n            markerNode.setProperties(Object.assign(Object.assign({ visible }, activeStyle), { translationX: point === null || point === void 0 ? void 0 : point.x, translationY: point === null || point === void 0 ? void 0 : point.y }));\r\n        }\r\n        else {\r\n            markerNode.setProperties(Object.assign({ visible }, activeStyle));\r\n        }\r\n        // Only for custom marker shapes\r\n        if (typeof marker.shape === 'function' && !markerNode.dirtyPath) {\r\n            markerNode.path.clear({ trackChanges: true });\r\n            markerNode.updatePath();\r\n            markerNode.checkPathDirty();\r\n        }\r\n    }\r\n    getMinRect() {\r\n        return undefined;\r\n    }\r\n    checkResize(newSeriesRect) {\r\n        const newNodeDataDependencies = {\r\n            seriesRectWidth: newSeriesRect === null || newSeriesRect === void 0 ? void 0 : newSeriesRect.width,\r\n            seriesRectHeight: newSeriesRect === null || newSeriesRect === void 0 ? void 0 : newSeriesRect.height,\r\n        };\r\n        const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\r\n        if (resize) {\r\n            this.nodeDataDependencies = newNodeDataDependencies;\r\n            this.markNodeDataDirty();\r\n        }\r\n        return resize;\r\n    }\r\n}\r\nSeries.highlightedZIndex = 1000000000000;\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"id\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"_visible\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"showInLegend\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"cursor\", void 0);\r\n__decorate([\r\n    Validate(INTERACTION_RANGE),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"nodeClickRange\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue: function (newVal, oldVal) {\r\n            this.onSeriesGroupingChange(oldVal, newVal);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"seriesGrouping\", void 0);\n\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, labelSelections) {\r\n    staticFromToMotion(id, subId, animationManager, labelSelections, { opacity: 0 }, { opacity: 1 }, LABEL_PHASE);\r\n}\r\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, labelSelections) {\r\n    staticFromToMotion(id, subId, animationManager, labelSelections, { opacity: 1 }, { opacity: 0 }, LABEL_PHASE);\r\n}\r\nfunction resetLabelFn(_node) {\r\n    return { opacity: 1 };\r\n}\n\nconst CONSTANTS = {\r\n    periods: ['AM', 'PM'],\r\n    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\r\n    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\r\n    months: [\r\n        'January',\r\n        'February',\r\n        'March',\r\n        'April',\r\n        'May',\r\n        'June',\r\n        'July',\r\n        'August',\r\n        'September',\r\n        'October',\r\n        'November',\r\n        'December',\r\n    ],\r\n    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\r\n};\r\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\r\n    const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\r\n    const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 60000;\r\n    const timeOneDay = 3600000 * 24;\r\n    return Math.floor(timeDiff / timeOneDay);\r\n}\r\nfunction weekOfYear(date, startDay) {\r\n    const startOfYear = new Date(date.getFullYear(), 0, 1);\r\n    const startOfYearDay = startOfYear.getDay();\r\n    const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\r\n    const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\r\n    if (startOffset <= date) {\r\n        return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\r\n    }\r\n    // Days before week 1 are in week 0.\r\n    return 0;\r\n}\r\nconst SUNDAY = 0;\r\nconst MONDAY = 1;\r\nconst THURSDAY = 4;\r\nfunction isoWeekOfYear(date, year = date.getFullYear()) {\r\n    const firstOfYear = new Date(year, 0, 1);\r\n    const firstOfYearDay = firstOfYear.getDay();\r\n    const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\r\n    const startOffset = new Date(year, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\r\n    if (startOffset <= date) {\r\n        return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\r\n    }\r\n    // Days before week 1 are in week 52/53 of previous year.\r\n    return isoWeekOfYear(date, year - 1);\r\n}\r\nfunction timezone(date) {\r\n    const offset = date.getTimezoneOffset();\r\n    const unsignedOffset = Math.abs(offset);\r\n    const sign = offset > 0 ? '-' : '+';\r\n    return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, '0')}${pad(Math.floor(unsignedOffset % 60), 2, '0')}`;\r\n}\r\nconst FORMATTERS = {\r\n    a: (d) => CONSTANTS.shortDays[d.getDay()],\r\n    A: (d) => CONSTANTS.days[d.getDay()],\r\n    b: (d) => CONSTANTS.shortMonths[d.getMonth()],\r\n    B: (d) => CONSTANTS.months[d.getMonth()],\r\n    c: '%x, %X',\r\n    d: (d, p) => pad(d.getDate(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    e: '%_d',\r\n    f: (d, p) => pad(d.getMilliseconds() * 1000, 6, p !== null && p !== void 0 ? p : '0'),\r\n    H: (d, p) => pad(d.getHours(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    I: (d, p) => {\r\n        const hours = d.getHours() % 12;\r\n        return hours === 0 ? '12' : pad(hours, 2, p !== null && p !== void 0 ? p : '0');\r\n    },\r\n    j: (d, p) => pad(dayOfYear(d) + 1, 3, p !== null && p !== void 0 ? p : '0'),\r\n    m: (d, p) => pad(d.getMonth() + 1, 2, p !== null && p !== void 0 ? p : '0'),\r\n    M: (d, p) => pad(d.getMinutes(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    L: (d, p) => pad(d.getMilliseconds(), 3, p !== null && p !== void 0 ? p : '0'),\r\n    p: (d) => (d.getHours() < 12 ? 'AM' : 'PM'),\r\n    Q: (d) => String(d.getTime()),\r\n    s: (d) => String(Math.floor(d.getTime() / 1000)),\r\n    S: (d, p) => pad(d.getSeconds(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    u: (d) => {\r\n        let day = d.getDay();\r\n        if (day < 1)\r\n            day += 7;\r\n        return String(day % 7);\r\n    },\r\n    U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p !== null && p !== void 0 ? p : '0'),\r\n    V: (d, p) => pad(isoWeekOfYear(d), 2, p !== null && p !== void 0 ? p : '0'),\r\n    w: (d, p) => pad(d.getDay(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p !== null && p !== void 0 ? p : '0'),\r\n    x: '%-m/%-d/%Y',\r\n    X: '%-I:%M:%S %p',\r\n    y: (d, p) => pad(d.getFullYear() % 100, 2, p !== null && p !== void 0 ? p : '0'),\r\n    Y: (d, p) => pad(d.getFullYear(), 4, p !== null && p !== void 0 ? p : '0'),\r\n    Z: (d) => timezone(d),\r\n    '%': () => '%',\r\n};\r\nconst PADS = {\r\n    _: ' ',\r\n    '0': '0',\r\n    '-': '',\r\n};\r\nfunction pad(value, size, padChar) {\r\n    const output = String(Math.floor(value));\r\n    if (output.length >= size) {\r\n        return output;\r\n    }\r\n    return `${padChar.repeat(size - output.length)}${output}`;\r\n}\r\nfunction buildFormatter(formatString) {\r\n    const formatParts = [];\r\n    while (formatString.length > 0) {\r\n        let nextEscapeIdx = formatString.indexOf('%');\r\n        if (nextEscapeIdx !== 0) {\r\n            const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\r\n            formatParts.push(literalPart);\r\n        }\r\n        if (nextEscapeIdx < 0)\r\n            break;\r\n        const maybePadSpecifier = formatString[nextEscapeIdx + 1];\r\n        const maybePad = PADS[maybePadSpecifier];\r\n        if (maybePad != null) {\r\n            nextEscapeIdx++;\r\n        }\r\n        const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\r\n        const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\r\n        if (typeof maybeFormatter === 'function') {\r\n            formatParts.push([maybeFormatter, maybePad]);\r\n        }\r\n        else if (typeof maybeFormatter === 'string') {\r\n            const formatter = buildFormatter(maybeFormatter);\r\n            formatParts.push([formatter, maybePad]);\r\n        }\r\n        else {\r\n            formatParts.push(`${maybePad !== null && maybePad !== void 0 ? maybePad : ''}${maybeFormatterSpecifier}`);\r\n        }\r\n        formatString = formatString.substring(nextEscapeIdx + 2);\r\n    }\r\n    return (dateTime) => {\r\n        const dateTimeAsDate = typeof dateTime === 'number' ? new Date(dateTime) : dateTime;\r\n        return formatParts.map((c) => (typeof c === 'string' ? c : c[0](dateTimeAsDate, c[1]))).join('');\r\n    };\r\n}\n\nconst interpolatePattern = /(#\\{(.*?)\\})/g;\r\nfunction interpolate(input, values, formats) {\r\n    return input.replace(interpolatePattern, function (...args) {\r\n        const name = args[2];\r\n        const [valueName, formatName] = name.split(':');\r\n        const value = values[valueName];\r\n        if (typeof value === 'number') {\r\n            const format = formatName && formats && formats[formatName];\r\n            if (format) {\r\n                const { locales, options } = format;\r\n                return value.toLocaleString(locales, options);\r\n            }\r\n            return String(value);\r\n        }\r\n        if (value instanceof Date) {\r\n            const format = formatName && formats && formats[formatName];\r\n            if (typeof format === 'string') {\r\n                const formatter = buildFormatter(format);\r\n                return formatter(value);\r\n            }\r\n            return value.toDateString();\r\n        }\r\n        if (typeof value === 'string' || (value === null || value === void 0 ? void 0 : value.toString)) {\r\n            return String(value);\r\n        }\r\n        return '';\r\n    });\r\n}\n\nfunction injectStyle(document, cssStyle) {\r\n    const styleElement = document.createElement('style');\r\n    styleElement.innerHTML = cssStyle;\r\n    // Make sure these styles are injected before other styles, so it can be overridden.\r\n    document.head.insertBefore(styleElement, document.head.querySelector('style'));\r\n}\n\nconst DEFAULT_TOOLTIP_CLASS = 'ag-chart-tooltip';\r\nconst DEFAULT_TOOLTIP_DARK_CLASS = 'ag-chart-dark-tooltip';\r\nconst defaultTooltipCss = `\n.${DEFAULT_TOOLTIP_CLASS} {\n    transition: transform 0.1s ease;\n    display: table;\n    position: fixed;\n    left: 0px;\n    top: 0px;\n    white-space: nowrap;\n    z-index: 99999;\n    font: 12px Verdana, sans-serif;\n    color: rgb(70, 70, 70);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-no-interaction {\n    pointer-events: none;\n    user-select: none;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-no-animation {\n    transition: none !important;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-hidden {\n    visibility: hidden;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-title {\n    position: relative;\n    padding: 8px 14px;\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n    color: white;\n    background-color: #888888;\n    z-index: 1;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-title:only-child {\n    border-bottom-left-radius: 2px;\n    border-bottom-right-radius: 2px;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-content {\n    padding: 6px 14px;\n    line-height: 1.7em;\n    background: white;\n    border-bottom-left-radius: 2px;\n    border-bottom-right-radius: 2px;\n    border: 1px solid rgba(0, 0, 0, 0.15);\n    overflow: hidden;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-arrow::before {\n    content: \"\";\n\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 5px solid #d9d9d9;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-arrow::after {\n    content: \"\";\n\n    position: absolute;\n    top: calc(100% - 1px);\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 5px solid white;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}.${DEFAULT_TOOLTIP_DARK_CLASS} {\n    color: white;\n    background: #15181c;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}.${DEFAULT_TOOLTIP_DARK_CLASS} .${DEFAULT_TOOLTIP_CLASS}-content {\n    border-color: rgba(255, 255, 255, 0.15);\n}\n\n.ag-chart-wrapper {\n    box-sizing: border-box;\n    overflow: hidden;\n}\n`;\r\nfunction toTooltipHtml(input, defaults) {\r\n    var _a, _b, _c;\r\n    if (typeof input === 'string') {\r\n        return input;\r\n    }\r\n    const { content = (_a = defaults === null || defaults === void 0 ? void 0 : defaults.content) !== null && _a !== void 0 ? _a : '', title = defaults === null || defaults === void 0 ? void 0 : defaults.title, color = (_b = defaults === null || defaults === void 0 ? void 0 : defaults.color) !== null && _b !== void 0 ? _b : 'white', backgroundColor = (_c = defaults === null || defaults === void 0 ? void 0 : defaults.backgroundColor) !== null && _c !== void 0 ? _c : '#888', } = input;\r\n    const titleHtml = title\r\n        ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>`\r\n        : '';\r\n    const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : '';\r\n    return `${titleHtml}${contentHtml}`;\r\n}\r\nconst POSITION_TYPES = ['pointer', 'node'];\r\nconst POSITION_TYPE = predicateWithMessage((v) => POSITION_TYPES.includes(v), `expecting a position type keyword such as 'pointer' or 'node'`);\r\nclass TooltipPosition {\r\n    constructor() {\r\n        /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\r\n        this.type = 'pointer';\r\n        /** The horizontal offset in pixels for the position of the tooltip. */\r\n        this.xOffset = 0;\r\n        /** The vertical offset in pixels for the position of the tooltip. */\r\n        this.yOffset = 0;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(POSITION_TYPE)\r\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\r\n    ,\r\n    __metadata(\"design:type\", String)\r\n], TooltipPosition.prototype, \"type\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1())\r\n    /** The horizontal offset in pixels for the position of the tooltip. */\r\n    ,\r\n    __metadata(\"design:type\", Number)\r\n], TooltipPosition.prototype, \"xOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1())\r\n    /** The vertical offset in pixels for the position of the tooltip. */\r\n    ,\r\n    __metadata(\"design:type\", Number)\r\n], TooltipPosition.prototype, \"yOffset\", void 0);\r\nclass Tooltip {\r\n    constructor(canvasElement, document, window, container) {\r\n        this.enableInteraction = false;\r\n        this.enabled = true;\r\n        this.showArrow = undefined;\r\n        this.class = undefined;\r\n        this.lastClass = undefined;\r\n        this.delay = 0;\r\n        this.range = 'nearest';\r\n        this.lastVisibilityChange = Date.now();\r\n        this.position = new TooltipPosition();\r\n        this.showTimeout = 0;\r\n        this._showArrow = true;\r\n        this.tooltipRoot = container;\r\n        this.window = window;\r\n        const element = document.createElement('div');\r\n        this.element = this.tooltipRoot.appendChild(element);\r\n        this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\r\n        this.canvasElement = canvasElement;\r\n        // Detect when the chart becomes invisible and hide the tooltip as well.\r\n        if (typeof IntersectionObserver !== 'undefined') {\r\n            const observer = new IntersectionObserver((entries) => {\r\n                for (const entry of entries) {\r\n                    if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {\r\n                        this.toggle(false);\r\n                    }\r\n                }\r\n            }, { root: this.tooltipRoot });\r\n            observer.observe(this.canvasElement);\r\n            this.observer = observer;\r\n        }\r\n        if (Tooltip.tooltipDocuments.indexOf(document) < 0) {\r\n            injectStyle(document, defaultTooltipCss);\r\n            Tooltip.tooltipDocuments.push(document);\r\n        }\r\n    }\r\n    destroy() {\r\n        const { parentNode } = this.element;\r\n        if (parentNode) {\r\n            parentNode.removeChild(this.element);\r\n        }\r\n        if (this.observer) {\r\n            this.observer.unobserve(this.canvasElement);\r\n        }\r\n    }\r\n    isVisible() {\r\n        const { element } = this;\r\n        return !element.classList.contains(DEFAULT_TOOLTIP_CLASS + '-hidden');\r\n    }\r\n    updateClass(visible, showArrow) {\r\n        const { element, class: newClass, lastClass, enableInteraction, lastVisibilityChange } = this;\r\n        const wasVisible = this.isVisible();\r\n        const nowVisible = !!visible;\r\n        let timeSinceLastVisibilityChangeMs = Infinity;\r\n        if (wasVisible !== nowVisible) {\r\n            const now = Date.now();\r\n            timeSinceLastVisibilityChangeMs = now - lastVisibilityChange;\r\n            this.lastVisibilityChange = now;\r\n        }\r\n        const toggleClass = (name, include) => {\r\n            const className = `${DEFAULT_TOOLTIP_CLASS}-${name}`;\r\n            if (include) {\r\n                element.classList.add(className);\r\n            }\r\n            else {\r\n                element.classList.remove(className);\r\n            }\r\n        };\r\n        // Time below which an animated move should be used.\r\n        const animatedMoveThresholdMs = 100;\r\n        // Time below which we should treat updates as indistinguishable to users, and we shouldn't\r\n        // adjust the `no-animation` CSS class.\r\n        const thrashingThresholdMs = 5;\r\n        // No animation on first show or if tooltip is disabled for a non-trivial amount of time.\r\n        // Don't change the `no-animation` class on fast update.\r\n        const noAnimation = !wasVisible && nowVisible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\r\n        if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\r\n            toggleClass('no-animation', noAnimation);\r\n        }\r\n        toggleClass('no-interaction', !enableInteraction); // Prevent interaction.\r\n        toggleClass('hidden', !visible); // Hide if not visible.\r\n        toggleClass('arrow', !!showArrow); // Add arrow if tooltip is constrained.\r\n        if (newClass !== lastClass) {\r\n            if (lastClass) {\r\n                element.classList.remove(lastClass);\r\n            }\r\n            if (newClass) {\r\n                element.classList.add(newClass);\r\n            }\r\n            this.lastClass = newClass;\r\n        }\r\n    }\r\n    /**\r\n     * Shows tooltip at the given event's coordinates.\r\n     * If the `html` parameter is missing, moves the existing tooltip to the new position.\r\n     */\r\n    show(meta, html, instantly = false) {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        const { element, canvasElement } = this;\r\n        if (html !== undefined) {\r\n            element.innerHTML = html;\r\n        }\r\n        else if (!element.innerHTML) {\r\n            this.toggle(false);\r\n            return;\r\n        }\r\n        const limit = (low, actual, high) => {\r\n            return Math.max(Math.min(actual, high), low);\r\n        };\r\n        const xOffset = (_b = (_a = meta.position) === null || _a === void 0 ? void 0 : _a.xOffset) !== null && _b !== void 0 ? _b : 0;\r\n        const yOffset = (_d = (_c = meta.position) === null || _c === void 0 ? void 0 : _c.yOffset) !== null && _d !== void 0 ? _d : 0;\r\n        const canvasRect = canvasElement.getBoundingClientRect();\r\n        const naiveLeft = canvasRect.left + meta.offsetX - element.clientWidth / 2 + xOffset;\r\n        const naiveTop = canvasRect.top + meta.offsetY - element.clientHeight - 8 + yOffset;\r\n        const windowBounds = this.getWindowBoundingBox();\r\n        const maxLeft = windowBounds.x + windowBounds.width - element.clientWidth - 1;\r\n        const maxTop = windowBounds.y + windowBounds.height - element.clientHeight;\r\n        const left = limit(windowBounds.x, naiveLeft, maxLeft);\r\n        const top = limit(windowBounds.y, naiveTop, maxTop);\r\n        const constrained = left !== naiveLeft || top !== naiveTop;\r\n        const defaultShowArrow = !constrained && !xOffset && !yOffset;\r\n        const showArrow = (_f = (_e = meta.showArrow) !== null && _e !== void 0 ? _e : this.showArrow) !== null && _f !== void 0 ? _f : defaultShowArrow;\r\n        this.updateShowArrow(showArrow);\r\n        element.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\r\n        this.enableInteraction = (_g = meta.enableInteraction) !== null && _g !== void 0 ? _g : false;\r\n        if (this.delay > 0 && !instantly) {\r\n            this.toggle(false);\r\n            this.showTimeout = this.window.setTimeout(() => {\r\n                this.toggle(true);\r\n            }, this.delay);\r\n            return;\r\n        }\r\n        this.toggle(true);\r\n    }\r\n    getWindowBoundingBox() {\r\n        return new BBox(0, 0, this.window.innerWidth, this.window.innerHeight);\r\n    }\r\n    toggle(visible) {\r\n        if (!visible) {\r\n            this.window.clearTimeout(this.showTimeout);\r\n        }\r\n        this.updateClass(visible, this._showArrow);\r\n    }\r\n    pointerLeftOntoTooltip(event) {\r\n        var _a;\r\n        if (!this.enableInteraction)\r\n            return false;\r\n        const classList = (_a = event.sourceEvent.relatedTarget) === null || _a === void 0 ? void 0 : _a.classList;\r\n        const classes = ['', '-title', '-content'];\r\n        const classListContains = Boolean(classes.filter((c) => classList === null || classList === void 0 ? void 0 : classList.contains(`${DEFAULT_TOOLTIP_CLASS}${c}`)));\r\n        return classList !== undefined && classListContains;\r\n    }\r\n    updateShowArrow(show) {\r\n        this._showArrow = show;\r\n    }\r\n}\r\nTooltip.tooltipDocuments = [];\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Tooltip.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Tooltip.prototype, \"showArrow\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], Tooltip.prototype, \"class\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Tooltip.prototype, \"delay\", void 0);\r\n__decorate([\r\n    Validate(INTERACTION_RANGE),\r\n    __metadata(\"design:type\", Object)\r\n], Tooltip.prototype, \"range\", void 0);\n\nclass SeriesTooltipInteraction {\r\n    constructor() {\r\n        this.enabled = false;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesTooltipInteraction.prototype, \"enabled\", void 0);\r\nclass SeriesTooltip {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.showArrow = undefined;\r\n        this.format = undefined;\r\n        this.renderer = undefined;\r\n        this.interaction = new SeriesTooltipInteraction();\r\n        this.position = new TooltipPosition();\r\n    }\r\n    toTooltipHtml(defaults, params, overrides) {\r\n        var _a, _b;\r\n        const formatFn = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.format) !== null && _a !== void 0 ? _a : this.format;\r\n        const rendererFn = (_b = overrides === null || overrides === void 0 ? void 0 : overrides.renderer) !== null && _b !== void 0 ? _b : this.renderer;\r\n        if (formatFn) {\r\n            return toTooltipHtml({ content: interpolate(formatFn, params) }, defaults);\r\n        }\r\n        if (rendererFn) {\r\n            return toTooltipHtml(rendererFn(params), defaults);\r\n        }\r\n        return toTooltipHtml(defaults);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesTooltip.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], SeriesTooltip.prototype, \"showArrow\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], SeriesTooltip.prototype, \"format\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], SeriesTooltip.prototype, \"renderer\", void 0);\n\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\r\n    const scale = [scaleFn.convert(0), scaleFn.convert(1)];\r\n    const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\r\n    const rotation = Math.PI / -2 + toRadians(rotationDegrees);\r\n    const scaleToNewRadius = ({ radius }) => {\r\n        return { innerRadius: scale[0], outerRadius: scale[0] + (scale[1] - scale[0]) * radius };\r\n    };\r\n    const scaleToOldRadius = ({ radius }) => {\r\n        return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\r\n    };\r\n    const fromFn = (sect, datum, status, { prevFromProps }) => {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        // Default to starting from current state.\r\n        let { startAngle, endAngle, innerRadius, outerRadius } = sect;\r\n        let { fill, stroke } = datum.sectorFormat;\r\n        if (status === 'unknown' || (status === 'added' && !prevFromProps)) {\r\n            // Start of animation (full new data) - sweep in.\r\n            startAngle = rotation;\r\n            endAngle = rotation;\r\n            innerRadius = datum.innerRadius;\r\n            outerRadius = datum.outerRadius;\r\n        }\r\n        else if (status === 'added' && prevFromProps) {\r\n            startAngle = (_a = prevFromProps.endAngle) !== null && _a !== void 0 ? _a : rotation;\r\n            endAngle = (_b = prevFromProps.endAngle) !== null && _b !== void 0 ? _b : rotation;\r\n            innerRadius = (_c = prevFromProps.innerRadius) !== null && _c !== void 0 ? _c : datum.innerRadius;\r\n            outerRadius = (_d = prevFromProps.outerRadius) !== null && _d !== void 0 ? _d : datum.outerRadius;\r\n        }\r\n        if (status === 'added' && !initialLoad) {\r\n            const radii = scaleToOldRadius(datum);\r\n            innerRadius = radii.innerRadius;\r\n            outerRadius = radii.outerRadius;\r\n        }\r\n        if (status === 'updated') {\r\n            fill = (_e = sect.fill) !== null && _e !== void 0 ? _e : fill;\r\n            stroke = (_f = sect.stroke) !== null && _f !== void 0 ? _f : stroke;\r\n        }\r\n        return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke };\r\n    };\r\n    const toFn = (_sect, datum, status, { prevLive }) => {\r\n        var _a, _b;\r\n        // Default to moving to target state.\r\n        let { startAngle, endAngle, innerRadius, outerRadius } = datum;\r\n        const { stroke, fill } = datum.sectorFormat;\r\n        if (status === 'removed' && prevLive) {\r\n            startAngle = (_a = prevLive.datum) === null || _a === void 0 ? void 0 : _a.endAngle;\r\n            endAngle = (_b = prevLive.datum) === null || _b === void 0 ? void 0 : _b.endAngle;\r\n        }\r\n        else if (status === 'removed' && !prevLive) {\r\n            startAngle = rotation;\r\n            endAngle = rotation;\r\n        }\r\n        if (status === 'removed') {\r\n            const radii = scaleToNewRadius(datum);\r\n            innerRadius = radii.innerRadius;\r\n            outerRadius = radii.outerRadius;\r\n        }\r\n        return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\r\n    };\r\n    const innerCircle = {\r\n        fromFn: (node, _datum) => {\r\n            var _a, _b, _c;\r\n            return { size: (_c = (_b = (_a = node.previousDatum) === null || _a === void 0 ? void 0 : _a.radius) !== null && _b !== void 0 ? _b : node.size) !== null && _c !== void 0 ? _c : 0 };\r\n        },\r\n        toFn: (_node, datum) => {\r\n            var _a;\r\n            return { size: (_a = datum.radius) !== null && _a !== void 0 ? _a : 0 };\r\n        },\r\n    };\r\n    return { nodes: { toFn, fromFn }, innerCircle };\r\n}\r\nfunction resetPieSelectionsFn(_node, datum) {\r\n    return {\r\n        startAngle: datum.startAngle,\r\n        endAngle: datum.endAngle,\r\n        innerRadius: datum.innerRadius,\r\n        outerRadius: datum.outerRadius,\r\n        fill: datum.sectorFormat.fill,\r\n        stroke: datum.sectorFormat.stroke,\r\n    };\r\n}\n\n/**\r\n * Implements a per-node reset.\r\n *\r\n * @param selections contains nodes to be reset\r\n * @param propsFn callback to determine per-node properties\r\n */\r\nfunction resetMotion(selectionsOrNodes, propsFn) {\r\n    const isNodes = isNodeArray(selectionsOrNodes);\r\n    const nodes = isNodes ? selectionsOrNodes : [];\r\n    const selections = !isNodes ? selectionsOrNodes : [];\r\n    for (const selection of selections) {\r\n        for (const node of selection.nodes()) {\r\n            const from = propsFn(node, node.datum);\r\n            node.setProperties(from);\r\n        }\r\n        selection.cleanup();\r\n    }\r\n    for (const node of nodes) {\r\n        const from = propsFn(node, node.datum);\r\n        node.setProperties(from);\r\n    }\r\n}\n\nvar resetMotion$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    resetMotion: resetMotion\n});\n\nclass StateMachine {\r\n    constructor(initialState, states, preTransitionCb) {\r\n        this.states = states;\r\n        this.preTransitionCb = preTransitionCb;\r\n        this.debug = Debug.create(true, 'animation');\r\n        this.state = initialState;\r\n        this.debug(`%c${this.constructor.name} | init -> ${initialState}`, 'color: green');\r\n    }\r\n    transition(event, data) {\r\n        var _a, _b;\r\n        const currentStateConfig = this.states[this.state];\r\n        const destinationTransition = currentStateConfig === null || currentStateConfig === void 0 ? void 0 : currentStateConfig[event];\r\n        if (!destinationTransition) {\r\n            this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.state}`, 'color: grey');\r\n            return;\r\n        }\r\n        let destinationState = this.state;\r\n        if (typeof destinationTransition === 'string') {\r\n            destinationState = destinationTransition;\r\n        }\r\n        else if (typeof destinationTransition === 'object') {\r\n            destinationState = destinationTransition.target;\r\n        }\r\n        this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${destinationState}`, 'color: green');\r\n        (_a = this.preTransitionCb) === null || _a === void 0 ? void 0 : _a.call(this, this.state, destinationState);\r\n        // Change the state before calling the transition action to allow the action to trigger a subsequent transition\r\n        this.state = destinationState;\r\n        if (typeof destinationTransition === 'function') {\r\n            destinationTransition(data);\r\n        }\r\n        else if (typeof destinationTransition === 'object') {\r\n            (_b = destinationTransition.action) === null || _b === void 0 ? void 0 : _b.call(destinationTransition, data);\r\n        }\r\n        return this.state;\r\n    }\r\n}\n\nclass DataModelSeries extends Series {\r\n    isContinuous() {\r\n        var _a, _b;\r\n        const isContinuousX = ContinuousScale.is((_a = this.axes[ChartAxisDirection.X]) === null || _a === void 0 ? void 0 : _a.scale);\r\n        const isContinuousY = ContinuousScale.is((_b = this.axes[ChartAxisDirection.Y]) === null || _b === void 0 ? void 0 : _b.scale);\r\n        return { isContinuousX, isContinuousY };\r\n    }\r\n    // Request data, but with message dispatching to series-options (modules).\r\n    requestDataModel(dataController, data, opts) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Merge properties of this series with properties of all the attached series-options\r\n            const props = opts.props;\r\n            const listenerProps = (_a = this.dispatch('data-prerequest', this.isContinuous())) !== null && _a !== void 0 ? _a : [];\r\n            for (const moreProps of listenerProps) {\r\n                props.push(...moreProps);\r\n            }\r\n            const { dataModel, processedData } = yield dataController.request(this.id, data !== null && data !== void 0 ? data : [], Object.assign(Object.assign({}, opts), { props }));\r\n            this.dataModel = dataModel;\r\n            this.processedData = processedData;\r\n            this.dispatch('data-processed', { dataModel, processedData });\r\n            return { dataModel, processedData };\r\n        });\r\n    }\r\n    isProcessedDataAnimatable() {\r\n        var _a, _b;\r\n        const validationResults = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.animationValidation;\r\n        if (!validationResults)\r\n            return true;\r\n        const { orderedKeys, uniqueKeys } = validationResults;\r\n        return !!orderedKeys && !!uniqueKeys;\r\n    }\r\n    checkProcessedDataAnimatable() {\r\n        if (!this.isProcessedDataAnimatable()) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n    }\r\n}\n\nclass PolarSeries extends DataModelSeries {\r\n    constructor(_a) {\r\n        var { useLabelLayer = false, pickModes = [SeriesNodePickMode.EXACT_SHAPE_MATCH], canHaveAxes = false, animationResetFns } = _a, opts = __rest(_a, [\"useLabelLayer\", \"pickModes\", \"canHaveAxes\", \"animationResetFns\"]);\r\n        super(Object.assign(Object.assign({}, opts), { useLabelLayer,\r\n            pickModes, contentGroupVirtual: false, directionKeys: {\r\n                [ChartAxisDirection.X]: ['angleKey'],\r\n                [ChartAxisDirection.Y]: ['radiusKey'],\r\n            }, directionNames: {\r\n                [ChartAxisDirection.X]: ['angleName'],\r\n                [ChartAxisDirection.Y]: ['radiusName'],\r\n            }, canHaveAxes }));\r\n        this.sectorGroup = this.contentGroup.appendChild(new Group());\r\n        this.itemSelection = Selection.select(this.sectorGroup, () => this.nodeFactory(), false);\r\n        this.labelSelection = Selection.select(this.labelGroup, Text, false);\r\n        this.highlightSelection = Selection.select(this.highlightGroup, () => this.nodeFactory());\r\n        /**\r\n         * The center of the polar series (for example, the center of a pie).\r\n         * If the polar chart has multiple series, all of them will have their\r\n         * center set to the same value as a result of the polar chart layout.\r\n         * The center coordinates are not supposed to be set by the user.\r\n         */\r\n        this.centerX = 0;\r\n        this.centerY = 0;\r\n        /**\r\n         * The maximum radius the series can use.\r\n         * This value is set automatically as a result of the polar chart layout\r\n         * and is not supposed to be set by the user.\r\n         */\r\n        this.radius = 0;\r\n        this.sectorGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\r\n        this.animationResetFns = animationResetFns;\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateEmptyUpdateReady(data),\r\n                },\r\n            },\r\n            ready: {\r\n                updateData: 'waiting',\r\n                clear: 'clearing',\r\n                highlight: (data) => this.animateReadyHighlight(data),\r\n                highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\r\n                resize: (data) => this.animateReadyResize(data),\r\n            },\r\n            waiting: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateWaitingUpdateReady(data),\r\n                },\r\n            },\r\n            clearing: {\r\n                update: {\r\n                    target: 'empty',\r\n                    action: (data) => this.animateClearingUpdateEmpty(data),\r\n                },\r\n            },\r\n        }, () => this.checkProcessedDataAnimatable());\r\n    }\r\n    getLabelData() {\r\n        return [];\r\n    }\r\n    computeLabelsBBox(_options, _seriesRect) {\r\n        return null;\r\n    }\r\n    resetAllAnimation() {\r\n        var _a;\r\n        const { item, label } = (_a = this.animationResetFns) !== null && _a !== void 0 ? _a : {};\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        if (item) {\r\n            resetMotion([this.itemSelection, this.highlightSelection], item);\r\n        }\r\n        if (label) {\r\n            resetMotion([this.labelSelection], label);\r\n        }\r\n        this.itemSelection.cleanup();\r\n        this.labelSelection.cleanup();\r\n        this.highlightSelection.cleanup();\r\n    }\r\n    animateEmptyUpdateReady(_data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation();\r\n    }\r\n    animateWaitingUpdateReady(_data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation();\r\n    }\r\n    animateReadyHighlight(_data) {\r\n        var _a;\r\n        const { item } = (_a = this.animationResetFns) !== null && _a !== void 0 ? _a : {};\r\n        if (item) {\r\n            resetMotion([this.highlightSelection], item);\r\n        }\r\n    }\r\n    animateReadyHighlightMarkers(_data) {\r\n        // Override point for sub-classes.\r\n    }\r\n    animateReadyResize(_data) {\r\n        this.resetAllAnimation();\r\n    }\r\n    animateClearingUpdateEmpty(_data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation();\r\n    }\r\n    animationTransitionClear() {\r\n        this.animationState.transition('clear', this.getAnimationData());\r\n    }\r\n    getAnimationData(seriesRect) {\r\n        return { seriesRect };\r\n    }\r\n}\n\nclass PieSeriesNodeClickEvent extends SeriesNodeClickEvent {\r\n    constructor(type, nativeEvent, datum, series) {\r\n        super(type, nativeEvent, datum, series);\r\n        this.angleKey = series.angleKey;\r\n        this.radiusKey = series.radiusKey;\r\n        this.calloutLabelKey = series.calloutLabelKey;\r\n        this.sectorLabelKey = series.sectorLabelKey;\r\n    }\r\n}\r\nvar PieNodeTag;\r\n(function (PieNodeTag) {\r\n    PieNodeTag[PieNodeTag[\"Sector\"] = 0] = \"Sector\";\r\n    PieNodeTag[PieNodeTag[\"Callout\"] = 1] = \"Callout\";\r\n    PieNodeTag[PieNodeTag[\"Label\"] = 2] = \"Label\";\r\n})(PieNodeTag || (PieNodeTag = {}));\r\nclass PieSeriesCalloutLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.offset = 3; // from the callout line\r\n        this.minAngle = 0; // in degrees\r\n        this.minSpacing = 4;\r\n        this.maxCollisionOffset = 50;\r\n        this.avoidCollisions = true;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"offset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"minAngle\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", void 0);\r\nclass PieSeriesSectorLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.positionOffset = 0;\r\n        this.positionRatio = 0.5;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesSectorLabel.prototype, \"positionOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesSectorLabel.prototype, \"positionRatio\", void 0);\r\nclass PieSeriesCalloutLine {\r\n    constructor() {\r\n        this.length = 10;\r\n        this.strokeWidth = 1;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeriesCalloutLine.prototype, \"colors\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeriesCalloutLine.prototype, \"length\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", void 0);\r\nclass PieTitle extends Caption {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.showInLegend = false;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], PieTitle.prototype, \"showInLegend\", void 0);\r\nclass DoughnutInnerLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.text = '';\r\n        this.margin = 2;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerLabel.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerLabel.prototype, \"margin\", void 0);\r\nclass DoughnutInnerCircle {\r\n    constructor() {\r\n        this.fill = 'transparent';\r\n        this.fillOpacity = 1;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerCircle.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerCircle.prototype, \"fillOpacity\", void 0);\r\nclass PieSeries extends PolarSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            useLabelLayer: true,\r\n            animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn },\r\n        });\r\n        this.previousRadiusScale = new LinearScale();\r\n        this.radiusScale = new LinearScale();\r\n        // The group node that contains the background graphics.\r\n        this.backgroundGroup = this.rootGroup.appendChild(new Group({\r\n            name: `${this.id}-background`,\r\n            layer: true,\r\n            zIndex: Layers.SERIES_BACKGROUND_ZINDEX,\r\n        }));\r\n        this.innertCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\r\n        this.nodeData = [];\r\n        // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\r\n        this.seriesItemEnabled = [];\r\n        this.title = undefined;\r\n        this.calloutLabel = new PieSeriesCalloutLabel();\r\n        this.sectorLabel = new PieSeriesSectorLabel();\r\n        this.calloutLine = new PieSeriesCalloutLine();\r\n        this.tooltip = new SeriesTooltip();\r\n        /**\r\n         * The key of the numeric field to use to determine the angle (for example,\r\n         * a pie sector angle).\r\n         */\r\n        this.angleKey = '';\r\n        this.angleName = '';\r\n        this.innerLabels = [];\r\n        this.innerCircle = undefined;\r\n        /**\r\n         * The key of the numeric field to use to determine the radii of pie sectors.\r\n         * The largest value will correspond to the full radius and smaller values to\r\n         * proportionally smaller radii.\r\n         */\r\n        this.radiusKey = undefined;\r\n        this.radiusName = undefined;\r\n        this.radiusMin = undefined;\r\n        this.radiusMax = undefined;\r\n        this.calloutLabelKey = undefined;\r\n        this.calloutLabelName = undefined;\r\n        this.sectorLabelKey = undefined;\r\n        this.sectorLabelName = undefined;\r\n        this.legendItemKey = undefined;\r\n        this.fills = Object.values(DEFAULT_FILLS);\r\n        this.strokes = Object.values(DEFAULT_STROKES);\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.formatter = undefined;\r\n        /**\r\n         * The series rotation in degrees.\r\n         */\r\n        this.rotation = 0;\r\n        this.outerRadiusOffset = 0;\r\n        this.outerRadiusRatio = 1;\r\n        this.innerRadiusOffset = 0;\r\n        this.innerRadiusRatio = 1;\r\n        this.strokeWidth = 1;\r\n        this.shadow = undefined;\r\n        this.highlightStyle = new HighlightStyle();\r\n        this.surroundingRadius = undefined;\r\n        this.NodeClickEvent = PieSeriesNodeClickEvent;\r\n        this.angleScale = new LinearScale();\r\n        // Each sector is a ratio of the whole, where all ratios add up to 1.\r\n        this.angleScale.domain = [0, 1];\r\n        // Add 90 deg to start the first pie at 12 o'clock.\r\n        this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);\r\n        const pieCalloutLabels = new Group({ name: 'pieCalloutLabels' });\r\n        const pieSectorLabels = new Group({ name: 'pieSectorLabels' });\r\n        const innerLabels = new Group({ name: 'innerLabels' });\r\n        this.labelGroup.append(pieCalloutLabels);\r\n        this.labelGroup.append(pieSectorLabels);\r\n        this.labelGroup.append(innerLabels);\r\n        this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);\r\n        this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);\r\n        this.innerLabelsSelection = Selection.select(innerLabels, Text);\r\n        this.innerCircleSelection = Selection.select(this.innertCircleGroup, Circle);\r\n    }\r\n    addChartEventListeners() {\r\n        var _a;\r\n        (_a = this.ctx.chartEventManager) === null || _a === void 0 ? void 0 : _a.addListener('legend-item-click', (event) => this.onLegendItemClick(event));\r\n    }\r\n    visibleChanged() {\r\n        this.processSeriesItemEnabled();\r\n    }\r\n    processSeriesItemEnabled() {\r\n        var _a;\r\n        const { data, visible } = this;\r\n        this.seriesItemEnabled = (_a = data === null || data === void 0 ? void 0 : data.map(() => visible)) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n    nodeFactory() {\r\n        return new Sector();\r\n    }\r\n    getSeriesDomain(direction) {\r\n        if (direction === ChartAxisDirection.X) {\r\n            return this.angleScale.domain;\r\n        }\r\n        else {\r\n            return this.radiusScale.domain;\r\n        }\r\n    }\r\n    processData(dataController) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let { data } = this;\r\n            const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, seriesItemEnabled } = this;\r\n            if (angleKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const extraKeyProps = [];\r\n            const extraProps = [];\r\n            // Order here should match `getDatumIdFromData()`.\r\n            if (legendItemKey) {\r\n                extraKeyProps.push(keyProperty(this, legendItemKey, false, { id: `legendItemKey` }));\r\n            }\r\n            else if (calloutLabelKey) {\r\n                extraKeyProps.push(keyProperty(this, calloutLabelKey, false, { id: `calloutLabelKey` }));\r\n            }\r\n            else if (sectorLabelKey) {\r\n                extraKeyProps.push(keyProperty(this, sectorLabelKey, false, { id: `sectorLabelKey` }));\r\n            }\r\n            if (radiusKey) {\r\n                extraProps.push(rangedValueProperty(this, radiusKey, {\r\n                    id: 'radiusValue',\r\n                    min: (_a = this.radiusMin) !== null && _a !== void 0 ? _a : 0,\r\n                    max: this.radiusMax,\r\n                }), valueProperty(this, radiusKey, true, { id: `radiusRaw` }), // Raw value pass-through.\r\n                normalisePropertyTo(this, { id: 'radiusValue' }, [0, 1], 1, (_b = this.radiusMin) !== null && _b !== void 0 ? _b : 0, this.radiusMax));\r\n            }\r\n            if (calloutLabelKey) {\r\n                extraProps.push(valueProperty(this, calloutLabelKey, false, { id: `calloutLabelValue` }));\r\n            }\r\n            if (sectorLabelKey) {\r\n                extraProps.push(valueProperty(this, sectorLabelKey, false, { id: `sectorLabelValue` }));\r\n            }\r\n            if (legendItemKey) {\r\n                extraProps.push(valueProperty(this, legendItemKey, false, { id: `legendItemValue` }));\r\n            }\r\n            if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\r\n                extraProps.push(diff(this.processedData));\r\n            }\r\n            extraProps.push(animationValidation(this));\r\n            data = data.map((d, idx) => (seriesItemEnabled[idx] ? d : Object.assign(Object.assign({}, d), { [angleKey]: 0 })));\r\n            yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    ...extraKeyProps,\r\n                    accumulativeValueProperty(this, angleKey, true, { id: `angleValue`, onlyPositive: true }),\r\n                    valueProperty(this, angleKey, true, { id: `angleRaw` }),\r\n                    normalisePropertyTo(this, { id: 'angleValue' }, [0, 1], 0, 0),\r\n                    ...extraProps,\r\n                ],\r\n            });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    maybeRefreshNodeData() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.nodeDataRefresh)\r\n                return;\r\n            const [{ nodeData = [] } = {}] = yield this.createNodeData();\r\n            this.nodeData = nodeData;\r\n            this.nodeDataRefresh = false;\r\n        });\r\n    }\r\n    getProcessedDataIndexes(dataModel) {\r\n        const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`).index;\r\n        const radiusIdx = this.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`).index : -1;\r\n        const calloutLabelIdx = this.calloutLabelKey\r\n            ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`).index\r\n            : -1;\r\n        const sectorLabelIdx = this.sectorLabelKey\r\n            ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`).index\r\n            : -1;\r\n        const legendItemIdx = this.legendItemKey\r\n            ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index\r\n            : -1;\r\n        return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };\r\n    }\r\n    createNodeData() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { id: seriesId, processedData, dataModel, rotation, angleScale } = this;\r\n            if (!processedData || !dataModel || processedData.type !== 'ungrouped')\r\n                return [];\r\n            const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\r\n            let currentStart = 0;\r\n            const nodeData = processedData.data.map((group, index) => {\r\n                var _a;\r\n                const { datum, values } = group;\r\n                const currentValue = values[angleIdx];\r\n                const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\r\n                currentStart = currentValue;\r\n                const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\r\n                const span = Math.abs(endAngle - startAngle);\r\n                const midAngle = startAngle + span / 2;\r\n                const angleValue = values[angleIdx + 1];\r\n                const radius = radiusIdx >= 0 ? (_a = values[radiusIdx]) !== null && _a !== void 0 ? _a : 1 : 1;\r\n                const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : undefined;\r\n                const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : undefined;\r\n                const labels = this.getLabels(datum, midAngle, span, true, values[calloutLabelIdx], values[sectorLabelIdx], legendItemValue);\r\n                const sectorFormat = this.getSectorFormat(datum, index, false);\r\n                return Object.assign({ itemId: index, series: this, datum,\r\n                    index,\r\n                    angleValue,\r\n                    midAngle, midCos: Math.cos(midAngle), midSin: Math.sin(midAngle), startAngle,\r\n                    endAngle,\r\n                    sectorFormat,\r\n                    radiusValue,\r\n                    radius, innerRadius: Math.max(this.radiusScale.convert(0), 0), outerRadius: Math.max(this.radiusScale.convert(radius), 0), legendItemValue }, labels);\r\n            });\r\n            return [{ itemId: seriesId, nodeData, labelData: nodeData }];\r\n        });\r\n    }\r\n    getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\r\n        const { calloutLabel, sectorLabel, legendItemKey } = this;\r\n        const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.calloutLabelKey : undefined;\r\n        const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.sectorLabelKey : undefined;\r\n        if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\r\n            return {};\r\n        }\r\n        const labelFormatterParams = {\r\n            datum,\r\n            angleKey: this.angleKey,\r\n            angleName: this.angleName,\r\n            radiusKey: this.radiusKey,\r\n            radiusName: this.radiusName,\r\n            calloutLabelKey: this.calloutLabelKey,\r\n            calloutLabelName: this.calloutLabelName,\r\n            sectorLabelKey: this.sectorLabelKey,\r\n            sectorLabelName: this.sectorLabelName,\r\n            legendItemKey: this.legendItemKey,\r\n        };\r\n        const result = {};\r\n        if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\r\n            result.calloutLabel = Object.assign(Object.assign({}, this.getTextAlignment(midAngle)), { text: this.getLabelText(calloutLabel, Object.assign(Object.assign({}, labelFormatterParams), { value: calloutLabelValue })), hidden: false, collisionTextAlign: undefined, collisionOffsetY: 0, box: undefined });\r\n        }\r\n        if (sectorLabelKey) {\r\n            result.sectorLabel = {\r\n                text: this.getLabelText(sectorLabel, Object.assign(Object.assign({}, labelFormatterParams), { value: sectorLabelValue })),\r\n            };\r\n        }\r\n        if (legendItemKey != null && legendItemValue != null) {\r\n            result.legendItem = { key: legendItemKey, text: legendItemValue };\r\n        }\r\n        return result;\r\n    }\r\n    getTextAlignment(midAngle) {\r\n        const quadrantTextOpts = [\r\n            { textAlign: 'center', textBaseline: 'bottom' },\r\n            { textAlign: 'left', textBaseline: 'middle' },\r\n            { textAlign: 'center', textBaseline: 'hanging' },\r\n            { textAlign: 'right', textBaseline: 'middle' },\r\n        ];\r\n        const midAngle180 = normalizeAngle180(midAngle);\r\n        // Split the circle into quadrants like so: ⊗\r\n        const quadrantStart = (-3 * Math.PI) / 4; // same as `normalizeAngle180(toRadians(-135))`\r\n        const quadrantOffset = midAngle180 - quadrantStart;\r\n        const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\r\n        const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\r\n        return quadrantTextOpts[quadrantIndex];\r\n    }\r\n    getSectorFormat(datum, formatIndex, highlight) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { angleKey, radiusKey, fills, strokes, formatter, id: seriesId, ctx: { callbackCache, highlightManager }, } = this;\r\n        const highlightedDatum = highlightManager.getActiveHighlight();\r\n        const isDatumHighlighted = highlight && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && formatIndex === highlightedDatum.itemId;\r\n        const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(isDatumHighlighted && this.highlightStyle.item, {\r\n            fill: fills[formatIndex % fills.length],\r\n            fillOpacity: this.fillOpacity,\r\n            stroke: strokes[formatIndex % strokes.length],\r\n            strokeWidth: this.getStrokeWidth(this.strokeWidth),\r\n            strokeOpacity: this.getOpacity(),\r\n        });\r\n        let format;\r\n        if (formatter) {\r\n            format = callbackCache.call(formatter, {\r\n                datum,\r\n                angleKey,\r\n                radiusKey,\r\n                fill,\r\n                stroke,\r\n                fills,\r\n                strokes,\r\n                strokeWidth,\r\n                highlighted: isDatumHighlighted,\r\n                seriesId,\r\n            });\r\n        }\r\n        return {\r\n            fill: (_a = format === null || format === void 0 ? void 0 : format.fill) !== null && _a !== void 0 ? _a : fill,\r\n            fillOpacity: (_b = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _b !== void 0 ? _b : fillOpacity,\r\n            stroke: (_c = format === null || format === void 0 ? void 0 : format.stroke) !== null && _c !== void 0 ? _c : stroke,\r\n            strokeWidth: (_d = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _d !== void 0 ? _d : strokeWidth,\r\n            strokeOpacity: (_e = format === null || format === void 0 ? void 0 : format.strokeOpacity) !== null && _e !== void 0 ? _e : strokeOpacity,\r\n        };\r\n    }\r\n    getInnerRadius() {\r\n        const { radius, innerRadiusRatio, innerRadiusOffset } = this;\r\n        const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\r\n        if (innerRadius === radius || innerRadius < 0) {\r\n            return 0;\r\n        }\r\n        return innerRadius;\r\n    }\r\n    getOuterRadius() {\r\n        return Math.max(this.radius * this.outerRadiusRatio + this.outerRadiusOffset, 0);\r\n    }\r\n    updateRadiusScale(resize) {\r\n        const newRange = [this.getInnerRadius(), this.getOuterRadius()];\r\n        this.radiusScale.range = newRange;\r\n        if (resize) {\r\n            this.previousRadiusScale.range = newRange;\r\n        }\r\n        this.nodeData = this.nodeData.map((_a) => {\r\n            var { radius } = _a, d = __rest(_a, [\"radius\"]);\r\n            return Object.assign(Object.assign({}, d), { radius, innerRadius: Math.max(this.radiusScale.convert(0), 0), outerRadius: Math.max(this.radiusScale.convert(radius), 0) });\r\n        });\r\n    }\r\n    getTitleTranslationY() {\r\n        var _a, _b;\r\n        const outerRadius = Math.max(0, this.radiusScale.range[1]);\r\n        if (outerRadius === 0) {\r\n            return NaN;\r\n        }\r\n        const spacing = (_b = (_a = this.title) === null || _a === void 0 ? void 0 : _a.spacing) !== null && _b !== void 0 ? _b : 0;\r\n        const titleOffset = 2 + spacing;\r\n        const dy = Math.max(0, -outerRadius);\r\n        return -outerRadius - titleOffset - dy;\r\n    }\r\n    update({ seriesRect }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { title } = this;\r\n            const newNodeDataDependencies = {\r\n                seriesRectWidth: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width,\r\n                seriesRectHeight: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.height,\r\n            };\r\n            const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\r\n            if (resize) {\r\n                this.nodeDataDependencies = newNodeDataDependencies;\r\n            }\r\n            yield this.maybeRefreshNodeData();\r\n            this.updateTitleNodes();\r\n            this.updateRadiusScale(resize);\r\n            this.contentGroup.translationX = this.centerX;\r\n            this.contentGroup.translationY = this.centerY;\r\n            this.highlightGroup.translationX = this.centerX;\r\n            this.highlightGroup.translationY = this.centerY;\r\n            this.backgroundGroup.translationX = this.centerX;\r\n            this.backgroundGroup.translationY = this.centerY;\r\n            if (this.labelGroup) {\r\n                this.labelGroup.translationX = this.centerX;\r\n                this.labelGroup.translationY = this.centerY;\r\n            }\r\n            if (title) {\r\n                const dy = this.getTitleTranslationY();\r\n                const titleBox = title.node.computeBBox();\r\n                title.node.visible =\r\n                    title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\r\n                title.node.translationY = isFinite(dy) ? dy : 0;\r\n            }\r\n            this.updateNodeMidPoint();\r\n            yield this.updateSelections();\r\n            yield this.updateNodes(seriesRect);\r\n        });\r\n    }\r\n    updateTitleNodes() {\r\n        var _a, _b;\r\n        const { title, oldTitle } = this;\r\n        if (oldTitle !== title) {\r\n            if (oldTitle) {\r\n                (_a = this.labelGroup) === null || _a === void 0 ? void 0 : _a.removeChild(oldTitle.node);\r\n            }\r\n            if (title) {\r\n                title.node.textBaseline = 'bottom';\r\n                (_b = this.labelGroup) === null || _b === void 0 ? void 0 : _b.appendChild(title.node);\r\n            }\r\n            this.oldTitle = title;\r\n        }\r\n    }\r\n    updateNodeMidPoint() {\r\n        this.nodeData.forEach((d) => {\r\n            const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\r\n            d.midPoint = {\r\n                x: d.midCos * Math.max(0, radius),\r\n                y: d.midSin * Math.max(0, radius),\r\n            };\r\n        });\r\n    }\r\n    updateSelections() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.updateGroupSelection();\r\n            this.updateInnerCircleSelection();\r\n        });\r\n    }\r\n    updateGroupSelection() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { itemSelection, highlightSelection, calloutLabelSelection, sectorLabelSelection, innerLabelsSelection } = this;\r\n            const update = (selection, clone) => {\r\n                let nodeData = this.nodeData;\r\n                if (clone) {\r\n                    // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\r\n                    // between normal and highlighted cases.\r\n                    nodeData = nodeData.map((datum) => (Object.assign(Object.assign({}, datum), { sectorFormat: Object.assign({}, datum.sectorFormat) })));\r\n                }\r\n                selection.update(nodeData);\r\n                if (this.ctx.animationManager.isSkipped()) {\r\n                    selection.cleanup();\r\n                }\r\n            };\r\n            update(itemSelection, false);\r\n            update(highlightSelection, true);\r\n            calloutLabelSelection.update(this.nodeData, (group) => {\r\n                const line = new Line();\r\n                line.tag = PieNodeTag.Callout;\r\n                line.pointerEvents = PointerEvents.None;\r\n                group.appendChild(line);\r\n                const text = new Text();\r\n                text.tag = PieNodeTag.Label;\r\n                text.pointerEvents = PointerEvents.None;\r\n                group.appendChild(text);\r\n            });\r\n            sectorLabelSelection.update(this.nodeData, (node) => {\r\n                node.pointerEvents = PointerEvents.None;\r\n            });\r\n            innerLabelsSelection.update(this.innerLabels, (node) => {\r\n                node.pointerEvents = PointerEvents.None;\r\n            });\r\n        });\r\n    }\r\n    updateInnerCircleSelection() {\r\n        const { innerCircle } = this;\r\n        let radius = 0;\r\n        const innerRadius = this.getInnerRadius();\r\n        if (innerRadius > 0) {\r\n            const circleRadius = Math.min(innerRadius, this.getOuterRadius());\r\n            const antiAliasingPadding = 1;\r\n            radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\r\n        }\r\n        const datums = innerCircle ? [{ radius }] : [];\r\n        this.innerCircleSelection.update(datums);\r\n    }\r\n    updateNodes(seriesRect) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\r\n            const isVisible = this.seriesItemEnabled.indexOf(true) >= 0;\r\n            this.rootGroup.visible = isVisible;\r\n            this.backgroundGroup.visible = isVisible;\r\n            this.contentGroup.visible = isVisible;\r\n            this.highlightGroup.visible = isVisible && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this;\r\n            if (this.labelGroup) {\r\n                this.labelGroup.visible = isVisible;\r\n            }\r\n            this.contentGroup.opacity = this.getOpacity();\r\n            this.innerCircleSelection.each((node, { radius }) => {\r\n                var _a, _b;\r\n                node.setProperties({\r\n                    fill: (_a = this.innerCircle) === null || _a === void 0 ? void 0 : _a.fill,\r\n                    opacity: (_b = this.innerCircle) === null || _b === void 0 ? void 0 : _b.fillOpacity,\r\n                    size: radius,\r\n                });\r\n            });\r\n            const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\r\n                const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\r\n                datum.sectorFormat.fill = format.fill;\r\n                datum.sectorFormat.stroke = format.stroke;\r\n                const animationDisabled = this.ctx.animationManager.isSkipped();\r\n                if (animationDisabled) {\r\n                    sector.startAngle = datum.startAngle;\r\n                    sector.endAngle = datum.endAngle;\r\n                    sector.innerRadius = datum.innerRadius;\r\n                    sector.outerRadius = datum.outerRadius;\r\n                }\r\n                if (isDatumHighlighted || animationDisabled) {\r\n                    sector.fill = format.fill;\r\n                    sector.stroke = format.stroke;\r\n                }\r\n                sector.strokeWidth = format.strokeWidth;\r\n                sector.fillOpacity = format.fillOpacity;\r\n                sector.strokeOpacity = this.strokeOpacity;\r\n                sector.lineDash = this.lineDash;\r\n                sector.lineDashOffset = this.lineDashOffset;\r\n                sector.fillShadow = this.shadow;\r\n                sector.lineJoin = 'round';\r\n            };\r\n            this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\r\n            this.highlightSelection.each((node, datum, index) => {\r\n                const isDatumHighlighted = (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;\r\n                updateSectorFn(node, datum, index, isDatumHighlighted);\r\n                node.visible = isDatumHighlighted;\r\n            });\r\n            this.updateCalloutLineNodes();\r\n            this.updateCalloutLabelNodes(seriesRect);\r\n            this.updateSectorLabelNodes();\r\n            this.updateInnerLabelNodes();\r\n            this.animationState.transition('update');\r\n        });\r\n    }\r\n    updateCalloutLineNodes() {\r\n        var _a;\r\n        const { calloutLine } = this;\r\n        const calloutLength = calloutLine.length;\r\n        const calloutStrokeWidth = calloutLine.strokeWidth;\r\n        const calloutColors = (_a = calloutLine.colors) !== null && _a !== void 0 ? _a : this.strokes;\r\n        const { offset } = this.calloutLabel;\r\n        this.calloutLabelSelection.selectByTag(PieNodeTag.Callout).forEach((line, index) => {\r\n            const datum = line.datum;\r\n            const { calloutLabel: label, outerRadius } = datum;\r\n            if ((label === null || label === void 0 ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {\r\n                line.visible = true;\r\n                line.strokeWidth = calloutStrokeWidth;\r\n                line.stroke = calloutColors[index % calloutColors.length];\r\n                line.fill = undefined;\r\n                const x1 = datum.midCos * outerRadius;\r\n                const y1 = datum.midSin * outerRadius;\r\n                let x2 = datum.midCos * (outerRadius + calloutLength);\r\n                let y2 = datum.midSin * (outerRadius + calloutLength);\r\n                const isMoved = label.collisionTextAlign || label.collisionOffsetY !== 0;\r\n                if (isMoved && label.box != null) {\r\n                    // Get the closest point to the text bounding box\r\n                    const box = label.box;\r\n                    let cx = x2;\r\n                    let cy = y2;\r\n                    if (x2 < box.x) {\r\n                        cx = box.x;\r\n                    }\r\n                    else if (x2 > box.x + box.width) {\r\n                        cx = box.x + box.width;\r\n                    }\r\n                    if (y2 < box.y) {\r\n                        cy = box.y;\r\n                    }\r\n                    else if (y2 > box.y + box.height) {\r\n                        cy = box.y + box.height;\r\n                    }\r\n                    // Apply label offset\r\n                    const dx = cx - x2;\r\n                    const dy = cy - y2;\r\n                    const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n                    const paddedLength = length - offset;\r\n                    if (paddedLength > 0) {\r\n                        x2 = x2 + (dx * paddedLength) / length;\r\n                        y2 = y2 + (dy * paddedLength) / length;\r\n                    }\r\n                }\r\n                line.x1 = x1;\r\n                line.y1 = y1;\r\n                line.x2 = x2;\r\n                line.y2 = y2;\r\n            }\r\n            else {\r\n                line.visible = false;\r\n            }\r\n        });\r\n    }\r\n    getLabelOverflow(text, box, seriesRect) {\r\n        const seriesLeft = seriesRect.x - this.centerX;\r\n        const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\r\n        const seriesTop = seriesRect.y - this.centerY;\r\n        const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\r\n        const errPx = 1; // Prevents errors related to floating point calculations\r\n        let visibleTextPart = 1;\r\n        if (box.x + errPx < seriesLeft) {\r\n            visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\r\n        }\r\n        else if (box.x + box.width - errPx > seriesRight) {\r\n            visibleTextPart = (seriesRight - box.x) / box.width;\r\n        }\r\n        const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\r\n        const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\r\n        const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\r\n        return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\r\n    }\r\n    bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\r\n        const { surroundingRadius } = this;\r\n        if (surroundingRadius == null) {\r\n            return false;\r\n        }\r\n        const corners = [\r\n            { x: box.x + dx, y: box.y + dy },\r\n            { x: box.x + box.width + dx, y: box.y + dy },\r\n            { x: box.x + box.width + dx, y: box.y + box.height + dy },\r\n            { x: box.x + dx, y: box.y + box.height + dy },\r\n        ];\r\n        const sur2 = Math.pow(surroundingRadius, 2);\r\n        return corners.some((corner) => Math.pow(corner.x, 2) + Math.pow(corner.y, 2) > sur2);\r\n    }\r\n    computeCalloutLabelCollisionOffsets() {\r\n        const { radiusScale, calloutLabel, calloutLine } = this;\r\n        const { offset, minSpacing } = calloutLabel;\r\n        const innerRadius = radiusScale.convert(0);\r\n        const shouldSkip = (datum) => {\r\n            const label = datum.calloutLabel;\r\n            return !label || datum.outerRadius === 0;\r\n        };\r\n        const fullData = this.nodeData;\r\n        const data = this.nodeData.filter((t) => !shouldSkip(t));\r\n        data.forEach((datum) => {\r\n            const label = datum.calloutLabel;\r\n            if (label == null)\r\n                return;\r\n            label.hidden = false;\r\n            label.collisionTextAlign = undefined;\r\n            label.collisionOffsetY = 0;\r\n        });\r\n        if (data.length <= 1) {\r\n            return;\r\n        }\r\n        const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\r\n        const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\r\n        const topLabels = data\r\n            .filter((d) => { var _a; return d.midSin < 0 && ((_a = d.calloutLabel) === null || _a === void 0 ? void 0 : _a.textAlign) === 'center'; })\r\n            .sort((a, b) => a.midCos - b.midCos);\r\n        const bottomLabels = data\r\n            .filter((d) => { var _a; return d.midSin >= 0 && ((_a = d.calloutLabel) === null || _a === void 0 ? void 0 : _a.textAlign) === 'center'; })\r\n            .sort((a, b) => a.midCos - b.midCos);\r\n        const tempTextNode = new Text();\r\n        const getTextBBox = (datum) => {\r\n            var _a;\r\n            const label = datum.calloutLabel;\r\n            if (label == null)\r\n                return new BBox(0, 0, 0, 0);\r\n            const labelRadius = datum.outerRadius + calloutLine.length + offset;\r\n            const x = datum.midCos * labelRadius;\r\n            const y = datum.midSin * labelRadius + label.collisionOffsetY;\r\n            tempTextNode.text = label.text;\r\n            tempTextNode.x = x;\r\n            tempTextNode.y = y;\r\n            tempTextNode.setFont(this.calloutLabel);\r\n            tempTextNode.setAlign({\r\n                textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\r\n                textBaseline: label.textBaseline,\r\n            });\r\n            return tempTextNode.computeBBox();\r\n        };\r\n        const avoidNeighbourYCollision = (label, next, direction) => {\r\n            const box = getTextBBox(label).grow(minSpacing / 2);\r\n            const other = getTextBBox(next).grow(minSpacing / 2);\r\n            // The full collision is not detected, because sometimes\r\n            // the next label can appear behind the label with offset\r\n            const collidesOrBehind = box.x < other.x + other.width &&\r\n                box.x + box.width > other.x &&\r\n                (direction === 'to-top' ? box.y < other.y + other.height : box.y + box.height > other.y);\r\n            if (collidesOrBehind) {\r\n                const dy = direction === 'to-top' ? box.y - other.y - other.height : box.y + box.height - other.y;\r\n                next.calloutLabel.collisionOffsetY = dy;\r\n            }\r\n        };\r\n        const avoidYCollisions = (labels) => {\r\n            const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\r\n            const midIndex = labels.indexOf(midLabel);\r\n            for (let i = midIndex - 1; i >= 0; i--) {\r\n                const prev = labels[i + 1];\r\n                const next = labels[i];\r\n                avoidNeighbourYCollision(prev, next, 'to-top');\r\n            }\r\n            for (let i = midIndex + 1; i < labels.length; i++) {\r\n                const prev = labels[i - 1];\r\n                const next = labels[i];\r\n                avoidNeighbourYCollision(prev, next, 'to-bottom');\r\n            }\r\n        };\r\n        const avoidXCollisions = (labels) => {\r\n            const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\r\n            const boxes = labels.map((label) => getTextBBox(label));\r\n            const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\r\n            let labelsCollideLabelsByX = false;\r\n            for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\r\n                const box = paddedBoxes[i];\r\n                for (let j = i + 1; j < labels.length; j++) {\r\n                    const other = paddedBoxes[j];\r\n                    if (box.collidesBBox(other)) {\r\n                        labelsCollideLabelsByX = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            const sectors = fullData.map((datum) => {\r\n                const { startAngle, endAngle, outerRadius } = datum;\r\n                return { startAngle, endAngle, innerRadius, outerRadius };\r\n            });\r\n            const labelsCollideSectors = boxes.some((box) => {\r\n                return sectors.some((sector) => boxCollidesSector(box, sector));\r\n            });\r\n            if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\r\n                return;\r\n            }\r\n            labels\r\n                .filter((d) => d.calloutLabel.textAlign === 'center')\r\n                .forEach((d) => {\r\n                const label = d.calloutLabel;\r\n                if (d.midCos < 0) {\r\n                    label.collisionTextAlign = 'right';\r\n                }\r\n                else if (d.midCos > 0) {\r\n                    label.collisionTextAlign = 'left';\r\n                }\r\n                else {\r\n                    label.collisionTextAlign = 'center';\r\n                }\r\n            });\r\n        };\r\n        avoidYCollisions(leftLabels);\r\n        avoidYCollisions(rightLabels);\r\n        avoidXCollisions(topLabels);\r\n        avoidXCollisions(bottomLabels);\r\n    }\r\n    updateCalloutLabelNodes(seriesRect) {\r\n        const { radiusScale, calloutLabel, calloutLine } = this;\r\n        const calloutLength = calloutLine.length;\r\n        const { offset, color } = calloutLabel;\r\n        const tempTextNode = new Text();\r\n        this.calloutLabelSelection.selectByTag(PieNodeTag.Label).forEach((text) => {\r\n            var _a;\r\n            const { datum } = text;\r\n            const label = datum.calloutLabel;\r\n            const radius = radiusScale.convert(datum.radius);\r\n            const outerRadius = Math.max(0, radius);\r\n            if (!(label === null || label === void 0 ? void 0 : label.text) || outerRadius === 0 || label.hidden) {\r\n                text.visible = false;\r\n                return;\r\n            }\r\n            const labelRadius = outerRadius + calloutLength + offset;\r\n            const x = datum.midCos * labelRadius;\r\n            const y = datum.midSin * labelRadius + label.collisionOffsetY;\r\n            // Detect text overflow\r\n            const align = {\r\n                textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\r\n                textBaseline: label.textBaseline,\r\n            };\r\n            tempTextNode.text = label.text;\r\n            tempTextNode.x = x;\r\n            tempTextNode.y = y;\r\n            tempTextNode.setFont(this.calloutLabel);\r\n            tempTextNode.setAlign(align);\r\n            const box = tempTextNode.computeBBox();\r\n            let displayText = label.text;\r\n            let visible = true;\r\n            if (calloutLabel.avoidCollisions) {\r\n                const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\r\n                displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}…`;\r\n                visible = !hasVerticalOverflow;\r\n            }\r\n            text.text = displayText;\r\n            text.x = x;\r\n            text.y = y;\r\n            text.setFont(this.calloutLabel);\r\n            text.setAlign(align);\r\n            text.fill = color;\r\n            text.visible = visible;\r\n        });\r\n    }\r\n    computeLabelsBBox(options, seriesRect) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { calloutLabel, calloutLine } = this;\r\n            const calloutLength = calloutLine.length;\r\n            const { offset, maxCollisionOffset, minSpacing } = calloutLabel;\r\n            if (!calloutLabel.avoidCollisions) {\r\n                return null;\r\n            }\r\n            yield this.maybeRefreshNodeData();\r\n            this.updateRadiusScale(false);\r\n            this.computeCalloutLabelCollisionOffsets();\r\n            const textBoxes = [];\r\n            const text = new Text();\r\n            let titleBox;\r\n            if (((_a = this.title) === null || _a === void 0 ? void 0 : _a.text) && this.title.enabled) {\r\n                const dy = this.getTitleTranslationY();\r\n                if (isFinite(dy)) {\r\n                    text.text = this.title.text;\r\n                    text.x = 0;\r\n                    text.y = dy;\r\n                    text.setFont(this.title);\r\n                    text.setAlign({\r\n                        textBaseline: 'bottom',\r\n                        textAlign: 'center',\r\n                    });\r\n                    titleBox = text.computeBBox();\r\n                    textBoxes.push(titleBox);\r\n                }\r\n            }\r\n            this.nodeData.forEach((datum) => {\r\n                var _a;\r\n                const label = datum.calloutLabel;\r\n                if (!label || datum.outerRadius === 0) {\r\n                    return null;\r\n                }\r\n                const labelRadius = datum.outerRadius + calloutLength + offset;\r\n                const x = datum.midCos * labelRadius;\r\n                const y = datum.midSin * labelRadius + label.collisionOffsetY;\r\n                text.text = label.text;\r\n                text.x = x;\r\n                text.y = y;\r\n                text.setFont(this.calloutLabel);\r\n                text.setAlign({\r\n                    textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\r\n                    textBaseline: label.textBaseline,\r\n                });\r\n                const box = text.computeBBox();\r\n                label.box = box;\r\n                // Hide labels that where pushed too far by the collision avoidance algorithm\r\n                if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\r\n                    label.hidden = true;\r\n                    return;\r\n                }\r\n                // Hide labels intersecting or above the title\r\n                if (titleBox) {\r\n                    const seriesTop = seriesRect.y - this.centerY;\r\n                    const titleCleanArea = new BBox(titleBox.x - minSpacing, seriesTop, titleBox.width + 2 * minSpacing, titleBox.y + titleBox.height + minSpacing - seriesTop);\r\n                    if (box.collidesBBox(titleCleanArea)) {\r\n                        label.hidden = true;\r\n                        return;\r\n                    }\r\n                }\r\n                if (options.hideWhenNecessary) {\r\n                    const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\r\n                    const isTooShort = label.text.length > 2 && textLength < 2;\r\n                    if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\r\n                        label.hidden = true;\r\n                        return;\r\n                    }\r\n                }\r\n                label.hidden = false;\r\n                textBoxes.push(box);\r\n            });\r\n            if (textBoxes.length === 0) {\r\n                return null;\r\n            }\r\n            return BBox.merge(textBoxes);\r\n        });\r\n    }\r\n    updateSectorLabelNodes() {\r\n        const { radiusScale } = this;\r\n        const innerRadius = radiusScale.convert(0);\r\n        const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.sectorLabel;\r\n        const isDoughnut = innerRadius > 0;\r\n        const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\r\n        this.sectorLabelSelection.each((text, datum) => {\r\n            const { sectorLabel, outerRadius } = datum;\r\n            let isTextVisible = false;\r\n            if (sectorLabel && outerRadius !== 0) {\r\n                const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\r\n                text.fill = color;\r\n                text.fontStyle = fontStyle;\r\n                text.fontWeight = fontWeight;\r\n                text.fontSize = fontSize;\r\n                text.fontFamily = fontFamily;\r\n                text.text = sectorLabel.text;\r\n                const shouldPutTextInCenter = !isDoughnut && singleVisibleSector;\r\n                if (shouldPutTextInCenter) {\r\n                    text.x = 0;\r\n                    text.y = 0;\r\n                }\r\n                else {\r\n                    text.x = datum.midCos * labelRadius;\r\n                    text.y = datum.midSin * labelRadius;\r\n                }\r\n                text.textAlign = 'center';\r\n                text.textBaseline = 'middle';\r\n                const bbox = text.computeBBox();\r\n                const corners = [\r\n                    [bbox.x, bbox.y],\r\n                    [bbox.x + bbox.width, bbox.y],\r\n                    [bbox.x + bbox.width, bbox.y + bbox.height],\r\n                    [bbox.x, bbox.y + bbox.height],\r\n                ];\r\n                const { startAngle, endAngle } = datum;\r\n                const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\r\n                if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\r\n                    isTextVisible = true;\r\n                }\r\n            }\r\n            text.visible = isTextVisible;\r\n        });\r\n    }\r\n    updateInnerLabelNodes() {\r\n        const textBBoxes = [];\r\n        const margins = [];\r\n        this.innerLabelsSelection.each((text, datum) => {\r\n            const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\r\n            text.fontStyle = fontStyle;\r\n            text.fontWeight = fontWeight;\r\n            text.fontSize = fontSize;\r\n            text.fontFamily = fontFamily;\r\n            text.text = datum.text;\r\n            text.x = 0;\r\n            text.y = 0;\r\n            text.fill = color;\r\n            text.textAlign = 'center';\r\n            text.textBaseline = 'alphabetic';\r\n            textBBoxes.push(text.computeBBox());\r\n            margins.push(datum.margin);\r\n        });\r\n        const getMarginTop = (index) => (index === 0 ? 0 : margins[index]);\r\n        const getMarginBottom = (index) => (index === margins.length - 1 ? 0 : margins[index]);\r\n        const totalHeight = textBBoxes.reduce((sum, bbox, i) => {\r\n            return sum + bbox.height + getMarginTop(i) + getMarginBottom(i);\r\n        }, 0);\r\n        const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\r\n        const innerRadius = this.getInnerRadius();\r\n        const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\r\n        const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\r\n        const textBottoms = [];\r\n        for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\r\n            const bbox = textBBoxes[i];\r\n            const bottom = bbox.height + prev + getMarginTop(i);\r\n            textBottoms.push(bottom);\r\n            prev = bottom + getMarginBottom(i);\r\n        }\r\n        this.innerLabelsSelection.each((text, _datum, index) => {\r\n            text.y = textBottoms[index];\r\n            text.visible = labelsVisible;\r\n        });\r\n    }\r\n    getDatumLegendName(nodeDatum) {\r\n        const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this;\r\n        const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\r\n        if (legendItemKey && legendItem !== undefined) {\r\n            return legendItem.text;\r\n        }\r\n        else if (calloutLabelKey && calloutLabelKey !== angleKey && (calloutLabel === null || calloutLabel === void 0 ? void 0 : calloutLabel.text) !== undefined) {\r\n            return calloutLabel.text;\r\n        }\r\n        else if (sectorLabelKey && sectorLabelKey !== angleKey && (sectorLabel === null || sectorLabel === void 0 ? void 0 : sectorLabel.text) !== undefined) {\r\n            return sectorLabel.text;\r\n        }\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        if (!this.angleKey) {\r\n            return '';\r\n        }\r\n        const { datum, angleValue, sectorFormat: { fill: color }, } = nodeDatum;\r\n        const title = sanitizeHtml((_a = this.title) === null || _a === void 0 ? void 0 : _a.text);\r\n        const content = isNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\r\n        const labelText = this.getDatumLegendName(nodeDatum);\r\n        return this.tooltip.toTooltipHtml({\r\n            title: title !== null && title !== void 0 ? title : labelText,\r\n            content: title && labelText ? `${labelText}: ${content}` : content,\r\n            backgroundColor: color,\r\n        }, {\r\n            datum,\r\n            title,\r\n            color,\r\n            seriesId: this.id,\r\n            angleKey: this.angleKey,\r\n            angleName: this.angleName,\r\n            radiusKey: this.radiusKey,\r\n            radiusName: this.radiusName,\r\n            calloutLabelKey: this.calloutLabelKey,\r\n            calloutLabelName: this.calloutLabelName,\r\n            sectorLabelKey: this.sectorLabelKey,\r\n            sectorLabelName: this.sectorLabelName,\r\n        });\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { processedData, angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, id, dataModel } = this;\r\n        if (!dataModel || !processedData || processedData.data.length === 0 || legendType !== 'category')\r\n            return [];\r\n        if (!legendItemKey &&\r\n            (!calloutLabelKey || calloutLabelKey === angleKey) &&\r\n            (!sectorLabelKey || sectorLabelKey === angleKey))\r\n            return [];\r\n        const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\r\n        const titleText = ((_a = this.title) === null || _a === void 0 ? void 0 : _a.showInLegend) && this.title.text;\r\n        const legendData = [];\r\n        for (let index = 0; index < processedData.data.length; index++) {\r\n            const { datum, values } = processedData.data[index];\r\n            const labelParts = [];\r\n            if (titleText) {\r\n                labelParts.push(titleText);\r\n            }\r\n            const labels = this.getLabels(datum, 2 * Math.PI, 2 * Math.PI, false, values[calloutLabelIdx], values[sectorLabelIdx], values[legendItemIdx]);\r\n            if (legendItemKey && labels.legendItem !== undefined) {\r\n                labelParts.push(labels.legendItem.text);\r\n            }\r\n            else if (calloutLabelKey && calloutLabelKey !== angleKey && ((_b = labels.calloutLabel) === null || _b === void 0 ? void 0 : _b.text) !== undefined) {\r\n                labelParts.push((_c = labels.calloutLabel) === null || _c === void 0 ? void 0 : _c.text);\r\n            }\r\n            else if (sectorLabelKey && sectorLabelKey !== angleKey && ((_d = labels.sectorLabel) === null || _d === void 0 ? void 0 : _d.text) !== undefined) {\r\n                labelParts.push((_e = labels.sectorLabel) === null || _e === void 0 ? void 0 : _e.text);\r\n            }\r\n            if (labelParts.length === 0)\r\n                continue;\r\n            const sectorFormat = this.getSectorFormat(datum, index, false);\r\n            legendData.push({\r\n                legendType: 'category',\r\n                id,\r\n                itemId: index,\r\n                seriesId: id,\r\n                enabled: this.seriesItemEnabled[index],\r\n                label: {\r\n                    text: labelParts.join(' - '),\r\n                },\r\n                marker: {\r\n                    fill: sectorFormat.fill,\r\n                    stroke: sectorFormat.stroke,\r\n                    fillOpacity: this.fillOpacity,\r\n                    strokeOpacity: this.strokeOpacity,\r\n                    strokeWidth: this.strokeWidth,\r\n                },\r\n            });\r\n        }\r\n        return legendData;\r\n    }\r\n    onLegendItemClick(event) {\r\n        const { enabled, itemId, series } = event;\r\n        if (series.id === this.id) {\r\n            this.toggleSeriesItem(itemId, enabled);\r\n        }\r\n        else if (series.type === 'pie') {\r\n            this.toggleOtherSeriesItems(series, itemId, enabled);\r\n        }\r\n    }\r\n    toggleSeriesItem(itemId, enabled) {\r\n        this.seriesItemEnabled[itemId] = enabled;\r\n        this.nodeDataRefresh = true;\r\n    }\r\n    toggleOtherSeriesItems(series, itemId, enabled) {\r\n        var _a, _b;\r\n        const { legendItemKey, dataModel } = this;\r\n        if (!legendItemKey || !dataModel)\r\n            return;\r\n        const datumToggledLegendItemValue = series.legendItemKey && ((_a = series.data) === null || _a === void 0 ? void 0 : _a.find((_, index) => index === itemId)[series.legendItemKey]);\r\n        if (!datumToggledLegendItemValue)\r\n            return;\r\n        const legendItemIdx = dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index;\r\n        (_b = this.processedData) === null || _b === void 0 ? void 0 : _b.data.forEach(({ values }, datumItemId) => {\r\n            if (values[legendItemIdx] === datumToggledLegendItemValue) {\r\n                this.toggleSeriesItem(datumItemId, enabled);\r\n            }\r\n        });\r\n    }\r\n    animateEmptyUpdateReady(_data) {\r\n        const { animationManager } = this.ctx;\r\n        const fns = preparePieSeriesAnimationFunctions(true, this.rotation, this.radiusScale, this.previousRadiusScale);\r\n        fromToMotion(this.id, 'nodes', animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);\r\n        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\r\n        seriesLabelFadeInAnimation(this, 'callout', animationManager, [this.calloutLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'sector', animationManager, [this.sectorLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'inner', animationManager, [this.innerLabelsSelection]);\r\n        this.previousRadiusScale.range = this.radiusScale.range;\r\n    }\r\n    animateWaitingUpdateReady() {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;\r\n        const { animationManager } = this.ctx;\r\n        const diff = (_a = processedData === null || processedData === void 0 ? void 0 : processedData.reduced) === null || _a === void 0 ? void 0 : _a.diff;\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        const supportedDiff = ((_b = diff === null || diff === void 0 ? void 0 : diff.moved.length) !== null && _b !== void 0 ? _b : 0) === 0 && (diff === null || diff === void 0 ? void 0 : diff.addedIndices.every((i) => !diff.removedIndices.includes(i)));\r\n        const hasKeys = ((_c = processedData === null || processedData === void 0 ? void 0 : processedData.defs.keys.length) !== null && _c !== void 0 ? _c : 0) > 0;\r\n        const hasUniqueKeys = (_f = (_e = (_d = processedData === null || processedData === void 0 ? void 0 : processedData.reduced) === null || _d === void 0 ? void 0 : _d.animationValidation) === null || _e === void 0 ? void 0 : _e.uniqueKeys) !== null && _f !== void 0 ? _f : true;\r\n        if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n        const fns = preparePieSeriesAnimationFunctions(false, this.rotation, radiusScale, previousRadiusScale);\r\n        fromToMotion(this.id, 'nodes', animationManager, [itemSelection, highlightSelection], fns.nodes, (_, datum) => this.getDatumId(datum), diff);\r\n        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\r\n        seriesLabelFadeInAnimation(this, 'callout', this.ctx.animationManager, [this.calloutLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'sector', this.ctx.animationManager, [this.sectorLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'inner', this.ctx.animationManager, [this.innerLabelsSelection]);\r\n        this.previousRadiusScale.range = this.radiusScale.range;\r\n    }\r\n    animateClearingUpdateEmpty() {\r\n        const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;\r\n        const { animationManager } = this.ctx;\r\n        const fns = preparePieSeriesAnimationFunctions(false, this.rotation, radiusScale, previousRadiusScale);\r\n        fromToMotion(this.id, 'nodes', animationManager, [itemSelection, highlightSelection], fns.nodes);\r\n        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\r\n        seriesLabelFadeOutAnimation(this, 'callout', this.ctx.animationManager, [this.calloutLabelSelection]);\r\n        seriesLabelFadeOutAnimation(this, 'sector', this.ctx.animationManager, [this.sectorLabelSelection]);\r\n        seriesLabelFadeOutAnimation(this, 'inner', this.ctx.animationManager, [this.innerLabelsSelection]);\r\n        this.previousRadiusScale.range = this.radiusScale.range;\r\n    }\r\n    getDatumIdFromData(datum) {\r\n        var _a, _b, _c;\r\n        const { calloutLabelKey, sectorLabelKey, legendItemKey } = this;\r\n        if (!((_c = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.animationValidation) === null || _c === void 0 ? void 0 : _c.uniqueKeys)) {\r\n            return undefined;\r\n        }\r\n        if (legendItemKey) {\r\n            return datum[legendItemKey];\r\n        }\r\n        else if (calloutLabelKey) {\r\n            return datum[calloutLabelKey];\r\n        }\r\n        else if (sectorLabelKey) {\r\n            return datum[sectorLabelKey];\r\n        }\r\n    }\r\n    getDatumId(datum) {\r\n        var _a;\r\n        const { index } = datum;\r\n        return (_a = this.getDatumIdFromData(datum.datum)) !== null && _a !== void 0 ? _a : `${index}`;\r\n    }\r\n    onDataChange() {\r\n        this.processSeriesItemEnabled();\r\n    }\r\n}\r\nPieSeries.className = 'PieSeries';\r\nPieSeries.type = 'pie';\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"angleKey\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"angleName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"radiusKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"radiusName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeries.prototype, \"radiusMin\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeries.prototype, \"radiusMax\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"calloutLabelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"calloutLabelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"sectorLabelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"sectorLabelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"legendItemKey\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeries.prototype, \"fills\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeries.prototype, \"strokes\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], PieSeries.prototype, \"formatter\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(-360, 360)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"outerRadiusOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"outerRadiusRatio\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"innerRadiusOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"innerRadiusRatio\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"strokeWidth\", void 0);\n\nconst JSON_APPLY_PLUGINS = {\r\n    constructors: {},\r\n    constructedArrays: new WeakMap(),\r\n};\r\nfunction assignJsonApplyConstructedArray(array, ctor) {\r\n    var _a;\r\n    (_a = JSON_APPLY_PLUGINS.constructedArrays) === null || _a === void 0 ? void 0 : _a.set(array, ctor);\r\n}\r\nconst JSON_APPLY_OPTIONS = {\r\n    constructors: {\r\n        title: Caption,\r\n        subtitle: Caption,\r\n        footnote: Caption,\r\n        shadow: DropShadow,\r\n        innerCircle: DoughnutInnerCircle,\r\n        'axes[].title': AxisTitle,\r\n        'series[].innerLabels[]': DoughnutInnerLabel,\r\n    },\r\n    allowedTypes: {\r\n        'legend.pagination.marker.shape': ['primitive', 'function'],\r\n        'series[].marker.shape': ['primitive', 'function'],\r\n        'axis[].tick.count': ['primitive', 'class-instance'],\r\n    },\r\n};\r\nfunction getJsonApplyOptions() {\r\n    return {\r\n        constructors: Object.assign(Object.assign({}, JSON_APPLY_OPTIONS.constructors), JSON_APPLY_PLUGINS.constructors),\r\n        constructedArrays: JSON_APPLY_PLUGINS.constructedArrays,\r\n        allowedTypes: Object.assign({}, JSON_APPLY_OPTIONS.allowedTypes),\r\n    };\r\n}\n\nclass Range extends Shape {\r\n    constructor(opts = {}) {\r\n        super(opts);\r\n        this.x1 = 0;\r\n        this.y1 = 0;\r\n        this.x2 = 0;\r\n        this.y2 = 0;\r\n        this.startLine = false;\r\n        this.endLine = false;\r\n        this.isRange = false;\r\n        this.restoreOwnStyles();\r\n    }\r\n    computeBBox() {\r\n        return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\r\n    }\r\n    isPointInPath(_x, _y) {\r\n        return false;\r\n    }\r\n    render(renderCtx) {\r\n        var _a;\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        let { x1, y1, x2, y2 } = this;\r\n        x1 = this.align(x1);\r\n        y1 = this.align(y1);\r\n        x2 = this.align(x2);\r\n        y2 = this.align(y2);\r\n        const { fill, opacity, isRange } = this;\r\n        const fillActive = !!(isRange && fill);\r\n        if (fillActive) {\r\n            const { fillOpacity } = this;\r\n            ctx.fillStyle = fill;\r\n            ctx.globalAlpha = opacity * fillOpacity;\r\n            ctx.beginPath();\r\n            ctx.moveTo(x1, y1);\r\n            ctx.lineTo(x2, y1);\r\n            ctx.lineTo(x2, y2);\r\n            ctx.lineTo(x1, y2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        }\r\n        const { stroke, strokeWidth, startLine, endLine } = this;\r\n        const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\r\n        if (strokeActive) {\r\n            const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\r\n            ctx.strokeStyle = stroke;\r\n            ctx.globalAlpha = opacity * strokeOpacity;\r\n            ctx.lineWidth = strokeWidth;\r\n            if (lineDash) {\r\n                ctx.setLineDash(lineDash);\r\n            }\r\n            if (lineDashOffset) {\r\n                ctx.lineDashOffset = lineDashOffset;\r\n            }\r\n            if (lineCap) {\r\n                ctx.lineCap = lineCap;\r\n            }\r\n            if (lineJoin) {\r\n                ctx.lineJoin = lineJoin;\r\n            }\r\n            ctx.beginPath();\r\n            if (startLine) {\r\n                ctx.moveTo(x1, y1);\r\n                ctx.lineTo(x2, y1);\r\n            }\r\n            if (endLine) {\r\n                ctx.moveTo(x2, y2);\r\n                ctx.lineTo(x1, y2);\r\n            }\r\n            ctx.stroke();\r\n        }\r\n        (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nRange.className = 'Range';\r\nRange.defaultStyles = Object.assign(Object.assign({}, Shape.defaultStyles), { strokeWidth: 1 });\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"x1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"y1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"x2\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"y2\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Range.prototype, \"startLine\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Range.prototype, \"endLine\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Range.prototype, \"isRange\", void 0);\n\nconst horizontalCrosslineTranslationDirections = {\r\n    top: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    left: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    right: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n    topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n    bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\r\n    insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n    insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n};\r\nconst verticalCrossLineTranslationDirections = {\r\n    top: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    left: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    right: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n    topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n    bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\r\n    insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n    insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n};\r\nfunction calculateLabelTranslation({ yDirection, padding = 0, position = 'top', bbox, }) {\r\n    const crossLineTranslationDirections = yDirection\r\n        ? horizontalCrosslineTranslationDirections\r\n        : verticalCrossLineTranslationDirections;\r\n    const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\r\n    const w = yDirection ? bbox.width : bbox.height;\r\n    const h = yDirection ? bbox.height : bbox.width;\r\n    const xTranslation = xTranslationDirection * (padding + w / 2);\r\n    const yTranslation = yTranslationDirection * (padding + h / 2);\r\n    return {\r\n        xTranslation,\r\n        yTranslation,\r\n    };\r\n}\r\nfunction calculateLabelChartPadding({ yDirection, bbox, padding = 0, position = 'top', }) {\r\n    const chartPadding = {};\r\n    if (position.startsWith('inside'))\r\n        return chartPadding;\r\n    if (position === 'top' && !yDirection) {\r\n        chartPadding.top = padding + bbox.height;\r\n    }\r\n    else if (position === 'bottom' && !yDirection) {\r\n        chartPadding.bottom = padding + bbox.height;\r\n    }\r\n    else if (position === 'left' && yDirection) {\r\n        chartPadding.left = padding + bbox.width;\r\n    }\r\n    else if (position === 'right' && yDirection) {\r\n        chartPadding.right = padding + bbox.width;\r\n    }\r\n    return chartPadding;\r\n}\r\nconst POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd / 2, y: yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n};\r\nconst POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xStart, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd / 2, y: yStart };\r\n    }\r\n};\r\nconst POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd / 2, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n};\r\nconst POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd / 2, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n    else {\r\n        return { x: xStart, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n};\r\nconst POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\r\n    return { x: xEnd / 2, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n};\r\nconst POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {\r\n    if (yDirection) {\r\n        return { x: xStart / 2, y: yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd, y: yStart };\r\n    }\r\n};\r\nconst POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xStart, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n    else {\r\n        return { x: xStart, y: yStart };\r\n    }\r\n};\r\nconst POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd, y: yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n};\r\nconst POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n    else {\r\n        return { x: xStart, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n};\r\nconst labeldDirectionHandling = {\r\n    top: { c: POSITION_TOP_COORDINATES },\r\n    bottom: { c: POSITION_BOTTOM_COORDINATES },\r\n    left: { c: POSITION_LEFT_COORDINATES },\r\n    right: { c: POSITION_RIGHT_COORDINATES },\r\n    topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\r\n    topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\r\n    bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\r\n    bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\r\n    inside: { c: POSITION_INSIDE_COORDINATES },\r\n    insideLeft: { c: POSITION_LEFT_COORDINATES },\r\n    insideRight: { c: POSITION_RIGHT_COORDINATES },\r\n    insideTop: { c: POSITION_TOP_COORDINATES },\r\n    insideBottom: { c: POSITION_BOTTOM_COORDINATES },\r\n    insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\r\n    insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\r\n    insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\r\n    insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\r\n};\n\nconst CROSSLINE_LABEL_POSITIONS = [\r\n    'top',\r\n    'left',\r\n    'right',\r\n    'bottom',\r\n    'topLeft',\r\n    'topRight',\r\n    'bottomLeft',\r\n    'bottomRight',\r\n    'inside',\r\n    'insideLeft',\r\n    'insideRight',\r\n    'insideTop',\r\n    'insideBottom',\r\n    'insideTopLeft',\r\n    'insideBottomLeft',\r\n    'insideTopRight',\r\n    'insideBottomRight',\r\n];\r\nconst OPT_CROSSLINE_LABEL_POSITION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v) => CROSSLINE_LABEL_POSITIONS.includes(v)), `expecting an optional crossLine label position keyword such as 'topLeft', 'topRight' or 'inside'`);\r\nconst OPT_CROSSLINE_TYPE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v) => v === 'range' || v === 'line'), `expecting a crossLine type keyword such as 'range' or 'line'`);\r\nclass CartesianCrossLineLabel {\r\n    constructor() {\r\n        this.enabled = undefined;\r\n        this.text = undefined;\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 14;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n        /**\r\n         * The padding between the label and the line.\r\n         */\r\n        this.padding = 5;\r\n        /**\r\n         * The color of the labels.\r\n         */\r\n        this.color = 'rgba(87, 87, 87, 1)';\r\n        this.position = undefined;\r\n        this.rotation = undefined;\r\n        this.parallel = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianCrossLineLabel.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLineLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLineLabel.prototype, \"padding\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_CROSSLINE_LABEL_POSITION),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"position\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(-360, 360)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLineLabel.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianCrossLineLabel.prototype, \"parallel\", void 0);\r\nclass CartesianCrossLine {\r\n    constructor() {\r\n        this.id = createId(this);\r\n        this.enabled = undefined;\r\n        this.type = undefined;\r\n        this.range = undefined;\r\n        this.value = undefined;\r\n        this.fill = undefined;\r\n        this.fillOpacity = undefined;\r\n        this.stroke = undefined;\r\n        this.strokeWidth = undefined;\r\n        this.strokeOpacity = undefined;\r\n        this.lineDash = undefined;\r\n        this.label = new CartesianCrossLineLabel();\r\n        this.scale = undefined;\r\n        this.clippedRange = [-Infinity, Infinity];\r\n        this.gridLength = 0;\r\n        this.sideFlag = -1;\r\n        this.parallelFlipRotation = 0;\r\n        this.regularFlipRotation = 0;\r\n        this.direction = ChartAxisDirection.X;\r\n        this.group = new Group({ name: `${this.id}`, layer: true, zIndex: CartesianCrossLine.LINE_LAYER_ZINDEX });\r\n        this.crossLineRange = new Range();\r\n        this.crossLineLabel = new Text();\r\n        this.labelPoint = undefined;\r\n        this.data = [];\r\n        this.startLine = false;\r\n        this.endLine = false;\r\n        this.isRange = false;\r\n        const { group, crossLineRange, crossLineLabel } = this;\r\n        group.append([crossLineRange, crossLineLabel]);\r\n        crossLineRange.pointerEvents = PointerEvents.None;\r\n    }\r\n    update(visible) {\r\n        if (!this.enabled || !visible || this.data.length === 0) {\r\n            this.group.visible = false;\r\n            return;\r\n        }\r\n        this.group.visible = true;\r\n        this.group.zIndex = this.getZIndex(this.isRange);\r\n        this.updateNodes();\r\n    }\r\n    calculateLayout(visible) {\r\n        if (!visible) {\r\n            return;\r\n        }\r\n        const dataCreated = this.createNodeData();\r\n        if (!dataCreated) {\r\n            return;\r\n        }\r\n        const { sideFlag, gridLength, data } = this;\r\n        const boxes = [];\r\n        const x1 = 0;\r\n        const x2 = sideFlag * gridLength;\r\n        const y1 = data[0];\r\n        const y2 = data[1];\r\n        const crossLineBox = new BBox(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));\r\n        boxes.push(crossLineBox);\r\n        const labelBox = this.computeLabelBBox();\r\n        if (labelBox) {\r\n            boxes.push(labelBox);\r\n        }\r\n        return BBox.merge(boxes);\r\n    }\r\n    updateNodes() {\r\n        this.updateRangeNode();\r\n        if (this.label.enabled) {\r\n            this.updateLabel();\r\n            this.positionLabel();\r\n        }\r\n    }\r\n    createNodeData() {\r\n        var _a, _b;\r\n        const { scale, gridLength, sideFlag, direction, label: { position = 'top' }, clippedRange, strokeWidth = 0, } = this;\r\n        this.data = [];\r\n        if (!scale) {\r\n            return false;\r\n        }\r\n        const bandwidth = (_a = scale.bandwidth) !== null && _a !== void 0 ? _a : 0;\r\n        const clippedRangeClamper = (x) => Math.max(Math.min(...clippedRange), Math.min(Math.max(...clippedRange), x));\r\n        const [xStart, xEnd] = [0, sideFlag * gridLength];\r\n        let [yStart, yEnd] = this.getRange();\r\n        let [clampedYStart, clampedYEnd] = [\r\n            Number(scale.convert(yStart, { clampMode: 'clamped' })),\r\n            scale.convert(yEnd, { clampMode: 'clamped' }) + bandwidth,\r\n        ];\r\n        clampedYStart = clippedRangeClamper(clampedYStart);\r\n        clampedYEnd = clippedRangeClamper(clampedYEnd);\r\n        [yStart, yEnd] = [Number(scale.convert(yStart)), scale.convert(yEnd) + bandwidth];\r\n        const validRange = !isNaN(clampedYStart) &&\r\n            !isNaN(clampedYEnd) &&\r\n            (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) &&\r\n            Math.abs(clampedYEnd - clampedYStart) > 0;\r\n        if (validRange) {\r\n            const reverse = clampedYStart !== Math.min(clampedYStart, clampedYEnd);\r\n            if (reverse) {\r\n                [clampedYStart, clampedYEnd] = [\r\n                    Math.min(clampedYStart, clampedYEnd),\r\n                    Math.max(clampedYStart, clampedYEnd),\r\n                ];\r\n                [yStart, yEnd] = [yEnd, yStart];\r\n            }\r\n        }\r\n        this.isRange = validRange;\r\n        this.startLine = !isNaN(yStart) && strokeWidth > 0 && yStart === clampedYStart;\r\n        this.endLine = !isNaN(yEnd) && strokeWidth > 0 && yEnd === clampedYEnd;\r\n        if (!validRange && !this.startLine && !this.endLine) {\r\n            return false;\r\n        }\r\n        this.data = [clampedYStart, clampedYEnd];\r\n        if (this.label.enabled) {\r\n            const yDirection = direction === ChartAxisDirection.Y;\r\n            const { c = POSITION_TOP_COORDINATES } = (_b = labeldDirectionHandling[position]) !== null && _b !== void 0 ? _b : {};\r\n            const { x: labelX, y: labelY } = c({\r\n                yDirection,\r\n                xStart,\r\n                xEnd,\r\n                yStart: clampedYStart,\r\n                yEnd: clampedYEnd,\r\n            });\r\n            this.labelPoint = {\r\n                x: labelX,\r\n                y: labelY,\r\n            };\r\n        }\r\n        return true;\r\n    }\r\n    updateRangeNode() {\r\n        var _a;\r\n        const { crossLineRange, sideFlag, gridLength, data, startLine, endLine, isRange, fill, fillOpacity, stroke, strokeWidth, lineDash, } = this;\r\n        crossLineRange.x1 = 0;\r\n        crossLineRange.x2 = sideFlag * gridLength;\r\n        crossLineRange.y1 = data[0];\r\n        crossLineRange.y2 = data[1];\r\n        crossLineRange.startLine = startLine;\r\n        crossLineRange.endLine = endLine;\r\n        crossLineRange.isRange = isRange;\r\n        crossLineRange.fill = fill;\r\n        crossLineRange.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;\r\n        crossLineRange.stroke = stroke;\r\n        crossLineRange.strokeWidth = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1;\r\n        crossLineRange.strokeOpacity = (_a = this.strokeOpacity) !== null && _a !== void 0 ? _a : 1;\r\n        crossLineRange.lineDash = lineDash;\r\n    }\r\n    updateLabel() {\r\n        const { crossLineLabel, label } = this;\r\n        if (!label.text) {\r\n            return;\r\n        }\r\n        crossLineLabel.fontStyle = label.fontStyle;\r\n        crossLineLabel.fontWeight = label.fontWeight;\r\n        crossLineLabel.fontSize = label.fontSize;\r\n        crossLineLabel.fontFamily = label.fontFamily;\r\n        crossLineLabel.fill = label.color;\r\n        crossLineLabel.text = label.text;\r\n    }\r\n    positionLabel() {\r\n        const { crossLineLabel, labelPoint: { x = undefined, y = undefined } = {}, label: { parallel, rotation, position = 'top', padding = 0 }, direction, parallelFlipRotation, regularFlipRotation, } = this;\r\n        if (x === undefined || y === undefined) {\r\n            return;\r\n        }\r\n        const { defaultRotation, configuredRotation } = calculateLabelRotation({\r\n            rotation,\r\n            parallel,\r\n            regularFlipRotation,\r\n            parallelFlipRotation,\r\n        });\r\n        crossLineLabel.rotation = defaultRotation + configuredRotation;\r\n        crossLineLabel.textBaseline = 'middle';\r\n        crossLineLabel.textAlign = 'center';\r\n        const bbox = crossLineLabel.computeTransformedBBox();\r\n        if (!bbox) {\r\n            return;\r\n        }\r\n        const yDirection = direction === ChartAxisDirection.Y;\r\n        const { xTranslation, yTranslation } = calculateLabelTranslation({\r\n            yDirection,\r\n            padding,\r\n            position,\r\n            bbox,\r\n        });\r\n        crossLineLabel.translationX = x + xTranslation;\r\n        crossLineLabel.translationY = y + yTranslation;\r\n    }\r\n    getZIndex(isRange = false) {\r\n        if (isRange) {\r\n            return CartesianCrossLine.RANGE_LAYER_ZINDEX;\r\n        }\r\n        return CartesianCrossLine.LINE_LAYER_ZINDEX;\r\n    }\r\n    getRange() {\r\n        const { value, range, scale } = this;\r\n        const isContinuous = ContinuousScale.is(scale);\r\n        let [start, end] = range !== null && range !== void 0 ? range : [value, undefined];\r\n        if (!isContinuous && end === undefined) {\r\n            end = start;\r\n        }\r\n        start = checkDatum(start, isContinuous) != null ? start : undefined;\r\n        end = checkDatum(end, isContinuous) != null ? end : undefined;\r\n        if (isContinuous && start === end) {\r\n            end = undefined;\r\n        }\r\n        if (start === undefined && end !== undefined) {\r\n            start = end;\r\n            end = undefined;\r\n        }\r\n        return [start, end];\r\n    }\r\n    computeLabelBBox() {\r\n        const { label } = this;\r\n        if (!label.enabled) {\r\n            return undefined;\r\n        }\r\n        const tempText = new Text();\r\n        tempText.fontFamily = label.fontFamily;\r\n        tempText.fontSize = label.fontSize;\r\n        tempText.fontStyle = label.fontStyle;\r\n        tempText.fontWeight = label.fontWeight;\r\n        tempText.text = label.text;\r\n        const { labelPoint: { x = undefined, y = undefined } = {}, label: { parallel, rotation, position = 'top', padding = 0 }, direction, parallelFlipRotation, regularFlipRotation, } = this;\r\n        if (x === undefined || y === undefined) {\r\n            return undefined;\r\n        }\r\n        const { configuredRotation } = calculateLabelRotation({\r\n            rotation,\r\n            parallel,\r\n            regularFlipRotation,\r\n            parallelFlipRotation,\r\n        });\r\n        tempText.rotation = configuredRotation;\r\n        tempText.textBaseline = 'middle';\r\n        tempText.textAlign = 'center';\r\n        const bbox = tempText.computeTransformedBBox();\r\n        if (!bbox) {\r\n            return undefined;\r\n        }\r\n        const yDirection = direction === ChartAxisDirection.Y;\r\n        const { xTranslation, yTranslation } = calculateLabelTranslation({\r\n            yDirection,\r\n            padding,\r\n            position,\r\n            bbox,\r\n        });\r\n        tempText.translationX = x + xTranslation;\r\n        tempText.translationY = y + yTranslation;\r\n        return tempText.computeTransformedBBox();\r\n    }\r\n    calculatePadding(padding) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        const { isRange, startLine, endLine, direction, label: { padding: labelPadding = 0, position = 'top' }, } = this;\r\n        if (!isRange && !startLine && !endLine) {\r\n            return;\r\n        }\r\n        const crossLineLabelBBox = this.computeLabelBBox();\r\n        const labelX = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.x;\r\n        const labelY = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.y;\r\n        if (!crossLineLabelBBox || labelX == undefined || labelY == undefined) {\r\n            return;\r\n        }\r\n        const chartPadding = calculateLabelChartPadding({\r\n            yDirection: direction === ChartAxisDirection.Y,\r\n            padding: labelPadding,\r\n            position,\r\n            bbox: crossLineLabelBBox,\r\n        });\r\n        padding.left = Math.max((_a = padding.left) !== null && _a !== void 0 ? _a : 0, (_b = chartPadding.left) !== null && _b !== void 0 ? _b : 0);\r\n        padding.right = Math.max((_c = padding.right) !== null && _c !== void 0 ? _c : 0, (_d = chartPadding.right) !== null && _d !== void 0 ? _d : 0);\r\n        padding.top = Math.max((_e = padding.top) !== null && _e !== void 0 ? _e : 0, (_f = chartPadding.top) !== null && _f !== void 0 ? _f : 0);\r\n        padding.bottom = Math.max((_g = padding.bottom) !== null && _g !== void 0 ? _g : 0, (_h = chartPadding.bottom) !== null && _h !== void 0 ? _h : 0);\r\n    }\r\n}\r\nCartesianCrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;\r\nCartesianCrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;\r\nCartesianCrossLine.className = 'CrossLine';\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianCrossLine.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_CROSSLINE_TYPE),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLine.prototype, \"type\", void 0);\r\n__decorate([\r\n    Validate(OPT_ARRAY(2)),\r\n    __metadata(\"design:type\", Array)\r\n], CartesianCrossLine.prototype, \"range\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLine.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLine.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLine.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER()),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLine.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLine.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], CartesianCrossLine.prototype, \"lineDash\", void 0);\n\nconst identity = (x) => x;\r\nclass LogScale extends ContinuousScale {\r\n    constructor() {\r\n        super([1, 10], [0, 1]);\r\n        this.type = 'log';\r\n        this.base = 10;\r\n        this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'base'];\r\n        this.baseLog = identity;\r\n        this.basePow = identity;\r\n        this.log = (x) => {\r\n            return this.domain[0] >= 0 ? this.baseLog(x) : -this.baseLog(-x);\r\n        };\r\n        this.pow = (x) => {\r\n            return this.domain[0] >= 0 ? this.basePow(x) : -this.basePow(-x);\r\n        };\r\n        // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.\r\n        this.defaultClampMode = 'clamped';\r\n    }\r\n    toDomain(d) {\r\n        return d;\r\n    }\r\n    transform(x) {\r\n        return this.domain[0] >= 0 ? Math.log(x) : -Math.log(-x);\r\n    }\r\n    transformInvert(x) {\r\n        return this.domain[0] >= 0 ? Math.exp(x) : -Math.exp(-x);\r\n    }\r\n    update() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return;\r\n        }\r\n        this.updateLogFn();\r\n        this.updatePowFn();\r\n        if (this.nice) {\r\n            this.updateNiceDomain();\r\n        }\r\n    }\r\n    updateLogFn() {\r\n        const { base } = this;\r\n        let log;\r\n        if (base === 10) {\r\n            log = Math.log10;\r\n        }\r\n        else if (base === Math.E) {\r\n            log = Math.log;\r\n        }\r\n        else if (base === 2) {\r\n            log = Math.log2;\r\n        }\r\n        else {\r\n            const logBase = Math.log(base);\r\n            log = (x) => Math.log(x) / logBase;\r\n        }\r\n        this.baseLog = log;\r\n    }\r\n    updatePowFn() {\r\n        const { base } = this;\r\n        let pow;\r\n        if (base === 10) {\r\n            pow = LogScale.pow10;\r\n        }\r\n        else if (base === Math.E) {\r\n            pow = Math.exp;\r\n        }\r\n        else {\r\n            pow = (x) => Math.pow(base, x);\r\n        }\r\n        this.basePow = pow;\r\n    }\r\n    updateNiceDomain() {\r\n        const [d0, d1] = this.domain;\r\n        const n0 = this.pow(Math.floor(this.log(d0)));\r\n        const n1 = this.pow(Math.ceil(this.log(d1)));\r\n        this.niceDomain = [n0, n1];\r\n    }\r\n    static pow10(x) {\r\n        return x >= 0 ? Math.pow(10, x) : 1 / Math.pow(10, -x);\r\n    }\r\n    ticks() {\r\n        var _a;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : 10;\r\n        if (!this.domain || this.domain.length < 2 || count < 1) {\r\n            return [];\r\n        }\r\n        this.refresh();\r\n        const base = this.base;\r\n        const [d0, d1] = this.getDomain();\r\n        let p0 = this.log(d0);\r\n        let p1 = this.log(d1);\r\n        if (this.interval) {\r\n            const step = Math.abs(this.interval);\r\n            const absDiff = Math.abs(p1 - p0);\r\n            const ticks = range$1(p0, p1, Math.min(absDiff, step))\r\n                .map((x) => this.pow(x))\r\n                .filter((t) => t >= d0 && t <= d1);\r\n            if (!this.isDenseInterval({ start: d0, stop: d1, interval: step, count: ticks.length })) {\r\n                return ticks;\r\n            }\r\n        }\r\n        const isBaseInteger = base % 1 === 0;\r\n        const isDiffLarge = p1 - p0 >= count;\r\n        if (!isBaseInteger || isDiffLarge) {\r\n            // Returns [10^1, 10^2, 10^3, 10^4, ...]\r\n            return ticks(p0, p1, Math.min(p1 - p0, count)).map((x) => this.pow(x));\r\n        }\r\n        const ticks$1 = [];\r\n        const isPositive = d0 > 0;\r\n        p0 = Math.floor(p0) - 1;\r\n        p1 = Math.round(p1) + 1;\r\n        const min = Math.min(...this.range);\r\n        const max = Math.max(...this.range);\r\n        const availableSpacing = (max - min) / count;\r\n        let lastTickPosition = Infinity;\r\n        for (let p = p0; p <= p1; p++) {\r\n            const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\r\n            for (let k = 1; k < base; k++) {\r\n                const q = isPositive ? k : base - k + 1;\r\n                const t = this.pow(p) * q;\r\n                const tickPosition = this.convert(t);\r\n                const prevSpacing = Math.abs(lastTickPosition - tickPosition);\r\n                const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\r\n                const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\r\n                if (t >= d0 && t <= d1 && (k === 1 || fits)) {\r\n                    ticks$1.push(t);\r\n                    lastTickPosition = tickPosition;\r\n                }\r\n            }\r\n        }\r\n        return ticks$1;\r\n    }\r\n    tickFormat({ count, ticks, specifier, }) {\r\n        const { base } = this;\r\n        if (specifier == null) {\r\n            specifier = base === 10 ? '.0e' : ',';\r\n        }\r\n        if (typeof specifier === 'string') {\r\n            specifier = format(specifier);\r\n        }\r\n        if (count === Infinity) {\r\n            return specifier;\r\n        }\r\n        if (ticks == null) {\r\n            this.ticks();\r\n        }\r\n        return (d) => {\r\n            return specifier(d);\r\n        };\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LogScale.prototype, \"base\", void 0);\n\nvar DefaultTimeFormats;\r\n(function (DefaultTimeFormats) {\r\n    DefaultTimeFormats[DefaultTimeFormats[\"MILLISECOND\"] = 0] = \"MILLISECOND\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"SECOND\"] = 1] = \"SECOND\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"MINUTE\"] = 2] = \"MINUTE\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"HOUR\"] = 3] = \"HOUR\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"WEEK_DAY\"] = 4] = \"WEEK_DAY\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"SHORT_MONTH\"] = 5] = \"SHORT_MONTH\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"MONTH\"] = 6] = \"MONTH\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"SHORT_YEAR\"] = 7] = \"SHORT_YEAR\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"YEAR\"] = 8] = \"YEAR\";\r\n})(DefaultTimeFormats || (DefaultTimeFormats = {}));\r\nconst formatStrings = {\r\n    [DefaultTimeFormats.MILLISECOND]: '.%L',\r\n    [DefaultTimeFormats.SECOND]: ':%S',\r\n    [DefaultTimeFormats.MINUTE]: '%I:%M',\r\n    [DefaultTimeFormats.HOUR]: '%I %p',\r\n    [DefaultTimeFormats.WEEK_DAY]: '%a',\r\n    [DefaultTimeFormats.SHORT_MONTH]: '%b %d',\r\n    [DefaultTimeFormats.MONTH]: '%B',\r\n    [DefaultTimeFormats.SHORT_YEAR]: '%y',\r\n    [DefaultTimeFormats.YEAR]: '%Y',\r\n};\r\nfunction toNumber(x) {\r\n    return x instanceof Date ? x.getTime() : x;\r\n}\r\nclass TimeScale extends ContinuousScale {\r\n    constructor() {\r\n        super([new Date(2022, 11, 7), new Date(2022, 11, 8)], [0, 1]);\r\n        this.type = 'time';\r\n        this.cacheProps = [\r\n            'domain',\r\n            'range',\r\n            'nice',\r\n            'tickCount',\r\n            'interval',\r\n            'minTickCount',\r\n            'maxTickCount',\r\n        ];\r\n        this.year = year;\r\n        this.month = month;\r\n        this.week = sunday;\r\n        this.day = day;\r\n        this.hour = hour;\r\n        this.minute = minute;\r\n        this.second = second;\r\n        this.millisecond = millisecond;\r\n        /**\r\n         * Array of default tick intervals in the following format:\r\n         *\r\n         *     [\r\n         *         interval (unit of time),\r\n         *         number of units (step),\r\n         *         the length of that number of units in milliseconds\r\n         *     ]\r\n         */\r\n        this.tickIntervals = [\r\n            [this.second, 1, durationSecond],\r\n            [this.second, 5, 5 * durationSecond],\r\n            [this.second, 15, 15 * durationSecond],\r\n            [this.second, 30, 30 * durationSecond],\r\n            [this.minute, 1, durationMinute],\r\n            [this.minute, 5, 5 * durationMinute],\r\n            [this.minute, 15, 15 * durationMinute],\r\n            [this.minute, 30, 30 * durationMinute],\r\n            [this.hour, 1, durationHour],\r\n            [this.hour, 3, 3 * durationHour],\r\n            [this.hour, 6, 6 * durationHour],\r\n            [this.hour, 12, 12 * durationHour],\r\n            [this.day, 1, durationDay],\r\n            [this.day, 2, 2 * durationDay],\r\n            [this.week, 1, durationWeek],\r\n            [this.week, 2, 2 * durationWeek],\r\n            [this.week, 3, 3 * durationWeek],\r\n            [this.month, 1, durationMonth],\r\n            [this.month, 2, 2 * durationMonth],\r\n            [this.month, 3, 3 * durationMonth],\r\n            [this.month, 4, 4 * durationMonth],\r\n            [this.month, 6, 6 * durationMonth],\r\n            [this.year, 1, durationYear],\r\n        ];\r\n    }\r\n    toDomain(d) {\r\n        return new Date(d);\r\n    }\r\n    calculateDefaultTickFormat(ticks = []) {\r\n        let defaultTimeFormat = DefaultTimeFormats.YEAR;\r\n        const updateFormat = (format) => {\r\n            if (format < defaultTimeFormat) {\r\n                defaultTimeFormat = format;\r\n            }\r\n        };\r\n        for (const value of ticks) {\r\n            const format = this.getLowestGranularityFormat(value);\r\n            updateFormat(format);\r\n        }\r\n        const firstTick = toNumber(ticks[0]);\r\n        const lastTick = toNumber(ticks[ticks.length - 1]);\r\n        const startYear = new Date(firstTick).getFullYear();\r\n        const stopYear = new Date(lastTick).getFullYear();\r\n        const yearChange = stopYear - startYear > 0;\r\n        return this.buildFormatString(defaultTimeFormat, yearChange);\r\n    }\r\n    buildFormatString(defaultTimeFormat, yearChange) {\r\n        let formatStringArray = [formatStrings[defaultTimeFormat]];\r\n        let timeEndIndex = 0;\r\n        const domain = this.getDomain();\r\n        const start = Math.min(...domain.map(toNumber));\r\n        const stop = Math.max(...domain.map(toNumber));\r\n        const extent = stop - start;\r\n        switch (defaultTimeFormat) {\r\n            case DefaultTimeFormats.SECOND:\r\n                if (extent / durationMinute > 1) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.MINUTE]);\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.MINUTE:\r\n                if (extent / durationHour > 1) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.HOUR]);\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.HOUR:\r\n                timeEndIndex = formatStringArray.length;\r\n                if (extent / durationDay > 1) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.WEEK_DAY]);\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.WEEK_DAY:\r\n                if (extent / durationWeek > 1 || yearChange) {\r\n                    // if it's more than a week or there is a year change, don't show week day\r\n                    const weekDayIndex = formatStringArray.indexOf(formatStrings[DefaultTimeFormats.WEEK_DAY]);\r\n                    if (weekDayIndex > -1) {\r\n                        formatStringArray.splice(weekDayIndex, 1, formatStrings[DefaultTimeFormats.SHORT_MONTH]);\r\n                    }\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.SHORT_MONTH:\r\n            case DefaultTimeFormats.MONTH:\r\n                if (extent / durationYear > 1 || yearChange) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.YEAR]);\r\n                }\r\n        }\r\n        if (timeEndIndex < formatStringArray.length) {\r\n            // Insert a gap between all date components.\r\n            formatStringArray = [\r\n                ...formatStringArray.slice(0, timeEndIndex),\r\n                formatStringArray.slice(timeEndIndex).join(' '),\r\n            ];\r\n        }\r\n        if (timeEndIndex > 0) {\r\n            // Reverse order of time components, since they should be displayed in descending\r\n            // granularity.\r\n            formatStringArray = [\r\n                ...formatStringArray.slice(0, timeEndIndex).reverse(),\r\n                ...formatStringArray.slice(timeEndIndex),\r\n            ];\r\n            if (timeEndIndex < formatStringArray.length) {\r\n                // Insert a gap between time and date components.\r\n                formatStringArray.splice(timeEndIndex, 0, ' ');\r\n            }\r\n        }\r\n        return formatStringArray.join('');\r\n    }\r\n    getLowestGranularityFormat(value) {\r\n        if (this.second.floor(value) < value) {\r\n            return DefaultTimeFormats.MILLISECOND;\r\n        }\r\n        else if (this.minute.floor(value) < value) {\r\n            return DefaultTimeFormats.SECOND;\r\n        }\r\n        else if (this.hour.floor(value) < value) {\r\n            return DefaultTimeFormats.MINUTE;\r\n        }\r\n        else if (this.day.floor(value) < value) {\r\n            return DefaultTimeFormats.HOUR;\r\n        }\r\n        else if (this.month.floor(value) < value) {\r\n            if (this.week.floor(value) < value) {\r\n                return DefaultTimeFormats.WEEK_DAY;\r\n            }\r\n            return DefaultTimeFormats.SHORT_MONTH;\r\n        }\r\n        else if (this.year.floor(value) < value) {\r\n            return DefaultTimeFormats.MONTH;\r\n        }\r\n        return DefaultTimeFormats.YEAR;\r\n    }\r\n    defaultTickFormat(ticks) {\r\n        const formatString = this.calculateDefaultTickFormat(ticks);\r\n        return (date) => buildFormatter(formatString)(date);\r\n    }\r\n    /**\r\n     * @param options Tick interval options.\r\n     * @param options.start The start time (timestamp).\r\n     * @param options.stop The end time (timestamp).\r\n     * @param options.count Number of intervals between ticks.\r\n     */\r\n    getTickInterval({ start, stop, count, minCount, maxCount, }) {\r\n        const { tickIntervals } = this;\r\n        let countableTimeInterval;\r\n        let step;\r\n        const tickCount = count !== null && count !== void 0 ? count : ContinuousScale.defaultTickCount;\r\n        const target = Math.abs(stop - start) / Math.max(tickCount, 1);\r\n        let i = 0;\r\n        while (i < tickIntervals.length && target > tickIntervals[i][2]) {\r\n            i++;\r\n        }\r\n        if (i === 0) {\r\n            step = Math.max(tickStep(start, stop, tickCount, minCount, maxCount), 1);\r\n            countableTimeInterval = this.millisecond;\r\n        }\r\n        else if (i === tickIntervals.length) {\r\n            const y0 = start / durationYear;\r\n            const y1 = stop / durationYear;\r\n            step = tickStep(y0, y1, tickCount, minCount, maxCount);\r\n            countableTimeInterval = this.year;\r\n        }\r\n        else {\r\n            const diff0 = target - tickIntervals[i - 1][2];\r\n            const diff1 = tickIntervals[i][2] - target;\r\n            const index = diff0 < diff1 ? i - 1 : i;\r\n            [countableTimeInterval, step] = tickIntervals[index];\r\n        }\r\n        return countableTimeInterval.every(step);\r\n    }\r\n    invert(y) {\r\n        return new Date(super.invert(y));\r\n    }\r\n    /**\r\n     * Returns uniformly-spaced dates that represent the scale's domain.\r\n     */\r\n    ticks() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return [];\r\n        }\r\n        this.refresh();\r\n        const [t0, t1] = this.getDomain().map(toNumber);\r\n        if (this.interval !== undefined) {\r\n            return this.getTicksForInterval({ start: t0, stop: t1 });\r\n        }\r\n        if (this.nice) {\r\n            const { tickCount } = this;\r\n            if (tickCount === 2) {\r\n                return this.niceDomain;\r\n            }\r\n            if (tickCount === 1) {\r\n                return this.niceDomain.slice(0, 1);\r\n            }\r\n        }\r\n        return this.getDefaultTicks({ start: t0, stop: t1 });\r\n    }\r\n    getDefaultTicks({ start, stop }) {\r\n        const t = this.getTickInterval({\r\n            start,\r\n            stop,\r\n            count: this.tickCount,\r\n            minCount: this.minTickCount,\r\n            maxCount: this.maxTickCount,\r\n        });\r\n        return t ? t.range(new Date(start), new Date(stop)) : []; // inclusive stop\r\n    }\r\n    getTicksForInterval({ start, stop }) {\r\n        const { interval, tickIntervals } = this;\r\n        if (!interval) {\r\n            return [];\r\n        }\r\n        if (interval instanceof TimeInterval) {\r\n            const ticks = interval.range(new Date(start), new Date(stop));\r\n            if (this.isDenseInterval({ start, stop, interval, count: ticks.length })) {\r\n                return this.getDefaultTicks({ start, stop });\r\n            }\r\n            return ticks;\r\n        }\r\n        const absInterval = Math.abs(interval);\r\n        if (this.isDenseInterval({ start, stop, interval: absInterval })) {\r\n            return this.getDefaultTicks({ start, stop });\r\n        }\r\n        const reversedInterval = [...tickIntervals];\r\n        reversedInterval.reverse();\r\n        const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval[2] === 0);\r\n        if (timeInterval) {\r\n            const i = timeInterval[0].every(absInterval / (timeInterval[2] / timeInterval[1]));\r\n            return i.range(new Date(start), new Date(stop));\r\n        }\r\n        let date = new Date(start);\r\n        const stopDate = new Date(stop);\r\n        const ticks = [];\r\n        while (date <= stopDate) {\r\n            ticks.push(date);\r\n            date = new Date(date);\r\n            date.setMilliseconds(date.getMilliseconds() + absInterval);\r\n        }\r\n        return ticks;\r\n    }\r\n    /**\r\n     * Returns a time format function suitable for displaying tick values.\r\n     * @param specifier If the specifier string is provided, this method is equivalent to\r\n     * the {@link TimeLocaleObject.format} method.\r\n     * If no specifier is provided, this method returns the default time format function.\r\n     */\r\n    tickFormat({ ticks, specifier }) {\r\n        return specifier == undefined ? this.defaultTickFormat(ticks) : buildFormatter(specifier);\r\n    }\r\n    update() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return;\r\n        }\r\n        if (this.nice) {\r\n            this.updateNiceDomain();\r\n        }\r\n    }\r\n    /**\r\n     * Extends the domain so that it starts and ends on nice round values.\r\n     * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\r\n     */\r\n    updateNiceDomain() {\r\n        const maxAttempts = 4;\r\n        let [d0, d1] = this.domain;\r\n        for (let i = 0; i < maxAttempts; i++) {\r\n            this.updateNiceDomainIteration(d0, d1);\r\n            const [n0, n1] = this.niceDomain;\r\n            if (toNumber(d0) === toNumber(n0) && toNumber(d1) === toNumber(n1)) {\r\n                break;\r\n            }\r\n            d0 = n0;\r\n            d1 = n1;\r\n        }\r\n    }\r\n    updateNiceDomainIteration(d0, d1) {\r\n        const start = toNumber(d0);\r\n        const stop = toNumber(d1);\r\n        const { interval } = this;\r\n        let i;\r\n        if (interval instanceof TimeInterval) {\r\n            i = interval;\r\n        }\r\n        else {\r\n            const tickCount = typeof interval === 'number' ? (stop - start) / Math.max(interval, 1) : this.tickCount;\r\n            i = this.getTickInterval({\r\n                start,\r\n                stop,\r\n                count: tickCount,\r\n                minCount: this.minTickCount,\r\n                maxCount: this.maxTickCount,\r\n            });\r\n        }\r\n        if (i) {\r\n            const intervalRange = i.range(d0, d1, true);\r\n            const n0 = intervalRange[0];\r\n            const n1 = intervalRange[intervalRange.length - 1];\r\n            this.niceDomain = [n0, n1];\r\n        }\r\n    }\r\n}\n\nclass Padding {\r\n    constructor(top = 0, right = top, bottom = top, left = right) {\r\n        this.top = top;\r\n        this.right = right;\r\n        this.bottom = bottom;\r\n        this.left = left;\r\n    }\r\n    clear() {\r\n        this.top = this.right = this.bottom = this.left = 0;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"top\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"right\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"bottom\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"left\", void 0);\n\nvar sparklinesUtil = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    extent: extent,\n    normalisedExtent: normalisedExtent,\n    normalisedExtentWithMetadata: normalisedExtentWithMetadata,\n    toFixed: toFixed,\n    isNumberEqual: isEqual,\n    tickFormat: tickFormat,\n    interpolateString: interpolate,\n    ticks: ticks,\n    tickStep: tickStep,\n    range: range$1,\n    Color: Color,\n    isString: isString,\n    isStringObject: isStringObject,\n    isDate: isDate,\n    isDiscrete: isDiscrete,\n    isContinuous: isContinuous,\n    checkDatum: checkDatum,\n    isNumber: isNumber,\n    resetIds: resetIds,\n    createId: createId,\n    Padding: Padding,\n    jsonDiff: jsonDiff,\n    DELETE: DELETE,\n    jsonMerge: jsonMerge,\n    jsonApply: jsonApply,\n    jsonWalk: jsonWalk,\n    normalizeAngle360: normalizeAngle360,\n    normalizeAngle360Inclusive: normalizeAngle360Inclusive,\n    normalizeAngle180: normalizeAngle180,\n    toRadians: toRadians,\n    toDegrees: toDegrees,\n    angleBetween: angleBetween,\n    zipObject: zipObject,\n    clamp: clamp,\n    isEqual: isEqual,\n    isNegative: isNegative,\n    round: round$1,\n    mod: mod,\n    sanitizeHtml: sanitizeHtml,\n    Logger: Logger\n});\n\nfunction areArrayNumbersEqual(arrA, arrB) {\r\n    return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\r\n}\n\nfunction circleRectOverlap(c, x, y, w, h) {\r\n    // Find closest horizontal and vertical edges.\r\n    let edgeX = c.x;\r\n    if (c.x < x) {\r\n        edgeX = x;\r\n    }\r\n    else if (c.x > x + w) {\r\n        edgeX = x + w;\r\n    }\r\n    let edgeY = c.y;\r\n    if (c.y < y) {\r\n        edgeY = y;\r\n    }\r\n    else if (c.y > y + h) {\r\n        edgeY = y + h;\r\n    }\r\n    // Find distance to closest edges.\r\n    const dx = c.x - edgeX;\r\n    const dy = c.y - edgeY;\r\n    const d = Math.sqrt(dx * dx + dy * dy);\r\n    return d <= c.size * 0.5;\r\n}\r\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\r\n    const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\r\n    const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\r\n    return xOverlap && yOverlap;\r\n}\r\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\r\n    return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\r\n}\r\nfunction isPointLabelDatum(x) {\r\n    return x != null && typeof x.point === 'object' && typeof x.label === 'object';\r\n}\r\n/**\r\n * @param data Points and labels for one or more series. The order of series determines label placement precedence.\r\n * @param bounds Bounds to fit the labels into. If a label can't be fully contained, it doesn't fit.\r\n * @returns Placed labels for the given series (in the given order).\r\n */\r\nfunction placeLabels(data, bounds, padding = 5) {\r\n    const result = [];\r\n    data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\r\n    for (let j = 0; j < data.length; j++) {\r\n        const labels = (result[j] = []);\r\n        const datum = data[j];\r\n        if (!((datum === null || datum === void 0 ? void 0 : datum.length) && datum[0].label)) {\r\n            continue;\r\n        }\r\n        for (let i = 0, ln = datum.length; i < ln; i++) {\r\n            const d = datum[i];\r\n            const l = d.label;\r\n            const r = d.point.size * 0.5;\r\n            const x = d.point.x - l.width * 0.5;\r\n            const y = d.point.y - r - l.height - padding;\r\n            const { width, height } = l;\r\n            const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\r\n            if (!withinBounds) {\r\n                continue;\r\n            }\r\n            const overlapPoints = data.some((datum) => datum.some((d) => circleRectOverlap(d.point, x, y, width, height)));\r\n            if (overlapPoints) {\r\n                continue;\r\n            }\r\n            const overlapLabels = result.some((labels) => labels.some((l) => rectRectOverlap(l, x, y, width, height)));\r\n            if (overlapLabels) {\r\n                continue;\r\n            }\r\n            labels.push({\r\n                index: i,\r\n                text: l.text,\r\n                x,\r\n                y,\r\n                width,\r\n                height,\r\n                datum: d,\r\n            });\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction axisLabelsOverlap(data, padding) {\r\n    const result = [];\r\n    for (let i = 0; i < data.length; i++) {\r\n        const datum = data[i];\r\n        const { point: { x, y }, label: { text }, } = datum;\r\n        let { label: { width, height }, } = datum;\r\n        width += padding !== null && padding !== void 0 ? padding : 0;\r\n        height += padding !== null && padding !== void 0 ? padding : 0;\r\n        const overlapLabels = result.some((l) => {\r\n            return rectRectOverlap(l, x, y, width, height);\r\n        });\r\n        if (overlapLabels) {\r\n            return true;\r\n        }\r\n        result.push({\r\n            index: i,\r\n            text,\r\n            x,\r\n            y,\r\n            width,\r\n            height,\r\n            datum,\r\n        });\r\n    }\r\n    return false;\r\n}\n\nconst GRID_STYLE_KEYS = ['stroke', 'lineDash'];\r\nconst GRID_STYLE = predicateWithMessage(ARRAY(undefined, (o) => {\r\n    for (const key in o) {\r\n        if (!GRID_STYLE_KEYS.includes(key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}), `expecting an Array of objects with gridline style properties such as 'stroke' and 'lineDash'`);\r\nclass AxisGridLine {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.width = 1;\r\n        this.style = [\r\n            {\r\n                stroke: undefined,\r\n                lineDash: [],\r\n            },\r\n        ];\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisGridLine.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisGridLine.prototype, \"width\", void 0);\r\n__decorate([\r\n    Validate(GRID_STYLE),\r\n    __metadata(\"design:type\", Array)\r\n], AxisGridLine.prototype, \"style\", void 0);\n\nfunction Default(defaultValue, replaces = [undefined]) {\r\n    return addTransformToInstanceProperty((_, __, v) => {\r\n        if (replaces.includes(v)) {\r\n            return defaultValue;\r\n        }\r\n        return v;\r\n    });\r\n}\n\nclass AxisLabel {\r\n    constructor() {\r\n        this.enabled = true;\r\n        /** If set to `false`, axis labels will not be wrapped on multiple lines. */\r\n        this.autoWrap = false;\r\n        /** Used to constrain the width of the label when `autoWrap` is `true`, if the label text width exceeds the `maxWidth`, it will be wrapped on multiple lines automatically. If `maxWidth` is omitted, a default width constraint will be applied. */\r\n        this.maxWidth = undefined;\r\n        /** Used to constrain the height of the multiline label, if the label text height exceeds the `maxHeight`, it will be truncated automatically. If `maxHeight` is omitted, a default height constraint will be applied. */\r\n        this.maxHeight = undefined;\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n        /**\r\n         * The padding between the labels and the ticks.\r\n         */\r\n        this.padding = 5;\r\n        /**\r\n         * Minimum gap in pixels between the axis labels before being removed to avoid collisions.\r\n         */\r\n        this.minSpacing = NaN;\r\n        /**\r\n         * The color of the labels.\r\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\r\n         */\r\n        this.color = 'rgba(87, 87, 87, 1)';\r\n        /**\r\n         * Custom label rotation in degrees.\r\n         * Labels are rendered perpendicular to the axis line by default.\r\n         * Or parallel to the axis line, if the {@link parallel} is set to `true`.\r\n         * The value of this config is used as the angular offset/deflection\r\n         * from the default rotation.\r\n         */\r\n        this.rotation = undefined;\r\n        /**\r\n         * Avoid axis label collision by automatically reducing the number of ticks displayed. If set to `false`, axis labels may collide.\r\n         */\r\n        this.avoidCollisions = true;\r\n        /**\r\n         * By default, labels and ticks are positioned to the left of the axis line.\r\n         * `true` positions the labels to the right of the axis line.\r\n         * However, if the axis is rotated, it's easier to think in terms\r\n         * of this side or the opposite side, rather than left and right.\r\n         * We use the term `mirror` for conciseness, although it's not\r\n         * true mirroring - for example, when a label is rotated, so that\r\n         * it is inclined at the 45 degree angle, text flowing from north-west\r\n         * to south-east, ending at the tick to the left of the axis line,\r\n         * and then we set this config to `true`, the text will still be flowing\r\n         * from north-west to south-east, _starting_ at the tick to the right\r\n         * of the axis line.\r\n         */\r\n        this.mirrored = false;\r\n        /**\r\n         * Labels are rendered perpendicular to the axis line by default.\r\n         * Setting this config to `true` makes labels render parallel to the axis line\r\n         * and center aligns labels' text at the ticks.\r\n         */\r\n        this.parallel = false;\r\n        /**\r\n         * In case {@param value} is a number, the {@param fractionDigits} parameter will\r\n         * be provided as well. The `fractionDigits` corresponds to the number of fraction\r\n         * digits used by the tick step. For example, if the tick step is `0.0005`,\r\n         * the `fractionDigits` is 4.\r\n         */\r\n        this.formatter = undefined;\r\n    }\r\n    /**\r\n     * The side of the axis line to position the labels on.\r\n     * -1 = left (default)\r\n     * 1 = right\r\n     */\r\n    getSideFlag() {\r\n        return this.mirrored ? 1 : -1;\r\n    }\r\n    getFont() {\r\n        return getFont(this);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisLabel.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"autoWrap\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"maxHeight\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(1)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"padding\", void 0);\r\n__decorate([\r\n    Validate(NUMBER_OR_NAN()),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"minSpacing\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(-360, 360)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"avoidCollisions\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"mirrored\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"parallel\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"format\", void 0);\n\nclass AxisLine {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.width = 1;\r\n        this.color = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisLine.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLine.prototype, \"width\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLine.prototype, \"color\", void 0);\n\nconst OPT_TICK_INTERVAL = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v, ctx) => (v !== 0 && NUMBER$1(0)(v, ctx)) || v instanceof TimeInterval), `expecting an optional non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`);\r\nclass AxisTick {\r\n    constructor() {\r\n        this.enabled = true;\r\n        /**\r\n         * The line width to be used by axis ticks.\r\n         */\r\n        this.width = 1;\r\n        /**\r\n         * The line length to be used by axis ticks.\r\n         */\r\n        this.size = 6;\r\n        /**\r\n         * The color of the axis ticks.\r\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\r\n         */\r\n        this.color = undefined;\r\n        this.interval = undefined;\r\n        this.values = undefined;\r\n        this.minSpacing = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisTick.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTick.prototype, \"width\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTick.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTick.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_TICK_INTERVAL),\r\n    __metadata(\"design:type\", Object)\r\n], AxisTick.prototype, \"interval\", void 0);\r\n__decorate([\r\n    Validate(OPT_ARRAY()),\r\n    __metadata(\"design:type\", Array)\r\n], AxisTick.prototype, \"values\", void 0);\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(1), LESS_THAN('maxSpacing'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTick.prototype, \"minSpacing\", void 0);\n\nfunction prepareAxisAnimationContext(axis) {\r\n    const requestedRangeMin = Math.min(...axis.range);\r\n    const requestedRangeMax = Math.max(...axis.range);\r\n    const min = Math.floor(requestedRangeMin);\r\n    const max = Math.ceil(requestedRangeMax);\r\n    const visible = min !== max;\r\n    return { min, max, visible };\r\n}\r\nconst fullCircle = Math.PI * 2;\r\nconst halfCircle = fullCircle / 2;\r\nfunction normaliseEndRotation(start, end) {\r\n    const directDistance = Math.abs(end - start);\r\n    if (directDistance < halfCircle)\r\n        return end;\r\n    if (start > end)\r\n        return end + fullCircle;\r\n    return end - fullCircle;\r\n}\r\nfunction prepareAxisAnimationFunctions(ctx) {\r\n    const outOfBounds = (datum) => {\r\n        var _a, _b;\r\n        const min = Math.min(...((_a = datum.range) !== null && _a !== void 0 ? _a : [ctx.min]));\r\n        const max = Math.max(...((_b = datum.range) !== null && _b !== void 0 ? _b : [ctx.max]));\r\n        const translationY = Math.round(datum.translationY);\r\n        return translationY < min || translationY > max;\r\n    };\r\n    const calculateStatus = (datum, nodeDatum, status) => {\r\n        if (status !== 'removed' && outOfBounds(datum)) {\r\n            return 'removed';\r\n        }\r\n        else if (status !== 'added' && outOfBounds(nodeDatum)) {\r\n            return 'added';\r\n        }\r\n        return status;\r\n    };\r\n    const fromBase = (node, datum, status) => {\r\n        // Default to starting at the same position that the node is currently in.\r\n        const source = { translationY: Math.round(node.translationY), opacity: node.opacity };\r\n        status = calculateStatus(datum, node.datum, status);\r\n        if (status === 'added') {\r\n            source.translationY = Math.round(datum.translationY);\r\n            source.opacity = 0;\r\n        }\r\n        return Object.assign(Object.assign({}, source), FROM_TO_MIXINS[status]);\r\n    };\r\n    const toBase = (_node, datum, status) => {\r\n        const target = { translationY: Math.round(datum.translationY), opacity: 1 };\r\n        if (status === 'removed') {\r\n            target.opacity = 0;\r\n        }\r\n        return target;\r\n    };\r\n    const tick = {\r\n        fromFn: fromBase,\r\n        toFn: toBase,\r\n        intermediateFn: (node, _datum, _status) => {\r\n            return { visible: !outOfBounds(node) };\r\n        },\r\n    };\r\n    const label = {\r\n        fromFn: ((node, newDatum, status) => {\r\n            var _a;\r\n            const datum = (_a = node.previousDatum) !== null && _a !== void 0 ? _a : newDatum;\r\n            let rotation = datum.rotation;\r\n            if (status === 'added' || status === 'removed') {\r\n                rotation = newDatum.rotation;\r\n            }\r\n            return Object.assign(Object.assign({}, fromBase(node, newDatum, status)), { x: datum.x, y: datum.y, rotation, rotationCenterX: datum.rotationCenterX });\r\n        }),\r\n        toFn: ((node, datum, status) => {\r\n            var _a, _b;\r\n            let rotation;\r\n            if (status === 'added' || status === 'removed') {\r\n                rotation = datum.rotation;\r\n            }\r\n            else {\r\n                rotation = normaliseEndRotation((_b = (_a = node.previousDatum) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : datum.rotation, datum.rotation);\r\n            }\r\n            return Object.assign(Object.assign({}, toBase(node, datum, status)), { x: datum.x, y: datum.y, rotation, rotationCenterX: datum.rotationCenterX, finish: { rotation: datum.rotation } });\r\n        }),\r\n    };\r\n    const line = {\r\n        fromFn: (node, datum) => {\r\n            var _a, _b;\r\n            return Object.assign(Object.assign({}, ((_b = (_a = node.previousDatum) !== null && _a !== void 0 ? _a : datum) !== null && _b !== void 0 ? _b : { y: node.y, x1: node.x1, x2: node.x2 })), FROM_TO_MIXINS['updated']);\r\n        },\r\n        toFn: (_node, datum) => {\r\n            return Object.assign({}, datum);\r\n        },\r\n    };\r\n    const group = {\r\n        fromFn: (group, _datum) => {\r\n            const { rotation, translationX, translationY } = group;\r\n            return Object.assign({ rotation,\r\n                translationX,\r\n                translationY }, FROM_TO_MIXINS['updated']);\r\n        },\r\n        toFn: (_group, datum) => {\r\n            const { rotation, translationX, translationY } = datum;\r\n            return {\r\n                rotation,\r\n                translationX,\r\n                translationY,\r\n            };\r\n        },\r\n    };\r\n    return { tick, line, label, group };\r\n}\r\nfunction resetAxisGroupFn() {\r\n    return (_node, datum) => {\r\n        return {\r\n            rotation: datum.rotation,\r\n            rotationCenterX: datum.rotationCenterX,\r\n            rotationCenterY: datum.rotationCenterY,\r\n            translationX: datum.translationX,\r\n            translationY: datum.translationY,\r\n        };\r\n    };\r\n}\r\nfunction resetAxisSelectionFn(ctx) {\r\n    const { visible: rangeVisible, min, max } = ctx;\r\n    return (_node, datum) => {\r\n        const translationY = Math.round(datum.translationY);\r\n        const visible = rangeVisible && translationY >= min && translationY <= max;\r\n        return {\r\n            translationY,\r\n            opacity: 1,\r\n            visible,\r\n        };\r\n    };\r\n}\r\nfunction resetAxisLabelSelectionFn() {\r\n    return (_node, datum) => {\r\n        return {\r\n            x: datum.x,\r\n            y: datum.y,\r\n            translationY: datum.translationY,\r\n            rotation: datum.rotation,\r\n            rotationCenterX: datum.rotationCenterX,\r\n        };\r\n    };\r\n}\r\nfunction resetAxisLineSelectionFn() {\r\n    return (_node, datum) => {\r\n        return Object.assign({}, datum);\r\n    };\r\n}\n\nvar Tags;\r\n(function (Tags) {\r\n    Tags[Tags[\"TickLine\"] = 0] = \"TickLine\";\r\n    Tags[Tags[\"TickLabel\"] = 1] = \"TickLabel\";\r\n    Tags[Tags[\"GridLine\"] = 2] = \"GridLine\";\r\n    Tags[Tags[\"GridArc\"] = 3] = \"GridArc\";\r\n    Tags[Tags[\"AxisLine\"] = 4] = \"AxisLine\";\r\n})(Tags || (Tags = {}));\r\nvar TickGenerationType;\r\n(function (TickGenerationType) {\r\n    TickGenerationType[TickGenerationType[\"CREATE\"] = 0] = \"CREATE\";\r\n    TickGenerationType[TickGenerationType[\"CREATE_SECONDARY\"] = 1] = \"CREATE_SECONDARY\";\r\n    TickGenerationType[TickGenerationType[\"FILTER\"] = 2] = \"FILTER\";\r\n    TickGenerationType[TickGenerationType[\"VALUES\"] = 3] = \"VALUES\";\r\n})(TickGenerationType || (TickGenerationType = {}));\r\n/**\r\n * A general purpose linear axis with no notion of orientation.\r\n * The axis is always rendered vertically, with horizontal labels positioned to the left\r\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\r\n * so that it can be used as a top, right, bottom, left, radial or any other kind\r\n * of linear axis.\r\n * The generic `D` parameter is the type of the domain of the axis' scale.\r\n * The output range of the axis' scale is always numeric (screen coordinates).\r\n */\r\nclass Axis {\r\n    get type() {\r\n        var _a;\r\n        return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';\r\n    }\r\n    set crossLines(value) {\r\n        var _a, _b;\r\n        (_a = this._crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => this.detachCrossLine(crossLine));\r\n        if (value) {\r\n            this.assignCrossLineArrayConstructor(value);\r\n        }\r\n        this._crossLines = value;\r\n        (_b = this._crossLines) === null || _b === void 0 ? void 0 : _b.forEach((crossLine) => {\r\n            this.attachCrossLine(crossLine);\r\n            this.initCrossLine(crossLine);\r\n        });\r\n    }\r\n    get crossLines() {\r\n        return this._crossLines;\r\n    }\r\n    constructor(moduleCtx, scale) {\r\n        this.moduleCtx = moduleCtx;\r\n        this.scale = scale;\r\n        this.id = createId(this);\r\n        this.nice = true;\r\n        this.dataDomain = { domain: [], clipped: false };\r\n        this.keys = [];\r\n        this.boundSeries = [];\r\n        this.includeInvisibleDomains = false;\r\n        this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: Layers.AXIS_ZINDEX });\r\n        this.lineNode = this.axisGroup.appendChild(new Line());\r\n        this.tickLineGroup = this.axisGroup.appendChild(new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: Layers.AXIS_ZINDEX }));\r\n        this.tickLabelGroup = this.axisGroup.appendChild(new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: Layers.AXIS_ZINDEX }));\r\n        this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });\r\n        this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });\r\n        this.gridLineGroup = this.gridGroup.appendChild(new Group({\r\n            name: `${this.id}-gridLines`,\r\n            zIndex: Layers.AXIS_GRID_ZINDEX,\r\n        }));\r\n        this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);\r\n        this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);\r\n        this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);\r\n        this.line = new AxisLine();\r\n        this.tick = this.createTick();\r\n        this.gridLine = new AxisGridLine();\r\n        this.label = this.createLabel();\r\n        this.defaultTickMinSpacing = Axis.defaultTickMinSpacing;\r\n        this.translation = { x: 0, y: 0 };\r\n        this.rotation = 0; // axis rotation angle in degrees\r\n        this.layout = {\r\n            label: {\r\n                fractionDigits: 0,\r\n                padding: this.label.padding,\r\n                format: this.label.format,\r\n            },\r\n        };\r\n        this.destroyFns = [];\r\n        this.range = [0, 1];\r\n        this.visibleRange = [0, 1];\r\n        this.title = undefined;\r\n        this._titleCaption = new Caption();\r\n        /**\r\n         * The length of the grid. The grid is only visible in case of a non-zero value.\r\n         * In case {@link radialGrid} is `true`, the value is interpreted as an angle\r\n         * (in degrees).\r\n         */\r\n        this._gridLength = 0;\r\n        this.fractionDigits = 0;\r\n        /**\r\n         * The distance between the grid ticks and the axis ticks.\r\n         */\r\n        this.gridPadding = 0;\r\n        /**\r\n         * Is used to avoid collisions between axis labels and series.\r\n         */\r\n        this.seriesAreaPadding = 0;\r\n        this.tickGenerationResult = undefined;\r\n        this.maxThickness = Infinity;\r\n        this.moduleMap = new ModuleMap(this);\r\n        this.refreshScale();\r\n        this._titleCaption.node.rotation = -Math.PI / 2;\r\n        this.axisGroup.appendChild(this._titleCaption.node);\r\n        this.destroyFns.push(moduleCtx.interactionManager.addListener('hover', (e) => this.checkAxisHover(e)));\r\n        this.animationManager = moduleCtx.animationManager;\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: () => this.resetSelectionNodes(),\r\n                },\r\n            },\r\n            ready: {\r\n                update: (data) => this.animateReadyUpdate(data),\r\n                resize: () => this.resetSelectionNodes(),\r\n            },\r\n        });\r\n        this._crossLines = [];\r\n        this.assignCrossLineArrayConstructor(this._crossLines);\r\n        let previousSize = undefined;\r\n        this.destroyFns.push(moduleCtx.layoutService.addListener('layout-complete', (e) => {\r\n            // Fire resize animation action if chart canvas size changes.\r\n            if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\r\n                this.animationState.transition('resize');\r\n            }\r\n            previousSize = Object.assign({}, e.chart);\r\n        }));\r\n        this.destroyFns.push(moduleCtx.updateService.addListener('update-complete', (e) => {\r\n            this.minRect = e.minRect;\r\n        }));\r\n    }\r\n    attachCrossLine(crossLine) {\r\n        this.crossLineGroup.appendChild(crossLine.group);\r\n    }\r\n    detachCrossLine(crossLine) {\r\n        this.crossLineGroup.removeChild(crossLine.group);\r\n    }\r\n    destroy() {\r\n        this.moduleMap.destroy();\r\n        this.destroyFns.forEach((f) => f());\r\n    }\r\n    refreshScale() {\r\n        var _a;\r\n        this.range = this.scale.range.slice();\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            this.initCrossLine(crossLine);\r\n        });\r\n    }\r\n    updateRange() {\r\n        var _a;\r\n        const { range: rr, visibleRange: vr, scale } = this;\r\n        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\r\n        const shift = span * vr[0];\r\n        const start = rr[0] - shift;\r\n        scale.range = [start, start + span];\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            crossLine.clippedRange = [rr[0], rr[1]];\r\n        });\r\n    }\r\n    setCrossLinesVisible(visible) {\r\n        this.crossLineGroup.visible = visible;\r\n    }\r\n    attachAxis(axisNode, gridNode) {\r\n        gridNode.appendChild(this.gridGroup);\r\n        axisNode.appendChild(this.axisGroup);\r\n        axisNode.appendChild(this.crossLineGroup);\r\n    }\r\n    detachAxis(axisNode, gridNode) {\r\n        gridNode.removeChild(this.gridGroup);\r\n        axisNode.removeChild(this.axisGroup);\r\n        axisNode.removeChild(this.crossLineGroup);\r\n    }\r\n    /**\r\n     * Checks if a point or an object is in range.\r\n     * @param x A point (or object's starting point).\r\n     * @param width Object's width.\r\n     * @param tolerance Expands the range on both ends by this amount.\r\n     */\r\n    inRange(x, width = 0, tolerance = 0) {\r\n        const min = Math.min(...this.range);\r\n        const max = Math.max(...this.range);\r\n        return x + width >= min - tolerance && x <= max + tolerance;\r\n    }\r\n    onLabelFormatChange(ticks, format) {\r\n        const { scale, fractionDigits } = this;\r\n        const logScale = scale instanceof LogScale;\r\n        const defaultLabelFormatter = !logScale && fractionDigits > 0\r\n            ? (x) => (typeof x === 'number' ? x.toFixed(fractionDigits) : String(x))\r\n            : (x) => String(x);\r\n        if (format && scale && scale.tickFormat) {\r\n            try {\r\n                this.labelFormatter = scale.tickFormat({ ticks, specifier: format });\r\n            }\r\n            catch (e) {\r\n                this.labelFormatter = defaultLabelFormatter;\r\n                Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\r\n            }\r\n        }\r\n        else {\r\n            this.labelFormatter = defaultLabelFormatter;\r\n        }\r\n    }\r\n    setDomain() {\r\n        var _a;\r\n        const { scale, dataDomain: { domain }, tick: { values: tickValues }, } = this;\r\n        if (tickValues && ContinuousScale.is(scale)) {\r\n            const [tickMin, tickMax] = (_a = extent(tickValues)) !== null && _a !== void 0 ? _a : [Infinity, -Infinity];\r\n            const min = Math.min(scale.fromDomain(domain[0]), tickMin);\r\n            const max = Math.max(scale.fromDomain(domain[1]), tickMax);\r\n            scale.domain = [scale.toDomain(min), scale.toDomain(max)];\r\n        }\r\n        else {\r\n            scale.domain = domain;\r\n        }\r\n    }\r\n    setTickInterval(interval) {\r\n        var _a;\r\n        this.scale.interval = (_a = this.tick.interval) !== null && _a !== void 0 ? _a : interval;\r\n    }\r\n    setTickCount(count, minTickCount, maxTickCount) {\r\n        const { scale } = this;\r\n        if (!(count && ContinuousScale.is(scale))) {\r\n            return;\r\n        }\r\n        if (typeof count === 'number') {\r\n            scale.tickCount = count;\r\n            scale.minTickCount = minTickCount !== null && minTickCount !== void 0 ? minTickCount : 0;\r\n            scale.maxTickCount = maxTickCount !== null && maxTickCount !== void 0 ? maxTickCount : Infinity;\r\n            return;\r\n        }\r\n        if (scale instanceof TimeScale) {\r\n            this.setTickInterval(count);\r\n        }\r\n    }\r\n    set gridLength(value) {\r\n        var _a;\r\n        // Was visible and now invisible, or was invisible and now visible.\r\n        if ((this._gridLength && !value) || (!this._gridLength && value)) {\r\n            this.gridLineGroupSelection.clear();\r\n        }\r\n        this._gridLength = value;\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            this.initCrossLine(crossLine);\r\n        });\r\n    }\r\n    get gridLength() {\r\n        return this._gridLength;\r\n    }\r\n    createTick() {\r\n        return new AxisTick();\r\n    }\r\n    createLabel() {\r\n        return new AxisLabel();\r\n    }\r\n    checkAxisHover(event) {\r\n        const bbox = this.computeBBox();\r\n        const isInAxis = bbox.containsPoint(event.offsetX, event.offsetY);\r\n        if (!isInAxis)\r\n            return;\r\n        this.moduleCtx.chartEventManager.axisHover(this.id, this.direction);\r\n    }\r\n    /**\r\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\r\n     */\r\n    update(primaryTickCount) {\r\n        if (!this.tickGenerationResult) {\r\n            return;\r\n        }\r\n        const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\r\n        const sideFlag = this.label.getSideFlag();\r\n        this.updatePosition();\r\n        const lineData = this.getAxisLineCoordinates();\r\n        const _a = this.tickGenerationResult, { tickData, combinedRotation, textBaseline, textAlign } = _a, ticksResult = __rest(_a, [\"tickData\", \"combinedRotation\", \"textBaseline\", \"textAlign\"]);\r\n        const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\r\n        this.updateSelections(lineData, tickData.ticks, {\r\n            combinedRotation,\r\n            textAlign,\r\n            textBaseline,\r\n            range: this.scale.range,\r\n        });\r\n        if (this.animationManager.isSkipped()) {\r\n            this.resetSelectionNodes();\r\n        }\r\n        else {\r\n            const diff = this.calculateUpdateDiff(previousTicks, tickData);\r\n            this.animationState.transition('update', diff);\r\n        }\r\n        this.updateAxisLine();\r\n        this.updateLabels();\r\n        this.updateVisibility();\r\n        this.updateGridLines(sideFlag);\r\n        this.updateTickLines();\r\n        this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\r\n        this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\r\n        this.updateLayoutState();\r\n        primaryTickCount = ticksResult.primaryTickCount;\r\n        return primaryTickCount;\r\n    }\r\n    getAxisLineCoordinates() {\r\n        const { range: [start, end], } = this;\r\n        const x = 0;\r\n        const y1 = Math.min(start, end);\r\n        const y2 = Math.max(start, end);\r\n        return { x, y1, y2 };\r\n    }\r\n    getTickLineCoordinates(datum) {\r\n        const { tick, label } = this;\r\n        const sideFlag = label.getSideFlag();\r\n        const x = sideFlag * tick.size;\r\n        const x1 = Math.min(0, x);\r\n        const x2 = x1 + Math.abs(x);\r\n        const y = Math.round(datum.translationY);\r\n        return { x1, x2, y };\r\n    }\r\n    getTickLabelProps(datum, params) {\r\n        const { label } = this;\r\n        const { combinedRotation, textBaseline, textAlign, range } = params;\r\n        const text = datum.tickLabel;\r\n        const sideFlag = label.getSideFlag();\r\n        const tickSize = this.tick.size;\r\n        const labelX = sideFlag * (tickSize + label.padding + this.seriesAreaPadding);\r\n        const visible = text !== '' && text != undefined;\r\n        return {\r\n            tickId: datum.tickId,\r\n            translationY: datum.translationY,\r\n            fill: label.color,\r\n            fontFamily: label.fontFamily,\r\n            fontSize: label.fontSize,\r\n            fontStyle: label.fontStyle,\r\n            fontWeight: label.fontWeight,\r\n            rotation: combinedRotation,\r\n            rotationCenterX: labelX,\r\n            text,\r\n            textAlign,\r\n            textBaseline,\r\n            visible,\r\n            x: labelX,\r\n            y: 0,\r\n            range,\r\n        };\r\n    }\r\n    setTitleProps(caption, params) {\r\n        var _a;\r\n        const { title } = this;\r\n        if (!title) {\r\n            caption.enabled = false;\r\n            return;\r\n        }\r\n        caption.color = title.color;\r\n        caption.fontFamily = title.fontFamily;\r\n        caption.fontSize = title.fontSize;\r\n        caption.fontStyle = title.fontStyle;\r\n        caption.fontWeight = title.fontWeight;\r\n        caption.enabled = title.enabled;\r\n        caption.wrapping = title.wrapping;\r\n        if (title.enabled) {\r\n            const titleNode = caption.node;\r\n            const { tickSpace } = params;\r\n            const padding = ((_a = title.spacing) !== null && _a !== void 0 ? _a : 0) + tickSpace;\r\n            const sideFlag = this.label.getSideFlag();\r\n            const parallelFlipRotation = normalizeAngle360(this.rotation);\r\n            const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\r\n            const rotation = (titleRotationFlag * sideFlag * Math.PI) / 2;\r\n            const textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\r\n            const { range } = this;\r\n            const x = Math.floor((titleRotationFlag * sideFlag * (range[0] + range[1])) / 2);\r\n            const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\r\n            const { callbackCache } = this.moduleCtx;\r\n            const { formatter = (params) => params.defaultValue } = title;\r\n            const text = callbackCache.call(formatter, this.getTitleFormatterParams());\r\n            titleNode.setProperties({\r\n                rotation,\r\n                text,\r\n                textBaseline,\r\n                visible: true,\r\n                x,\r\n                y,\r\n            });\r\n        }\r\n    }\r\n    calculateLayout(primaryTickCount) {\r\n        var _a;\r\n        const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\r\n        const sideFlag = this.label.getSideFlag();\r\n        const labelX = sideFlag * (this.tick.size + this.label.padding + this.seriesAreaPadding);\r\n        this.updateScale();\r\n        this.tickGenerationResult = this.generateTicks({\r\n            primaryTickCount,\r\n            parallelFlipRotation,\r\n            regularFlipRotation,\r\n            labelX,\r\n            sideFlag,\r\n        });\r\n        const _b = this.tickGenerationResult, { tickData, combinedRotation, textBaseline, textAlign } = _b, ticksResult = __rest(_b, [\"tickData\", \"combinedRotation\", \"textBaseline\", \"textAlign\"]);\r\n        const boxes = [];\r\n        const { x, y1, y2 } = this.getAxisLineCoordinates();\r\n        const lineBox = new BBox(x, y1, 0, y2 - y1);\r\n        boxes.push(lineBox);\r\n        const { tick } = this;\r\n        if (tick.enabled) {\r\n            tickData.ticks.forEach((datum) => {\r\n                const { x1, x2, y } = this.getTickLineCoordinates(datum);\r\n                const tickLineBox = new BBox(x1, y, x2 - x1, 0);\r\n                boxes.push(tickLineBox);\r\n            });\r\n        }\r\n        const { label } = this;\r\n        if (label.enabled) {\r\n            const tempText = new Text();\r\n            tickData.ticks.forEach((datum) => {\r\n                const labelProps = this.getTickLabelProps(datum, {\r\n                    combinedRotation,\r\n                    textAlign,\r\n                    textBaseline,\r\n                    range: this.scale.range,\r\n                });\r\n                if (!labelProps.visible) {\r\n                    return;\r\n                }\r\n                tempText.setProperties(Object.assign(Object.assign({}, labelProps), { translationY: Math.round(datum.translationY) }));\r\n                const box = tempText.computeTransformedBBox();\r\n                if (box) {\r\n                    boxes.push(box);\r\n                }\r\n            });\r\n        }\r\n        const getTransformBox = (bbox) => {\r\n            const matrix = new Matrix();\r\n            const { rotation: axisRotation, translationX, translationY, rotationCenterX, rotationCenterY, } = this.getAxisTransform();\r\n            Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\r\n                scalingCenterX: 0,\r\n                scalingCenterY: 0,\r\n                rotationCenterX,\r\n                rotationCenterY,\r\n            });\r\n            return matrix.transformBBox(bbox);\r\n        };\r\n        const { title } = this;\r\n        if (title === null || title === void 0 ? void 0 : title.enabled) {\r\n            const caption = new Caption();\r\n            let tickSpace = 0;\r\n            if (tickData.ticks.length > 0) {\r\n                const contentBox = BBox.merge(boxes);\r\n                const tickWidth = contentBox.width;\r\n                if (isFinite(tickWidth)) {\r\n                    tickSpace += tickWidth;\r\n                }\r\n            }\r\n            this.setTitleProps(caption, { tickSpace });\r\n            const titleNode = caption.node;\r\n            const titleBox = titleNode.computeTransformedBBox();\r\n            if (titleBox) {\r\n                boxes.push(titleBox);\r\n            }\r\n        }\r\n        const bbox = BBox.merge(boxes);\r\n        const transformedBBox = getTransformBox(bbox);\r\n        const anySeriesActive = this.isAnySeriesActive();\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            var _a;\r\n            crossLine.sideFlag = -sideFlag;\r\n            crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n            if (crossLine instanceof CartesianCrossLine) {\r\n                crossLine.label.parallel = (_a = crossLine.label.parallel) !== null && _a !== void 0 ? _a : this.label.parallel;\r\n            }\r\n            crossLine.parallelFlipRotation = parallelFlipRotation;\r\n            crossLine.regularFlipRotation = regularFlipRotation;\r\n            crossLine.calculateLayout(anySeriesActive);\r\n        });\r\n        this.updateLayoutState();\r\n        primaryTickCount = ticksResult.primaryTickCount;\r\n        return { primaryTickCount, bbox: transformedBBox };\r\n    }\r\n    updateLayoutState() {\r\n        this.layout.label = {\r\n            fractionDigits: this.fractionDigits,\r\n            padding: this.label.padding,\r\n            format: this.label.format,\r\n        };\r\n    }\r\n    updateScale() {\r\n        this.updateRange();\r\n        this.calculateDomain();\r\n        this.setDomain();\r\n        this.setTickInterval(this.tick.interval);\r\n        const { scale, nice } = this;\r\n        if (!ContinuousScale.is(scale)) {\r\n            return;\r\n        }\r\n        scale.nice = nice;\r\n        scale.update();\r\n    }\r\n    calculateRotations() {\r\n        const rotation = toRadians(this.rotation);\r\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\r\n        // flip the labels to avoid upside-down text, when the axis is rotated\r\n        // such that it is in the right hemisphere, i.e. the angle of rotation\r\n        // is in the [0, π] interval.\r\n        // The rotation angle is normalized, so that we have an easier time checking\r\n        // if it's in the said interval. Since the axis is always rendered vertically\r\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\r\n        // -1 = flip\r\n        //  1 = don't flip (default)\r\n        const parallelFlipRotation = normalizeAngle360(rotation);\r\n        const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\r\n        return { rotation, parallelFlipRotation, regularFlipRotation };\r\n    }\r\n    generateTicks({ primaryTickCount, parallelFlipRotation, regularFlipRotation, labelX, sideFlag, }) {\r\n        var _a;\r\n        const { scale, tick, label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }, } = this;\r\n        const secondaryAxis = primaryTickCount !== undefined;\r\n        const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\r\n            rotation,\r\n            parallel,\r\n            regularFlipRotation,\r\n            parallelFlipRotation,\r\n        });\r\n        const initialRotation = configuredRotation + defaultRotation;\r\n        const labelMatrix = new Matrix();\r\n        const { maxTickCount } = this.estimateTickCount({\r\n            minSpacing: tick.minSpacing,\r\n            maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN,\r\n        });\r\n        const continuous = ContinuousScale.is(scale);\r\n        const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\r\n        let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\r\n        const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\r\n        const textProps = {\r\n            fontFamily,\r\n            fontSize,\r\n            fontStyle,\r\n            fontWeight,\r\n            textBaseline,\r\n            textAlign,\r\n        };\r\n        let tickData = {\r\n            rawTicks: [],\r\n            ticks: [],\r\n            labelCount: 0,\r\n        };\r\n        let index = 0;\r\n        let autoRotation = 0;\r\n        let labelOverlap = true;\r\n        let terminate = false;\r\n        while (labelOverlap && index <= maxIterations) {\r\n            if (terminate) {\r\n                break;\r\n            }\r\n            autoRotation = 0;\r\n            textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\r\n            const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\r\n            for (const strategy of tickStrategies) {\r\n                ({ tickData, index, autoRotation, terminate } = strategy({\r\n                    index,\r\n                    tickData,\r\n                    textProps,\r\n                    labelOverlap,\r\n                    terminate,\r\n                    primaryTickCount,\r\n                }));\r\n                const rotated = configuredRotation !== 0 || autoRotation !== 0;\r\n                const rotation = initialRotation + autoRotation;\r\n                textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\r\n                labelOverlap = this.checkLabelOverlap(rotation, rotated, labelMatrix, tickData.ticks, labelX, Object.assign(Object.assign({}, textProps), { textAlign }));\r\n            }\r\n        }\r\n        const combinedRotation = defaultRotation + configuredRotation + autoRotation;\r\n        if (!secondaryAxis && tickData.rawTicks.length > 0) {\r\n            primaryTickCount = tickData.rawTicks.length;\r\n        }\r\n        return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };\r\n    }\r\n    getTickStrategies({ index, secondaryAxis }) {\r\n        const { scale, label, tick } = this;\r\n        const continuous = ContinuousScale.is(scale);\r\n        const avoidLabelCollisions = label.enabled && label.avoidCollisions;\r\n        const filterTicks = !continuous && index !== 0 && avoidLabelCollisions;\r\n        const autoRotate = label.autoRotate === true && label.rotation === undefined;\r\n        const strategies = [];\r\n        let tickGenerationType;\r\n        if (this.tick.values) {\r\n            tickGenerationType = TickGenerationType.VALUES;\r\n        }\r\n        else if (secondaryAxis) {\r\n            tickGenerationType = TickGenerationType.CREATE_SECONDARY;\r\n        }\r\n        else if (filterTicks) {\r\n            tickGenerationType = TickGenerationType.FILTER;\r\n        }\r\n        else {\r\n            tickGenerationType = TickGenerationType.CREATE;\r\n        }\r\n        const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\r\n        strategies.push(tickGenerationStrategy);\r\n        if (!continuous && !isNaN(tick.minSpacing)) {\r\n            const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(TickGenerationType.FILTER, index, tickData, terminate, primaryTickCount);\r\n            strategies.push(tickFilterStrategy);\r\n        }\r\n        if (!avoidLabelCollisions) {\r\n            return strategies;\r\n        }\r\n        if (label.autoWrap) {\r\n            const autoWrapStrategy = ({ index, tickData, textProps }) => this.wrapLabels(tickData, index, textProps);\r\n            strategies.push(autoWrapStrategy);\r\n        }\r\n        else if (autoRotate) {\r\n            const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\r\n                index,\r\n                tickData,\r\n                autoRotation: this.getAutoRotation(labelOverlap),\r\n                terminate,\r\n            });\r\n            strategies.push(autoRotateStrategy);\r\n        }\r\n        return strategies;\r\n    }\r\n    createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\r\n        var _a;\r\n        const { scale, tick } = this;\r\n        const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({\r\n            minSpacing: tick.minSpacing,\r\n            maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN,\r\n        });\r\n        const continuous = ContinuousScale.is(scale);\r\n        const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\r\n        let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\r\n        const regenerateTicks = tick.interval === undefined &&\r\n            tick.values === undefined &&\r\n            tickCount > minTickCount &&\r\n            (continuous || tickGenerationType === TickGenerationType.FILTER);\r\n        let unchanged = true;\r\n        while (unchanged && index <= maxIterations) {\r\n            const prevTicks = tickData.rawTicks;\r\n            tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\r\n            const { rawTicks, ticks, labelCount } = this.getTicks({\r\n                tickGenerationType,\r\n                previousTicks: prevTicks,\r\n                tickCount,\r\n                minTickCount,\r\n                maxTickCount,\r\n                primaryTickCount,\r\n            });\r\n            tickData.rawTicks = rawTicks;\r\n            tickData.ticks = ticks;\r\n            tickData.labelCount = labelCount;\r\n            unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\r\n            index++;\r\n        }\r\n        const shouldTerminate = tick.interval !== undefined || tick.values !== undefined;\r\n        terminate || (terminate = shouldTerminate);\r\n        return { tickData, index, autoRotation: 0, terminate };\r\n    }\r\n    checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textProps) {\r\n        Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);\r\n        const labelData = this.createLabelData(tickData, labelX, textProps, labelMatrix);\r\n        const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\r\n        return axisLabelsOverlap(labelData, labelSpacing);\r\n    }\r\n    createLabelData(tickData, labelX, textProps, labelMatrix) {\r\n        const labelData = [];\r\n        for (const tickDatum of tickData) {\r\n            const { tickLabel, translationY } = tickDatum;\r\n            if (tickLabel === '' || tickLabel == undefined) {\r\n                // skip user hidden ticks\r\n                continue;\r\n            }\r\n            const lines = splitText(tickLabel);\r\n            const { width, height } = measureText(lines, labelX, translationY, textProps);\r\n            const bbox = new BBox(labelX, translationY, width, height);\r\n            const labelDatum = calculateLabelBBox(tickLabel, bbox, labelX, translationY, labelMatrix);\r\n            labelData.push(labelDatum);\r\n        }\r\n        return labelData;\r\n    }\r\n    getAutoRotation(labelOverlap) {\r\n        var _a;\r\n        return labelOverlap ? normalizeAngle360(toRadians((_a = this.label.autoRotateAngle) !== null && _a !== void 0 ? _a : 0)) : 0;\r\n    }\r\n    getTicks({ tickGenerationType, previousTicks, tickCount, minTickCount, maxTickCount, primaryTickCount, }) {\r\n        var _a;\r\n        const { range, scale, visibleRange } = this;\r\n        let rawTicks = [];\r\n        switch (tickGenerationType) {\r\n            case TickGenerationType.VALUES:\r\n                rawTicks = this.tick.values;\r\n                break;\r\n            case TickGenerationType.CREATE_SECONDARY:\r\n                // `updateSecondaryAxisTicks` mutates `scale.domain` based on `primaryTickCount`\r\n                rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\r\n                break;\r\n            case TickGenerationType.FILTER:\r\n                rawTicks = this.filterTicks(previousTicks, tickCount);\r\n                break;\r\n            default:\r\n                rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\r\n                break;\r\n        }\r\n        // When the scale domain or the ticks change, the label format may change\r\n        this.onLabelFormatChange(rawTicks, this.label.format);\r\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\r\n        this.fractionDigits = rawTicks.fractionDigits >= 0 ? rawTicks.fractionDigits : 0;\r\n        const halfBandwidth = ((_a = scale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n        const ticks = [];\r\n        let labelCount = 0;\r\n        const tickIdCounts = new Map();\r\n        // Only get the ticks within a sliding window of the visible range to improve performance\r\n        const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\r\n        const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\r\n        for (let i = start; i < end; i++) {\r\n            const rawTick = rawTicks[i];\r\n            const translationY = scale.convert(rawTick) + halfBandwidth;\r\n            // Do not render ticks outside the range with a small tolerance. A clip rect would trim long labels, so\r\n            // instead hide ticks based on their translation.\r\n            if (range.length > 0 && !this.inRange(translationY, 0, 0.001))\r\n                continue;\r\n            const tickLabel = this.formatTick(rawTick, i);\r\n            // Create a tick id from the label, or as an increment of the last label if this tick label is blank\r\n            let tickId = tickLabel;\r\n            if (tickIdCounts.has(tickId)) {\r\n                const count = tickIdCounts.get(tickId);\r\n                tickIdCounts.set(tickId, count + 1);\r\n                tickId = `${tickId}_${count}`;\r\n            }\r\n            else {\r\n                tickIdCounts.set(tickId, 1);\r\n            }\r\n            ticks.push({ tick: rawTick, tickId, tickLabel, translationY });\r\n            if (tickLabel === '' || tickLabel == undefined) {\r\n                continue;\r\n            }\r\n            labelCount++;\r\n        }\r\n        return { rawTicks, ticks, labelCount };\r\n    }\r\n    filterTicks(ticks, tickCount) {\r\n        var _a;\r\n        const tickSpacing = !isNaN(this.tick.minSpacing) || !isNaN((_a = this.tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN);\r\n        const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\r\n        return ticks.filter((_, i) => i % keepEvery === 0);\r\n    }\r\n    createTicks(tickCount, minTickCount, maxTickCount) {\r\n        var _a, _b, _c;\r\n        this.setTickCount(tickCount, minTickCount, maxTickCount);\r\n        return (_c = (_b = (_a = this.scale).ticks) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\r\n    }\r\n    estimateTickCount({ minSpacing, maxSpacing }) {\r\n        const { minRect } = this;\r\n        const rangeWithBleed = this.calculateRangeWithBleed();\r\n        const defaultMinSpacing = Math.max(this.defaultTickMinSpacing, rangeWithBleed / ContinuousScale.defaultMaxTickCount);\r\n        let clampMaxTickCount = !isNaN(maxSpacing);\r\n        if (isNaN(minSpacing)) {\r\n            minSpacing = defaultMinSpacing;\r\n        }\r\n        if (isNaN(maxSpacing)) {\r\n            maxSpacing = rangeWithBleed;\r\n        }\r\n        if (minSpacing > maxSpacing) {\r\n            if (minSpacing === defaultMinSpacing) {\r\n                minSpacing = maxSpacing;\r\n            }\r\n            else {\r\n                maxSpacing = minSpacing;\r\n            }\r\n        }\r\n        // Clamps the min spacing between ticks to be no more than the min distance between datums\r\n        const minRectDistance = minRect\r\n            ? this.direction === ChartAxisDirection.X\r\n                ? minRect.width\r\n                : minRect.height\r\n            : 1;\r\n        clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\r\n        const maxTickCount = clamp(1, Math.floor(rangeWithBleed / minSpacing), clampMaxTickCount ? Math.floor(rangeWithBleed / minRectDistance) : Infinity);\r\n        const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\r\n        const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\r\n        return { minTickCount, maxTickCount, defaultTickCount };\r\n    }\r\n    updateVisibility() {\r\n        if (this.moduleCtx.animationManager.isSkipped()) {\r\n            this.resetSelectionNodes();\r\n        }\r\n        this.tickLineGroup.visible = this.tick.enabled;\r\n        this.gridLineGroup.visible = this.gridLine.enabled;\r\n        this.tickLabelGroup.visible = this.label.enabled;\r\n    }\r\n    updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation, }) {\r\n        var _a;\r\n        const sideFlag = this.label.getSideFlag();\r\n        const anySeriesActive = this.isAnySeriesActive();\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            var _a;\r\n            crossLine.sideFlag = -sideFlag;\r\n            crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n            if (crossLine instanceof CartesianCrossLine) {\r\n                crossLine.label.parallel = (_a = crossLine.label.parallel) !== null && _a !== void 0 ? _a : this.label.parallel;\r\n            }\r\n            crossLine.parallelFlipRotation = parallelFlipRotation;\r\n            crossLine.regularFlipRotation = regularFlipRotation;\r\n            crossLine.update(anySeriesActive);\r\n        });\r\n    }\r\n    updateTickLines() {\r\n        const { tick, label } = this;\r\n        const sideFlag = label.getSideFlag();\r\n        this.tickLineGroupSelection.each((line) => {\r\n            line.strokeWidth = tick.width;\r\n            line.stroke = tick.color;\r\n            line.x1 = sideFlag * tick.size;\r\n            line.x2 = 0;\r\n            line.y1 = 0;\r\n            line.y2 = 0;\r\n        });\r\n    }\r\n    calculateAvailableRange() {\r\n        const { range } = this;\r\n        const min = Math.min(...range);\r\n        const max = Math.max(...range);\r\n        return max - min;\r\n    }\r\n    /**\r\n     * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\r\n     * the visible range is only a portion of the axis.\r\n     */\r\n    calculateRangeWithBleed() {\r\n        const { visibleRange } = this;\r\n        const visibleScale = 1 / (visibleRange[1] - visibleRange[0]);\r\n        return round$1(this.calculateAvailableRange() * visibleScale, 2);\r\n    }\r\n    calculateDomain() {\r\n        if (this.linkedTo) {\r\n            this.dataDomain = this.linkedTo.dataDomain;\r\n        }\r\n        else {\r\n            const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\r\n            const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\r\n            this.dataDomain = this.normaliseDataDomain(domains);\r\n        }\r\n    }\r\n    getAxisTransform() {\r\n        return {\r\n            rotation: toRadians(this.rotation),\r\n            rotationCenterX: 0,\r\n            rotationCenterY: 0,\r\n            translationX: this.translation.x,\r\n            translationY: this.translation.y,\r\n        };\r\n    }\r\n    updatePosition() {\r\n        const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;\r\n        const { rotation } = this.calculateRotations();\r\n        const sideFlag = this.label.getSideFlag();\r\n        const translationX = Math.floor(translation.x);\r\n        const translationY = Math.floor(translation.y);\r\n        crossLineGroup.setProperties({ rotation, translationX, translationY });\r\n        axisGroup.datum = this.getAxisTransform();\r\n        gridGroup.setProperties({ rotation, translationX, translationY });\r\n        gridLineGroupSelection.each((line) => {\r\n            line.x1 = gridPadding;\r\n            line.x2 = -sideFlag * gridLength + gridPadding;\r\n            line.y = 0;\r\n        });\r\n    }\r\n    updateSecondaryAxisTicks(_primaryTickCount) {\r\n        throw new Error('AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.');\r\n    }\r\n    updateSelections(lineData, data, params) {\r\n        this.lineNode.datum = lineData;\r\n        this.gridLineGroupSelection.update(this.gridLength ? data : [], (group) => group.append(new Line({ tag: Tags.GridLine })), (datum) => datum.tickId);\r\n        this.tickLineGroupSelection.update(data, (group) => group.appendChild(new Line({ tag: Tags.TickLine })), (datum) => datum.tickId);\r\n        this.tickLabelGroupSelection.update(data.map((d) => this.getTickLabelProps(d, params)), (group) => group.appendChild(new Text({ tag: Tags.TickLabel })), (datum) => datum.tickId);\r\n    }\r\n    updateAxisLine() {\r\n        const { line } = this;\r\n        // Without this the layout isn't consistent when enabling/disabling the line, padding configurations are not respected.\r\n        const strokeWidth = line.enabled ? line.width : 0;\r\n        this.lineNode.setProperties({\r\n            stroke: line.color,\r\n            strokeWidth,\r\n        });\r\n    }\r\n    updateGridLines(sideFlag) {\r\n        const { gridLine: { style, width }, gridPadding, gridLength, } = this;\r\n        if (gridLength === 0 || style.length === 0) {\r\n            return;\r\n        }\r\n        this.gridLineGroupSelection.each((line, _, index) => {\r\n            const { stroke, lineDash } = style[index % style.length];\r\n            line.setProperties({\r\n                x1: gridPadding,\r\n                x2: -sideFlag * gridLength + gridPadding,\r\n                y: 0,\r\n                fill: undefined,\r\n                stroke,\r\n                strokeWidth: width,\r\n                lineDash,\r\n            });\r\n        });\r\n    }\r\n    updateLabels() {\r\n        const { label } = this;\r\n        if (!label.enabled) {\r\n            return;\r\n        }\r\n        // Apply label option values\r\n        this.tickLabelGroupSelection.each((node, datum) => {\r\n            node.setProperties(datum, [\r\n                'fill',\r\n                'fontFamily',\r\n                'fontSize',\r\n                'fontStyle',\r\n                'fontWeight',\r\n                'text',\r\n                'textAlign',\r\n                'textBaseline',\r\n            ]);\r\n        });\r\n    }\r\n    wrapLabels(tickData, index, labelProps) {\r\n        const { parallel, maxWidth, maxHeight } = this.label;\r\n        let defaultMaxWidth = this.maxThickness;\r\n        let defaultMaxHeight = Math.round(this.calculateAvailableRange() / tickData.labelCount);\r\n        if (parallel) {\r\n            [defaultMaxWidth, defaultMaxHeight] = [defaultMaxHeight, defaultMaxWidth];\r\n        }\r\n        tickData.ticks.forEach((tickDatum) => {\r\n            tickDatum.tickLabel = Text.wrap(tickDatum.tickLabel, maxWidth !== null && maxWidth !== void 0 ? maxWidth : defaultMaxWidth, maxHeight !== null && maxHeight !== void 0 ? maxHeight : defaultMaxHeight, labelProps, 'hyphenate');\r\n        });\r\n        return { tickData, index, autoRotation: 0, terminate: true };\r\n    }\r\n    updateTitle(params) {\r\n        const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;\r\n        if (!title) {\r\n            _titleCaption.enabled = false;\r\n            return;\r\n        }\r\n        let tickSpace = 0;\r\n        const { anyTickVisible } = params;\r\n        if (title.enabled && anyTickVisible) {\r\n            const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);\r\n            const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\r\n            if (Math.abs(tickWidth) < Infinity) {\r\n                tickSpace += tickWidth;\r\n            }\r\n        }\r\n        this.setTitleProps(_titleCaption, { tickSpace });\r\n    }\r\n    // For formatting (nice rounded) tick values.\r\n    formatTick(datum, index) {\r\n        var _a, _b;\r\n        const { label, labelFormatter, fractionDigits, moduleCtx: { callbackCache }, } = this;\r\n        if (label.formatter) {\r\n            const value = fractionDigits > 0 ? datum : String(datum);\r\n            return ((_a = callbackCache.call(label.formatter, {\r\n                value,\r\n                index,\r\n                fractionDigits,\r\n                formatter: labelFormatter,\r\n            })) !== null && _a !== void 0 ? _a : value);\r\n        }\r\n        else if (labelFormatter) {\r\n            return (_b = callbackCache.call(labelFormatter, datum)) !== null && _b !== void 0 ? _b : String(datum);\r\n        }\r\n        // The axis is using a logScale or the`datum` is an integer, a string or an object\r\n        return String(datum);\r\n    }\r\n    // For formatting arbitrary values between the ticks.\r\n    formatDatum(datum) {\r\n        return String(datum);\r\n    }\r\n    computeBBox() {\r\n        return this.axisGroup.computeBBox();\r\n    }\r\n    initCrossLine(crossLine) {\r\n        crossLine.scale = this.scale;\r\n        crossLine.gridLength = this.gridLength;\r\n    }\r\n    isAnySeriesActive() {\r\n        return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\r\n    }\r\n    clipTickLines(x, y, width, height) {\r\n        this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\r\n    }\r\n    clipGrid(x, y, width, height) {\r\n        this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\r\n    }\r\n    calculatePadding(min, _max) {\r\n        return [Math.abs(min * 0.01), Math.abs(min * 0.01)];\r\n    }\r\n    getTitleFormatterParams() {\r\n        var _a;\r\n        const boundSeries = this.boundSeries.reduce((acc, next) => {\r\n            const keys = next.getKeys(this.direction);\r\n            const names = next.getNames(this.direction);\r\n            for (let idx = 0; idx < keys.length; idx++) {\r\n                acc.push({ key: keys[idx], name: names[idx] });\r\n            }\r\n            return acc;\r\n        }, []);\r\n        return {\r\n            direction: this.direction,\r\n            boundSeries,\r\n            defaultValue: (_a = this.title) === null || _a === void 0 ? void 0 : _a.text,\r\n        };\r\n    }\r\n    normaliseDataDomain(d) {\r\n        return { domain: d, clipped: false };\r\n    }\r\n    getLayoutState() {\r\n        return Object.assign({ rect: this.computeBBox(), gridPadding: this.gridPadding, seriesAreaPadding: this.seriesAreaPadding, tickSize: this.tick.size }, this.layout);\r\n    }\r\n    getModuleMap() {\r\n        return this.moduleMap;\r\n    }\r\n    createModuleContext() {\r\n        var _a;\r\n        (_a = this.axisContext) !== null && _a !== void 0 ? _a : (this.axisContext = this.createAxisContext());\r\n        return Object.assign(Object.assign({}, this.moduleCtx), { parent: this.axisContext });\r\n    }\r\n    createAxisContext() {\r\n        return {\r\n            axisId: this.id,\r\n            direction: this.direction,\r\n            continuous: ContinuousScale.is(this.scale),\r\n            keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\r\n            scaleValueFormatter: (specifier) => { var _a, _b; return (_b = (_a = this.scale).tickFormat) === null || _b === void 0 ? void 0 : _b.call(_a, { specifier }); },\r\n            scaleBandwidth: () => { var _a; return (_a = this.scale.bandwidth) !== null && _a !== void 0 ? _a : 0; },\r\n            scaleConvert: (val) => this.scale.convert(val),\r\n            scaleInvert: (val) => { var _a, _b; return (_b = (_a = this.scale).invert) === null || _b === void 0 ? void 0 : _b.call(_a, val); },\r\n        };\r\n    }\r\n    animateReadyUpdate(diff) {\r\n        const { animationManager } = this.moduleCtx;\r\n        const selectionCtx = prepareAxisAnimationContext(this);\r\n        const fns = prepareAxisAnimationFunctions(selectionCtx);\r\n        fromToMotion(this.id, 'axis-group', animationManager, [this.axisGroup], fns.group);\r\n        fromToMotion(this.id, 'line', animationManager, [this.lineNode], fns.line);\r\n        fromToMotion(this.id, 'line-paths', animationManager, [this.gridLineGroupSelection, this.tickLineGroupSelection], fns.tick, (_, d) => d.tickId, diff);\r\n        fromToMotion(this.id, 'tick-labels', animationManager, [this.tickLabelGroupSelection], fns.label, (_, d) => d.tickId, diff);\r\n    }\r\n    resetSelectionNodes() {\r\n        const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\r\n        const selectionCtx = prepareAxisAnimationContext(this);\r\n        resetMotion([this.axisGroup], resetAxisGroupFn());\r\n        resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\r\n        resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\r\n        resetMotion([lineNode], resetAxisLineSelectionFn());\r\n    }\r\n    calculateUpdateDiff(previous, tickData) {\r\n        const added = new Set();\r\n        const removed = new Set();\r\n        const tickCount = Math.max(previous.length, tickData.ticks.length);\r\n        for (let i = 0; i < tickCount; i++) {\r\n            const tickDatum = tickData.ticks[i];\r\n            const prev = previous[i];\r\n            const tick = tickDatum === null || tickDatum === void 0 ? void 0 : tickDatum.tickId;\r\n            if (prev === tick) {\r\n                continue;\r\n            }\r\n            if (removed.has(tick)) {\r\n                removed.delete(tick);\r\n            }\r\n            else if (tick) {\r\n                added.add(tick);\r\n            }\r\n            if (added.has(prev)) {\r\n                added.delete(prev);\r\n            }\r\n            else if (prev) {\r\n                removed.add(prev);\r\n            }\r\n        }\r\n        return {\r\n            changed: added.size > 0 || removed.size > 0,\r\n            added: [...added.values()],\r\n            removed: [...removed.values()],\r\n        };\r\n    }\r\n}\r\nAxis.defaultTickMinSpacing = 50;\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Axis.prototype, \"nice\", void 0);\r\n__decorate([\r\n    Validate(STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], Axis.prototype, \"keys\", void 0);\n\nclass CartesianAxisLabel extends AxisLabel {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Rotation angle to use when autoRotate is applied.\r\n         */\r\n        this.autoRotateAngle = 335;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianAxisLabel.prototype, \"autoRotate\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(-360, 360)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", void 0);\n\nclass CartesianAxis extends Axis {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.thickness = 0;\r\n        this.position = 'left';\r\n    }\r\n    get direction() {\r\n        return ['top', 'bottom'].includes(this.position) ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n    }\r\n    updateDirection() {\r\n        switch (this.position) {\r\n            case 'top':\r\n                this.rotation = -90;\r\n                this.label.mirrored = true;\r\n                this.label.parallel = true;\r\n                break;\r\n            case 'right':\r\n                this.rotation = 0;\r\n                this.label.mirrored = true;\r\n                this.label.parallel = false;\r\n                break;\r\n            case 'bottom':\r\n                this.rotation = -90;\r\n                this.label.mirrored = false;\r\n                this.label.parallel = true;\r\n                break;\r\n            case 'left':\r\n                this.rotation = 0;\r\n                this.label.mirrored = false;\r\n                this.label.parallel = false;\r\n                break;\r\n        }\r\n        if (this.axisContext) {\r\n            this.axisContext.position = this.position;\r\n            this.axisContext.direction = this.direction;\r\n        }\r\n    }\r\n    update(primaryTickCount) {\r\n        this.updateDirection();\r\n        return super.update(primaryTickCount);\r\n    }\r\n    calculateLayout(primaryTickCount) {\r\n        this.updateDirection();\r\n        return super.calculateLayout(primaryTickCount);\r\n    }\r\n    createAxisContext() {\r\n        return Object.assign(Object.assign({}, super.createAxisContext()), { position: this.position });\r\n    }\r\n    assignCrossLineArrayConstructor(crossLines) {\r\n        assignJsonApplyConstructedArray(crossLines, CartesianCrossLine);\r\n    }\r\n    createLabel() {\r\n        return new CartesianAxisLabel();\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianAxis.prototype, \"thickness\", void 0);\r\n__decorate([\r\n    Validate(POSITION),\r\n    __metadata(\"design:type\", String)\r\n], CartesianAxis.prototype, \"position\", void 0);\n\nclass CategoryAxis extends CartesianAxis {\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new BandScale());\r\n        this._paddingOverrideEnabled = false;\r\n        this.groupPaddingInner = 0.1;\r\n        this.includeInvisibleDomains = true;\r\n    }\r\n    set paddingInner(value) {\r\n        this._paddingOverrideEnabled = true;\r\n        this.scale.paddingInner = value;\r\n    }\r\n    get paddingInner() {\r\n        this._paddingOverrideEnabled = true;\r\n        return this.scale.paddingInner;\r\n    }\r\n    set paddingOuter(value) {\r\n        this.scale.paddingOuter = value;\r\n    }\r\n    get paddingOuter() {\r\n        return this.scale.paddingOuter;\r\n    }\r\n    normaliseDataDomain(d) {\r\n        const domain = [];\r\n        const uniqueValues = new Set();\r\n        for (const v of d) {\r\n            const key = v instanceof Date ? v.getTime() : v;\r\n            if (!uniqueValues.has(key)) {\r\n                uniqueValues.add(key);\r\n                // Only add unique values\r\n                domain.push(v);\r\n            }\r\n        }\r\n        return { domain, clipped: false };\r\n    }\r\n    calculateDomain() {\r\n        if (!this._paddingOverrideEnabled) {\r\n            const paddings = this.boundSeries.map((s) => { var _a; return (_a = s.getBandScalePadding) === null || _a === void 0 ? void 0 : _a.call(s); }).filter((p) => p != null);\r\n            if (paddings.length > 0) {\r\n                this.scale.paddingInner = Math.min(...paddings.map((p) => p.inner));\r\n                this.scale.paddingOuter = Math.max(...paddings.map((p) => p.outer));\r\n            }\r\n        }\r\n        return super.calculateDomain();\r\n    }\r\n}\r\nCategoryAxis.className = 'CategoryAxis';\r\nCategoryAxis.type = 'category';\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], CategoryAxis.prototype, \"groupPaddingInner\", void 0);\n\n/**\r\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\r\n * and the tree grows downward from the root.\r\n */\r\nclass TreeNode {\r\n    constructor(label = '', parent, number = 0) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.subtreeLeft = NaN;\r\n        this.subtreeRight = NaN;\r\n        this.screenX = 0;\r\n        this.screenY = 0;\r\n        this.children = [];\r\n        this.leafCount = 0;\r\n        this.prelim = 0;\r\n        this.mod = 0;\r\n        this.ancestor = this;\r\n        this.change = 0;\r\n        this.shift = 0;\r\n        this.label = label;\r\n        // screenX and screenY are meant to be recomputed from (layout) x and y\r\n        // when the tree is resized (without performing another layout)\r\n        this.parent = parent;\r\n        this.depth = parent ? parent.depth + 1 : 0;\r\n        this.number = number;\r\n    }\r\n    getLeftSibling() {\r\n        return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\r\n    }\r\n    getLeftmostSibling() {\r\n        return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\r\n    }\r\n    // traverse the left contour of a subtree, return the successor of v on this contour\r\n    nextLeft() {\r\n        return this.children ? this.children[0] : this.thread;\r\n    }\r\n    // traverse the right contour of a subtree, return the successor of v on this contour\r\n    nextRight() {\r\n        return this.children ? this.children[this.children.length - 1] : this.thread;\r\n    }\r\n    getSiblings() {\r\n        return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\r\n    }\r\n}\r\n/**\r\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\r\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\r\n * creating empty labels.\r\n */\r\nfunction ticksToTree(ticks, pad = true) {\r\n    const root = new TreeNode();\r\n    let depth = 0;\r\n    if (pad) {\r\n        ticks.forEach((tick) => (depth = Math.max(depth, tick.labels.length)));\r\n    }\r\n    ticks.forEach((tick) => {\r\n        if (pad) {\r\n            while (tick.labels.length < depth) {\r\n                tick.labels.unshift('');\r\n            }\r\n        }\r\n        insertTick(root, tick);\r\n    });\r\n    return root;\r\n}\r\nfunction insertTick(root, tick) {\r\n    const pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\r\n    const lastPartIndex = pathParts.length - 1;\r\n    pathParts.forEach((pathPart, partIndex) => {\r\n        const children = root.children;\r\n        const existingNode = children.find((child) => child.label === pathPart);\r\n        const isNotLeaf = partIndex !== lastPartIndex;\r\n        if (existingNode && isNotLeaf) {\r\n            // the isNotLeaf check is to allow duplicate leafs\r\n            root = existingNode;\r\n        }\r\n        else {\r\n            const node = new TreeNode(pathPart, root);\r\n            node.number = children.length;\r\n            children.push(node);\r\n            if (isNotLeaf) {\r\n                root = node;\r\n            }\r\n        }\r\n    });\r\n}\r\n// Shift the subtree.\r\nfunction moveSubtree(wm, wp, shift) {\r\n    const subtrees = wp.number - wm.number;\r\n    const ratio = shift / subtrees;\r\n    wp.change -= ratio;\r\n    wp.shift += shift;\r\n    wm.change += ratio;\r\n    wp.prelim += shift;\r\n    wp.mod += shift;\r\n}\r\nfunction ancestor(vim, v, defaultAncestor) {\r\n    return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\r\n}\r\n// Spaces out the children.\r\nfunction executeShifts(v) {\r\n    const children = v.children;\r\n    if (children) {\r\n        let shift = 0;\r\n        let change = 0;\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            const w = children[i];\r\n            w.prelim += shift;\r\n            w.mod += shift;\r\n            change += w.change;\r\n            shift += w.shift + change;\r\n        }\r\n    }\r\n}\r\n// Moves current subtree with v as the root if some nodes are conflicting in space.\r\nfunction apportion(v, defaultAncestor, distance) {\r\n    const w = v.getLeftSibling();\r\n    if (w) {\r\n        let vop = v;\r\n        let vip = v;\r\n        let vim = w;\r\n        let vom = vip.getLeftmostSibling();\r\n        let sip = vip.mod;\r\n        let sop = vop.mod;\r\n        let sim = vim.mod;\r\n        let som = vom.mod;\r\n        while (vim.nextRight() && vip.nextLeft()) {\r\n            vim = vim.nextRight();\r\n            vip = vip.nextLeft();\r\n            vom = vom.nextLeft();\r\n            vop = vop.nextRight();\r\n            vop.ancestor = v;\r\n            const shift = vim.prelim + sim - (vip.prelim + sip) + distance;\r\n            if (shift > 0) {\r\n                moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\r\n                sip += shift;\r\n                sop += shift;\r\n            }\r\n            sim += vim.mod;\r\n            sip += vip.mod;\r\n            som += vom.mod;\r\n            sop += vop.mod;\r\n        }\r\n        if (vim.nextRight() && !vop.nextRight()) {\r\n            vop.thread = vim.nextRight();\r\n            vop.mod += sim - sop;\r\n        }\r\n        else {\r\n            if (vip.nextLeft() && !vom.nextLeft()) {\r\n                vom.thread = vip.nextLeft();\r\n                vom.mod += sip - som;\r\n            }\r\n            defaultAncestor = v;\r\n        }\r\n    }\r\n    return defaultAncestor;\r\n}\r\n// Compute the preliminary x-coordinate of node and its children (recursively).\r\nfunction firstWalk(node, distance) {\r\n    const children = node.children;\r\n    if (children.length) {\r\n        let defaultAncestor = children[0];\r\n        children.forEach((child) => {\r\n            firstWalk(child, distance);\r\n            defaultAncestor = apportion(child, defaultAncestor, distance);\r\n        });\r\n        executeShifts(node);\r\n        const midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\r\n        const leftSibling = node.getLeftSibling();\r\n        if (leftSibling) {\r\n            node.prelim = leftSibling.prelim + distance;\r\n            node.mod = node.prelim - midpoint;\r\n        }\r\n        else {\r\n            node.prelim = midpoint;\r\n        }\r\n    }\r\n    else {\r\n        const leftSibling = node.getLeftSibling();\r\n        node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\r\n    }\r\n}\r\nclass Dimensions {\r\n    constructor() {\r\n        this.top = Infinity;\r\n        this.right = -Infinity;\r\n        this.bottom = -Infinity;\r\n        this.left = Infinity;\r\n    }\r\n    update(node, xy) {\r\n        const { x, y } = xy(node);\r\n        if (x > this.right) {\r\n            this.right = x;\r\n        }\r\n        if (x < this.left) {\r\n            this.left = x;\r\n        }\r\n        if (y > this.bottom) {\r\n            this.bottom = y;\r\n        }\r\n        if (y < this.top) {\r\n            this.top = y;\r\n        }\r\n    }\r\n}\r\nfunction secondWalk(v, m, layout) {\r\n    v.x = v.prelim + m;\r\n    v.y = v.depth;\r\n    layout.update(v);\r\n    v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\r\n}\r\n// After the second walk the parent nodes are positioned at the center of their immediate children.\r\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\r\n// we need a third walk to adjust the positions.\r\nfunction thirdWalk(v) {\r\n    const children = v.children;\r\n    let leafCount = 0;\r\n    children.forEach((w) => {\r\n        thirdWalk(w);\r\n        if (w.children.length) {\r\n            leafCount += w.leafCount;\r\n        }\r\n        else {\r\n            leafCount++;\r\n        }\r\n    });\r\n    v.leafCount = leafCount;\r\n    if (children.length) {\r\n        v.subtreeLeft = children[0].subtreeLeft;\r\n        v.subtreeRight = children[v.children.length - 1].subtreeRight;\r\n        v.x = (v.subtreeLeft + v.subtreeRight) / 2;\r\n    }\r\n    else {\r\n        v.subtreeLeft = v.x;\r\n        v.subtreeRight = v.x;\r\n    }\r\n}\r\nfunction treeLayout(root) {\r\n    const layout = new TreeLayout();\r\n    firstWalk(root, 1);\r\n    secondWalk(root, -root.prelim, layout);\r\n    thirdWalk(root);\r\n    return layout;\r\n}\r\nclass TreeLayout {\r\n    constructor() {\r\n        this.dimensions = new Dimensions();\r\n        this.leafCount = 0;\r\n        this.nodes = [];\r\n        // One might want to process leaf nodes separately from the rest of the tree.\r\n        // For example, position labels corresponding to leafs vertically, rather than horizontally.\r\n        this.leafNodes = [];\r\n        this.nonLeafNodes = [];\r\n        this.depth = 0;\r\n    }\r\n    update(node) {\r\n        this.dimensions.update(node, (node) => ({ x: node.x, y: node.y }));\r\n        if (!node.children.length) {\r\n            this.leafCount++;\r\n            this.leafNodes.push(node);\r\n        }\r\n        else {\r\n            this.nonLeafNodes.push(node);\r\n        }\r\n        if (node.depth > this.depth) {\r\n            this.depth = node.depth;\r\n        }\r\n        this.nodes.push(node);\r\n    }\r\n    resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {\r\n        const xSteps = this.leafCount - 1;\r\n        const ySteps = this.depth;\r\n        const dimensions = this.dimensions;\r\n        let scalingX = 1;\r\n        let scalingY = 1;\r\n        if (width > 0 && xSteps) {\r\n            const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\r\n            const desiredSpacingX = width / xSteps;\r\n            scalingX = desiredSpacingX / existingSpacingX;\r\n            if (flipX) {\r\n                scalingX = -scalingX;\r\n            }\r\n        }\r\n        if (height > 0 && ySteps) {\r\n            const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\r\n            const desiredSpacingY = height / ySteps;\r\n            scalingY = desiredSpacingY / existingSpacingY;\r\n        }\r\n        const screenDimensions = new Dimensions();\r\n        this.nodes.forEach((node) => {\r\n            node.screenX = node.x * scalingX;\r\n            node.screenY = node.y * scalingY;\r\n            screenDimensions.update(node, (node) => ({ x: node.screenX, y: node.screenY }));\r\n        });\r\n        // Normalize so that root top and leftmost leaf left start at zero.\r\n        const offsetX = -screenDimensions.left;\r\n        const offsetY = -screenDimensions.top;\r\n        this.nodes.forEach((node) => {\r\n            node.screenX += offsetX + shiftX;\r\n            node.screenY += offsetY + shiftY;\r\n        });\r\n    }\r\n}\n\nclass GroupedCategoryAxisLabel extends AxisLabel {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.grid = false;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], GroupedCategoryAxisLabel.prototype, \"grid\", void 0);\r\nclass GroupedCategoryAxis extends CartesianAxis {\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new BandScale());\r\n        // Label scale (labels are positioned between ticks, tick count = label count + 1).\r\n        // We don't call is `labelScale` for consistency with other axes.\r\n        this.tickScale = new BandScale();\r\n        this.line = new AxisLine();\r\n        this.label = new GroupedCategoryAxisLabel();\r\n        /**\r\n         * The color of the labels.\r\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\r\n         */\r\n        this.labelColor = 'rgba(87, 87, 87, 1)';\r\n        this.includeInvisibleDomains = true;\r\n        const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale, scale } = this;\r\n        scale.paddingOuter = 0.1;\r\n        scale.paddingInner = scale.paddingOuter * 2;\r\n        this.range = scale.range.slice();\r\n        this.refreshScale();\r\n        tickScale.paddingInner = 1;\r\n        tickScale.paddingOuter = 0;\r\n        this.gridLineSelection = Selection.select(gridLineGroup, Line);\r\n        this.axisLineSelection = Selection.select(tickLineGroup, Line);\r\n        this.separatorSelection = Selection.select(tickLineGroup, Line);\r\n        this.labelSelection = Selection.select(tickLabelGroup, Text);\r\n    }\r\n    updateRange() {\r\n        const { range: rr, visibleRange: vr, scale } = this;\r\n        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\r\n        const shift = span * vr[0];\r\n        const start = rr[0] - shift;\r\n        this.tickScale.range = scale.range = [start, start + span];\r\n        this.resizeTickTree();\r\n    }\r\n    resizeTickTree() {\r\n        var _a;\r\n        const s = this.scale;\r\n        const range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\r\n        const layout = this.tickTreeLayout;\r\n        const lineHeight = this.lineHeight;\r\n        if (layout) {\r\n            layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + ((_a = s.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\r\n        }\r\n    }\r\n    get lineHeight() {\r\n        return this.label.fontSize * 1.5;\r\n    }\r\n    /**\r\n     * The length of the grid. The grid is only visible in case of a non-zero value.\r\n     */\r\n    set gridLength(value) {\r\n        // Was visible and now invisible, or was invisible and now visible.\r\n        if ((this._gridLength && !value) || (!this._gridLength && value)) {\r\n            this.gridLineSelection.clear();\r\n            this.labelSelection.clear();\r\n        }\r\n        this._gridLength = value;\r\n    }\r\n    get gridLength() {\r\n        return this._gridLength;\r\n    }\r\n    calculateDomain() {\r\n        var _a;\r\n        const { direction } = this;\r\n        const domains = [];\r\n        let isNumericX;\r\n        this.boundSeries\r\n            .filter((s) => s.visible)\r\n            .forEach((series) => {\r\n            if (direction === ChartAxisDirection.X) {\r\n                if (isNumericX === undefined) {\r\n                    // always add first X domain\r\n                    const domain = series.getDomain(direction);\r\n                    domains.push(domain);\r\n                    isNumericX = typeof domain[0] === 'number';\r\n                }\r\n                else if (isNumericX) {\r\n                    // only add further X domains if the axis is numeric\r\n                    domains.push(series.getDomain(direction));\r\n                }\r\n            }\r\n            else {\r\n                domains.push(series.getDomain(direction));\r\n            }\r\n        });\r\n        const domain = new Array().concat(...domains);\r\n        const values = (_a = extent(domain)) !== null && _a !== void 0 ? _a : domain;\r\n        this.dataDomain = this.normaliseDataDomain(values);\r\n        this.scale.domain = this.dataDomain.domain;\r\n    }\r\n    normaliseDataDomain(d) {\r\n        // Prevent duplicate categories.\r\n        const values = d.filter((s, i, arr) => arr.indexOf(s) === i);\r\n        const tickTree = ticksToTree(values);\r\n        this.tickTreeLayout = treeLayout(tickTree);\r\n        const tickScaleDomain = values.slice();\r\n        tickScaleDomain.push('');\r\n        this.tickScale.domain = tickScaleDomain;\r\n        this.resizeTickTree();\r\n        return { domain: values, clipped: false };\r\n    }\r\n    /**\r\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\r\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\r\n     * This allows to bulk set axis properties before updating the nodes.\r\n     * The node changes made by this method are rendered on the next animation frame.\r\n     * We could schedule this method call automatically on the next animation frame\r\n     * when any of the axis properties change (the way we do when properties of scene graph's\r\n     * nodes change), but this will mean that we first wait for the next animation\r\n     * frame to make changes to the nodes of the axis, then wait for another animation\r\n     * frame to render those changes. It's nice to have everything update automatically,\r\n     * but this extra level of async indirection will not just introduce an unwanted delay,\r\n     * it will also make it harder to reason about the program.\r\n     */\r\n    update() {\r\n        if (!this.computedLayout) {\r\n            return;\r\n        }\r\n        this.updatePosition();\r\n        this.updateTitleCaption();\r\n        this.updateCategoryLabels();\r\n        this.updateSeparators();\r\n        this.updateAxisLines();\r\n        this.updateCategoryGridLines();\r\n        this.resetSelectionNodes();\r\n        return undefined;\r\n    }\r\n    updateTitleCaption() {\r\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\r\n        // The phantom root of the tree layout is used instead.\r\n        const { _titleCaption } = this;\r\n        _titleCaption.node.visible = false;\r\n    }\r\n    updateCategoryLabels() {\r\n        if (!this.computedLayout)\r\n            return;\r\n        const { tickLabelLayout } = this.computedLayout;\r\n        const labelSelection = this.labelSelection.update(tickLabelLayout);\r\n        labelSelection.each((node, datum) => {\r\n            node.setProperties(datum);\r\n        });\r\n    }\r\n    updateSeparators() {\r\n        if (!this.computedLayout)\r\n            return;\r\n        const { separatorLayout } = this.computedLayout;\r\n        const { range } = this;\r\n        const epsilon = 0.0000001;\r\n        const separatorSelection = this.separatorSelection.update(separatorLayout);\r\n        separatorSelection.each((line, datum) => {\r\n            line.x1 = datum.x1;\r\n            line.x2 = datum.x2;\r\n            line.y1 = datum.y;\r\n            line.y2 = datum.y;\r\n            line.visible = datum.y >= range[0] - epsilon && datum.y <= range[1] + epsilon;\r\n            line.stroke = this.tick.color;\r\n            line.fill = undefined;\r\n            line.strokeWidth = 1;\r\n        });\r\n    }\r\n    updateAxisLines() {\r\n        if (!this.computedLayout)\r\n            return;\r\n        const { axisLineLayout } = this.computedLayout;\r\n        const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\r\n        axisLineSelection.each((line, datum) => {\r\n            line.setProperties(Object.assign(Object.assign({}, datum), { stroke: this.line.color, strokeWidth: this.line.width }));\r\n            line.x1 = datum.x;\r\n            line.x2 = datum.x;\r\n            line.y1 = datum.y1;\r\n            line.y2 = datum.y2;\r\n            line.strokeWidth = this.line.width;\r\n            line.stroke = this.line.color;\r\n        });\r\n    }\r\n    updateCategoryGridLines() {\r\n        const { gridLength, gridLine, label, range, tickScale } = this;\r\n        const ticks = tickScale.ticks();\r\n        const sideFlag = label.getSideFlag();\r\n        const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\r\n        if (gridLength) {\r\n            const { width, style } = gridLine;\r\n            const styleCount = style.length;\r\n            gridSelection.each((line, datum, index) => {\r\n                const y = Math.round(tickScale.convert(datum));\r\n                line.x1 = 0;\r\n                line.x2 = -sideFlag * gridLength;\r\n                line.y1 = y;\r\n                line.y2 = y;\r\n                line.visible = y >= range[0] && y <= range[1];\r\n                const { stroke, lineDash } = style[index % styleCount];\r\n                line.stroke = stroke;\r\n                line.strokeWidth = width;\r\n                line.lineDash = lineDash;\r\n                line.fill = undefined;\r\n            });\r\n        }\r\n    }\r\n    computeLayout() {\r\n        this.updateDirection();\r\n        this.calculateDomain();\r\n        this.updateRange();\r\n        const { scale, label, label: { parallel }, moduleCtx: { callbackCache }, range, title, title: { formatter = (p) => p.defaultValue } = {}, } = this;\r\n        const rangeStart = scale.range[0];\r\n        const rangeEnd = scale.range[1];\r\n        const rangeLength = Math.abs(rangeEnd - rangeStart);\r\n        const bandwidth = rangeLength / scale.domain.length || 0;\r\n        const rotation = toRadians(this.rotation);\r\n        const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\r\n        const sideFlag = label.getSideFlag();\r\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\r\n        // The phantom root of the tree layout is used instead.\r\n        const lineHeight = this.lineHeight;\r\n        // Render ticks and labels.\r\n        const tickTreeLayout = this.tickTreeLayout;\r\n        const labels = scale.ticks();\r\n        const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\r\n        const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\r\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\r\n        // flip the labels to avoid upside-down text, when the axis is rotated\r\n        // such that it is in the right hemisphere, i.e. the angle of rotation\r\n        // is in the [0, π] interval.\r\n        // The rotation angle is normalized, so that we have an easier time checking\r\n        // if it's in the said interval. Since the axis is always rendered vertically\r\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\r\n        // -1 = flip\r\n        //  1 = don't flip (default)\r\n        const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\r\n            rotation: label.rotation,\r\n            parallel,\r\n            regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\r\n            parallelFlipRotation: normalizeAngle360(rotation),\r\n        });\r\n        const tickLabelLayout = [];\r\n        const copyLabelProps = (node) => {\r\n            return {\r\n                fill: node.fill,\r\n                fontFamily: node.fontFamily,\r\n                fontSize: node.fontSize,\r\n                fontStyle: node.fontStyle,\r\n                fontWeight: node.fontWeight,\r\n                rotation: node.rotation,\r\n                rotationCenterX: node.rotationCenterX,\r\n                rotationCenterY: node.rotationCenterY,\r\n                text: node.text,\r\n                textAlign: node.textAlign,\r\n                textBaseline: node.textBaseline,\r\n                translationX: node.translationX,\r\n                translationY: node.translationY,\r\n                visible: node.visible,\r\n                x: node.x,\r\n                y: node.y,\r\n            };\r\n        };\r\n        const labelBBoxes = new Map();\r\n        let maxLeafLabelWidth = 0;\r\n        const tempText = new Text();\r\n        const setLabelProps = (datum, index) => {\r\n            var _a;\r\n            tempText.setProperties({\r\n                fill: label.color,\r\n                fontFamily: label.fontFamily,\r\n                fontSize: label.fontSize,\r\n                fontStyle: label.fontStyle,\r\n                fontWeight: label.fontWeight,\r\n                textAlign: 'center',\r\n                textBaseline: parallelFlipFlag === -1 ? 'bottom' : 'hanging',\r\n                translationX: datum.screenY - label.fontSize * 0.25,\r\n                translationY: datum.screenX,\r\n            });\r\n            if (index === 0) {\r\n                const isCaptionEnabled = (title === null || title === void 0 ? void 0 : title.enabled) && labels.length > 0;\r\n                if (!isCaptionEnabled) {\r\n                    return false;\r\n                }\r\n                const text = callbackCache.call(formatter, this.getTitleFormatterParams());\r\n                tempText.setProperties({\r\n                    fill: title.color,\r\n                    fontFamily: title.fontFamily,\r\n                    fontSize: title.fontSize,\r\n                    fontStyle: title.fontStyle,\r\n                    fontWeight: title.fontWeight,\r\n                    text,\r\n                    textBaseline: 'hanging',\r\n                    translationX: datum.screenY - label.fontSize * 0.25,\r\n                    translationY: datum.screenX,\r\n                });\r\n            }\r\n            else {\r\n                const isInRange = datum.screenX >= range[0] && datum.screenX <= range[1];\r\n                if (!isInRange) {\r\n                    return false;\r\n                }\r\n                if (label.formatter) {\r\n                    tempText.text =\r\n                        (_a = callbackCache.call(label.formatter, {\r\n                            value: String(datum.label),\r\n                            index,\r\n                        })) !== null && _a !== void 0 ? _a : String(datum.label);\r\n                }\r\n                else {\r\n                    tempText.text = String(datum.label);\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        treeLabels.forEach((datum, index) => {\r\n            const isVisible = setLabelProps(datum, index);\r\n            if (isVisible) {\r\n                const bbox = tempText.computeTransformedBBox();\r\n                if (bbox) {\r\n                    labelBBoxes.set(index, bbox);\r\n                    if (bbox.width > maxLeafLabelWidth) {\r\n                        maxLeafLabelWidth = bbox.width;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        const labelX = sideFlag * label.padding;\r\n        const labelGrid = this.label.grid;\r\n        const separatorData = [];\r\n        treeLabels.forEach((datum, index) => {\r\n            let visible = setLabelProps(datum, index);\r\n            const id = index;\r\n            tempText.x = labelX;\r\n            tempText.rotationCenterX = labelX;\r\n            const isLeaf = !datum.children.length;\r\n            if (isLeaf) {\r\n                tempText.rotation = configuredRotation;\r\n                tempText.textAlign = 'end';\r\n                tempText.textBaseline = 'middle';\r\n                const bbox = labelBBoxes.get(id);\r\n                if (bbox && bbox.height > bandwidth) {\r\n                    visible = false;\r\n                    labelBBoxes.delete(id);\r\n                }\r\n            }\r\n            else {\r\n                tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\r\n                const availableRange = datum.leafCount * bandwidth;\r\n                const bbox = labelBBoxes.get(id);\r\n                if (bbox && bbox.width > availableRange) {\r\n                    visible = false;\r\n                    labelBBoxes.delete(id);\r\n                }\r\n                else if (isHorizontal) {\r\n                    tempText.rotation = defaultRotation;\r\n                }\r\n                else {\r\n                    tempText.rotation = -Math.PI / 2;\r\n                }\r\n            }\r\n            // Calculate positions of label separators for all nodes except the root.\r\n            // Each separator is placed to the top of the current label.\r\n            if (datum.parent && isLabelTree) {\r\n                const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - (datum.leafCount * bandwidth) / 2;\r\n                if (isLeaf) {\r\n                    if (datum.number !== datum.children.length - 1 || labelGrid) {\r\n                        separatorData.push({\r\n                            y,\r\n                            x1: 0,\r\n                            x2: -maxLeafLabelWidth - this.label.padding * 2,\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\r\n                    separatorData.push({\r\n                        y,\r\n                        x1: x + lineHeight,\r\n                        x2: x,\r\n                    });\r\n                }\r\n            }\r\n            let props;\r\n            if (visible) {\r\n                const bbox = tempText.computeTransformedBBox();\r\n                if (bbox) {\r\n                    labelBBoxes.set(index, bbox);\r\n                }\r\n                props = Object.assign(Object.assign({}, copyLabelProps(tempText)), { visible });\r\n            }\r\n            else {\r\n                labelBBoxes.delete(index);\r\n                props = { visible };\r\n            }\r\n            tickLabelLayout.push(props);\r\n        });\r\n        // Calculate the position of the long separator on the far bottom of the axis.\r\n        let minX = 0;\r\n        separatorData.forEach((d) => (minX = Math.min(minX, d.x2)));\r\n        separatorData.push({\r\n            y: Math.max(rangeStart, rangeEnd),\r\n            x1: 0,\r\n            x2: minX,\r\n        });\r\n        const separatorLayout = [];\r\n        const separatorBoxes = [];\r\n        const epsilon = 0.0000001;\r\n        separatorData.forEach((datum) => {\r\n            if (datum.y >= range[0] - epsilon && datum.y <= range[1] + epsilon) {\r\n                const { x1, x2, y } = datum;\r\n                const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\r\n                separatorBoxes.push(separatorBox);\r\n                separatorLayout.push({ x1, x2, y });\r\n            }\r\n        });\r\n        const axisLineLayout = [];\r\n        const axisLineBoxes = [];\r\n        const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\r\n        for (let i = 0; i < lineCount; i++) {\r\n            const visible = labels.length > 0 && (i === 0 || (labelGrid && isLabelTree));\r\n            const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\r\n            const lineBox = new BBox(x, Math.min(...range), 0, Math.abs(range[1] - range[0]));\r\n            axisLineBoxes.push(lineBox);\r\n            axisLineLayout.push({ x, y1: range[0], y2: range[1], visible });\r\n        }\r\n        const getTransformBox = (bbox) => {\r\n            const matrix = new Matrix();\r\n            const { rotation: axisRotation, translationX, translationY, rotationCenterX, rotationCenterY, } = this.getAxisTransform();\r\n            Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\r\n                scalingCenterX: 0,\r\n                scalingCenterY: 0,\r\n                rotationCenterX,\r\n                rotationCenterY,\r\n            });\r\n            return matrix.transformBBox(bbox);\r\n        };\r\n        const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);\r\n        const transformedBBox = getTransformBox(bbox);\r\n        return {\r\n            bbox: transformedBBox,\r\n            tickLabelLayout,\r\n            separatorLayout,\r\n            axisLineLayout,\r\n        };\r\n    }\r\n    calculateLayout() {\r\n        const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\r\n        this.computedLayout = {\r\n            axisLineLayout,\r\n            separatorLayout,\r\n            tickLabelLayout,\r\n        };\r\n        return { bbox, primaryTickCount: undefined };\r\n    }\r\n}\r\nGroupedCategoryAxis.className = 'GroupedCategoryAxis';\r\nGroupedCategoryAxis.type = 'grouped-category';\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], GroupedCategoryAxis.prototype, \"labelColor\", void 0);\n\n/**\r\n * Wraps a native OffscreenCanvas and overrides its OffscreenCanvasRenderingContext2D to\r\n * provide resolution independent rendering based on `window.devicePixelRatio`.\r\n */\r\nclass HdpiOffscreenCanvas {\r\n    static isSupported() {\r\n        return typeof OffscreenCanvas !== 'undefined' && OffscreenCanvas.prototype.transferToImageBitmap != null;\r\n    }\r\n    // The width/height attributes of the Canvas element default to\r\n    // 300/150 according to w3.org.\r\n    constructor({ width = 600, height = 300, overrideDevicePixelRatio }) {\r\n        this.enabled = true;\r\n        // `NaN` is deliberate here, so that overrides are always applied\r\n        // and the `resetTransform` inside the `resize` method works in IE11.\r\n        this._pixelRatio = NaN;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this.canvas = new OffscreenCanvas(width, height);\r\n        this.realContext = this.canvas.getContext('2d');\r\n        this.imageSource = this.canvas.transferToImageBitmap();\r\n        this.context = this.setPixelRatio(overrideDevicePixelRatio);\r\n        this.resize(width, height);\r\n    }\r\n    snapshot() {\r\n        this.imageSource.close();\r\n        this.imageSource = this.canvas.transferToImageBitmap();\r\n    }\r\n    destroy() {\r\n        this.imageSource.close();\r\n        // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.\r\n        // See https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n        this.canvas.width = 0;\r\n        this.canvas.height = 0;\r\n        this.context.clearRect(0, 0, 0, 0);\r\n    }\r\n    clear() {\r\n        this.context.save();\r\n        this.context.resetTransform();\r\n        this.context.clearRect(0, 0, this.width, this.height);\r\n        this.context.restore();\r\n    }\r\n    get pixelRatio() {\r\n        return this._pixelRatio;\r\n    }\r\n    /**\r\n     * Changes the pixel ratio of the Canvas element to the given value,\r\n     * or uses the window.devicePixelRatio (default), then resizes the Canvas\r\n     * element accordingly (default).\r\n     */\r\n    setPixelRatio(ratio) {\r\n        let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : window.devicePixelRatio;\r\n        if (!isDesktop()) {\r\n            // Mobile browsers have stricter memory limits, we reduce rendering resolution to\r\n            // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they\r\n            // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n            pixelRatio = 1;\r\n        }\r\n        this._pixelRatio = pixelRatio;\r\n        return HdpiCanvas.overrideScale(this.realContext, pixelRatio);\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    resize(width, height) {\r\n        if (!(width > 0 && height > 0)) {\r\n            return;\r\n        }\r\n        const { canvas, context, pixelRatio } = this;\r\n        canvas.width = Math.round(width * pixelRatio);\r\n        canvas.height = Math.round(height * pixelRatio);\r\n        context.resetTransform();\r\n        this._width = width;\r\n        this._height = height;\r\n    }\r\n}\n\nvar DebugSelectors;\r\n(function (DebugSelectors) {\r\n    DebugSelectors[\"SCENE\"] = \"scene\";\r\n    DebugSelectors[\"SCENE_STATS\"] = \"scene:stats\";\r\n    DebugSelectors[\"SCENE_STATS_VERBOSE\"] = \"scene:stats:verbose\";\r\n    DebugSelectors[\"SCENE_DIRTY_TREE\"] = \"scene:dirtyTree\";\r\n})(DebugSelectors || (DebugSelectors = {}));\r\nconst advancedCompositeIdentifier = 'adv-composite';\r\nconst domCompositeIdentifier = 'dom-composite';\r\nclass Scene {\r\n    constructor(opts) {\r\n        var _a;\r\n        this.id = createId(this);\r\n        this.layers = [];\r\n        this._nextZIndex = 0;\r\n        this._nextLayerId = 0;\r\n        this._dirty = false;\r\n        this._root = null;\r\n        this.debug = Debug.create(true, DebugSelectors.SCENE);\r\n        const { document, window, mode = (_a = windowValue('agChartsSceneRenderModel')) !== null && _a !== void 0 ? _a : advancedCompositeIdentifier, width, height, overrideDevicePixelRatio = undefined, } = opts;\r\n        this.overrideDevicePixelRatio = overrideDevicePixelRatio;\r\n        this.opts = { document, window, mode };\r\n        this.canvas = new HdpiCanvas({ document, window, width, height, overrideDevicePixelRatio });\r\n    }\r\n    set container(value) {\r\n        this.canvas.container = value;\r\n    }\r\n    get container() {\r\n        return this.canvas.container;\r\n    }\r\n    download(fileName, fileFormat) {\r\n        this.canvas.download(fileName, fileFormat);\r\n    }\r\n    getDataURL(type) {\r\n        return this.canvas.getDataURL(type);\r\n    }\r\n    get width() {\r\n        return this.pendingSize ? this.pendingSize[0] : this.canvas.width;\r\n    }\r\n    get height() {\r\n        return this.pendingSize ? this.pendingSize[1] : this.canvas.height;\r\n    }\r\n    resize(width, height) {\r\n        width = Math.round(width);\r\n        height = Math.round(height);\r\n        // HdpiCanvas doesn't allow width/height <= 0.\r\n        const lessThanZero = width <= 0 || height <= 0;\r\n        const nan = isNaN(width) || isNaN(height);\r\n        const unchanged = width === this.width && height === this.height;\r\n        if (unchanged || nan || lessThanZero) {\r\n            return false;\r\n        }\r\n        this.pendingSize = [width, height];\r\n        this.markDirty();\r\n        return true;\r\n    }\r\n    addLayer(opts) {\r\n        var _a;\r\n        const { mode } = this.opts;\r\n        const layeredModes = ['composite', domCompositeIdentifier, advancedCompositeIdentifier];\r\n        if (!layeredModes.includes(mode)) {\r\n            return undefined;\r\n        }\r\n        const { zIndex = this._nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\r\n        const { width, height, overrideDevicePixelRatio } = this;\r\n        const domLayer = mode === domCompositeIdentifier;\r\n        const advLayer = mode === advancedCompositeIdentifier;\r\n        const canvas = !advLayer || !HdpiOffscreenCanvas.isSupported()\r\n            ? new HdpiCanvas({\r\n                document: this.opts.document,\r\n                window: this.opts.window,\r\n                width,\r\n                height,\r\n                domLayer,\r\n                zIndex,\r\n                name,\r\n                overrideDevicePixelRatio,\r\n            })\r\n            : new HdpiOffscreenCanvas({\r\n                width,\r\n                height,\r\n                overrideDevicePixelRatio,\r\n            });\r\n        const newLayer = {\r\n            id: this._nextLayerId++,\r\n            name,\r\n            zIndex,\r\n            zIndexSubOrder,\r\n            canvas,\r\n            getComputedOpacity,\r\n            getVisibility,\r\n        };\r\n        if (zIndex >= this._nextZIndex) {\r\n            this._nextZIndex = zIndex + 1;\r\n        }\r\n        this.layers.push(newLayer);\r\n        this.sortLayers();\r\n        if (domLayer) {\r\n            const domCanvases = this.layers\r\n                .map((v) => v.canvas)\r\n                .filter((v) => v instanceof HdpiCanvas);\r\n            const newLayerIndex = domCanvases.findIndex((v) => v === canvas);\r\n            const lastLayer = (_a = domCanvases[newLayerIndex - 1]) !== null && _a !== void 0 ? _a : this.canvas;\r\n            lastLayer.element.insertAdjacentElement('afterend', canvas.element);\r\n        }\r\n        this.debug('Scene.addLayer() - layers', this.layers);\r\n        return newLayer.canvas;\r\n    }\r\n    removeLayer(canvas) {\r\n        const index = this.layers.findIndex((l) => l.canvas === canvas);\r\n        if (index >= 0) {\r\n            this.layers.splice(index, 1);\r\n            canvas.destroy();\r\n            this.markDirty();\r\n            this.debug('Scene.removeLayer() -  layers', this.layers);\r\n        }\r\n    }\r\n    moveLayer(canvas, newZIndex, newZIndexSubOrder) {\r\n        const layer = this.layers.find((l) => l.canvas === canvas);\r\n        if (layer) {\r\n            layer.zIndex = newZIndex;\r\n            layer.zIndexSubOrder = newZIndexSubOrder;\r\n            this.sortLayers();\r\n            this.markDirty();\r\n            this.debug('Scene.moveLayer() -  layers', this.layers);\r\n        }\r\n    }\r\n    sortLayers() {\r\n        this.layers.sort((a, b) => {\r\n            var _a, _b;\r\n            return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.id], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.id], ascendingStringNumberUndefined);\r\n        });\r\n    }\r\n    markDirty() {\r\n        this._dirty = true;\r\n    }\r\n    get dirty() {\r\n        return this._dirty;\r\n    }\r\n    set root(node) {\r\n        var _a;\r\n        if (node === this._root) {\r\n            return;\r\n        }\r\n        (_a = this._root) === null || _a === void 0 ? void 0 : _a._setLayerManager();\r\n        this._root = node;\r\n        if (node) {\r\n            node._setLayerManager({\r\n                addLayer: (opts) => this.addLayer(opts),\r\n                moveLayer: (...opts) => this.moveLayer(...opts),\r\n                removeLayer: (...opts) => this.removeLayer(...opts),\r\n                markDirty: () => this.markDirty(),\r\n                canvas: this.canvas,\r\n                debug: Debug.create(DebugSelectors.SCENE),\r\n            });\r\n        }\r\n        this.markDirty();\r\n    }\r\n    get root() {\r\n        return this._root;\r\n    }\r\n    /** Alternative to destroy() that preserves re-usable resources. */\r\n    strip() {\r\n        const { layers } = this;\r\n        for (const layer of layers) {\r\n            layer.canvas.destroy();\r\n            delete layer['canvas'];\r\n        }\r\n        layers.splice(0, layers.length);\r\n        this.root = null;\r\n        this._dirty = false;\r\n        this.canvas.context.resetTransform();\r\n    }\r\n    destroy() {\r\n        this.container = undefined;\r\n        this.strip();\r\n        this.canvas.destroy();\r\n        Object.assign(this, { canvas: undefined, ctx: undefined });\r\n    }\r\n    render(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { debugSplitTimes = { start: performance.now() }, extraDebugStats = {} } = opts !== null && opts !== void 0 ? opts : {};\r\n            const { canvas, canvas: { context: ctx }, root, layers, pendingSize, opts: { mode }, } = this;\r\n            if (pendingSize) {\r\n                this.canvas.resize(...pendingSize);\r\n                this.layers.forEach((layer) => layer.canvas.resize(...pendingSize));\r\n                this.pendingSize = undefined;\r\n            }\r\n            if (root && !root.visible) {\r\n                this._dirty = false;\r\n                return;\r\n            }\r\n            if (root && !this.dirty) {\r\n                this.debug('Scene.render() - no-op', {\r\n                    redrawType: RedrawType[root.dirty],\r\n                    tree: this.buildTree(root),\r\n                });\r\n                this.debugStats(debugSplitTimes, ctx, undefined, extraDebugStats);\r\n                return;\r\n            }\r\n            const renderCtx = {\r\n                ctx,\r\n                devicePixelRatio: (_a = this.canvas.pixelRatio) !== null && _a !== void 0 ? _a : 1,\r\n                forceRender: true,\r\n                resized: !!pendingSize,\r\n                debugNodes: {},\r\n            };\r\n            if (Debug.check(DebugSelectors.SCENE_STATS_VERBOSE)) {\r\n                renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\r\n            }\r\n            let canvasCleared = false;\r\n            if (!root || root.dirty >= RedrawType.TRIVIAL) {\r\n                // start with a blank canvas, clear previous drawing\r\n                canvasCleared = true;\r\n                canvas.clear();\r\n            }\r\n            if (root) {\r\n                const { dirtyTree, paths } = this.buildDirtyTree(root);\r\n                Debug.create(DebugSelectors.SCENE_DIRTY_TREE)('Scene.render() - dirtyTree', {\r\n                    dirtyTree,\r\n                    paths,\r\n                });\r\n            }\r\n            if (root && canvasCleared) {\r\n                this.debug('Scene.render() - before', {\r\n                    redrawType: RedrawType[root.dirty],\r\n                    canvasCleared,\r\n                    tree: this.buildTree(root),\r\n                });\r\n                if (root.visible) {\r\n                    ctx.save();\r\n                    root.render(renderCtx);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n            debugSplitTimes['✍️'] = performance.now();\r\n            if (mode !== domCompositeIdentifier && layers.length > 0 && canvasCleared) {\r\n                this.sortLayers();\r\n                ctx.save();\r\n                ctx.setTransform(1 / canvas.pixelRatio, 0, 0, 1 / canvas.pixelRatio, 0, 0);\r\n                layers.forEach(({ canvas: { imageSource, enabled }, getComputedOpacity, getVisibility }) => {\r\n                    if (!enabled || !getVisibility()) {\r\n                        return;\r\n                    }\r\n                    ctx.globalAlpha = getComputedOpacity();\r\n                    ctx.drawImage(imageSource, 0, 0);\r\n                });\r\n                ctx.restore();\r\n                debugSplitTimes['⛙'] = performance.now();\r\n            }\r\n            // Check for save/restore depth of zero!\r\n            (_b = ctx.verifyDepthZero) === null || _b === void 0 ? void 0 : _b.call(ctx);\r\n            this._dirty = false;\r\n            this.debugStats(debugSplitTimes, ctx, renderCtx.stats, extraDebugStats);\r\n            this.debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\r\n            if (root) {\r\n                this.debug('Scene.render() - after', {\r\n                    redrawType: RedrawType[root.dirty],\r\n                    canvasCleared,\r\n                    tree: this.buildTree(root),\r\n                });\r\n            }\r\n        });\r\n    }\r\n    debugStats(debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}) {\r\n        if (Debug.check(DebugSelectors.SCENE_STATS, DebugSelectors.SCENE_STATS_VERBOSE)) {\r\n            const end = performance.now();\r\n            const start = debugSplitTimes['start'];\r\n            debugSplitTimes['end'] = performance.now();\r\n            const pct = (rendered, skipped) => {\r\n                const total = rendered + skipped;\r\n                return `${rendered} / ${total} (${Math.round((100 * rendered) / total)}%)`;\r\n            };\r\n            const time = (name, start, end) => {\r\n                return `${name}: ${Math.round((end - start) * 100) / 100}ms`;\r\n            };\r\n            const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats !== null && renderCtxStats !== void 0 ? renderCtxStats : {};\r\n            let lastSplit = 0;\r\n            const splits = Object.entries(debugSplitTimes)\r\n                .filter(([n]) => n !== 'end')\r\n                .map(([n, t], i) => {\r\n                const result = i > 0 ? time(n, lastSplit, t) : null;\r\n                lastSplit = t;\r\n                return result;\r\n            })\r\n                .filter((v) => v != null)\r\n                .join(' + ');\r\n            const extras = Object.entries(extraDebugStats)\r\n                .map(([k, v]) => `${k}: ${v}`)\r\n                .join(' ; ');\r\n            const detailedStats = Debug.check(DebugSelectors.SCENE_STATS_VERBOSE);\r\n            const stats = [\r\n                `${time('⏱️', start, end)} (${splits})`,\r\n                `${extras}`,\r\n                `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : this.layers.length}`,\r\n                detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null,\r\n            ].filter((v) => v != null);\r\n            const statsSize = stats.map((t) => [t, HdpiCanvas.getTextSize(t, ctx.font)]);\r\n            const width = Math.max(...statsSize.map(([, { width }]) => width));\r\n            const height = statsSize.reduce((total, [, { height }]) => total + height, 0);\r\n            ctx.save();\r\n            ctx.fillStyle = 'white';\r\n            ctx.fillRect(0, 0, width, height);\r\n            ctx.fillStyle = 'black';\r\n            let y = 0;\r\n            for (const [stat, size] of statsSize) {\r\n                y += size.height;\r\n                ctx.fillText(stat, 2, y);\r\n            }\r\n            ctx.restore();\r\n        }\r\n    }\r\n    debugSceneNodeHighlight(ctx, debugNodes) {\r\n        var _a;\r\n        const regexpPredicate = (matcher) => (n) => {\r\n            if (matcher.test(n.id)) {\r\n                return true;\r\n            }\r\n            return n instanceof Group && n.name != null && matcher.test(n.name);\r\n        };\r\n        const stringPredicate = (match) => (n) => {\r\n            if (match === n.id) {\r\n                return true;\r\n            }\r\n            return n instanceof Group && n.name != null && match === n.name;\r\n        };\r\n        const sceneNodeHighlight = toArray(windowValue('agChartsSceneDebug')).flatMap((name) => name === 'layout' ? ['seriesRoot', 'legend', 'root', /.*Axis-\\d+-axis.*/] : name);\r\n        for (const next of sceneNodeHighlight) {\r\n            if (typeof next === 'string' && debugNodes[next] != null)\r\n                continue;\r\n            const predicate = typeof next === 'string' ? stringPredicate(next) : regexpPredicate(next);\r\n            const nodes = (_a = this.root) === null || _a === void 0 ? void 0 : _a.findNodes(predicate);\r\n            if (!nodes || nodes.length === 0) {\r\n                Logger.log(`Scene.render() - no debugging node with id [${next}] in scene graph.`);\r\n                continue;\r\n            }\r\n            for (const node of nodes) {\r\n                if (node instanceof Group && node.name) {\r\n                    debugNodes[node.name] = node;\r\n                }\r\n                else {\r\n                    debugNodes[node.id] = node;\r\n                }\r\n            }\r\n        }\r\n        ctx.save();\r\n        for (const [name, node] of Object.entries(debugNodes)) {\r\n            const bbox = node.computeTransformedBBox();\r\n            if (!bbox) {\r\n                Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\r\n                continue;\r\n            }\r\n            ctx.globalAlpha = 0.8;\r\n            ctx.strokeStyle = 'red';\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\r\n            ctx.fillStyle = 'red';\r\n            ctx.strokeStyle = 'white';\r\n            ctx.font = '16px sans-serif';\r\n            ctx.textBaseline = 'top';\r\n            ctx.textAlign = 'left';\r\n            ctx.lineWidth = 2;\r\n            ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\r\n            ctx.fillText(name, bbox.x, bbox.y, bbox.width);\r\n        }\r\n        ctx.restore();\r\n    }\r\n    buildTree(node) {\r\n        var _a, _b;\r\n        const name = (_a = (node instanceof Group ? node.name : null)) !== null && _a !== void 0 ? _a : node.id;\r\n        return Object.assign(Object.assign({ name,\r\n            node, dirty: RedrawType[node.dirty] }, (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.isVirtual)\r\n            ? {\r\n                virtualParentDirty: RedrawType[node.parent.dirty],\r\n                virtualParent: node.parent,\r\n            }\r\n            : {})), node.children\r\n            .map((c) => this.buildTree(c))\r\n            .reduce((result, childTree) => {\r\n            let { name: treeNodeName } = childTree;\r\n            const { node: { visible, opacity, zIndex, zIndexSubOrder }, node: childNode, virtualParent, } = childTree;\r\n            if (!visible || opacity <= 0) {\r\n                treeNodeName = `(${treeNodeName})`;\r\n            }\r\n            if (childNode instanceof Group && childNode.isLayer()) {\r\n                treeNodeName = `*${treeNodeName}*`;\r\n            }\r\n            const key = [\r\n                `${treeNodeName !== null && treeNodeName !== void 0 ? treeNodeName : '<unknown>'}`,\r\n                `z: ${zIndex}`,\r\n                zIndexSubOrder &&\r\n                    `zo: ${zIndexSubOrder\r\n                        .map((v) => (typeof v === 'function' ? `${v()} (fn)` : v))\r\n                        .join(' / ')}`,\r\n                virtualParent && `(virtual parent)`,\r\n            ]\r\n                .filter((v) => !!v)\r\n                .join(' ');\r\n            let selectedKey = key;\r\n            let index = 1;\r\n            while (result[selectedKey] != null && index < 100) {\r\n                selectedKey = `${key} (${index++})`;\r\n            }\r\n            result[selectedKey] = childTree;\r\n            return result;\r\n        }, {}));\r\n    }\r\n    buildDirtyTree(node) {\r\n        var _a;\r\n        if (node.dirty === RedrawType.NONE) {\r\n            return { dirtyTree: {}, paths: [] };\r\n        }\r\n        const childrenDirtyTree = node.children.map((c) => this.buildDirtyTree(c)).filter((c) => c.paths.length > 0);\r\n        const name = (_a = (node instanceof Group ? node.name : null)) !== null && _a !== void 0 ? _a : node.id;\r\n        const paths = childrenDirtyTree.length === 0\r\n            ? [name]\r\n            : childrenDirtyTree\r\n                .map((c) => c.paths)\r\n                .reduce((r, p) => r.concat(p), [])\r\n                .map((p) => `${name}.${p}`);\r\n        return {\r\n            dirtyTree: Object.assign({ name,\r\n                node, dirty: RedrawType[node.dirty] }, childrenDirtyTree\r\n                .map((c) => c.dirtyTree)\r\n                .filter((t) => t.dirty !== undefined)\r\n                .reduce((result, childTree) => {\r\n                var _a;\r\n                result[(_a = childTree.name) !== null && _a !== void 0 ? _a : '<unknown>'] = childTree;\r\n                return result;\r\n            }, {})),\r\n            paths,\r\n        };\r\n    }\r\n}\r\nScene.className = 'Scene';\n\nfunction sleep(sleepTimeoutMs) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => resolve(undefined), sleepTimeoutMs);\r\n    });\r\n}\n\nclass CallbackCache {\r\n    constructor() {\r\n        this.cache = new WeakMap();\r\n    }\r\n    call(fn, ...params) {\r\n        let serialisedParams;\r\n        let paramCache = this.cache.get(fn);\r\n        const invoke = () => {\r\n            try {\r\n                const result = fn(...params);\r\n                if (paramCache && serialisedParams != null) {\r\n                    paramCache.set(serialisedParams, result);\r\n                }\r\n                return result;\r\n            }\r\n            catch (e) {\r\n                Logger.warnOnce(`User callback errored, ignoring`, e);\r\n                return undefined;\r\n            }\r\n        };\r\n        try {\r\n            serialisedParams = JSON.stringify(params);\r\n        }\r\n        catch (e) {\r\n            // Unable to serialise params!\r\n            // No caching possible.\r\n            return invoke();\r\n        }\r\n        if (paramCache == null) {\r\n            paramCache = new Map();\r\n            this.cache.set(fn, paramCache);\r\n        }\r\n        if (!paramCache.has(serialisedParams)) {\r\n            return invoke();\r\n        }\r\n        return paramCache.get(serialisedParams);\r\n    }\r\n    invalidateCache() {\r\n        this.cache = new WeakMap();\r\n    }\r\n}\n\nclass Mutex {\r\n    constructor() {\r\n        this.available = true;\r\n        this.acquireQueue = [];\r\n    }\r\n    acquire(cb) {\r\n        return new Promise((resolve) => {\r\n            this.acquireQueue.push([cb, resolve]);\r\n            if (this.available) {\r\n                this.dispatchNext();\r\n            }\r\n        });\r\n    }\r\n    acquireImmediately(cb) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.available) {\r\n                return false;\r\n            }\r\n            yield this.acquire(cb);\r\n            return true;\r\n        });\r\n    }\r\n    waitForClearAcquireQueue() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.acquire(() => __awaiter(this, void 0, void 0, function* () { return undefined; }));\r\n        });\r\n    }\r\n    dispatchNext() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.available = false;\r\n            let [next, done] = (_a = this.acquireQueue.shift()) !== null && _a !== void 0 ? _a : [];\r\n            while (next) {\r\n                try {\r\n                    yield next();\r\n                    done === null || done === void 0 ? void 0 : done();\r\n                }\r\n                catch (error) {\r\n                    Logger.error('mutex callback error', error);\r\n                    done === null || done === void 0 ? void 0 : done();\r\n                }\r\n                [next, done] = (_b = this.acquireQueue.shift()) !== null && _b !== void 0 ? _b : [];\r\n            }\r\n            this.available = true;\r\n        });\r\n    }\r\n}\n\n/**\r\n * Wrap a function in debouncing trigger function. A requestAnimationFrame() is scheduled\r\n * after the first schedule() call, and subsequent schedule() calls will be ignored until the\r\n * animation callback executes.\r\n */\r\nfunction debouncedAnimationFrame(cb) {\r\n    return buildScheduler((cb, _delayMs) => requestAnimationFrame(cb), cb);\r\n}\r\nfunction debouncedCallback(cb) {\r\n    return buildScheduler((cb, delayMs = 0) => setTimeout(cb, delayMs), cb);\r\n}\r\nfunction buildScheduler(scheduleFn, cb) {\r\n    let scheduleCount = 0;\r\n    let promiseRunning = false;\r\n    let awaitingPromise;\r\n    let awaitingDone;\r\n    const busy = () => {\r\n        return promiseRunning;\r\n    };\r\n    const done = () => {\r\n        promiseRunning = false;\r\n        awaitingDone === null || awaitingDone === void 0 ? void 0 : awaitingDone();\r\n        awaitingDone = undefined;\r\n        awaitingPromise = undefined;\r\n        if (scheduleCount > 0) {\r\n            scheduleFn(scheduleCb);\r\n        }\r\n    };\r\n    const scheduleCb = () => {\r\n        const count = scheduleCount;\r\n        scheduleCount = 0;\r\n        promiseRunning = true;\r\n        const maybePromise = cb({ count });\r\n        if (!maybePromise) {\r\n            done();\r\n            return;\r\n        }\r\n        maybePromise.then(done).catch(done);\r\n    };\r\n    return {\r\n        schedule(delayMs) {\r\n            if (scheduleCount === 0 && !busy()) {\r\n                scheduleFn(scheduleCb, delayMs);\r\n            }\r\n            scheduleCount++;\r\n        },\r\n        await() {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                if (!busy()) {\r\n                    return;\r\n                }\r\n                if (awaitingPromise == null) {\r\n                    awaitingPromise = new Promise((resolve) => {\r\n                        awaitingDone = resolve;\r\n                    });\r\n                }\r\n                while (busy()) {\r\n                    yield awaitingPromise;\r\n                }\r\n            });\r\n        },\r\n    };\r\n}\n\nclass SizeMonitor {\r\n    static init(document) {\r\n        if (typeof ResizeObserver !== 'undefined') {\r\n            this.resizeObserver = new ResizeObserver((entries) => {\r\n                for (const entry of entries) {\r\n                    const { width, height } = entry.contentRect;\r\n                    this.checkSize(this.elements.get(entry.target), entry.target, width, height);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // polyfill (more reliable even in browsers that support ResizeObserver)\r\n            const step = () => {\r\n                this.elements.forEach((entry, element) => {\r\n                    this.checkClientSize(element, entry);\r\n                });\r\n            };\r\n            this.pollerHandler = window.setInterval(step, 100);\r\n        }\r\n        this.ready = true;\r\n        this.documentReady = document.readyState !== 'loading';\r\n        if (this.documentReady)\r\n            return;\r\n        // Add DOMContentLoaded listener so we can check if the main document is ready again, and\r\n        // if it is then attach any queued requests for resize monitoring.\r\n        //\r\n        // If we attach before ent.readyState !== 'loading', then additional incorrect resize events\r\n        // are fired, leading to multiple re-renderings on chart initial load. Waiting for the\r\n        // document to be loaded irons out this browser quirk.\r\n        this.readyEventFn = () => {\r\n            const newState = document.readyState !== 'loading';\r\n            const oldState = this.documentReady;\r\n            this.documentReady = newState;\r\n            if (!newState)\r\n                return;\r\n            if (newState === oldState)\r\n                return;\r\n            for (const [el, cb] of this.queuedObserveRequests) {\r\n                this.observe(el, cb);\r\n            }\r\n            this.queuedObserveRequests.length = 0;\r\n        };\r\n        document.addEventListener('DOMContentLoaded', this.readyEventFn);\r\n    }\r\n    static destroy() {\r\n        var _a;\r\n        if (this.pollerHandler != null) {\r\n            clearInterval(this.pollerHandler);\r\n            this.pollerHandler = undefined;\r\n        }\r\n        if (this.readyEventFn) {\r\n            document.removeEventListener('DOMContentLoaded', this.readyEventFn);\r\n            this.readyEventFn = undefined;\r\n        }\r\n        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n        this.resizeObserver = undefined;\r\n        this.ready = false;\r\n    }\r\n    static checkSize(entry, element, width, height) {\r\n        if (!entry)\r\n            return;\r\n        if (!entry.size || width !== entry.size.width || height !== entry.size.height) {\r\n            entry.size = { width, height };\r\n            entry.cb(entry.size, element);\r\n        }\r\n    }\r\n    // Only a single callback is supported.\r\n    static observe(element, cb) {\r\n        if (!this.ready) {\r\n            this.init(element.ownerDocument);\r\n        }\r\n        if (!this.documentReady) {\r\n            this.queuedObserveRequests.push([element, cb]);\r\n            return;\r\n        }\r\n        this.unobserve(element, false);\r\n        if (this.resizeObserver) {\r\n            this.resizeObserver.observe(element);\r\n        }\r\n        this.elements.set(element, { cb });\r\n    }\r\n    static unobserve(element, cleanup = true) {\r\n        if (this.resizeObserver) {\r\n            this.resizeObserver.unobserve(element);\r\n        }\r\n        this.elements.delete(element);\r\n        this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el === element);\r\n        if (cleanup && this.elements.size === 0) {\r\n            this.destroy();\r\n        }\r\n    }\r\n    static checkClientSize(element, entry) {\r\n        const width = element.clientWidth ? element.clientWidth : 0;\r\n        const height = element.clientHeight ? element.clientHeight : 0;\r\n        this.checkSize(entry, element, width, height);\r\n    }\r\n}\r\nSizeMonitor.elements = new Map();\r\nSizeMonitor.ready = false;\r\nSizeMonitor.documentReady = false;\r\nSizeMonitor.queuedObserveRequests = [];\n\nclass ChartHighlight {\r\n    constructor() {\r\n        this.range = 'tooltip';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(STRING_UNION('tooltip', 'node')),\r\n    __metadata(\"design:type\", String)\r\n], ChartHighlight.prototype, \"range\", void 0);\n\n/** Types of chart-update, in pipeline execution order. */\r\nvar ChartUpdateType;\r\n(function (ChartUpdateType) {\r\n    ChartUpdateType[ChartUpdateType[\"FULL\"] = 0] = \"FULL\";\r\n    ChartUpdateType[ChartUpdateType[\"PROCESS_DATA\"] = 1] = \"PROCESS_DATA\";\r\n    ChartUpdateType[ChartUpdateType[\"PERFORM_LAYOUT\"] = 2] = \"PERFORM_LAYOUT\";\r\n    ChartUpdateType[ChartUpdateType[\"SERIES_UPDATE\"] = 3] = \"SERIES_UPDATE\";\r\n    ChartUpdateType[ChartUpdateType[\"TOOLTIP_RECALCULATION\"] = 4] = \"TOOLTIP_RECALCULATION\";\r\n    ChartUpdateType[ChartUpdateType[\"SCENE_RENDER\"] = 5] = \"SCENE_RENDER\";\r\n    ChartUpdateType[ChartUpdateType[\"NONE\"] = 6] = \"NONE\";\r\n})(ChartUpdateType || (ChartUpdateType = {}));\n\nclass DataDomain {\r\n    constructor(type) {\r\n        this.type = type;\r\n        this.continuousDomain = [Infinity, -Infinity];\r\n        this.discreteDomain = new Set();\r\n    }\r\n    extend(val) {\r\n        if (this.type === 'discrete') {\r\n            this.discreteDomain.add(val);\r\n        }\r\n        else if (this.type === 'continuous') {\r\n            if (this.continuousDomain[0] > val) {\r\n                this.continuousDomain[0] = val;\r\n            }\r\n            if (this.continuousDomain[1] < val) {\r\n                this.continuousDomain[1] = val;\r\n            }\r\n        }\r\n    }\r\n    getDomain() {\r\n        if (this.type === 'discrete') {\r\n            return this.discreteDomain;\r\n        }\r\n        else if (this.type === 'continuous') {\r\n            return this.continuousDomain;\r\n        }\r\n        throw new Error('AG Charts - Unsupported data domain type: ' + this.type);\r\n    }\r\n}\n\nfunction toKeyString(keys) {\r\n    return keys\r\n        .map((v) => {\r\n        if (v == null) {\r\n            return v;\r\n        }\r\n        else if (typeof v === 'number' || typeof v === 'string' || typeof v === 'boolean') {\r\n            return v;\r\n        }\r\n        else if (typeof v === 'object') {\r\n            return JSON.stringify(v);\r\n        }\r\n        return v;\r\n    })\r\n        .join('-');\r\n}\r\nfunction round(val) {\r\n    const accuracy = 10000;\r\n    if (Number.isInteger(val)) {\r\n        return val;\r\n    }\r\n    else if (Math.abs(val) > accuracy) {\r\n        return Math.trunc(val);\r\n    }\r\n    return Math.round(val * accuracy) / accuracy;\r\n}\r\nfunction fixNumericExtentInternal(extent) {\r\n    if (extent === undefined) {\r\n        // Don't return a range, there is no range.\r\n        return [];\r\n    }\r\n    let [min, max] = extent;\r\n    min = +min;\r\n    max = +max;\r\n    if (min === 0 && max === 0) {\r\n        // domain has zero length and the single valid value is 0. Use the default of [0, 1].\r\n        return [0, 1];\r\n    }\r\n    if (min === Infinity && max === -Infinity) {\r\n        // There's no data in the domain.\r\n        return [];\r\n    }\r\n    if (min === Infinity) {\r\n        min = 0;\r\n    }\r\n    if (max === -Infinity) {\r\n        max = 0;\r\n    }\r\n    if (!(isNumber(min) && isNumber(max))) {\r\n        return [];\r\n    }\r\n    return [min, max];\r\n}\r\nfunction fixNumericExtent(extent, axis) {\r\n    var _a;\r\n    const fixedExtent = fixNumericExtentInternal(extent);\r\n    if (fixedExtent.length === 0) {\r\n        return fixedExtent;\r\n    }\r\n    let [min, max] = fixedExtent;\r\n    if (min === max) {\r\n        // domain has zero length, there is only a single valid value in data\r\n        const [paddingMin, paddingMax] = (_a = axis === null || axis === void 0 ? void 0 : axis.calculatePadding(min, max)) !== null && _a !== void 0 ? _a : [1, 1];\r\n        min -= paddingMin;\r\n        max += paddingMax;\r\n    }\r\n    return [min, max];\r\n}\r\nconst INVALID_VALUE = Symbol('invalid');\r\nclass DataModel {\r\n    constructor(opts) {\r\n        const { props, mode = 'standalone' } = opts;\r\n        this.mode = mode;\r\n        // Validate that keys appear before values in the definitions, as output ordering depends\r\n        // on configuration ordering, but we process keys before values.\r\n        let keys = true;\r\n        for (const next of props) {\r\n            if (next.type === 'key' && !keys) {\r\n                throw new Error('AG Charts - internal config error: keys must come before values.');\r\n            }\r\n            if (next.type === 'value' && keys) {\r\n                keys = false;\r\n            }\r\n        }\r\n        this.opts = Object.assign({ dataVisible: true }, opts);\r\n        this.keys = props\r\n            .filter((def) => def.type === 'key')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index, missing: 0 })));\r\n        this.values = props\r\n            .filter((def) => def.type === 'value')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index, missing: 0 })));\r\n        this.aggregates = props\r\n            .filter((def) => def.type === 'aggregate')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.groupProcessors = props\r\n            .filter((def) => def.type === 'group-value-processor')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.propertyProcessors = props\r\n            .filter((def) => def.type === 'property-value-processor')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.reducers = props\r\n            .filter((def) => def.type === 'reducer')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.processors = props\r\n            .filter((def) => def.type === 'processor')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        for (const def of this.values) {\r\n            if (def.property == null) {\r\n                throw new Error(`AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(def)}`);\r\n            }\r\n        }\r\n        const verifyMatchGroupId = ({ matchGroupIds }) => {\r\n            for (const matchGroupId of matchGroupIds !== null && matchGroupIds !== void 0 ? matchGroupIds : []) {\r\n                if (!this.values.some((def) => def.groupId === matchGroupId)) {\r\n                    throw new Error(`AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`);\r\n                }\r\n            }\r\n        };\r\n        const verifyMatchIds = ({ matchIds }) => {\r\n            for (const matchId of matchIds !== null && matchIds !== void 0 ? matchIds : []) {\r\n                if (!this.values.some((def) => { var _a; return (_a = def.ids) === null || _a === void 0 ? void 0 : _a.some(([scope, id]) => scope === matchId[0] && id === matchId[1]); })) {\r\n                    throw new Error(`AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchId}).`);\r\n                }\r\n            }\r\n        };\r\n        for (const def of [...this.groupProcessors, ...this.aggregates]) {\r\n            verifyMatchIds(def);\r\n            verifyMatchGroupId(def);\r\n        }\r\n    }\r\n    resolveProcessedDataIndexById(scope, searchId) {\r\n        var _a;\r\n        const { index, def } = (_a = this.resolveProcessedDataDefById(scope, searchId)) !== null && _a !== void 0 ? _a : {};\r\n        return { index, def };\r\n    }\r\n    resolveProcessedDataIndicesById(scope, searchId) {\r\n        return this.resolveProcessedDataDefsById(scope, searchId).map(({ index, def }) => ({ index, def }));\r\n    }\r\n    resolveProcessedDataDefById(scope, searchId) {\r\n        return this.resolveProcessedDataDefsById(scope, searchId)[0];\r\n    }\r\n    resolveProcessedDataDefsByIds(scope, searchIds) {\r\n        const defs = [];\r\n        for (const searchId of searchIds) {\r\n            defs.push([searchId, this.resolveProcessedDataDefsById(scope, searchId)]);\r\n        }\r\n        return defs;\r\n    }\r\n    resolveProcessedDataDefsValues(defs, { keys, values }) {\r\n        const result = {};\r\n        for (const [searchId, [{ index, def }]] of defs) {\r\n            const processedData = def.type === 'key' ? keys : values;\r\n            result[searchId] = processedData[index];\r\n        }\r\n        return result;\r\n    }\r\n    resolveProcessedDataDefsById(searchScope, searchId) {\r\n        const { keys, values, aggregates, groupProcessors, reducers } = this;\r\n        const match = (prop) => {\r\n            const { ids, scopes } = prop;\r\n            if (ids == null)\r\n                return false;\r\n            if (searchScope != null && !(scopes === null || scopes === void 0 ? void 0 : scopes.some((scope) => scope === searchScope.id)))\r\n                return false;\r\n            return ids.some(([scope, id]) => scope === searchScope.id && (typeof searchId === 'string' ? id === searchId : searchId.test(id)));\r\n        };\r\n        const allDefs = [\r\n            keys,\r\n            values,\r\n            aggregates,\r\n            groupProcessors,\r\n            reducers,\r\n        ];\r\n        const result = [];\r\n        for (const defs of allDefs) {\r\n            result.push(...defs.filter(match).map((def) => ({ index: def.index, def })));\r\n        }\r\n        if (result.length > 0) {\r\n            return result;\r\n        }\r\n        throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${searchScope.id}]`);\r\n    }\r\n    getDomain(scope, searchId, type = 'value', processedData) {\r\n        var _a, _b, _c, _d;\r\n        let matches;\r\n        try {\r\n            matches = this.resolveProcessedDataIndicesById(scope, searchId);\r\n        }\r\n        catch (e) {\r\n            if (typeof searchId !== 'string' && /didn't find property definition/.test(e.message))\r\n                return [];\r\n            throw e;\r\n        }\r\n        let domainProp;\r\n        switch (type) {\r\n            case 'key':\r\n                domainProp = 'keys';\r\n                break;\r\n            case 'value':\r\n                domainProp = 'values';\r\n                break;\r\n            case 'aggregate':\r\n                domainProp = 'aggValues';\r\n                break;\r\n            case 'group-value-processor':\r\n                domainProp = 'groups';\r\n                break;\r\n            default:\r\n                return [];\r\n        }\r\n        const firstMatch = (_b = (_a = processedData.domain[domainProp]) === null || _a === void 0 ? void 0 : _a[matches[0].index]) !== null && _b !== void 0 ? _b : [];\r\n        if (matches.length === 1) {\r\n            return firstMatch;\r\n        }\r\n        const result = [...firstMatch];\r\n        for (const idx of matches.slice(1)) {\r\n            extendDomain((_d = (_c = processedData.domain[domainProp]) === null || _c === void 0 ? void 0 : _c[idx.index]) !== null && _d !== void 0 ? _d : [], result);\r\n        }\r\n        return result;\r\n    }\r\n    processData(data) {\r\n        const { opts: { groupByKeys, groupByFn }, aggregates, groupProcessors, reducers, processors, propertyProcessors, } = this;\r\n        const start = performance.now();\r\n        for (const def of [...this.keys, ...this.values]) {\r\n            def.missing = 0;\r\n        }\r\n        if (groupByKeys && this.keys.length === 0) {\r\n            return undefined;\r\n        }\r\n        let processedData = this.extractData(data);\r\n        if (groupByKeys) {\r\n            processedData = this.groupData(processedData);\r\n        }\r\n        else if (groupByFn) {\r\n            processedData = this.groupData(processedData, groupByFn(processedData));\r\n        }\r\n        if (groupProcessors.length > 0) {\r\n            this.postProcessGroups(processedData);\r\n        }\r\n        if (aggregates.length > 0) {\r\n            this.aggregateData(processedData);\r\n        }\r\n        if (propertyProcessors.length > 0) {\r\n            this.postProcessProperties(processedData);\r\n        }\r\n        if (reducers.length > 0) {\r\n            this.reduceData(processedData);\r\n        }\r\n        if (processors.length > 0) {\r\n            this.postProcessData(processedData);\r\n        }\r\n        for (const def of [...this.keys, ...this.values]) {\r\n            if (data.length > 0 && def.missing >= data.length) {\r\n                Logger.warnOnce(`the key '${def.property}' was not found in any data element.`);\r\n            }\r\n        }\r\n        const end = performance.now();\r\n        processedData.time = end - start;\r\n        if (Debug.check(true, 'data-model')) {\r\n            logProcessedData(processedData);\r\n        }\r\n        return processedData;\r\n    }\r\n    valueGroupIdxLookup({ matchGroupIds, matchIds }) {\r\n        return this.values\r\n            .map((def, index) => ({ def, index }))\r\n            .filter(({ def }) => {\r\n            if (matchGroupIds && (def.groupId == null || !matchGroupIds.includes(def.groupId))) {\r\n                return false;\r\n            }\r\n            if (!matchIds)\r\n                return true;\r\n            if (def.ids == null)\r\n                return false;\r\n            return matchIds.some(([matchScope, matchId]) => { var _a; return (_a = def.ids) === null || _a === void 0 ? void 0 : _a.some(([defScope, defId]) => defScope === matchScope && defId === matchId); });\r\n        })\r\n            .map(({ index }) => index);\r\n    }\r\n    valueIdxLookup(scopes, prop) {\r\n        const noScopesToMatch = scopes == null || scopes.length === 0;\r\n        const scopeMatch = (compareTo) => {\r\n            const anyScope = compareTo == null;\r\n            if (anyScope)\r\n                return true;\r\n            const noScopes = compareTo == null || compareTo.length === 0;\r\n            if (noScopesToMatch === noScopes)\r\n                return true;\r\n            return compareTo === null || compareTo === void 0 ? void 0 : compareTo.some((s) => scopes.includes(s));\r\n        };\r\n        const propId = typeof prop === 'string' ? prop : prop.id;\r\n        const idMatch = ([scope, id]) => {\r\n            return scopeMatch([scope]) && id === propId;\r\n        };\r\n        const result = this.values.findIndex((def) => {\r\n            var _a;\r\n            return (scopeMatch(def.scopes) &&\r\n                (((_a = def.ids) === null || _a === void 0 ? void 0 : _a.some((id) => idMatch(id))) || def.property === propId || def.id === propId));\r\n        });\r\n        if (result >= 0) {\r\n            return result;\r\n        }\r\n        throw new Error(`AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(scopes)}`);\r\n    }\r\n    extractData(data) {\r\n        var _a;\r\n        const { keys: keyDefs, values: valueDefs, opts: { dataVisible }, } = this;\r\n        const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\r\n        const resultData = new Array(dataVisible ? data.length : 0);\r\n        let resultDataIdx = 0;\r\n        let partialValidDataCount = 0;\r\n        for (const datum of data) {\r\n            const validScopes = scopes.size > 0 ? new Set(scopes) : undefined;\r\n            const keys = dataVisible ? new Array(keyDefs.length) : undefined;\r\n            let keyIdx = 0;\r\n            let key;\r\n            for (const def of keyDefs) {\r\n                key = processValue(def, datum, key);\r\n                if (key === INVALID_VALUE)\r\n                    break;\r\n                if (keys) {\r\n                    keys[keyIdx++] = key;\r\n                }\r\n            }\r\n            if (key === INVALID_VALUE)\r\n                continue;\r\n            const values = dataVisible && valueDefs.length > 0 ? new Array(valueDefs.length) : undefined;\r\n            let valueIdx = 0;\r\n            let value;\r\n            for (const def of valueDefs) {\r\n                value = processValue(def, datum, value);\r\n                if (value === INVALID_VALUE) {\r\n                    if (allScopesHaveSameDefs)\r\n                        break;\r\n                    for (const scope of (_a = def.scopes) !== null && _a !== void 0 ? _a : scopes) {\r\n                        validScopes === null || validScopes === void 0 ? void 0 : validScopes.delete(scope);\r\n                    }\r\n                    valueIdx++;\r\n                    if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.size) === 0)\r\n                        break;\r\n                }\r\n                else if (values) {\r\n                    values[valueIdx++] = value;\r\n                }\r\n            }\r\n            if (value === INVALID_VALUE && allScopesHaveSameDefs)\r\n                continue;\r\n            if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.size) === 0)\r\n                continue;\r\n            if (dataVisible) {\r\n                const result = {\r\n                    datum,\r\n                    keys: keys,\r\n                    values,\r\n                };\r\n                if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\r\n                    partialValidDataCount++;\r\n                    result.validScopes = [...validScopes];\r\n                }\r\n                resultData[resultDataIdx++] = result;\r\n            }\r\n        }\r\n        resultData.length = resultDataIdx;\r\n        const propertyDomain = (def) => {\r\n            const result = dataDomain.get(def).getDomain();\r\n            if (Array.isArray(result) && result[0] > result[1]) {\r\n                // Ignore starting values.\r\n                return [];\r\n            }\r\n            return [...result];\r\n        };\r\n        return {\r\n            type: 'ungrouped',\r\n            input: { count: data.length },\r\n            data: resultData,\r\n            domain: {\r\n                keys: keyDefs.map((def) => propertyDomain(def)),\r\n                values: valueDefs.map((def) => propertyDomain(def)),\r\n            },\r\n            defs: {\r\n                allScopesHaveSameDefs,\r\n                keys: keyDefs,\r\n                values: valueDefs,\r\n            },\r\n            partialValidDataCount,\r\n            time: 0,\r\n        };\r\n    }\r\n    groupData(data, groupingFn) {\r\n        var _a, _b, _c, _d;\r\n        const processedData = new Map();\r\n        for (const dataEntry of data.data) {\r\n            const { keys, values, datum, validScopes } = dataEntry;\r\n            const group = groupingFn ? groupingFn(dataEntry) : keys;\r\n            const groupStr = toKeyString(group);\r\n            if (processedData.has(groupStr)) {\r\n                const existingData = processedData.get(groupStr);\r\n                existingData.values.push(values);\r\n                existingData.datum.push(datum);\r\n                if (validScopes != null) {\r\n                    // Intersection of existing validScopes with new validScopes.\r\n                    for (let index = 0; index < ((_b = (_a = existingData.validScopes) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); index++) {\r\n                        const scope = (_c = existingData.validScopes) === null || _c === void 0 ? void 0 : _c[index];\r\n                        if (validScopes.some((s) => s === scope))\r\n                            continue;\r\n                        (_d = existingData.validScopes) === null || _d === void 0 ? void 0 : _d.splice(index, 1);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                processedData.set(groupStr, {\r\n                    keys: group,\r\n                    values: [values],\r\n                    datum: [datum],\r\n                    validScopes,\r\n                });\r\n            }\r\n        }\r\n        const resultData = new Array(processedData.size);\r\n        const resultGroups = new Array(processedData.size);\r\n        let dataIndex = 0;\r\n        for (const [, { keys, values, datum, validScopes }] of processedData.entries()) {\r\n            if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.length) === 0)\r\n                continue;\r\n            resultGroups[dataIndex] = keys;\r\n            resultData[dataIndex++] = {\r\n                keys,\r\n                values,\r\n                datum,\r\n                validScopes,\r\n            };\r\n        }\r\n        return Object.assign(Object.assign({}, data), { type: 'grouped', data: resultData, domain: Object.assign(Object.assign({}, data.domain), { groups: resultGroups }) });\r\n    }\r\n    aggregateData(processedData) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        const { aggregates: aggDefs } = this;\r\n        if (!aggDefs)\r\n            return;\r\n        const resultAggValues = aggDefs.map(() => [Infinity, -Infinity]);\r\n        const resultAggValueIndices = aggDefs.map((def) => this.valueGroupIdxLookup(def));\r\n        const resultAggFns = aggDefs.map((def) => def.aggregateFunction);\r\n        const resultGroupAggFns = aggDefs.map((def) => def.groupAggregateFunction);\r\n        const resultFinalFns = aggDefs.map((def) => def.finalFunction);\r\n        for (const group of processedData.data) {\r\n            let { values } = group;\r\n            const { validScopes } = group;\r\n            (_a = group.aggValues) !== null && _a !== void 0 ? _a : (group.aggValues = new Array(resultAggValueIndices.length));\r\n            if (processedData.type === 'ungrouped') {\r\n                values = [values];\r\n            }\r\n            let resultIdx = 0;\r\n            for (const indices of resultAggValueIndices) {\r\n                const scopeValid = (_b = validScopes === null || validScopes === void 0 ? void 0 : validScopes.some((s) => { var _a; return (_a = aggDefs[resultIdx].matchScopes) === null || _a === void 0 ? void 0 : _a.some((as) => s === as); })) !== null && _b !== void 0 ? _b : true;\r\n                if (!scopeValid) {\r\n                    resultIdx++;\r\n                    continue;\r\n                }\r\n                let groupAggValues = (_d = (_c = resultGroupAggFns[resultIdx]) === null || _c === void 0 ? void 0 : _c.call(resultGroupAggFns)) !== null && _d !== void 0 ? _d : extendDomain([]);\r\n                for (const distinctValues of values) {\r\n                    const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\r\n                    const valuesAgg = resultAggFns[resultIdx](valuesToAgg, group.keys);\r\n                    if (valuesAgg) {\r\n                        groupAggValues =\r\n                            (_f = (_e = resultGroupAggFns[resultIdx]) === null || _e === void 0 ? void 0 : _e.call(resultGroupAggFns, valuesAgg, groupAggValues)) !== null && _f !== void 0 ? _f : extendDomain(valuesAgg, groupAggValues);\r\n                    }\r\n                }\r\n                const finalValues = ((_h = (_g = resultFinalFns[resultIdx]) === null || _g === void 0 ? void 0 : _g.call(resultFinalFns, groupAggValues)) !== null && _h !== void 0 ? _h : groupAggValues).map((v) => round(v));\r\n                extendDomain(finalValues, resultAggValues[resultIdx]);\r\n                group.aggValues[resultIdx++] = finalValues;\r\n            }\r\n        }\r\n        processedData.domain.aggValues = resultAggValues;\r\n    }\r\n    postProcessGroups(processedData) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { groupProcessors } = this;\r\n        if (!groupProcessors)\r\n            return;\r\n        const affectedIndices = new Set();\r\n        const updatedDomains = new Map();\r\n        const groupProcessorIndices = new Map();\r\n        const groupProcessorInitFns = new Map();\r\n        for (const processor of groupProcessors) {\r\n            const indices = this.valueGroupIdxLookup(processor);\r\n            groupProcessorIndices.set(processor, indices);\r\n            groupProcessorInitFns.set(processor, processor.adjust());\r\n            for (const idx of indices) {\r\n                const valueDef = this.values[idx];\r\n                affectedIndices.add(idx);\r\n                updatedDomains.set(idx, new DataDomain(valueDef.valueType === 'category' ? 'discrete' : 'continuous'));\r\n            }\r\n        }\r\n        const updateDomains = (values) => {\r\n            var _a;\r\n            for (const valueIndex of affectedIndices) {\r\n                (_a = updatedDomains.get(valueIndex)) === null || _a === void 0 ? void 0 : _a.extend(values[valueIndex]);\r\n            }\r\n        };\r\n        for (const group of processedData.data) {\r\n            for (const processor of groupProcessors) {\r\n                const scopeValid = (_b = (_a = group.validScopes) === null || _a === void 0 ? void 0 : _a.some((s) => { var _a; return (_a = processor.matchScopes) === null || _a === void 0 ? void 0 : _a.some((as) => s === as); })) !== null && _b !== void 0 ? _b : true;\r\n                if (!scopeValid) {\r\n                    continue;\r\n                }\r\n                const valueIndexes = (_c = groupProcessorIndices.get(processor)) !== null && _c !== void 0 ? _c : [];\r\n                const adjustFn = (_e = (_d = groupProcessorInitFns.get(processor)) === null || _d === void 0 ? void 0 : _d()) !== null && _e !== void 0 ? _e : (() => undefined);\r\n                if (processedData.type === 'grouped') {\r\n                    for (const values of group.values) {\r\n                        if (values) {\r\n                            adjustFn(values, valueIndexes);\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                if (group.values) {\r\n                    adjustFn(group.values, valueIndexes);\r\n                }\r\n            }\r\n            if (processedData.type === 'grouped') {\r\n                for (const values of group.values) {\r\n                    updateDomains(values);\r\n                }\r\n            }\r\n            else {\r\n                updateDomains(group.values);\r\n            }\r\n        }\r\n        for (const [idx, dataDomain] of updatedDomains) {\r\n            processedData.domain.values[idx] = [...dataDomain.getDomain()];\r\n        }\r\n    }\r\n    postProcessProperties(processedData) {\r\n        const { propertyProcessors } = this;\r\n        if (!propertyProcessors)\r\n            return;\r\n        for (const { adjust, property, scopes } of propertyProcessors) {\r\n            adjust()(processedData, this.valueIdxLookup(scopes !== null && scopes !== void 0 ? scopes : [], property));\r\n        }\r\n    }\r\n    reduceData(processedData) {\r\n        var _a, _b, _c;\r\n        const { reducers: reducerDefs } = this;\r\n        const scopes = reducerDefs.map((def) => def.scopes);\r\n        const reducers = reducerDefs.map((def) => def.reducer());\r\n        const accValues = reducerDefs.map((def) => def.initialValue);\r\n        for (const group of processedData.data) {\r\n            let reducerIndex = 0;\r\n            for (const reducer of reducers) {\r\n                const scopeValid = (_b = (_a = group.validScopes) === null || _a === void 0 ? void 0 : _a.some((s) => { var _a; return (_a = scopes[reducerIndex]) === null || _a === void 0 ? void 0 : _a.some((as) => s === as); })) !== null && _b !== void 0 ? _b : true;\r\n                if (!scopeValid) {\r\n                    reducerIndex++;\r\n                    continue;\r\n                }\r\n                accValues[reducerIndex] = reducer(accValues[reducerIndex], group);\r\n                reducerIndex++;\r\n            }\r\n        }\r\n        for (let accIdx = 0; accIdx < accValues.length; accIdx++) {\r\n            (_c = processedData.reduced) !== null && _c !== void 0 ? _c : (processedData.reduced = {});\r\n            processedData.reduced[reducerDefs[accIdx].property] = accValues[accIdx];\r\n        }\r\n    }\r\n    postProcessData(processedData) {\r\n        var _a;\r\n        const { processors: processorDefs } = this;\r\n        for (const def of processorDefs) {\r\n            (_a = processedData.reduced) !== null && _a !== void 0 ? _a : (processedData.reduced = {});\r\n            processedData.reduced[def.property] = def.calculate(processedData);\r\n        }\r\n    }\r\n    initDataDomainProcessor() {\r\n        var _a;\r\n        const { keys: keyDefs, values: valueDefs } = this;\r\n        const scopes = new Set();\r\n        for (const valueDef of valueDefs) {\r\n            for (const scope of (_a = valueDef.scopes) !== null && _a !== void 0 ? _a : []) {\r\n                scopes.add(scope);\r\n            }\r\n        }\r\n        const scopesCount = scopes.size;\r\n        const dataDomain = new Map();\r\n        const processorFns = new Map();\r\n        let allScopesHaveSameDefs = true;\r\n        const initDataDomainKey = (key, type, updateDataDomain = dataDomain) => {\r\n            var _a;\r\n            if (type === 'category') {\r\n                updateDataDomain.set(key, new DataDomain('discrete'));\r\n            }\r\n            else {\r\n                updateDataDomain.set(key, new DataDomain('continuous'));\r\n                allScopesHaveSameDefs && (allScopesHaveSameDefs = ((_a = key.scopes) !== null && _a !== void 0 ? _a : []).length === scopesCount);\r\n            }\r\n        };\r\n        const initDataDomain = () => {\r\n            keyDefs.forEach((def) => initDataDomainKey(def, def.valueType));\r\n            valueDefs.forEach((def) => initDataDomainKey(def, def.valueType));\r\n        };\r\n        initDataDomain();\r\n        const accessors = this.buildAccessors(...keyDefs, ...valueDefs);\r\n        const processValue = (def, datum, previousDatum) => {\r\n            var _a, _b, _c, _d;\r\n            const hasAccessor = def.property in accessors;\r\n            let valueInDatum = false;\r\n            let value;\r\n            if (hasAccessor) {\r\n                try {\r\n                    value = accessors[def.property](datum);\r\n                }\r\n                catch (error) {\r\n                    // Swallow errors - these get reported as missing values to the user later.\r\n                }\r\n                valueInDatum = value !== undefined;\r\n            }\r\n            else {\r\n                valueInDatum = def.property in datum;\r\n                value = valueInDatum ? datum[def.property] : def.missingValue;\r\n            }\r\n            if (def.forceValue != null) {\r\n                // Maintain sign of forceValue from actual value, this maybe significant later when\r\n                // we account fo the value falling into positive/negative buckets.\r\n                const valueNegative = valueInDatum && isNegative(value);\r\n                value = valueNegative ? -1 * def.forceValue : def.forceValue;\r\n                valueInDatum = true;\r\n            }\r\n            const missingValueDef = 'missingValue' in def;\r\n            if (!valueInDatum && !missingValueDef) {\r\n                def.missing++;\r\n            }\r\n            if (!dataDomain.has(def)) {\r\n                initDataDomain();\r\n            }\r\n            if (valueInDatum) {\r\n                const valid = (_b = (_a = def.validation) === null || _a === void 0 ? void 0 : _a.call(def, value, datum)) !== null && _b !== void 0 ? _b : true;\r\n                if (!valid) {\r\n                    if ('invalidValue' in def) {\r\n                        value = def.invalidValue;\r\n                    }\r\n                    else {\r\n                        return INVALID_VALUE;\r\n                    }\r\n                }\r\n            }\r\n            if (def.processor) {\r\n                if (!processorFns.has(def)) {\r\n                    processorFns.set(def, def.processor());\r\n                }\r\n                value = (_c = processorFns.get(def)) === null || _c === void 0 ? void 0 : _c(value, previousDatum !== INVALID_VALUE ? previousDatum : undefined);\r\n            }\r\n            (_d = dataDomain.get(def)) === null || _d === void 0 ? void 0 : _d.extend(value);\r\n            return value;\r\n        };\r\n        return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\r\n    }\r\n    buildAccessors(...defs) {\r\n        const result = {};\r\n        if (this.mode === 'integrated')\r\n            return result;\r\n        for (const def of defs) {\r\n            const isPath = def.property.indexOf('.') >= 0 || def.property.indexOf('[') >= 0;\r\n            if (!isPath)\r\n                continue;\r\n            let fnBody;\r\n            if (def.property.startsWith('[')) {\r\n                fnBody = `return datum${def.property};`;\r\n            }\r\n            else {\r\n                fnBody = `return datum.${def.property};`;\r\n            }\r\n            result[def.property] = new Function('datum', fnBody);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction logProcessedData(processedData) {\r\n    var _a, _b;\r\n    const logValues = (name, data) => {\r\n        if (data.length > 0) {\r\n            Logger.log(`DataModel.processData() - ${name}`);\r\n            Logger.table(data);\r\n        }\r\n    };\r\n    Logger.log('DataModel.processData() - processedData', processedData);\r\n    logValues('Key Domains', processedData.domain.keys);\r\n    logValues('Group Domains', (_a = processedData.domain.groups) !== null && _a !== void 0 ? _a : []);\r\n    logValues('Value Domains', processedData.domain.values);\r\n    logValues('Aggregate Domains', (_b = processedData.domain.aggValues) !== null && _b !== void 0 ? _b : []);\r\n    if (processedData.type === 'grouped') {\r\n        const flattenedValues = processedData.data.reduce((acc, next) => {\r\n            var _a, _b;\r\n            const keys = (_a = next.keys) !== null && _a !== void 0 ? _a : [];\r\n            const aggValues = (_b = next.aggValues) !== null && _b !== void 0 ? _b : [];\r\n            const skipKeys = next.keys.map(() => undefined);\r\n            const skipAggValues = aggValues === null || aggValues === void 0 ? void 0 : aggValues.map(() => undefined);\r\n            acc.push(...next.values.map((v, i) => [\r\n                ...(i === 0 ? keys : skipKeys),\r\n                ...(v !== null && v !== void 0 ? v : []),\r\n                ...(i == 0 ? aggValues : skipAggValues),\r\n            ]));\r\n            return acc;\r\n        }, []);\r\n        logValues('Values', flattenedValues);\r\n    }\r\n    else {\r\n        const flattenedValues = processedData.data.reduce((acc, next) => {\r\n            var _a;\r\n            const aggValues = (_a = next.aggValues) !== null && _a !== void 0 ? _a : [];\r\n            acc.push([...next.keys, ...next.values, ...aggValues]);\r\n            return acc;\r\n        }, []);\r\n        logValues('Values', flattenedValues);\r\n    }\r\n}\n\n/** Implements cross-series data model coordination. */\r\nclass DataController {\r\n    constructor(mode) {\r\n        this.mode = mode;\r\n        this.debug = Debug.create(true, 'data-model');\r\n        this.requested = [];\r\n        this.status = 'setup';\r\n    }\r\n    request(id, data, opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.status !== 'setup')\r\n                throw new Error(`AG Charts - data request after data setup phase.`);\r\n            return new Promise((resolve, reject) => {\r\n                this.requested.push({\r\n                    id,\r\n                    opts,\r\n                    data,\r\n                    resultCb: resolve,\r\n                    reject,\r\n                });\r\n            });\r\n        });\r\n    }\r\n    execute() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.status !== 'setup')\r\n                throw new Error(`AG Charts - data request after data setup phase.`);\r\n            this.status = 'executed';\r\n            this.debug('DataController.execute() - requested', this.requested);\r\n            const merged = this.mergeRequested();\r\n            this.debug('DataController.execute() - merged', merged);\r\n            const debugMode = Debug.check(true, 'data-model');\r\n            if (debugMode) {\r\n                window.processedData = [];\r\n            }\r\n            for (const { opts, data, resultCbs, rejects, ids } of merged) {\r\n                try {\r\n                    const dataModel = new DataModel(Object.assign(Object.assign({}, opts), { mode: this.mode }));\r\n                    const processedData = dataModel.processData(data);\r\n                    if (debugMode) {\r\n                        window.processedData.push(processedData);\r\n                    }\r\n                    if (processedData && processedData.partialValidDataCount === 0) {\r\n                        resultCbs.forEach((cb) => cb({ dataModel, processedData }));\r\n                    }\r\n                    else if (processedData) {\r\n                        this.splitResult(dataModel, processedData, ids, resultCbs);\r\n                    }\r\n                    else {\r\n                        rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    rejects.forEach((cb) => cb(error));\r\n                }\r\n            }\r\n        });\r\n    }\r\n    mergeRequested() {\r\n        const grouped = [];\r\n        const keys = (props) => {\r\n            return props\r\n                .filter((p) => p.type === 'key')\r\n                .map((p) => p.property)\r\n                .join(';');\r\n        };\r\n        const groupMatch = ({ opts, data }) => (gr) => {\r\n            return (gr[0].data === data &&\r\n                gr[0].opts.groupByKeys === opts.groupByKeys &&\r\n                gr[0].opts.dataVisible === opts.dataVisible &&\r\n                gr[0].opts.groupByFn === opts.groupByFn &&\r\n                keys(gr[0].opts.props) === keys(opts.props));\r\n        };\r\n        const propMatch = (prop) => (existing) => {\r\n            var _a;\r\n            if (existing.type !== prop.type)\r\n                return false;\r\n            const diff = (_a = jsonDiff(existing, prop)) !== null && _a !== void 0 ? _a : {};\r\n            delete diff['scopes'];\r\n            delete diff['id'];\r\n            delete diff['ids'];\r\n            return Object.keys(diff).length === 0;\r\n        };\r\n        const mergeOpts = (opts) => {\r\n            return Object.assign(Object.assign({}, opts[0]), { props: opts.reduce((result, next) => {\r\n                    var _a, _b, _c, _d, _e, _f;\r\n                    for (const prop of next.props) {\r\n                        if (prop.id != null) {\r\n                            (_a = prop.ids) !== null && _a !== void 0 ? _a : (prop.ids = []);\r\n                            (_b = prop.scopes) === null || _b === void 0 ? void 0 : _b.forEach((scope) => { var _a; return (_a = prop.ids) === null || _a === void 0 ? void 0 : _a.push([scope, prop.id]); });\r\n                        }\r\n                        const match = result.find(propMatch(prop));\r\n                        if (!match) {\r\n                            result.push(prop);\r\n                            continue;\r\n                        }\r\n                        (_c = match.scopes) !== null && _c !== void 0 ? _c : (match.scopes = []);\r\n                        match.scopes.push(...((_d = prop.scopes) !== null && _d !== void 0 ? _d : []));\r\n                        if (match.type !== 'key' && match.type !== 'value')\r\n                            continue;\r\n                        (_e = match.ids) === null || _e === void 0 ? void 0 : _e.push(...((_f = prop.ids) !== null && _f !== void 0 ? _f : []));\r\n                    }\r\n                    return result;\r\n                }, []) });\r\n        };\r\n        const merge = (props) => {\r\n            return {\r\n                ids: props.map(({ id }) => id),\r\n                resultCbs: props.map(({ resultCb }) => resultCb),\r\n                rejects: props.map(({ reject }) => reject),\r\n                data: props[0].data,\r\n                opts: mergeOpts(props.map(({ opts }) => opts)),\r\n            };\r\n        };\r\n        for (const request of this.requested) {\r\n            const match = grouped.find(groupMatch(request));\r\n            if (match) {\r\n                match.push(request);\r\n            }\r\n            else {\r\n                grouped.push([request]);\r\n            }\r\n        }\r\n        return grouped.map(merge);\r\n    }\r\n    splitResult(dataModel, processedData, scopes, resultCbs) {\r\n        for (let index = 0; index < scopes.length; index++) {\r\n            const scope = scopes[index];\r\n            const resultCb = resultCbs[index];\r\n            resultCb({\r\n                dataModel,\r\n                processedData: Object.assign(Object.assign({}, processedData), { data: processedData.data.filter(({ validScopes }) => {\r\n                        return validScopes == null || validScopes.some((s) => s === scope);\r\n                    }) }),\r\n            });\r\n        }\r\n    }\r\n}\n\nclass DataService {\r\n    constructor(getSeries) {\r\n        this.getSeries = getSeries;\r\n    }\r\n}\n\nclass BaseManager {\r\n    constructor() {\r\n        this.listeners = new Listeners();\r\n    }\r\n    addListener(type, handler, meta) {\r\n        return this.listeners.addListener(type, handler, meta);\r\n    }\r\n    removeListener(listenerSymbol) {\r\n        this.listeners.removeListener(listenerSymbol);\r\n    }\r\n}\n\nconst DEBUG_SELECTORS = [true, 'animation'];\r\n/**\r\n * Manage animations across a chart, running all animations through only one `requestAnimationFrame` callback,\r\n * preventing duplicate animations and handling their lifecycle.\r\n */\r\nclass AnimationManager extends BaseManager {\r\n    constructor(interactionManager, chartUpdateMutex) {\r\n        super();\r\n        this.interactionManager = interactionManager;\r\n        this.chartUpdateMutex = chartUpdateMutex;\r\n        this.defaultDuration = 1000;\r\n        this.batch = new AnimationBatch();\r\n        this.debug = Debug.create(...DEBUG_SELECTORS);\r\n        this.isPlaying = false;\r\n        this.requestId = null;\r\n        this.skipAnimations = false;\r\n    }\r\n    /**\r\n     * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\r\n     * with the same `id`, immediately stop it.\r\n     */\r\n    animate(_a) {\r\n        var _b, _c;\r\n        var { disableInteractions = true, immutable = true } = _a, opts = __rest(_a, [\"disableInteractions\", \"immutable\"]);\r\n        const { batch } = this;\r\n        try {\r\n            if (opts.id != null && batch.controllers.has(opts.id)) {\r\n                if (!immutable) {\r\n                    return batch.controllers.get(opts.id).reset(opts);\r\n                }\r\n                batch.controllers.get(opts.id).stop();\r\n                this.debug(`Skipping animation batch due to update of existing animation: ${opts.id}`);\r\n                this.batch.skip();\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.failsafeOnError(error);\r\n            return;\r\n        }\r\n        const id = (_b = opts.id) !== null && _b !== void 0 ? _b : Math.random().toString();\r\n        const skip = this.isSkipped();\r\n        if (skip) {\r\n            this.debug('AnimationManager - skipping animation');\r\n        }\r\n        return new Animation(Object.assign(Object.assign({}, opts), { id,\r\n            skip, autoplay: this.isPlaying ? opts.autoplay : false, duration: (_c = opts.duration) !== null && _c !== void 0 ? _c : this.defaultDuration, onPlay: (controller) => {\r\n                var _a;\r\n                batch.controllers.set(id, controller);\r\n                this.requestAnimation();\r\n                if (disableInteractions) {\r\n                    this.interactionManager.pause('animation');\r\n                }\r\n                (_a = opts.onPlay) === null || _a === void 0 ? void 0 : _a.call(controller, controller);\r\n            }, onStop: (controller) => {\r\n                var _a;\r\n                batch.controllers.delete(id);\r\n                if (disableInteractions) {\r\n                    this.interactionManager.resume('animation');\r\n                }\r\n                (_a = opts.onStop) === null || _a === void 0 ? void 0 : _a.call(controller, controller);\r\n            } }));\r\n    }\r\n    play() {\r\n        if (this.isPlaying) {\r\n            return;\r\n        }\r\n        this.isPlaying = true;\r\n        this.debug('AnimationManager.play()');\r\n        for (const controller of this.batch.controllers.values()) {\r\n            try {\r\n                controller.play();\r\n            }\r\n            catch (error) {\r\n                this.failsafeOnError(error);\r\n            }\r\n        }\r\n        this.requestAnimation();\r\n    }\r\n    pause() {\r\n        if (!this.isPlaying) {\r\n            return;\r\n        }\r\n        this.isPlaying = false;\r\n        this.cancelAnimation();\r\n        this.debug('AnimationManager.pause()');\r\n        for (const controller of this.batch.controllers.values()) {\r\n            try {\r\n                controller.pause();\r\n            }\r\n            catch (error) {\r\n                this.failsafeOnError(error);\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        this.isPlaying = false;\r\n        this.cancelAnimation();\r\n        this.debug('AnimationManager.stop()');\r\n        for (const controller of this.batch.controllers.values()) {\r\n            try {\r\n                controller.stop();\r\n            }\r\n            catch (error) {\r\n                this.failsafeOnError(error, false);\r\n            }\r\n        }\r\n    }\r\n    stopByAnimationId(id) {\r\n        var _a;\r\n        try {\r\n            if (id != null && this.batch.controllers.has(id)) {\r\n                (_a = this.batch.controllers.get(id)) === null || _a === void 0 ? void 0 : _a.stop();\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.failsafeOnError(error);\r\n            return;\r\n        }\r\n    }\r\n    stopByAnimationGroupId(id) {\r\n        for (const controller of this.batch.controllers.values()) {\r\n            if (controller.groupId === id) {\r\n                this.stopByAnimationId(controller.id);\r\n            }\r\n        }\r\n    }\r\n    reset() {\r\n        if (this.isPlaying) {\r\n            this.stop();\r\n            this.play();\r\n        }\r\n        else {\r\n            this.stop();\r\n        }\r\n    }\r\n    skip(skip = true) {\r\n        this.skipAnimations = skip;\r\n    }\r\n    isSkipped() {\r\n        return this.skipAnimations || this.batch.isSkipped();\r\n    }\r\n    isActive() {\r\n        return this.isPlaying && this.batch.isActive();\r\n    }\r\n    skipCurrentBatch() {\r\n        if (Debug.check(...DEBUG_SELECTORS)) {\r\n            this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\r\n        }\r\n        this.batch.skip();\r\n    }\r\n    /** Mocking point for tests to guarantee that animation updates happen. */\r\n    isSkippingFrames() {\r\n        return true;\r\n    }\r\n    /** Mocking point for tests to capture requestAnimationFrame callbacks. */\r\n    scheduleAnimationFrame(cb) {\r\n        this.requestId = requestAnimationFrame(cb);\r\n    }\r\n    requestAnimation() {\r\n        if (!this.batch.isActive() || this.requestId !== null)\r\n            return;\r\n        let prevTime;\r\n        const onAnimationFrame = (time) => __awaiter(this, void 0, void 0, function* () {\r\n            const executeAnimationFrame = () => __awaiter(this, void 0, void 0, function* () {\r\n                const deltaTime = time - (prevTime !== null && prevTime !== void 0 ? prevTime : time);\r\n                prevTime = time;\r\n                this.debug('AnimationManager - onAnimationFrame()', {\r\n                    controllersCount: this.batch.controllers.size,\r\n                });\r\n                for (const controller of this.batch.controllers.values()) {\r\n                    try {\r\n                        controller.update(deltaTime);\r\n                    }\r\n                    catch (error) {\r\n                        this.failsafeOnError(error);\r\n                    }\r\n                }\r\n                this.listeners.dispatch('animation-frame', {\r\n                    type: 'animation-frame',\r\n                    deltaMs: deltaTime,\r\n                });\r\n            });\r\n            if (this.isSkippingFrames()) {\r\n                // Only run the animation frame if we can acquire the chart update mutex immediately.\r\n                yield this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\r\n            }\r\n            else {\r\n                // Wait for the next available point we can execute.\r\n                yield this.chartUpdateMutex.acquire(executeAnimationFrame);\r\n            }\r\n            if (this.batch.isActive()) {\r\n                this.scheduleAnimationFrame(onAnimationFrame);\r\n            }\r\n        });\r\n        this.scheduleAnimationFrame(onAnimationFrame);\r\n    }\r\n    cancelAnimation() {\r\n        if (this.requestId === null)\r\n            return;\r\n        cancelAnimationFrame(this.requestId);\r\n        this.requestId = null;\r\n        this.startBatch();\r\n    }\r\n    failsafeOnError(error, cancelAnimation = true) {\r\n        Logger.error('Error during animation, skipping animations', error);\r\n        if (cancelAnimation) {\r\n            this.cancelAnimation();\r\n        }\r\n    }\r\n    startBatch(skipAnimations) {\r\n        this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\r\n        this.reset();\r\n        this.batch.destroy();\r\n        this.batch = new AnimationBatch();\r\n        if (skipAnimations === true) {\r\n            this.batch.skip();\r\n        }\r\n    }\r\n    endBatch() {\r\n        this.debug(`AnimationManager - endBatch() with ${this.batch.controllers.size} animations; skipped: ${this.batch.isSkipped()}.`);\r\n        if (this.batch.isSkipped() && !this.batch.isActive()) {\r\n            this.batch.skip(false);\r\n        }\r\n    }\r\n}\r\n/**\r\n * A batch of animations that are synchronised together. Can be skipped independently of other batches and the main\r\n * animation skipping status.\r\n */\r\nclass AnimationBatch {\r\n    constructor() {\r\n        this.controllers = new Map();\r\n        this.skipAnimations = false;\r\n    }\r\n    // private phase?: 'initial-load' | 'remove' | 'update' | 'add';\r\n    isActive() {\r\n        return this.controllers.size > 0;\r\n    }\r\n    skip(skip = true) {\r\n        if (this.skipAnimations === false && skip === true) {\r\n            for (const controller of this.controllers.values()) {\r\n                controller.stop();\r\n            }\r\n            this.controllers.clear();\r\n        }\r\n        this.skipAnimations = skip;\r\n    }\r\n    isSkipped() {\r\n        return this.skipAnimations;\r\n    }\r\n    destroy() { }\r\n}\n\nclass ChartEventManager extends BaseManager {\r\n    legendItemClick(series, itemId, enabled, legendItemName) {\r\n        const event = {\r\n            type: 'legend-item-click',\r\n            series,\r\n            itemId,\r\n            enabled,\r\n            legendItemName,\r\n        };\r\n        this.listeners.dispatch('legend-item-click', event);\r\n    }\r\n    legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\r\n        const event = {\r\n            type: 'legend-item-double-click',\r\n            series,\r\n            itemId,\r\n            enabled,\r\n            legendItemName,\r\n            numVisibleItems,\r\n        };\r\n        this.listeners.dispatch('legend-item-double-click', event);\r\n    }\r\n    axisHover(axisId, direction) {\r\n        const event = {\r\n            type: 'axis-hover',\r\n            axisId,\r\n            direction,\r\n        };\r\n        this.listeners.dispatch('axis-hover', event);\r\n    }\r\n}\n\n/**\r\n * Manages the cursor styling for an element. Tracks the requested styling from distinct\r\n * dependents and handles conflicting styling requests.\r\n */\r\nclass CursorManager {\r\n    constructor(element) {\r\n        this.states = {};\r\n        this.element = element;\r\n    }\r\n    updateCursor(callerId, style) {\r\n        delete this.states[callerId];\r\n        if (style != null) {\r\n            this.states[callerId] = { style };\r\n        }\r\n        this.applyStates();\r\n    }\r\n    applyStates() {\r\n        let styleToApply = 'default';\r\n        // Last added entry wins.\r\n        Object.entries(this.states)\r\n            .reverse()\r\n            .slice(0, 1)\r\n            .forEach(([_, { style }]) => (styleToApply = style));\r\n        this.element.style.cursor = styleToApply;\r\n    }\r\n    getCursor() {\r\n        return this.element.style.cursor;\r\n    }\r\n}\n\n/**\r\n * Manages the actively highlighted series/datum for a chart. Tracks the requested highlights from\r\n * distinct dependents and handles conflicting highlight requests.\r\n */\r\nclass HighlightManager extends BaseManager {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.highlightStates = new Map();\r\n        this.pickedStates = new Map();\r\n    }\r\n    updateHighlight(callerId, highlightedDatum) {\r\n        this.highlightStates.delete(callerId);\r\n        if (highlightedDatum != null) {\r\n            this.highlightStates.set(callerId, highlightedDatum);\r\n        }\r\n        this.applyHighlightStates();\r\n    }\r\n    getActiveHighlight() {\r\n        return this.activeHighlight;\r\n    }\r\n    updatePicked(callerId, clickableDatum) {\r\n        this.pickedStates.delete(callerId);\r\n        if (clickableDatum != null) {\r\n            this.pickedStates.set(callerId, clickableDatum);\r\n        }\r\n        this.applyPickedStates();\r\n    }\r\n    getActivePicked() {\r\n        return this.activePicked;\r\n    }\r\n    applyHighlightStates() {\r\n        // Last added entry wins.\r\n        const { activeHighlight: previousHighlight } = this;\r\n        this.activeHighlight = Array.from(this.highlightStates.values()).pop();\r\n        if (!this.isEqual(this.activeHighlight, previousHighlight)) {\r\n            this.listeners.dispatch('highlight-change', {\r\n                type: 'highlight-change',\r\n                currentHighlight: this.activeHighlight,\r\n                previousHighlight,\r\n            });\r\n        }\r\n    }\r\n    applyPickedStates() {\r\n        this.activePicked = Array.from(this.pickedStates.values()).pop();\r\n    }\r\n    isEqual(a, b) {\r\n        return a === b || ((a === null || a === void 0 ? void 0 : a.series) === (b === null || b === void 0 ? void 0 : b.series) && (a === null || a === void 0 ? void 0 : a.itemId) === (b === null || b === void 0 ? void 0 : b.itemId) && (a === null || a === void 0 ? void 0 : a.datum) === (b === null || b === void 0 ? void 0 : b.datum));\r\n    }\r\n}\n\nconst WINDOW_EVENT_HANDLERS = ['pagehide', 'mousemove', 'mouseup'];\r\nconst EVENT_HANDLERS = [\r\n    'click',\r\n    'dblclick',\r\n    'contextmenu',\r\n    'mousedown',\r\n    'mouseout',\r\n    'mouseenter',\r\n    'touchstart',\r\n    'touchmove',\r\n    'touchend',\r\n    'touchcancel',\r\n    'wheel',\r\n];\r\nconst CSS = `\n.ag-chart-wrapper {\n    touch-action: none;\n}\n`;\r\n/**\r\n * Manages user interactions with a specific HTMLElement (or interactions that bubble from it's\r\n * children)\r\n */\r\nclass InteractionManager extends BaseManager {\r\n    constructor(element, document, window) {\r\n        super();\r\n        this.eventHandler = (event) => this.processEvent(event);\r\n        this.mouseDown = false;\r\n        this.touchDown = false;\r\n        this.pausers = { animation: 0, 'context-menu': 0 };\r\n        this.rootElement = document.body;\r\n        this.element = element;\r\n        this.window = window;\r\n        for (const type of EVENT_HANDLERS) {\r\n            if (type.startsWith('touch')) {\r\n                element.addEventListener(type, this.eventHandler, { passive: true });\r\n            }\r\n            else if (type === 'wheel') {\r\n                element.addEventListener(type, this.eventHandler, { passive: false });\r\n            }\r\n            else {\r\n                element.addEventListener(type, this.eventHandler);\r\n            }\r\n        }\r\n        for (const type of WINDOW_EVENT_HANDLERS) {\r\n            this.window.addEventListener(type, this.eventHandler);\r\n        }\r\n        if (!InteractionManager.interactionDocuments.includes(document)) {\r\n            injectStyle(document, CSS);\r\n            InteractionManager.interactionDocuments.push(document);\r\n        }\r\n    }\r\n    destroy() {\r\n        for (const type of WINDOW_EVENT_HANDLERS) {\r\n            this.window.removeEventListener(type, this.eventHandler);\r\n        }\r\n        for (const type of EVENT_HANDLERS) {\r\n            this.element.removeEventListener(type, this.eventHandler);\r\n        }\r\n    }\r\n    resume(pauseType) {\r\n        this.pausers[pauseType]--;\r\n    }\r\n    pause(pauseType) {\r\n        this.pausers[pauseType]++;\r\n    }\r\n    processEvent(event) {\r\n        const types = this.decideInteractionEventTypes(event);\r\n        if (types.length > 0) {\r\n            // Async dispatch to avoid blocking the event-processing thread.\r\n            this.dispatchEvent(event, types).catch((e) => Logger.errorOnce(e));\r\n        }\r\n    }\r\n    dispatchEvent(event, types) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const coords = this.calculateCoordinates(event);\r\n            if (coords == null) {\r\n                return;\r\n            }\r\n            const pauses = Object.entries(this.pausers)\r\n                .filter(([, count]) => count > 0)\r\n                .map(([pause]) => pause);\r\n            for (const type of types) {\r\n                this.listeners.dispatchWrapHandlers(type, (handler, meta, interactionEvent) => {\r\n                    var _a;\r\n                    if (pauses.length > 0 && !((_a = meta === null || meta === void 0 ? void 0 : meta.bypassPause) === null || _a === void 0 ? void 0 : _a.some((p) => pauses.includes(p)))) {\r\n                        return;\r\n                    }\r\n                    if (!interactionEvent.consumed) {\r\n                        handler(interactionEvent);\r\n                    }\r\n                }, this.buildEvent(Object.assign({ type, event, pauses }, coords)));\r\n            }\r\n        });\r\n    }\r\n    decideInteractionEventTypes(event) {\r\n        const dragStart = 'drag-start';\r\n        switch (event.type) {\r\n            case 'click':\r\n                return ['click'];\r\n            case 'dblclick':\r\n                return ['dblclick'];\r\n            case 'contextmenu':\r\n                return ['contextmenu'];\r\n            case 'mousedown':\r\n                this.mouseDown = true;\r\n                this.dragStartElement = event.target;\r\n                return [dragStart];\r\n            case 'touchstart':\r\n                this.touchDown = true;\r\n                this.dragStartElement = event.target;\r\n                return [dragStart];\r\n            case 'touchmove':\r\n            case 'mousemove':\r\n                if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\r\n                    // We only care about these events if the target is the canvas, unless\r\n                    // we're in the middle of a drag/slide.\r\n                    return [];\r\n                }\r\n                return this.mouseDown || this.touchDown ? ['drag'] : ['hover'];\r\n            case 'mouseup':\r\n                if (!this.mouseDown && !this.isEventOverElement(event)) {\r\n                    // We only care about these events if the target is the canvas, unless\r\n                    // we're in the middle of a drag.\r\n                    return [];\r\n                }\r\n                this.mouseDown = false;\r\n                this.dragStartElement = undefined;\r\n                return ['drag-end'];\r\n            case 'touchend':\r\n                if (!this.touchDown && !this.isEventOverElement(event)) {\r\n                    // We only care about these events if the target is the canvas, unless\r\n                    // we're in the middle of a slide.\r\n                    return [];\r\n                }\r\n                this.touchDown = false;\r\n                this.dragStartElement = undefined;\r\n                return ['drag-end'];\r\n            case 'mouseout':\r\n            case 'touchcancel':\r\n                return ['leave'];\r\n            case 'mouseenter':\r\n                const mouseButtonDown = event instanceof MouseEvent && (event.buttons & 1) === 1;\r\n                if (this.mouseDown !== mouseButtonDown) {\r\n                    this.mouseDown = mouseButtonDown;\r\n                    return [mouseButtonDown ? dragStart : 'drag-end'];\r\n                }\r\n                return [];\r\n            case 'pagehide':\r\n                return ['page-left'];\r\n            case 'wheel':\r\n                return ['wheel'];\r\n        }\r\n        return [];\r\n    }\r\n    isEventOverElement(event) {\r\n        var _a;\r\n        return event.target === this.element || ((_a = event.target) === null || _a === void 0 ? void 0 : _a.parentElement) === this.element;\r\n    }\r\n    calculateCoordinates(event) {\r\n        var _a;\r\n        if (event instanceof MouseEvent) {\r\n            const { clientX, clientY, pageX, pageY, offsetX, offsetY } = event;\r\n            return this.fixOffsets(event, { clientX, clientY, pageX, pageY, offsetX, offsetY });\r\n        }\r\n        else if (typeof TouchEvent !== 'undefined' && event instanceof TouchEvent) {\r\n            const lastTouch = (_a = event.touches[0]) !== null && _a !== void 0 ? _a : event.changedTouches[0];\r\n            const { clientX, clientY, pageX, pageY } = lastTouch;\r\n            return Object.assign(Object.assign({}, InteractionManager.NULL_COORDS), { clientX, clientY, pageX, pageY });\r\n        }\r\n        else if (event instanceof PageTransitionEvent) {\r\n            if (event.persisted) {\r\n                // Don't fire the page-left event since the page maybe revisited.\r\n                return;\r\n            }\r\n            return InteractionManager.NULL_COORDS;\r\n        }\r\n        // Unsupported event - abort.\r\n    }\r\n    fixOffsets(event, coords) {\r\n        const offsets = (el) => {\r\n            let x = 0;\r\n            let y = 0;\r\n            while (el) {\r\n                x += el.offsetLeft;\r\n                y += el.offsetTop;\r\n                el = el.offsetParent;\r\n            }\r\n            return { x, y };\r\n        };\r\n        if (this.dragStartElement != null && event.target !== this.dragStartElement) {\r\n            // Offsets need to be relative to the drag-start element to avoid jumps when\r\n            // the pointer moves between element boundaries.\r\n            const offsetDragStart = offsets(this.dragStartElement);\r\n            const offsetEvent = offsets(event.target);\r\n            coords.offsetX -= offsetDragStart.x - offsetEvent.x;\r\n            coords.offsetY -= offsetDragStart.y - offsetEvent.y;\r\n        }\r\n        return coords;\r\n    }\r\n    buildEvent(opts) {\r\n        const { type, event, clientX, clientY, pauses } = opts;\r\n        let { offsetX, offsetY, pageX, pageY } = opts;\r\n        if (!isNumber(offsetX) || !isNumber(offsetY)) {\r\n            const rect = this.element.getBoundingClientRect();\r\n            offsetX = clientX - rect.left;\r\n            offsetY = clientY - rect.top;\r\n        }\r\n        if (!isNumber(pageX) || !isNumber(pageY)) {\r\n            const pageRect = this.rootElement.getBoundingClientRect();\r\n            pageX = clientX - pageRect.left;\r\n            pageY = clientY - pageRect.top;\r\n        }\r\n        const builtEvent = {\r\n            type,\r\n            offsetX: offsetX,\r\n            offsetY: offsetY,\r\n            pageX: pageX,\r\n            pageY: pageY,\r\n            sourceEvent: event,\r\n            consumed: false,\r\n            pauses,\r\n            consume() {\r\n                builtEvent.consumed = true;\r\n            },\r\n        };\r\n        return builtEvent;\r\n    }\r\n}\r\nInteractionManager.interactionDocuments = [];\r\nInteractionManager.NULL_COORDS = {\r\n    clientX: -Infinity,\r\n    clientY: -Infinity,\r\n    pageX: -Infinity,\r\n    pageY: -Infinity,\r\n    offsetX: -Infinity,\r\n    offsetY: -Infinity,\r\n};\n\n/**\r\n * Manages the tooltip HTML an element. Tracks the requested HTML from distinct dependents and\r\n * handles conflicting tooltip requests.\r\n */\r\nclass TooltipManager {\r\n    constructor(tooltip, interactionManager) {\r\n        this.states = {};\r\n        this.exclusiveAreas = {};\r\n        this.destroyFns = [];\r\n        this.tooltip = tooltip;\r\n        this.destroyFns.push(interactionManager.addListener('hover', (e) => this.checkExclusiveRects(e)));\r\n    }\r\n    getRange() {\r\n        return this.tooltip.range;\r\n    }\r\n    updateTooltip(callerId, meta, content) {\r\n        var _a;\r\n        if (content == null) {\r\n            content = (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.content;\r\n        }\r\n        this.states[callerId] = { content, meta };\r\n        this.applyStates();\r\n    }\r\n    updateExclusiveRect(callerId, area) {\r\n        if (area) {\r\n            this.exclusiveAreas[callerId] = area;\r\n        }\r\n        else {\r\n            delete this.exclusiveAreas[callerId];\r\n        }\r\n    }\r\n    removeTooltip(callerId) {\r\n        delete this.states[callerId];\r\n        this.applyStates();\r\n    }\r\n    getTooltipMeta(callerId) {\r\n        var _a;\r\n        return (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.meta;\r\n    }\r\n    destroy() {\r\n        for (const destroyFn of this.destroyFns) {\r\n            destroyFn();\r\n        }\r\n    }\r\n    checkExclusiveRects(e) {\r\n        let newAppliedExclusiveArea;\r\n        for (const [entryId, area] of Object.entries(this.exclusiveAreas)) {\r\n            if (!area.containsPoint(e.offsetX, e.offsetY)) {\r\n                continue;\r\n            }\r\n            newAppliedExclusiveArea = entryId;\r\n            break;\r\n        }\r\n        if (newAppliedExclusiveArea === this.appliedExclusiveArea) {\r\n            return;\r\n        }\r\n        this.appliedExclusiveArea = newAppliedExclusiveArea;\r\n        this.applyStates();\r\n    }\r\n    applyStates() {\r\n        var _a;\r\n        const ids = this.appliedExclusiveArea ? [this.appliedExclusiveArea] : Object.keys(this.states);\r\n        let contentToApply;\r\n        let metaToApply;\r\n        // Last added entry wins.\r\n        ids.reverse();\r\n        ids.slice(0, 1).forEach((id) => {\r\n            var _a;\r\n            const { content, meta } = (_a = this.states[id]) !== null && _a !== void 0 ? _a : {};\r\n            contentToApply = content;\r\n            metaToApply = meta;\r\n        });\r\n        if (metaToApply === undefined || contentToApply === undefined) {\r\n            this.appliedState = undefined;\r\n            this.tooltip.toggle(false);\r\n            return;\r\n        }\r\n        if (((_a = this.appliedState) === null || _a === void 0 ? void 0 : _a.content) === contentToApply) {\r\n            const renderInstantly = this.tooltip.isVisible();\r\n            this.tooltip.show(metaToApply, undefined, renderInstantly);\r\n        }\r\n        else {\r\n            this.tooltip.show(metaToApply, contentToApply);\r\n        }\r\n        this.appliedState = { content: contentToApply, meta: metaToApply };\r\n    }\r\n    static makeTooltipMeta(event, canvas, datum, window) {\r\n        var _a, _b, _c, _d;\r\n        const { pageX, pageY, offsetX, offsetY } = event;\r\n        const position = {\r\n            xOffset: datum.series.tooltip.position.xOffset,\r\n            yOffset: datum.series.tooltip.position.yOffset,\r\n        };\r\n        const meta = {\r\n            pageX,\r\n            pageY,\r\n            offsetX,\r\n            offsetY,\r\n            event: event,\r\n            showArrow: datum.series.tooltip.showArrow,\r\n            position,\r\n        };\r\n        // On line and scatter series, the tooltip covers the top of errorbars when using\r\n        // datum.midPoint. Using datum.yBar.upperPoint renders the tooltip higher up.\r\n        const refPoint = (_b = (_a = datum.yBar) === null || _a === void 0 ? void 0 : _a.upperPoint) !== null && _b !== void 0 ? _b : datum.midPoint;\r\n        if (datum.series.tooltip.position.type === 'node' && refPoint) {\r\n            const { x, y } = refPoint;\r\n            const point = datum.series.contentGroup.inverseTransformPoint(x, y);\r\n            const canvasRect = canvas.element.getBoundingClientRect();\r\n            return Object.assign(Object.assign({}, meta), { pageX: Math.round(canvasRect.left + window.scrollX + point.x), pageY: Math.round(canvasRect.top + window.scrollY + point.y), offsetX: Math.round(point.x), offsetY: Math.round(point.y) });\r\n        }\r\n        meta.enableInteraction = (_d = (_c = datum.series.tooltip.interaction) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false;\r\n        return meta;\r\n    }\r\n}\n\n/**\r\n * Manages the current zoom state for a chart. Tracks the requested zoom from distinct dependents\r\n * and handles conflicting zoom requests.\r\n */\r\nclass ZoomManager extends BaseManager {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.axes = {};\r\n    }\r\n    updateAxes(axes) {\r\n        var _a;\r\n        const removedAxes = new Set(Object.keys(this.axes));\r\n        axes.forEach((axis) => {\r\n            var _a;\r\n            var _b, _c;\r\n            removedAxes.delete(axis.id);\r\n            (_a = (_b = this.axes)[_c = axis.id]) !== null && _a !== void 0 ? _a : (_b[_c] = new AxisZoomManager(axis));\r\n        });\r\n        removedAxes.forEach((axisId) => {\r\n            delete this.axes[axisId];\r\n        });\r\n        if ((_a = this.initialZoom) === null || _a === void 0 ? void 0 : _a.newZoom) {\r\n            this.updateZoom(this.initialZoom.callerId, this.initialZoom.newZoom);\r\n        }\r\n        this.initialZoom = undefined;\r\n    }\r\n    updateZoom(callerId, newZoom) {\r\n        if (Object.keys(this.axes).length === 0) {\r\n            this.initialZoom = { callerId, newZoom };\r\n            return;\r\n        }\r\n        Object.values(this.axes).forEach((axis) => {\r\n            axis.updateZoom(callerId, newZoom === null || newZoom === void 0 ? void 0 : newZoom[axis.getDirection()]);\r\n        });\r\n        this.applyStates();\r\n    }\r\n    updateAxisZoom(callerId, axisId, newZoom) {\r\n        var _a;\r\n        (_a = this.axes[axisId]) === null || _a === void 0 ? void 0 : _a.updateZoom(callerId, newZoom);\r\n        this.applyStates();\r\n    }\r\n    getZoom() {\r\n        let x;\r\n        let y;\r\n        // TODO: this only works when there is a single axis on each direction as it gets the last of each\r\n        Object.values(this.axes).forEach((axis) => {\r\n            if (axis.getDirection() === ChartAxisDirection.X) {\r\n                x = axis.getZoom();\r\n            }\r\n            else if (axis.getDirection() === ChartAxisDirection.Y) {\r\n                y = axis.getZoom();\r\n            }\r\n        });\r\n        if (x || y) {\r\n            return { x, y };\r\n        }\r\n    }\r\n    getAxisZoom(axisId) {\r\n        var _a;\r\n        return (_a = this.axes[axisId]) === null || _a === void 0 ? void 0 : _a.getZoom();\r\n    }\r\n    getAxisZooms() {\r\n        const axes = {};\r\n        for (const [axisId, axis] of Object.entries(this.axes)) {\r\n            axes[axisId] = {\r\n                direction: axis.getDirection(),\r\n                zoom: axis.getZoom(),\r\n            };\r\n        }\r\n        return axes;\r\n    }\r\n    applyStates() {\r\n        const changed = Object.values(this.axes)\r\n            .map((axis) => axis.applyStates())\r\n            .some(Boolean);\r\n        if (!changed) {\r\n            return;\r\n        }\r\n        const currentZoom = this.getZoom();\r\n        const axes = {};\r\n        for (const [axisId, axis] of Object.entries(this.axes)) {\r\n            axes[axisId] = axis.getZoom();\r\n        }\r\n        this.listeners.dispatch('zoom-change', Object.assign(Object.assign({ type: 'zoom-change' }, (currentZoom !== null && currentZoom !== void 0 ? currentZoom : {})), { axes }));\r\n    }\r\n}\r\nclass AxisZoomManager {\r\n    constructor(axis) {\r\n        this.states = {};\r\n        this.axis = axis;\r\n        const [min = 0, max = 1] = axis.visibleRange;\r\n        this.currentZoom = { min, max };\r\n        this.states['__initial__'] = this.currentZoom;\r\n    }\r\n    getDirection() {\r\n        return this.axis.direction;\r\n    }\r\n    updateZoom(callerId, newZoom) {\r\n        delete this.states[callerId];\r\n        if (newZoom != null) {\r\n            this.states[callerId] = Object.assign({}, newZoom);\r\n        }\r\n    }\r\n    getZoom() {\r\n        return this.currentZoom;\r\n    }\r\n    applyStates() {\r\n        var _a, _b;\r\n        const prevZoom = this.currentZoom;\r\n        const last = Object.keys(this.states)[Object.keys(this.states).length - 1];\r\n        this.currentZoom = Object.assign({}, this.states[last]);\r\n        return (prevZoom === null || prevZoom === void 0 ? void 0 : prevZoom.min) !== ((_a = this.currentZoom) === null || _a === void 0 ? void 0 : _a.min) || (prevZoom === null || prevZoom === void 0 ? void 0 : prevZoom.max) !== ((_b = this.currentZoom) === null || _b === void 0 ? void 0 : _b.max);\r\n    }\r\n}\n\nclass LayoutService extends Listeners {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.layoutComplete = 'layout-complete';\r\n    }\r\n    addListener(eventType, handler) {\r\n        if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {\r\n            return super.addListener(eventType, handler);\r\n        }\r\n        throw new Error(`AG Charts - unsupported listener type: ${eventType}`);\r\n    }\r\n    dispatchPerformLayout(stage, ctx) {\r\n        if (this.isLayoutStage(stage)) {\r\n            return this.getListenersByType(stage).reduce((result, listener) => {\r\n                try {\r\n                    return listener.handler(result);\r\n                }\r\n                catch (e) {\r\n                    Logger.errorOnce(e);\r\n                    return result;\r\n                }\r\n            }, ctx);\r\n        }\r\n        return ctx;\r\n    }\r\n    dispatchLayoutComplete(event) {\r\n        this.dispatch(this.layoutComplete, event);\r\n    }\r\n    isLayoutStage(eventType) {\r\n        return eventType !== this.layoutComplete;\r\n    }\r\n    isLayoutComplete(eventType) {\r\n        return eventType === this.layoutComplete;\r\n    }\r\n}\n\nfunction gridLayout({ orientation, bboxes, maxHeight, maxWidth, itemPaddingY = 0, itemPaddingX = 0, forceResult = false, }) {\r\n    const horizontal = orientation === 'horizontal';\r\n    const primary = {\r\n        max: horizontal ? maxWidth : maxHeight,\r\n        fn: horizontal ? (b) => b.width : (b) => b.height,\r\n        padding: horizontal ? itemPaddingX : itemPaddingY,\r\n    };\r\n    const secondary = {\r\n        max: !horizontal ? maxWidth : maxHeight,\r\n        fn: !horizontal ? (b) => b.width : (b) => b.height,\r\n        padding: !horizontal ? itemPaddingX : itemPaddingY,\r\n    };\r\n    let processedBBoxCount = 0;\r\n    const rawPages = [];\r\n    while (processedBBoxCount < bboxes.length) {\r\n        const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\r\n        const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\r\n        if (!result) {\r\n            return;\r\n        }\r\n        processedBBoxCount += result.processedBBoxCount;\r\n        rawPages.push(result.pageIndices);\r\n    }\r\n    return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\r\n}\r\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\r\n    // If calculatePage() fails on the first guess, we could use the number of items that fit\r\n    // as a good guess for the next iteration.\r\n    const minGuess = 1;\r\n    let startingGuess = estimateStartingGuess(bboxes, primary);\r\n    if (startingGuess < minGuess) {\r\n        if (!forceResult) {\r\n            return undefined;\r\n        }\r\n        // Legend constraints too small! Display at least one row/column if forceResult is true\r\n        startingGuess = minGuess;\r\n    }\r\n    for (let guess = startingGuess; guess >= minGuess; guess--) {\r\n        const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\r\n        if (pageIndices == null && guess <= minGuess) {\r\n            // Can't layout!\r\n            return undefined;\r\n        }\r\n        if (pageIndices == null) {\r\n            // Guess again!\r\n            continue;\r\n        }\r\n        if (typeof pageIndices === 'number') {\r\n            // calculatePage() suggested a better guess, use that if it's more than minGuess.\r\n            if (pageIndices <= minGuess) {\r\n                // Can't layout!\r\n                return undefined;\r\n            }\r\n            guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\r\n            continue;\r\n        }\r\n        const processedBBoxCount = pageIndices.length * pageIndices[0].length; // this is an estimate, not all rows/columns will have the same length\r\n        return { processedBBoxCount, pageIndices };\r\n    }\r\n}\r\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\r\n    var _a;\r\n    const result = [];\r\n    let sumSecondary = 0;\r\n    let currentMaxSecondary = 0;\r\n    let currentPrimaryIndices = [];\r\n    const maxPrimaryValues = [];\r\n    for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\r\n        const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\r\n        if (primaryValueIdx === 0) {\r\n            sumSecondary += currentMaxSecondary;\r\n            currentMaxSecondary = 0;\r\n            if (currentPrimaryIndices.length > 0) {\r\n                result.push(currentPrimaryIndices);\r\n            }\r\n            currentPrimaryIndices = [];\r\n        }\r\n        const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\r\n        maxPrimaryValues[primaryValueIdx] = Math.max((_a = maxPrimaryValues[primaryValueIdx]) !== null && _a !== void 0 ? _a : 0, primaryValue);\r\n        currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\r\n        const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\r\n        const returnResult = !forceResult || result.length > 0;\r\n        if (currentSecondaryDimension > secondary.max && returnResult) {\r\n            // Breached max secondary dimension size, return indices accumlated so far (but not in-progress row/column).\r\n            currentPrimaryIndices = [];\r\n            break;\r\n        }\r\n        const sumPrimary = maxPrimaryValues.reduce((sum, next) => sum + next, 0);\r\n        if (sumPrimary > primary.max && !forceResult) {\r\n            // Breached max main dimension size.\r\n            if (maxPrimaryValues.length < primaryCount) {\r\n                // Feedback as guess for next iteration if we're on the first round still.\r\n                return maxPrimaryValues.length;\r\n            }\r\n            return undefined;\r\n        }\r\n        currentPrimaryIndices.push(bboxIndex + indexOffset);\r\n    }\r\n    if (currentPrimaryIndices.length > 0) {\r\n        result.push(currentPrimaryIndices);\r\n    }\r\n    return result.length > 0 ? result : undefined;\r\n}\r\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\r\n    let maxPageWidth = 0;\r\n    let maxPageHeight = 0;\r\n    const pages = rawPages.map((indices) => {\r\n        if (orientation === 'horizontal') {\r\n            indices = transpose(indices);\r\n        }\r\n        let endIndex = 0;\r\n        const columns = indices.map((colIndices) => {\r\n            const colBBoxes = colIndices.map((bboxIndex) => {\r\n                endIndex = Math.max(bboxIndex, endIndex);\r\n                return bboxes[bboxIndex];\r\n            });\r\n            let columnHeight = 0;\r\n            let columnWidth = 0;\r\n            colBBoxes.forEach((bbox) => {\r\n                columnHeight += bbox.height + itemPaddingY;\r\n                columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\r\n            });\r\n            return {\r\n                indices: colIndices,\r\n                bboxes: colBBoxes,\r\n                columnHeight: Math.ceil(columnHeight),\r\n                columnWidth: Math.ceil(columnWidth),\r\n            };\r\n        });\r\n        let pageWidth = 0;\r\n        let pageHeight = 0;\r\n        columns.forEach((column) => {\r\n            pageWidth += column.columnWidth;\r\n            pageHeight = Math.max(pageHeight, column.columnHeight);\r\n        });\r\n        maxPageWidth = Math.max(pageWidth, maxPageWidth);\r\n        maxPageHeight = Math.max(pageHeight, maxPageHeight);\r\n        return {\r\n            columns,\r\n            startIndex: indices[0][0],\r\n            endIndex,\r\n            pageWidth,\r\n            pageHeight,\r\n        };\r\n    });\r\n    return { pages, maxPageWidth, maxPageHeight };\r\n}\r\nfunction transpose(data) {\r\n    const result = [];\r\n    for (const _ of data[0]) {\r\n        result.push([]);\r\n    }\r\n    data.forEach((innerData, dataIdx) => {\r\n        innerData.forEach((item, itemIdx) => {\r\n            result[itemIdx][dataIdx] = item;\r\n        });\r\n    });\r\n    return result;\r\n}\r\nfunction estimateStartingGuess(bboxes, primary) {\r\n    const n = bboxes.length;\r\n    let primarySum = 0;\r\n    for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\r\n        primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\r\n        if (primarySum > primary.max) {\r\n            const ratio = n / bboxIndex;\r\n            if (ratio < 2) {\r\n                return Math.ceil(n / 2);\r\n            }\r\n            return bboxIndex;\r\n        }\r\n    }\r\n    return n;\r\n}\n\nclass Cross extends Marker {\r\n    updatePath() {\r\n        const s = this.size / 4.2;\r\n        super.applyPath(s, Cross.moves);\r\n    }\r\n}\r\nCross.className = 'Cross';\r\nCross.moves = [\r\n    { x: -1, y: 0, t: 'move' },\r\n    { x: -1, y: -1 },\r\n    { x: +1, y: -1 },\r\n    { x: +1, y: +1 },\r\n    { x: +1, y: -1 },\r\n    { x: +1, y: +1 },\r\n    { x: -1, y: +1 },\r\n    { x: +1, y: +1 },\r\n    { x: -1, y: +1 },\r\n    { x: -1, y: -1 },\r\n    { x: -1, y: +1 },\r\n    { x: -1, y: -1 },\r\n];\n\nclass Diamond extends Marker {\r\n    updatePath() {\r\n        const s = this.size / 2;\r\n        super.applyPath(s, Diamond.moves);\r\n    }\r\n}\r\nDiamond.className = 'Diamond';\r\nDiamond.moves = [\r\n    { x: 0, y: -1, t: 'move' },\r\n    { x: +1, y: +1 },\r\n    { x: -1, y: +1 },\r\n    { x: -1, y: -1 },\r\n    { x: +1, y: -1 },\r\n];\n\nclass Heart extends Marker {\r\n    rad(degree) {\r\n        return (degree / 180) * Math.PI;\r\n    }\r\n    updatePath() {\r\n        const { x, path, size, rad } = this;\r\n        const r = size / 4;\r\n        const y = this.y + r / 2;\r\n        path.clear();\r\n        path.arc(x - r, y - r, r, rad(130), rad(330));\r\n        path.arc(x + r, y - r, r, rad(220), rad(50));\r\n        path.lineTo(x, y + r);\r\n        path.closePath();\r\n    }\r\n}\r\nHeart.className = 'Heart';\n\nclass Plus extends Marker {\r\n    updatePath() {\r\n        const s = this.size / 3;\r\n        super.applyPath(s, Plus.moves);\r\n    }\r\n}\r\nPlus.className = 'Plus';\r\nPlus.moves = [\r\n    { x: -0.5, y: -0.5, t: 'move' },\r\n    { x: 0, y: -1 },\r\n    { x: +1, y: 0 },\r\n    { x: 0, y: +1 },\r\n    { x: +1, y: 0 },\r\n    { x: 0, y: +1 },\r\n    { x: -1, y: 0 },\r\n    { x: 0, y: +1 },\r\n    { x: -1, y: 0 },\r\n    { x: 0, y: -1 },\r\n    { x: -1, y: 0 },\r\n    { x: 0, y: -1 },\r\n];\n\nclass Square extends Marker {\r\n    updatePath() {\r\n        const { path, x, y } = this;\r\n        const hs = this.size / 2;\r\n        path.clear();\r\n        path.moveTo(this.align(x - hs), this.align(y - hs));\r\n        path.lineTo(this.align(x + hs), this.align(y - hs));\r\n        path.lineTo(this.align(x + hs), this.align(y + hs));\r\n        path.lineTo(this.align(x - hs), this.align(y + hs));\r\n        path.closePath();\r\n    }\r\n}\r\nSquare.className = 'Square';\n\nclass Triangle extends Marker {\r\n    updatePath() {\r\n        const s = this.size * 1.1;\r\n        super.applyPath(s, Triangle.moves);\r\n    }\r\n}\r\nTriangle.className = 'Triangle';\r\nTriangle.moves = [\r\n    { x: 0, y: -0.48, t: 'move' },\r\n    { x: 0.5, y: 0.87 },\r\n    { x: -1, y: 0 },\r\n];\n\nconst MARKER_SHAPES = {\r\n    circle: Circle,\r\n    cross: Cross,\r\n    diamond: Diamond,\r\n    heart: Heart,\r\n    plus: Plus,\r\n    square: Square,\r\n    triangle: Triangle,\r\n};\r\nconst MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\r\nfunction isMarkerShape(shape) {\r\n    return MARKER_SUPPORTED_SHAPES.includes(shape);\r\n}\r\n// This function is in its own file because putting it into SeriesMarker makes the Legend\r\n// suddenly aware of the series (it's an agnostic component), and putting it into Marker\r\n// introduces circular dependencies.\r\nfunction getMarker(shape = Square) {\r\n    if (isMarkerShape(shape)) {\r\n        return MARKER_SHAPES[shape];\r\n    }\r\n    if (typeof shape === 'function') {\r\n        return shape;\r\n    }\r\n    return Square;\r\n}\n\nclass MarkerLabel extends Group {\r\n    constructor() {\r\n        super({ name: 'markerLabelGroup' });\r\n        this.label = new Text();\r\n        this._marker = new Square();\r\n        this._markerSize = 15;\r\n        this._spacing = 8;\r\n        const label = this.label;\r\n        label.textBaseline = 'middle';\r\n        label.fontSize = 12;\r\n        label.fontFamily = 'Verdana, sans-serif';\r\n        label.fill = 'black';\r\n        // For better looking vertical alignment of labels to markers.\r\n        label.y = HdpiCanvas.has.textMetrics ? 1 : 0;\r\n        this.append([this.marker, label]);\r\n        this.update();\r\n    }\r\n    set marker(value) {\r\n        if (this._marker !== value) {\r\n            this.removeChild(this._marker);\r\n            this._marker = value;\r\n            this.appendChild(value);\r\n            this.update();\r\n        }\r\n    }\r\n    get marker() {\r\n        return this._marker;\r\n    }\r\n    set markerSize(value) {\r\n        if (this._markerSize !== value) {\r\n            this._markerSize = value;\r\n            this.update();\r\n        }\r\n    }\r\n    get markerSize() {\r\n        return this._markerSize;\r\n    }\r\n    set spacing(value) {\r\n        if (this._spacing !== value) {\r\n            this._spacing = value;\r\n            this.update();\r\n        }\r\n    }\r\n    get spacing() {\r\n        return this._spacing;\r\n    }\r\n    update() {\r\n        const marker = this.marker;\r\n        const markerSize = this.markerSize;\r\n        marker.size = markerSize;\r\n        this.label.x = markerSize / 2 + this.spacing;\r\n    }\r\n    render(renderCtx) {\r\n        // Cannot override field Group.opacity with get/set pair, so\r\n        // propagate opacity changes here.\r\n        this.marker.opacity = this.opacity;\r\n        this.label.opacity = this.opacity;\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nMarkerLabel.className = 'MarkerLabel';\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"text\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label', 'fill'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'fill'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"markerFill\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'stroke'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"markerStroke\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'strokeWidth'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"markerStrokeWidth\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'fillOpacity'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"markerFillOpacity\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'strokeOpacity'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"markerStrokeOpacity\", void 0);\n\nclass PaginationLabel {\r\n    constructor() {\r\n        this.color = 'black';\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"fontFamily\", void 0);\r\nclass PaginationMarkerStyle {\r\n    constructor() {\r\n        this.size = 15;\r\n        this.fill = undefined;\r\n        this.fillOpacity = undefined;\r\n        this.stroke = undefined;\r\n        this.strokeWidth = 1;\r\n        this.strokeOpacity = 1;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PaginationMarkerStyle.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationMarkerStyle.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarkerStyle.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationMarkerStyle.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarkerStyle.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", void 0);\r\nclass PaginationMarker {\r\n    constructor(parent) {\r\n        this.parent = parent;\r\n        this.shape = Triangle;\r\n        this.size = 15;\r\n        /**\r\n         * Inner padding between a pagination button and the label.\r\n         */\r\n        this.padding = 8;\r\n    }\r\n}\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue() {\r\n            if (this.parent.marker === this) {\r\n                this.parent.onMarkerShapeChange();\r\n            }\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], PaginationMarker.prototype, \"shape\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PaginationMarker.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarker.prototype, \"padding\", void 0);\r\nclass Pagination {\r\n    constructor(chartUpdateCallback, pageUpdateCallback, interactionManager, cursorManager) {\r\n        this.chartUpdateCallback = chartUpdateCallback;\r\n        this.pageUpdateCallback = pageUpdateCallback;\r\n        this.interactionManager = interactionManager;\r\n        this.cursorManager = cursorManager;\r\n        this.id = createId(this);\r\n        this.group = new Group({ name: 'pagination' });\r\n        this.labelNode = new Text();\r\n        this.marker = new PaginationMarker(this);\r\n        this.activeStyle = new PaginationMarkerStyle();\r\n        this.inactiveStyle = new PaginationMarkerStyle();\r\n        this.highlightStyle = new PaginationMarkerStyle();\r\n        this.label = new PaginationLabel();\r\n        this.totalPages = 0;\r\n        this.currentPage = 0;\r\n        this.translationX = 0;\r\n        this.translationY = 0;\r\n        this.nextButtonDisabled = false;\r\n        this.previousButtonDisabled = false;\r\n        this._visible = true;\r\n        this._enabled = true;\r\n        this._orientation = 'vertical';\r\n        this._nextButton = new Triangle();\r\n        this._previousButton = new Triangle();\r\n        const { labelNode } = this;\r\n        labelNode.textBaseline = 'middle';\r\n        labelNode.fontSize = 12;\r\n        labelNode.fontFamily = 'Verdana, sans-serif';\r\n        labelNode.fill = 'black';\r\n        labelNode.y = HdpiCanvas.has.textMetrics ? 1 : 0;\r\n        this.group.append([this.nextButton, this.previousButton, labelNode]);\r\n        this.interactionManager.addListener('click', (event) => this.onPaginationClick(event));\r\n        this.interactionManager.addListener('hover', (event) => this.onPaginationMouseMove(event));\r\n        this.update();\r\n        this.updateMarkers();\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    set enabled(value) {\r\n        this._enabled = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    updateGroupVisibility() {\r\n        this.group.visible = this.enabled && this.visible;\r\n    }\r\n    set orientation(value) {\r\n        this._orientation = value;\r\n        switch (value) {\r\n            case 'horizontal': {\r\n                this.previousButton.rotation = -Math.PI / 2;\r\n                this.nextButton.rotation = Math.PI / 2;\r\n                break;\r\n            }\r\n            case 'vertical':\r\n            default: {\r\n                this.previousButton.rotation = 0;\r\n                this.nextButton.rotation = Math.PI;\r\n            }\r\n        }\r\n    }\r\n    get orientation() {\r\n        return this._orientation;\r\n    }\r\n    set nextButton(value) {\r\n        if (this._nextButton !== value) {\r\n            this.group.removeChild(this._nextButton);\r\n            this._nextButton = value;\r\n            this.group.appendChild(value);\r\n        }\r\n    }\r\n    get nextButton() {\r\n        return this._nextButton;\r\n    }\r\n    set previousButton(value) {\r\n        if (this._previousButton !== value) {\r\n            this.group.removeChild(this._previousButton);\r\n            this._previousButton = value;\r\n            this.group.appendChild(value);\r\n        }\r\n    }\r\n    get previousButton() {\r\n        return this._previousButton;\r\n    }\r\n    update() {\r\n        this.updateLabel();\r\n        this.updatePositions();\r\n        this.enableOrDisableButtons();\r\n    }\r\n    updatePositions() {\r\n        this.group.translationX = this.translationX;\r\n        this.group.translationY = this.translationY;\r\n        this.updateLabelPosition();\r\n        this.updateNextButtonPosition();\r\n    }\r\n    updateLabelPosition() {\r\n        const { size: markerSize, padding: markerPadding } = this.marker;\r\n        this.nextButton.size = markerSize;\r\n        this.previousButton.size = markerSize;\r\n        this.labelNode.x = markerSize / 2 + markerPadding;\r\n    }\r\n    updateNextButtonPosition() {\r\n        const labelBBox = this.labelNode.computeBBox();\r\n        this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;\r\n    }\r\n    updateLabel() {\r\n        const { currentPage, totalPages: pages, labelNode, label: { color, fontStyle, fontWeight, fontSize, fontFamily }, } = this;\r\n        labelNode.text = `${currentPage + 1} / ${pages}`;\r\n        labelNode.fill = color;\r\n        labelNode.fontStyle = fontStyle;\r\n        labelNode.fontWeight = fontWeight;\r\n        labelNode.fontSize = fontSize;\r\n        labelNode.fontFamily = fontFamily;\r\n    }\r\n    updateMarkers() {\r\n        const { nextButton, previousButton, nextButtonDisabled, previousButtonDisabled, activeStyle, inactiveStyle, highlightStyle, highlightActive, } = this;\r\n        const buttonStyle = (button, disabled) => {\r\n            if (disabled) {\r\n                return inactiveStyle;\r\n            }\r\n            else if (button === highlightActive) {\r\n                return highlightStyle;\r\n            }\r\n            return activeStyle;\r\n        };\r\n        this.updateMarker(nextButton, buttonStyle('next', nextButtonDisabled));\r\n        this.updateMarker(previousButton, buttonStyle('previous', previousButtonDisabled));\r\n    }\r\n    updateMarker(marker, style) {\r\n        var _a;\r\n        const { size } = this.marker;\r\n        marker.size = size;\r\n        marker.fill = style.fill;\r\n        marker.fillOpacity = (_a = style.fillOpacity) !== null && _a !== void 0 ? _a : 1;\r\n        marker.stroke = style.stroke;\r\n        marker.strokeWidth = style.strokeWidth;\r\n        marker.strokeOpacity = style.strokeOpacity;\r\n    }\r\n    enableOrDisableButtons() {\r\n        const { currentPage, totalPages } = this;\r\n        const zeroPagesToDisplay = totalPages === 0;\r\n        const onLastPage = currentPage === totalPages - 1;\r\n        const onFirstPage = currentPage === 0;\r\n        this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\r\n        this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\r\n    }\r\n    nextButtonContainsPoint(offsetX, offsetY) {\r\n        return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);\r\n    }\r\n    previousButtonContainsPoint(offsetX, offsetY) {\r\n        return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);\r\n    }\r\n    onPaginationClick(event) {\r\n        const { offsetX, offsetY } = event;\r\n        if (this.nextButtonContainsPoint(offsetX, offsetY)) {\r\n            this.incrementPage();\r\n            this.onPaginationChanged();\r\n            event.consume();\r\n        }\r\n        else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\r\n            this.decrementPage();\r\n            this.onPaginationChanged();\r\n            event.consume();\r\n        }\r\n    }\r\n    onPaginationMouseMove(event) {\r\n        const { offsetX, offsetY } = event;\r\n        if (this.nextButtonContainsPoint(offsetX, offsetY)) {\r\n            this.cursorManager.updateCursor(this.id, 'pointer');\r\n            this.highlightActive = 'next';\r\n        }\r\n        else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\r\n            this.cursorManager.updateCursor(this.id, 'pointer');\r\n            this.highlightActive = 'previous';\r\n        }\r\n        else {\r\n            this.cursorManager.updateCursor(this.id);\r\n            this.highlightActive = undefined;\r\n        }\r\n        this.updateMarkers();\r\n        this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    onPaginationChanged() {\r\n        this.pageUpdateCallback(this.currentPage);\r\n    }\r\n    incrementPage() {\r\n        this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\r\n    }\r\n    decrementPage() {\r\n        this.currentPage = Math.max(this.currentPage - 1, 0);\r\n    }\r\n    onMarkerShapeChange() {\r\n        const Marker = getMarker(this.marker.shape || Triangle);\r\n        this.previousButton = new Marker();\r\n        this.nextButton = new Marker();\r\n        this.updatePositions();\r\n        this.updateMarkers();\r\n        this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    attachPagination(node) {\r\n        node.append(this.group);\r\n    }\r\n    computeBBox() {\r\n        return this.group.computeBBox();\r\n    }\r\n}\r\nPagination.className = 'Pagination';\n\nconst ORIENTATIONS = ['horizontal', 'vertical'];\r\nconst OPT_ORIENTATION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v) => ORIENTATIONS.includes(v)), `expecting an orientation keyword such as 'horizontal' or 'vertical'`);\r\nclass LegendLabel {\r\n    constructor() {\r\n        this.maxLength = undefined;\r\n        this.color = 'black';\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n        this.formatter = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendLabel.prototype, \"maxLength\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], LegendLabel.prototype, \"formatter\", void 0);\r\nclass LegendMarker {\r\n    constructor() {\r\n        this.size = 15;\r\n        /**\r\n         * If the marker type is set, the legend will always use that marker type for all its items,\r\n         * regardless of the type that comes from the `data`.\r\n         */\r\n        this._shape = undefined;\r\n        /**\r\n         * Padding between the marker and the label within each legend item.\r\n         */\r\n        this.padding = 8;\r\n        this.strokeWidth = undefined;\r\n    }\r\n    set shape(value) {\r\n        var _a;\r\n        this._shape = value;\r\n        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.onMarkerShapeChange();\r\n    }\r\n    get shape() {\r\n        return this._shape;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendMarker.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendMarker.prototype, \"padding\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendMarker.prototype, \"strokeWidth\", void 0);\r\nclass LegendItem {\r\n    constructor() {\r\n        this.marker = new LegendMarker();\r\n        this.label = new LegendLabel();\r\n        /** Used to constrain the width of legend items. */\r\n        this.maxWidth = undefined;\r\n        /**\r\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\r\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\r\n         * padding between legend items.\r\n         */\r\n        this.paddingX = 16;\r\n        /**\r\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\r\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\r\n         * padding between legend items.\r\n         */\r\n        this.paddingY = 8;\r\n        this.toggleSeriesVisible = true;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendItem.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendItem.prototype, \"paddingX\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendItem.prototype, \"paddingY\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], LegendItem.prototype, \"toggleSeriesVisible\", void 0);\r\nclass LegendListeners {\r\n    constructor() {\r\n        this.legendItemClick = undefined;\r\n        this.legendItemDoubleClick = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], LegendListeners.prototype, \"legendItemClick\", void 0);\r\nclass Legend {\r\n    set data(value) {\r\n        this._data = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get data() {\r\n        return this._data;\r\n    }\r\n    set enabled(value) {\r\n        this._enabled = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    getOrientation() {\r\n        if (this.orientation !== undefined) {\r\n            return this.orientation;\r\n        }\r\n        switch (this.position) {\r\n            case 'right':\r\n            case 'left':\r\n                return 'vertical';\r\n            case 'bottom':\r\n            case 'top':\r\n                return 'horizontal';\r\n        }\r\n    }\r\n    constructor(ctx) {\r\n        this.ctx = ctx;\r\n        this.id = createId(this);\r\n        this.group = new Group({ name: 'legend', layer: true, zIndex: Layers.LEGEND_ZINDEX });\r\n        this.itemSelection = Selection.select(this.group, MarkerLabel);\r\n        this.oldSize = [0, 0];\r\n        this.pages = [];\r\n        this.maxPageSize = [0, 0];\r\n        /** Item index to track on re-pagination, so current page updates appropriately. */\r\n        this.paginationTrackingIndex = 0;\r\n        this.item = new LegendItem();\r\n        this.listeners = new LegendListeners();\r\n        this.truncatedItems = new Set();\r\n        this._data = [];\r\n        this._enabled = true;\r\n        this.position = 'bottom';\r\n        /** Used to constrain the width of the legend. */\r\n        this.maxWidth = undefined;\r\n        /** Used to constrain the height of the legend. */\r\n        this.maxHeight = undefined;\r\n        /** Reverse the display order of legend items if `true`. */\r\n        this.reverseOrder = undefined;\r\n        this.destroyFns = [];\r\n        /**\r\n         * Spacing between the legend and the edge of the chart's element.\r\n         */\r\n        this.spacing = 20;\r\n        this.characterWidths = new Map();\r\n        this.size = [0, 0];\r\n        this._visible = true;\r\n        this.item.marker.parent = this;\r\n        this.pagination = new Pagination((type) => ctx.updateService.update(type), (page) => this.updatePageNumber(page), ctx.interactionManager, ctx.cursorManager);\r\n        this.pagination.attachPagination(this.group);\r\n        this.item.marker.parent = this;\r\n        const bypass = { bypassPause: ['animation'] };\r\n        this.destroyFns.push(ctx.interactionManager.addListener('click', (e) => this.checkLegendClick(e), bypass), ctx.interactionManager.addListener('dblclick', (e) => this.checkLegendDoubleClick(e), bypass), ctx.interactionManager.addListener('hover', (e) => this.handleLegendMouseMove(e)), ctx.layoutService.addListener('start-layout', (e) => this.positionLegend(e.shrinkRect)), () => this.detachLegend());\r\n    }\r\n    destroy() {\r\n        this.destroyFns.forEach((f) => f());\r\n    }\r\n    onMarkerShapeChange() {\r\n        this.itemSelection.clear();\r\n        this.group.markDirty(this.group, RedrawType.MINOR);\r\n    }\r\n    getCharacterWidths(font) {\r\n        const { characterWidths } = this;\r\n        if (characterWidths.has(font)) {\r\n            return characterWidths.get(font);\r\n        }\r\n        const cw = {\r\n            '...': HdpiCanvas.getTextSize('...', font).width,\r\n        };\r\n        characterWidths.set(font, cw);\r\n        return cw;\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    updateGroupVisibility() {\r\n        this.group.visible = this.enabled && this.visible && this.data.length > 0;\r\n    }\r\n    attachLegend(node) {\r\n        node.append(this.group);\r\n    }\r\n    detachLegend() {\r\n        var _a;\r\n        (_a = this.group.parent) === null || _a === void 0 ? void 0 : _a.removeChild(this.group);\r\n    }\r\n    getItemLabel(datum) {\r\n        const { ctx: { callbackCache }, } = this;\r\n        const { formatter } = this.item.label;\r\n        if (formatter) {\r\n            return callbackCache.call(formatter, {\r\n                itemId: datum.itemId,\r\n                value: datum.label.text,\r\n                seriesId: datum.seriesId,\r\n            });\r\n        }\r\n        return datum.label.text;\r\n    }\r\n    /**\r\n     * The method is given the desired size of the legend, which only serves as a hint.\r\n     * The vertically oriented legend will take as much horizontal space as needed, but will\r\n     * respect the height constraints, and the horizontal legend will take as much vertical\r\n     * space as needed in an attempt not to exceed the given width.\r\n     * After the layout is done, the {@link size} will contain the actual size of the legend.\r\n     * If the actual size is not the same as the previous actual size, the legend will fire\r\n     * the 'layoutChange' event to communicate that another layout is needed, and the above\r\n     * process should be repeated.\r\n     * @param width\r\n     * @param height\r\n     */\r\n    performLayout(width, height) {\r\n        const { paddingX, paddingY, label, maxWidth, marker: { size: markerSize, padding: markerPadding, shape: markerShape }, label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }, } = this.item;\r\n        const data = [...this.data];\r\n        if (this.reverseOrder) {\r\n            data.reverse();\r\n        }\r\n        this.itemSelection.update(data);\r\n        // Update properties that affect the size of the legend items and measure them.\r\n        const bboxes = [];\r\n        const font = getFont(label);\r\n        const itemMaxWidthPercentage = 0.8;\r\n        const maxItemWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : width * itemMaxWidthPercentage;\r\n        const paddedMarkerWidth = markerSize + markerPadding + paddingX;\r\n        this.itemSelection.each((markerLabel, datum) => {\r\n            var _a;\r\n            const Marker = getMarker(markerShape !== null && markerShape !== void 0 ? markerShape : datum.marker.shape);\r\n            if (!(markerLabel.marker && markerLabel.marker instanceof Marker)) {\r\n                markerLabel.marker = new Marker();\r\n            }\r\n            markerLabel.markerSize = markerSize;\r\n            markerLabel.spacing = markerPadding;\r\n            markerLabel.fontStyle = fontStyle;\r\n            markerLabel.fontWeight = fontWeight;\r\n            markerLabel.fontSize = fontSize;\r\n            markerLabel.fontFamily = fontFamily;\r\n            const id = (_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id;\r\n            const labelText = this.getItemLabel(datum);\r\n            const text = (labelText !== null && labelText !== void 0 ? labelText : '<unknown>').replace(/\\r?\\n/g, ' ');\r\n            markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedMarkerWidth, font, id);\r\n            bboxes.push(markerLabel.computeBBox());\r\n        });\r\n        width = Math.max(1, width);\r\n        height = Math.max(1, height);\r\n        if (!isFinite(width)) {\r\n            return false;\r\n        }\r\n        const size = this.size;\r\n        const oldSize = this.oldSize;\r\n        size[0] = width;\r\n        size[1] = height;\r\n        if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\r\n            oldSize[0] = size[0];\r\n            oldSize[1] = size[1];\r\n        }\r\n        const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);\r\n        this.pages = pages;\r\n        this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\r\n        const pageNumber = this.pagination.currentPage;\r\n        const page = this.pages[pageNumber];\r\n        if (this.pages.length < 1 || !page) {\r\n            this.visible = false;\r\n            return;\r\n        }\r\n        this.visible = true;\r\n        // Position legend items\r\n        this.updatePositions(pageNumber);\r\n        // Update legend item properties that don't affect the layout.\r\n        this.update();\r\n    }\r\n    truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\r\n        const ellipsis = `...`;\r\n        const textChars = text.split('');\r\n        let addEllipsis = false;\r\n        if (text.length > maxCharLength) {\r\n            text = `${text.substring(0, maxCharLength)}`;\r\n            addEllipsis = true;\r\n        }\r\n        const labelWidth = Math.floor(paddedMarkerWidth + HdpiCanvas.getTextSize(text, font).width);\r\n        if (labelWidth > maxItemWidth) {\r\n            let truncatedText = '';\r\n            const characterWidths = this.getCharacterWidths(font);\r\n            let cumulativeWidth = paddedMarkerWidth + characterWidths[ellipsis];\r\n            for (const char of textChars) {\r\n                if (!characterWidths[char]) {\r\n                    characterWidths[char] = HdpiCanvas.getTextSize(char, font).width;\r\n                }\r\n                cumulativeWidth += characterWidths[char];\r\n                if (cumulativeWidth > maxItemWidth) {\r\n                    break;\r\n                }\r\n                truncatedText += char;\r\n            }\r\n            text = truncatedText;\r\n            addEllipsis = true;\r\n        }\r\n        if (addEllipsis) {\r\n            text += ellipsis;\r\n            this.truncatedItems.add(id);\r\n        }\r\n        else {\r\n            this.truncatedItems.delete(id);\r\n        }\r\n        return text;\r\n    }\r\n    updatePagination(bboxes, width, height) {\r\n        const orientation = this.getOrientation();\r\n        const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\r\n        this.pagination.orientation = orientation;\r\n        this.pagination.translationX = 0;\r\n        this.pagination.translationY = 0;\r\n        const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(bboxes, width, height);\r\n        const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\r\n        this.pagination.currentPage = Math.min(Math.max(newCurrentPage, 0), pages.length - 1);\r\n        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\r\n        const paginationComponentPadding = 8;\r\n        const legendItemsWidth = maxPageWidth - itemPaddingX;\r\n        const legendItemsHeight = maxPageHeight - itemPaddingY;\r\n        let paginationX = 0;\r\n        let paginationY = -paginationBBox.y - this.item.marker.size / 2;\r\n        if (paginationVertical) {\r\n            paginationY += legendItemsHeight + paginationComponentPadding;\r\n        }\r\n        else {\r\n            paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\r\n            paginationY += (legendItemsHeight - paginationBBox.height) / 2;\r\n        }\r\n        this.pagination.translationX = paginationX;\r\n        this.pagination.translationY = paginationY;\r\n        this.pagination.update();\r\n        this.pagination.updateMarkers();\r\n        return {\r\n            maxPageHeight,\r\n            maxPageWidth,\r\n            pages,\r\n        };\r\n    }\r\n    calculatePagination(bboxes, width, height) {\r\n        var _a, _b, _c;\r\n        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\r\n        const orientation = this.getOrientation();\r\n        const paginationVertical = ['left', 'right'].includes(this.position);\r\n        let paginationBBox = this.pagination.computeBBox();\r\n        let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\r\n        let pages = [];\r\n        let maxPageWidth = 0;\r\n        let maxPageHeight = 0;\r\n        let count = 0;\r\n        const stableOutput = (lastPassPaginationBBox) => {\r\n            const { width, height } = lastPassPaginationBBox;\r\n            return width === paginationBBox.width && height === paginationBBox.height;\r\n        };\r\n        const forceResult = this.maxWidth !== undefined || this.maxHeight !== undefined;\r\n        do {\r\n            if (count++ > 10) {\r\n                Logger.warn('unable to find stable legend layout.');\r\n                break;\r\n            }\r\n            paginationBBox = lastPassPaginationBBox;\r\n            const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);\r\n            const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);\r\n            const layout = gridLayout({\r\n                orientation,\r\n                bboxes,\r\n                maxHeight,\r\n                maxWidth,\r\n                itemPaddingY,\r\n                itemPaddingX,\r\n                forceResult,\r\n            });\r\n            pages = (_a = layout === null || layout === void 0 ? void 0 : layout.pages) !== null && _a !== void 0 ? _a : [];\r\n            maxPageWidth = (_b = layout === null || layout === void 0 ? void 0 : layout.maxPageWidth) !== null && _b !== void 0 ? _b : 0;\r\n            maxPageHeight = (_c = layout === null || layout === void 0 ? void 0 : layout.maxPageHeight) !== null && _c !== void 0 ? _c : 0;\r\n            const totalPages = pages.length;\r\n            this.pagination.visible = totalPages > 1;\r\n            this.pagination.totalPages = totalPages;\r\n            this.pagination.update();\r\n            lastPassPaginationBBox = this.pagination.computeBBox();\r\n            if (!this.pagination.visible) {\r\n                break;\r\n            }\r\n        } while (!stableOutput(lastPassPaginationBBox));\r\n        return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };\r\n    }\r\n    updatePositions(pageNumber = 0) {\r\n        const { item: { paddingY }, itemSelection, pages, } = this;\r\n        if (pages.length < 1 || !pages[pageNumber]) {\r\n            return;\r\n        }\r\n        const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\r\n        // Position legend items using the layout computed above.\r\n        let x = 0;\r\n        let y = 0;\r\n        const columnCount = columns.length;\r\n        const rowCount = columns[0].indices.length;\r\n        const horizontal = this.getOrientation() === 'horizontal';\r\n        const itemHeight = columns[0].bboxes[0].height + paddingY;\r\n        const rowSumColumnWidths = [];\r\n        itemSelection.each((markerLabel, _, i) => {\r\n            var _a, _b;\r\n            if (i < visibleStart || i > visibleEnd) {\r\n                markerLabel.visible = false;\r\n                return;\r\n            }\r\n            const pageIndex = i - visibleStart;\r\n            let columnIndex = 0;\r\n            let rowIndex = 0;\r\n            if (horizontal) {\r\n                columnIndex = pageIndex % columnCount;\r\n                rowIndex = Math.floor(pageIndex / columnCount);\r\n            }\r\n            else {\r\n                columnIndex = Math.floor(pageIndex / rowCount);\r\n                rowIndex = pageIndex % rowCount;\r\n            }\r\n            markerLabel.visible = true;\r\n            const column = columns[columnIndex];\r\n            if (!column) {\r\n                return;\r\n            }\r\n            y = itemHeight * rowIndex;\r\n            x = (_a = rowSumColumnWidths[rowIndex]) !== null && _a !== void 0 ? _a : 0;\r\n            rowSumColumnWidths[rowIndex] = ((_b = rowSumColumnWidths[rowIndex]) !== null && _b !== void 0 ? _b : 0) + column.columnWidth;\r\n            // Round off for pixel grid alignment to work properly.\r\n            markerLabel.translationX = Math.floor(x);\r\n            markerLabel.translationY = Math.floor(y);\r\n        });\r\n    }\r\n    updatePageNumber(pageNumber) {\r\n        const { pages } = this;\r\n        // Track an item on the page in re-pagination cases (e.g. resize).\r\n        const { startIndex, endIndex } = pages[pageNumber];\r\n        if (startIndex === 0) {\r\n            // Stay on first page on pagination update.\r\n            this.paginationTrackingIndex = 0;\r\n        }\r\n        else if (pageNumber === pages.length - 1) {\r\n            // Stay on last page on pagination update.\r\n            this.paginationTrackingIndex = endIndex;\r\n        }\r\n        else {\r\n            // Track the middle item on the page).\r\n            this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\r\n        }\r\n        this.pagination.update();\r\n        this.pagination.updateMarkers();\r\n        this.updatePositions(pageNumber);\r\n        this.ctx.updateService.update(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    update() {\r\n        const { label: { color }, marker: itemMarker, } = this.item;\r\n        this.itemSelection.each((markerLabel, datum) => {\r\n            var _a;\r\n            const marker = datum.marker;\r\n            markerLabel.markerFill = marker.fill;\r\n            markerLabel.markerStroke = marker.stroke;\r\n            markerLabel.markerStrokeWidth = (_a = itemMarker.strokeWidth) !== null && _a !== void 0 ? _a : Math.min(2, marker.strokeWidth);\r\n            markerLabel.markerFillOpacity = marker.fillOpacity;\r\n            markerLabel.markerStrokeOpacity = marker.strokeOpacity;\r\n            markerLabel.opacity = datum.enabled ? 1 : 0.5;\r\n            markerLabel.color = color;\r\n        });\r\n    }\r\n    getDatumForPoint(x, y) {\r\n        const visibleChildBBoxes = [];\r\n        const closestLeftTop = { dist: Infinity, datum: undefined };\r\n        for (const child of this.group.children) {\r\n            if (!child.visible)\r\n                continue;\r\n            if (!(child instanceof MarkerLabel))\r\n                continue;\r\n            const childBBox = child.computeBBox();\r\n            childBBox.grow(this.item.paddingX / 2, 'horizontal');\r\n            childBBox.grow(this.item.paddingY / 2, 'vertical');\r\n            if (childBBox.containsPoint(x, y)) {\r\n                return child.datum;\r\n            }\r\n            const distX = x - childBBox.x - this.item.paddingX / 2;\r\n            const distY = y - childBBox.y - this.item.paddingY / 2;\r\n            const dist = Math.pow(distX, 2) + Math.pow(distY, 2);\r\n            const toTheLeftTop = distX >= 0 && distY >= 0;\r\n            if (toTheLeftTop && dist < closestLeftTop.dist) {\r\n                closestLeftTop.dist = dist;\r\n                closestLeftTop.datum = child.datum;\r\n            }\r\n            visibleChildBBoxes.push(childBBox);\r\n        }\r\n        const pageBBox = BBox.merge(visibleChildBBoxes);\r\n        if (!pageBBox.containsPoint(x, y)) {\r\n            // We're not in-between legend items.\r\n            return undefined;\r\n        }\r\n        // Fallback to returning closest match to the left/up.\r\n        return closestLeftTop.datum;\r\n    }\r\n    computeBBox() {\r\n        return this.group.computeBBox();\r\n    }\r\n    computePagedBBox() {\r\n        const actualBBox = this.group.computeBBox();\r\n        if (this.pages.length <= 1) {\r\n            return actualBBox;\r\n        }\r\n        const [maxPageWidth, maxPageHeight] = this.maxPageSize;\r\n        actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\r\n        actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\r\n        return actualBBox;\r\n    }\r\n    checkLegendClick(event) {\r\n        const { listeners: { legendItemClick }, ctx: { dataService, highlightManager }, item: { toggleSeriesVisible }, } = this;\r\n        const { offsetX, offsetY } = event;\r\n        const legendBBox = this.computeBBox();\r\n        const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\r\n        const datum = this.getDatumForPoint(offsetX, offsetY);\r\n        if (!pointerInsideLegend || !datum) {\r\n            return;\r\n        }\r\n        const { id, itemId, enabled } = datum;\r\n        const chartSeries = dataService.getSeries();\r\n        const series = chartSeries.find((s) => s.id === id);\r\n        if (!series) {\r\n            return;\r\n        }\r\n        event.consume();\r\n        let newEnabled = enabled;\r\n        if (toggleSeriesVisible) {\r\n            newEnabled = !enabled;\r\n            this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\r\n        }\r\n        if (!newEnabled) {\r\n            highlightManager.updateHighlight(this.id);\r\n        }\r\n        else {\r\n            highlightManager.updateHighlight(this.id, {\r\n                series,\r\n                itemId,\r\n                datum: undefined,\r\n            });\r\n        }\r\n        this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, { forceNodeDataRefresh: true });\r\n        legendItemClick === null || legendItemClick === void 0 ? void 0 : legendItemClick({ type: 'click', enabled: newEnabled, itemId, seriesId: series.id });\r\n    }\r\n    checkLegendDoubleClick(event) {\r\n        var _a;\r\n        const { listeners: { legendItemDoubleClick }, ctx: { dataService }, item: { toggleSeriesVisible }, } = this;\r\n        const { offsetX, offsetY } = event;\r\n        // Integrated charts do not handle double click behaviour correctly due to multiple instances of the\r\n        // chart being created. See https://ag-grid.atlassian.net/browse/RTI-1381\r\n        if (this.ctx.mode === 'integrated') {\r\n            return;\r\n        }\r\n        const legendBBox = this.computeBBox();\r\n        const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\r\n        const datum = this.getDatumForPoint(offsetX, offsetY);\r\n        if (!pointerInsideLegend || !datum) {\r\n            return;\r\n        }\r\n        const { id, itemId, seriesId } = datum;\r\n        const chartSeries = dataService.getSeries();\r\n        const series = chartSeries.find((s) => s.id === id);\r\n        if (!series) {\r\n            return;\r\n        }\r\n        event.consume();\r\n        if (toggleSeriesVisible) {\r\n            const numVisibleItems = {};\r\n            const legendData = chartSeries.flatMap((series) => series.getLegendData('category'));\r\n            legendData.forEach((d) => {\r\n                var _a;\r\n                var _b;\r\n                (_a = numVisibleItems[_b = d.seriesId]) !== null && _a !== void 0 ? _a : (numVisibleItems[_b] = 0);\r\n                if (d.enabled) {\r\n                    numVisibleItems[d.seriesId]++;\r\n                }\r\n            });\r\n            const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\r\n            this.ctx.chartEventManager.legendItemDoubleClick(series, itemId, (_a = clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.enabled) !== null && _a !== void 0 ? _a : false, numVisibleItems, clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.legendItemName);\r\n        }\r\n        this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, { forceNodeDataRefresh: true });\r\n        legendItemDoubleClick === null || legendItemDoubleClick === void 0 ? void 0 : legendItemDoubleClick({ type: 'dblclick', enabled: true, itemId, seriesId: series.id });\r\n    }\r\n    handleLegendMouseMove(event) {\r\n        var _a;\r\n        const { enabled, item: { toggleSeriesVisible }, listeners, } = this;\r\n        if (!enabled) {\r\n            return;\r\n        }\r\n        const legendBBox = this.computeBBox();\r\n        const { pageX, pageY, offsetX, offsetY } = event;\r\n        const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\r\n        if (!pointerInsideLegend) {\r\n            this.ctx.cursorManager.updateCursor(this.id);\r\n            this.ctx.highlightManager.updateHighlight(this.id);\r\n            this.ctx.tooltipManager.removeTooltip(this.id);\r\n            return;\r\n        }\r\n        // Prevent other handlers from consuming this event if it's generated inside the legend\r\n        // boundaries.\r\n        event.consume();\r\n        const datum = this.getDatumForPoint(offsetX, offsetY);\r\n        const pointerOverLegendDatum = pointerInsideLegend && datum !== undefined;\r\n        if (!pointerOverLegendDatum) {\r\n            this.ctx.cursorManager.updateCursor(this.id);\r\n            this.ctx.highlightManager.updateHighlight(this.id);\r\n            return;\r\n        }\r\n        const series = datum ? this.ctx.dataService.getSeries().find((series) => series.id === (datum === null || datum === void 0 ? void 0 : datum.id)) : undefined;\r\n        if (datum && this.truncatedItems.has((_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id)) {\r\n            this.ctx.tooltipManager.updateTooltip(this.id, { pageX, pageY, offsetX, offsetY, event, showArrow: false }, toTooltipHtml({ content: this.getItemLabel(datum) }));\r\n        }\r\n        else {\r\n            this.ctx.tooltipManager.removeTooltip(this.id);\r\n        }\r\n        if (toggleSeriesVisible || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {\r\n            this.ctx.cursorManager.updateCursor(this.id, 'pointer');\r\n        }\r\n        if ((datum === null || datum === void 0 ? void 0 : datum.enabled) && series) {\r\n            this.ctx.highlightManager.updateHighlight(this.id, {\r\n                series,\r\n                itemId: datum === null || datum === void 0 ? void 0 : datum.itemId,\r\n                datum: undefined,\r\n            });\r\n        }\r\n        else {\r\n            this.ctx.highlightManager.updateHighlight(this.id);\r\n        }\r\n    }\r\n    positionLegend(shrinkRect) {\r\n        const newShrinkRect = shrinkRect.clone();\r\n        if (!this.enabled || !this.data.length) {\r\n            return { shrinkRect: newShrinkRect };\r\n        }\r\n        const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);\r\n        this.group.translationX = 0;\r\n        this.group.translationY = 0;\r\n        this.performLayout(legendWidth, legendHeight);\r\n        const legendBBox = this.computePagedBBox();\r\n        const calculateTranslationPerpendicularDimension = () => {\r\n            switch (this.position) {\r\n                case 'top':\r\n                case 'left':\r\n                    return 0;\r\n                case 'bottom':\r\n                    return shrinkRect.height - legendBBox.height;\r\n                case 'right':\r\n                default:\r\n                    return shrinkRect.width - legendBBox.width;\r\n            }\r\n        };\r\n        if (this.visible) {\r\n            let translationX;\r\n            let translationY;\r\n            switch (this.position) {\r\n                case 'top':\r\n                case 'bottom':\r\n                    translationX = (shrinkRect.width - legendBBox.width) / 2;\r\n                    translationY = calculateTranslationPerpendicularDimension();\r\n                    newShrinkRect.shrink(legendBBox.height, this.position);\r\n                    break;\r\n                case 'left':\r\n                case 'right':\r\n                default:\r\n                    translationX = calculateTranslationPerpendicularDimension();\r\n                    translationY = (shrinkRect.height - legendBBox.height) / 2;\r\n                    newShrinkRect.shrink(legendBBox.width, this.position);\r\n            }\r\n            // Round off for pixel grid alignment to work properly.\r\n            this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);\r\n            this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);\r\n        }\r\n        if (this.visible && this.enabled && this.data.length) {\r\n            const legendPadding = this.spacing;\r\n            newShrinkRect.shrink(legendPadding, this.position);\r\n            const legendPositionedBBox = legendBBox.clone();\r\n            legendPositionedBBox.x += this.group.translationX;\r\n            legendPositionedBBox.y += this.group.translationY;\r\n            this.ctx.tooltipManager.updateExclusiveRect(this.id, legendPositionedBBox);\r\n        }\r\n        else {\r\n            this.ctx.tooltipManager.updateExclusiveRect(this.id);\r\n        }\r\n        return { shrinkRect: newShrinkRect };\r\n    }\r\n    calculateLegendDimensions(shrinkRect) {\r\n        const { width, height } = shrinkRect;\r\n        const aspectRatio = width / height;\r\n        const maxCoefficient = 0.5;\r\n        const minHeightCoefficient = 0.2;\r\n        const minWidthCoefficient = 0.25;\r\n        let legendWidth, legendHeight;\r\n        switch (this.position) {\r\n            case 'top':\r\n            case 'bottom':\r\n                // A horizontal legend should take maximum between 20 to 50 percent of the chart height if height is larger than width\r\n                // and maximum 20 percent of the chart height if height is smaller than width.\r\n                const heightCoefficient = aspectRatio < 1\r\n                    ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio))\r\n                    : minHeightCoefficient;\r\n                legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;\r\n                legendHeight = this.maxHeight\r\n                    ? Math.min(this.maxHeight, height)\r\n                    : Math.round(height * heightCoefficient);\r\n                break;\r\n            case 'left':\r\n            case 'right':\r\n            default:\r\n                // A vertical legend should take maximum between 25 to 50 percent of the chart width if width is larger than height\r\n                // and maximum 25 percent of the chart width if width is smaller than height.\r\n                const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\r\n                legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);\r\n                legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;\r\n        }\r\n        return [legendWidth, legendHeight];\r\n    }\r\n}\r\nLegend.className = 'Legend';\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Legend.prototype, \"_enabled\", void 0);\r\n__decorate([\r\n    Validate(POSITION),\r\n    __metadata(\"design:type\", String)\r\n], Legend.prototype, \"position\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Legend.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Legend.prototype, \"maxHeight\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Legend.prototype, \"reverseOrder\", void 0);\r\n__decorate([\r\n    Validate(OPT_ORIENTATION),\r\n    __metadata(\"design:type\", String)\r\n], Legend.prototype, \"orientation\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], Legend.prototype, \"spacing\", void 0);\n\nclass Overlay {\r\n    constructor(className, parent, document) {\r\n        this.text = undefined;\r\n        this.className = className;\r\n        this.parentElement = parent;\r\n        this.document = document;\r\n    }\r\n    show(rect) {\r\n        var _a, _b;\r\n        let element = this.element;\r\n        if (!element) {\r\n            element = this.document.createElement('div');\r\n            element.className = this.className;\r\n            this.element = element;\r\n        }\r\n        element.style.position = 'absolute';\r\n        element.style.left = `${rect.x}px`;\r\n        element.style.top = `${rect.y}px`;\r\n        element.style.width = `${rect.width}px`;\r\n        element.style.height = `${rect.height}px`;\r\n        if (this.renderer) {\r\n            element.innerHTML = this.renderer();\r\n        }\r\n        else {\r\n            const content = this.document.createElement('div');\r\n            content.style.alignItems = 'center';\r\n            content.style.boxSizing = 'border-box';\r\n            content.style.display = 'flex';\r\n            content.style.justifyContent = 'center';\r\n            content.style.margin = '8px';\r\n            content.style.height = '100%';\r\n            content.style.font = '12px Verdana, sans-serif';\r\n            content.innerText = (_a = this.text) !== null && _a !== void 0 ? _a : 'No data to display';\r\n            element.append(content);\r\n        }\r\n        (_b = this.parentElement) === null || _b === void 0 ? void 0 : _b.append(element);\r\n    }\r\n    hide() {\r\n        var _a;\r\n        (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();\r\n        this.element = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], Overlay.prototype, \"renderer\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], Overlay.prototype, \"text\", void 0);\n\nclass ChartOverlays {\r\n    constructor(parent) {\r\n        this.noData = new Overlay('ag-chart-no-data-overlay', parent, parent.ownerDocument);\r\n    }\r\n}\n\nconst SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\r\nclass SeriesLayerManager {\r\n    constructor(rootGroup) {\r\n        this.groups = {};\r\n        this.series = {};\r\n        this.expectedSeriesCount = 1;\r\n        this.mode = 'normal';\r\n        this.rootGroup = rootGroup;\r\n    }\r\n    setSeriesCount(count) {\r\n        this.expectedSeriesCount = count;\r\n    }\r\n    requestGroup(seriesConfig) {\r\n        var _a, _b;\r\n        var _c, _d;\r\n        const { id, type, rootGroup: seriesRootGroup, highlightGroup: seriesHighlightGroup, annotationGroup: seriesAnnotationGroup, seriesGrouping, } = seriesConfig;\r\n        const { groupIndex = id } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\r\n        if (this.series[id] != null) {\r\n            throw new Error(`AG Charts - series already has an allocated layer: ${this.series[id]}`);\r\n        }\r\n        // Re-evaluate mode only on first series addition - we can't swap strategy mid-setup.\r\n        if (Object.keys(this.series).length === 0) {\r\n            this.mode =\r\n                this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\r\n                    ? 'aggressive-grouping'\r\n                    : 'normal';\r\n        }\r\n        (_a = (_c = this.groups)[type]) !== null && _a !== void 0 ? _a : (_c[type] = {});\r\n        const lookupIndex = this.lookupIdx(groupIndex);\r\n        let groupInfo = this.groups[type][lookupIndex];\r\n        if (!groupInfo) {\r\n            groupInfo = (_b = (_d = this.groups[type])[lookupIndex]) !== null && _b !== void 0 ? _b : (_d[lookupIndex] = {\r\n                seriesIds: [],\r\n                group: this.rootGroup.appendChild(new Group({\r\n                    name: `${type}-content`,\r\n                    layer: true,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('data'),\r\n                })),\r\n                highlight: this.rootGroup.appendChild(new Group({\r\n                    name: `${type}-highlight`,\r\n                    layer: true,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('highlight'),\r\n                })),\r\n                annotation: this.rootGroup.appendChild(new Group({\r\n                    name: `${type}-annotation`,\r\n                    layer: true,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('annotation'),\r\n                })),\r\n            });\r\n        }\r\n        this.series[id] = { layerState: groupInfo, seriesConfig };\r\n        groupInfo.seriesIds.push(id);\r\n        groupInfo.group.appendChild(seriesRootGroup);\r\n        groupInfo.highlight.appendChild(seriesHighlightGroup);\r\n        groupInfo.annotation.appendChild(seriesAnnotationGroup);\r\n        return groupInfo.group;\r\n    }\r\n    changeGroup(seriesConfig) {\r\n        var _a, _b;\r\n        const { id, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\r\n        const { groupIndex = id } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\r\n        if ((_b = (_a = this.groups[type]) === null || _a === void 0 ? void 0 : _a[groupIndex]) === null || _b === void 0 ? void 0 : _b.seriesIds.includes(id)) {\r\n            // Already in the right group, nothing to do.\r\n            return;\r\n        }\r\n        if (this.series[id] != null) {\r\n            this.releaseGroup({ id, seriesGrouping: oldGrouping, type, rootGroup, highlightGroup, annotationGroup });\r\n        }\r\n        this.requestGroup(seriesConfig);\r\n    }\r\n    releaseGroup(seriesConfig) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { id, seriesGrouping, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\r\n        const { groupIndex = id } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\r\n        if (this.series[id] == null) {\r\n            throw new Error(`AG Charts - series doesn't have an allocated layer: ${id}`);\r\n        }\r\n        const lookupIndex = this.lookupIdx(groupIndex);\r\n        const groupInfo = (_b = (_a = this.groups[type]) === null || _a === void 0 ? void 0 : _a[lookupIndex]) !== null && _b !== void 0 ? _b : (_c = this.series[id]) === null || _c === void 0 ? void 0 : _c.layerState;\r\n        if (groupInfo) {\r\n            groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== id);\r\n            groupInfo.group.removeChild(rootGroup);\r\n            groupInfo.highlight.removeChild(highlightGroup);\r\n            groupInfo.annotation.removeChild(annotationGroup);\r\n        }\r\n        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.length) === 0) {\r\n            // Last member of the layer, cleanup.\r\n            this.rootGroup.removeChild(groupInfo.group);\r\n            this.rootGroup.removeChild(groupInfo.highlight);\r\n            this.rootGroup.removeChild(groupInfo.annotation);\r\n            delete this.groups[type][lookupIndex];\r\n            delete this.groups[type][id];\r\n        }\r\n        else if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.length) > 0) {\r\n            // Update zIndexSubOrder to avoid it becoming stale as series are removed and re-added\r\n            // with the same groupIndex, but are otherwise unrelated.\r\n            const leadSeriesConfig = (_e = this.series[(_d = groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds) === null || _d === void 0 ? void 0 : _d[0]]) === null || _e === void 0 ? void 0 : _e.seriesConfig;\r\n            groupInfo.group.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('data');\r\n            groupInfo.highlight.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('highlight');\r\n            groupInfo.annotation.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('annotation');\r\n        }\r\n        delete this.series[id];\r\n    }\r\n    lookupIdx(groupIndex) {\r\n        if (this.mode === 'normal') {\r\n            return groupIndex;\r\n        }\r\n        if (typeof groupIndex === 'string') {\r\n            groupIndex = Number(groupIndex.split('-').slice(-1)[0]);\r\n            if (!groupIndex)\r\n                return 0;\r\n        }\r\n        return Math.floor(Math.max(Math.min(groupIndex / this.expectedSeriesCount, 1), 0) *\r\n            SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION);\r\n    }\r\n    destroy() {\r\n        for (const groups of Object.values(this.groups)) {\r\n            for (const groupInfo of Object.values(groups)) {\r\n                this.rootGroup.removeChild(groupInfo.group);\r\n                this.rootGroup.removeChild(groupInfo.highlight);\r\n                this.rootGroup.removeChild(groupInfo.annotation);\r\n            }\r\n        }\r\n        this.groups = {};\r\n        this.series = {};\r\n    }\r\n}\n\nclass SeriesStateManager {\r\n    constructor() {\r\n        this.groups = {};\r\n    }\r\n    registerSeries({ id, seriesGrouping, visible, type, }) {\r\n        var _a;\r\n        var _b;\r\n        if (!seriesGrouping)\r\n            return;\r\n        (_a = (_b = this.groups)[type]) !== null && _a !== void 0 ? _a : (_b[type] = {});\r\n        this.groups[type][id] = { grouping: seriesGrouping, visible };\r\n    }\r\n    deregisterSeries({ id, type }) {\r\n        if (this.groups[type]) {\r\n            delete this.groups[type][id];\r\n        }\r\n        if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\r\n            delete this.groups[type];\r\n        }\r\n    }\r\n    getVisiblePeerGroupIndex({ type, seriesGrouping }) {\r\n        var _a;\r\n        if (!seriesGrouping)\r\n            return { visibleGroupCount: 1, index: 0 };\r\n        const visibleGroups = [\r\n            ...Object.entries((_a = this.groups[type]) !== null && _a !== void 0 ? _a : {})\r\n                .filter(([_, entry]) => entry.visible)\r\n                .reduce((result, [_, next]) => {\r\n                if (next.visible) {\r\n                    result.add(next.grouping.groupIndex);\r\n                }\r\n                return result;\r\n            }, new Set())\r\n                .values(),\r\n        ];\r\n        visibleGroups.sort((a, b) => a - b);\r\n        return {\r\n            visibleGroupCount: visibleGroups.length,\r\n            index: visibleGroups.indexOf(seriesGrouping.groupIndex),\r\n        };\r\n    }\r\n}\n\nclass BaseLayoutProcessor {\r\n    constructor(chartLike, layoutService) {\r\n        this.chartLike = chartLike;\r\n        this.layoutService = layoutService;\r\n        this.destroyFns = [];\r\n        this.destroyFns.push(\r\n        // eslint-disable-next-line sonarjs/no-duplicate-string\r\n        this.layoutService.addListener('layout-complete', (e) => this.layoutComplete(e)), this.layoutService.addListener('start-layout', (e) => this.positionPadding(e.shrinkRect)), this.layoutService.addListener('start-layout', (e) => this.positionCaptions(e.shrinkRect)));\r\n    }\r\n    destroy() {\r\n        this.destroyFns.forEach((cb) => cb());\r\n    }\r\n    layoutComplete({ clipSeries, series: { paddedRect } }) {\r\n        const { seriesArea, seriesRoot } = this.chartLike;\r\n        if (seriesArea.clip || clipSeries) {\r\n            seriesRoot.setClipRectInGroupCoordinateSpace(paddedRect);\r\n        }\r\n        else {\r\n            seriesRoot.setClipRectInGroupCoordinateSpace();\r\n        }\r\n    }\r\n    positionPadding(shrinkRect) {\r\n        const { padding } = this.chartLike;\r\n        shrinkRect.shrink(padding.left, 'left');\r\n        shrinkRect.shrink(padding.top, 'top');\r\n        shrinkRect.shrink(padding.right, 'right');\r\n        shrinkRect.shrink(padding.bottom, 'bottom');\r\n        return { shrinkRect };\r\n    }\r\n    positionCaptions(shrinkRect) {\r\n        var _a, _b, _c, _d;\r\n        const { title, subtitle, footnote } = this.chartLike;\r\n        const newShrinkRect = shrinkRect.clone();\r\n        const updateCaption = (caption) => {\r\n            var _a;\r\n            const defaultCaptionHeight = shrinkRect.height / 10;\r\n            const captionLineHeight = (_a = caption.lineHeight) !== null && _a !== void 0 ? _a : caption.fontSize * Text.defaultLineHeightRatio;\r\n            const maxWidth = shrinkRect.width;\r\n            const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);\r\n            caption.computeTextWrap(maxWidth, maxHeight);\r\n        };\r\n        const positionTopAndShrinkBBox = (caption, spacing) => {\r\n            const baseY = newShrinkRect.y;\r\n            caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;\r\n            caption.node.y = baseY;\r\n            caption.node.textBaseline = 'top';\r\n            updateCaption(caption);\r\n            const bbox = caption.node.computeBBox();\r\n            // As the bbox (x,y) ends up at a different location than specified above, we need to\r\n            // take it into consideration when calculating how much space needs to be reserved to\r\n            // accommodate the caption.\r\n            const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);\r\n            newShrinkRect.shrink(bboxHeight, 'top');\r\n        };\r\n        const positionBottomAndShrinkBBox = (caption, spacing) => {\r\n            const baseY = newShrinkRect.y + newShrinkRect.height;\r\n            caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;\r\n            caption.node.y = baseY;\r\n            caption.node.textBaseline = 'bottom';\r\n            updateCaption(caption);\r\n            const bbox = caption.node.computeBBox();\r\n            const bboxHeight = Math.ceil(baseY - bbox.y + spacing);\r\n            newShrinkRect.shrink(bboxHeight, 'bottom');\r\n        };\r\n        if (subtitle) {\r\n            subtitle.node.visible = (_a = subtitle.enabled) !== null && _a !== void 0 ? _a : false;\r\n        }\r\n        if (title) {\r\n            title.node.visible = title.enabled;\r\n            if (title.node.visible) {\r\n                const defaultTitleSpacing = (subtitle === null || subtitle === void 0 ? void 0 : subtitle.node.visible) ? Caption.SMALL_PADDING : Caption.LARGE_PADDING;\r\n                const spacing = (_b = title.spacing) !== null && _b !== void 0 ? _b : defaultTitleSpacing;\r\n                positionTopAndShrinkBBox(title, spacing);\r\n            }\r\n        }\r\n        if (subtitle && subtitle.node.visible) {\r\n            positionTopAndShrinkBBox(subtitle, (_c = subtitle.spacing) !== null && _c !== void 0 ? _c : 0);\r\n        }\r\n        if (footnote) {\r\n            footnote.node.visible = footnote.enabled;\r\n            if (footnote.node.visible) {\r\n                positionBottomAndShrinkBBox(footnote, (_d = footnote.spacing) !== null && _d !== void 0 ? _d : 0);\r\n            }\r\n        }\r\n        return { shrinkRect: newShrinkRect };\r\n    }\r\n}\n\nclass UpdateService extends Listeners {\r\n    constructor(updateCallback) {\r\n        super();\r\n        this.updateCallback = updateCallback;\r\n    }\r\n    update(type = ChartUpdateType.FULL, { forceNodeDataRefresh = false, skipAnimations = false } = {}) {\r\n        this.updateCallback(type, { forceNodeDataRefresh, skipAnimations });\r\n    }\r\n    dispatchUpdateComplete(minRect) {\r\n        const event = { type: 'update-complete', minRect };\r\n        this.dispatch('update-complete', event);\r\n    }\r\n}\n\nfunction initialiseSpecialOverrides(opts) {\r\n    let globalWindow;\r\n    if (opts.window != null) {\r\n        globalWindow = opts.window;\r\n    }\r\n    else if (typeof window !== 'undefined') {\r\n        globalWindow = window;\r\n    }\r\n    else if (typeof __webpack_require__.g !== 'undefined') {\r\n        globalWindow = __webpack_require__.g.window;\r\n    }\r\n    else {\r\n        throw new Error('AG Charts - unable to resolve global window');\r\n    }\r\n    let globalDocument;\r\n    if (opts.document != null) {\r\n        globalDocument = opts.document;\r\n    }\r\n    else if (typeof document !== 'undefined') {\r\n        globalDocument = document;\r\n    }\r\n    else if (typeof __webpack_require__.g !== 'undefined') {\r\n        globalDocument = __webpack_require__.g.document;\r\n    }\r\n    else {\r\n        throw new Error('AG Charts - unable to resolve global document');\r\n    }\r\n    return {\r\n        document: globalDocument,\r\n        window: globalWindow,\r\n        overrideDevicePixelRatio: opts.overrideDevicePixelRatio,\r\n        sceneMode: opts.sceneMode,\r\n    };\r\n}\r\nclass SeriesArea {\r\n    constructor() {\r\n        this.clip = undefined;\r\n        this.padding = new Padding(0);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], SeriesArea.prototype, \"clip\", void 0);\r\nclass Chart extends Observable {\r\n    getOptions() {\r\n        var _a;\r\n        const { queuedUserOptions } = this;\r\n        const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : this.userOptions;\r\n        return jsonMerge([lastUpdateOptions]);\r\n    }\r\n    autoSizeChanged(value) {\r\n        const { style } = this.element;\r\n        if (value) {\r\n            style.display = 'block';\r\n            style.width = '100%';\r\n            style.height = '100%';\r\n            if (!this._lastAutoSize) {\r\n                return;\r\n            }\r\n            this.resize(undefined, undefined, 'autoSize option');\r\n        }\r\n        else {\r\n            style.display = 'inline-block';\r\n            style.width = 'auto';\r\n            style.height = 'auto';\r\n        }\r\n    }\r\n    download(fileName, fileFormat) {\r\n        this.scene.download(fileName, fileFormat);\r\n    }\r\n    get destroyed() {\r\n        return this._destroyed;\r\n    }\r\n    constructor(specialOverrides, resources) {\r\n        var _a;\r\n        super();\r\n        this.id = createId(this);\r\n        this.processedOptions = {};\r\n        this.userOptions = {};\r\n        this.queuedUserOptions = [];\r\n        this.seriesRoot = new Group({ name: `${this.id}-Series-root` });\r\n        this.debug = Debug.create();\r\n        this.extraDebugStats = {};\r\n        this.container = undefined;\r\n        this.data = [];\r\n        this._firstAutoSize = true;\r\n        this.padding = new Padding(20);\r\n        this.seriesArea = new SeriesArea();\r\n        this.title = undefined;\r\n        this.subtitle = undefined;\r\n        this.footnote = undefined;\r\n        this.mode = 'standalone';\r\n        this._destroyed = false;\r\n        this._destroyFns = [];\r\n        this.modules = {};\r\n        this.legendModules = {};\r\n        this.processors = [];\r\n        this.legends = new Map();\r\n        this._pendingFactoryUpdatesCount = 0;\r\n        this._performUpdateNoRenderCount = 0;\r\n        this._performUpdateType = ChartUpdateType.NONE;\r\n        this._performUpdateSkipAnimations = false;\r\n        this.updateShortcutCount = 0;\r\n        this.seriesToUpdate = new Set();\r\n        this.updateMutex = new Mutex();\r\n        this.updateRequestors = {};\r\n        this.performUpdateTrigger = debouncedCallback(({ count }) => __awaiter(this, void 0, void 0, function* () {\r\n            if (this._destroyed)\r\n                return;\r\n            this.updateMutex.acquire(() => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    yield this.performUpdate(count);\r\n                }\r\n                catch (error) {\r\n                    this._lastPerformUpdateError = error;\r\n                    Logger.error('update error', error);\r\n                }\r\n            }));\r\n        }));\r\n        this._axes = [];\r\n        this._series = [];\r\n        this.lastInteractionEvent = undefined;\r\n        this.pointerScheduler = debouncedAnimationFrame(() => {\r\n            if (this.lastInteractionEvent) {\r\n                this.handlePointer(this.lastInteractionEvent);\r\n            }\r\n            this.lastInteractionEvent = undefined;\r\n        });\r\n        this.onSeriesNodeClick = (event) => {\r\n            const seriesNodeClickEvent = Object.assign(Object.assign({}, event), { type: 'seriesNodeClick' });\r\n            Object.defineProperty(seriesNodeClickEvent, 'series', {\r\n                enumerable: false,\r\n                // Should display the deprecation warning\r\n                get: () => event.series,\r\n            });\r\n            this.fireEvent(seriesNodeClickEvent);\r\n        };\r\n        this.onSeriesNodeDoubleClick = (event) => {\r\n            const seriesNodeDoubleClick = Object.assign(Object.assign({}, event), { type: 'seriesNodeDoubleClick' });\r\n            this.fireEvent(seriesNodeDoubleClick);\r\n        };\r\n        this.specialOverrides = initialiseSpecialOverrides(specialOverrides);\r\n        const { window, document } = this.specialOverrides;\r\n        const scene = resources === null || resources === void 0 ? void 0 : resources.scene;\r\n        const element = (_a = resources === null || resources === void 0 ? void 0 : resources.element) !== null && _a !== void 0 ? _a : document.createElement('div');\r\n        const container = resources === null || resources === void 0 ? void 0 : resources.container;\r\n        const root = new Group({ name: 'root' });\r\n        // Prevent the scene from rendering chart components in an invalid state\r\n        // (before first layout is performed).\r\n        root.visible = false;\r\n        root.append(this.seriesRoot);\r\n        this.axisGridGroup = new Group({ name: 'Axes-Grids', layer: true, zIndex: Layers.AXIS_GRID_ZINDEX });\r\n        root.appendChild(this.axisGridGroup);\r\n        this.axisGroup = new Group({ name: 'Axes', layer: true, zIndex: Layers.AXIS_ZINDEX });\r\n        root.appendChild(this.axisGroup);\r\n        this.element = element;\r\n        element.classList.add('ag-chart-wrapper');\r\n        element.style.position = 'relative';\r\n        this.scene = scene !== null && scene !== void 0 ? scene : new Scene(this.specialOverrides);\r\n        this.scene.root = root;\r\n        this.scene.container = element;\r\n        this.autoSize = true;\r\n        this.chartEventManager = new ChartEventManager();\r\n        this.cursorManager = new CursorManager(element);\r\n        this.highlightManager = new HighlightManager();\r\n        this.interactionManager = new InteractionManager(element, document, window);\r\n        this.zoomManager = new ZoomManager();\r\n        this.dataService = new DataService(() => this.series);\r\n        this.layoutService = new LayoutService();\r\n        this.updateService = new UpdateService((type = ChartUpdateType.FULL, { forceNodeDataRefresh, skipAnimations }) => this.update(type, { forceNodeDataRefresh, skipAnimations }));\r\n        this.seriesStateManager = new SeriesStateManager();\r\n        this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);\r\n        this.callbackCache = new CallbackCache();\r\n        this.animationManager = new AnimationManager(this.interactionManager, this.updateMutex);\r\n        this.animationManager.skip();\r\n        this.animationManager.play();\r\n        this.processors = [new BaseLayoutProcessor(this, this.layoutService)];\r\n        this.tooltip = new Tooltip(this.scene.canvas.element, document, window, document.body);\r\n        this.tooltipManager = new TooltipManager(this.tooltip, this.interactionManager);\r\n        this.overlays = new ChartOverlays(this.element);\r\n        this.highlight = new ChartHighlight();\r\n        this.container = container;\r\n        SizeMonitor.observe(this.element, (size) => this.rawResize(size));\r\n        this._destroyFns.push(this.interactionManager.addListener('click', (event) => this.onClick(event)), this.interactionManager.addListener('dblclick', (event) => this.onDoubleClick(event)), this.interactionManager.addListener('hover', (event) => this.onMouseMove(event)), this.interactionManager.addListener('leave', (event) => this.onLeave(event)), this.interactionManager.addListener('page-left', () => this.destroy()), this.interactionManager.addListener('wheel', () => this.disablePointer()), \r\n        // Block redundant and interfering attempts to update the hovered element during dragging.\r\n        this.interactionManager.addListener('drag-start', () => this.disablePointer()), this.animationManager.addListener('animation-frame', (_) => {\r\n            this.update(ChartUpdateType.SCENE_RENDER);\r\n        }), this.highlightManager.addListener('highlight-change', (event) => this.changeHighlightDatum(event)), this.zoomManager.addListener('zoom-change', (_) => this.update(ChartUpdateType.PROCESS_DATA, { forceNodeDataRefresh: true, skipAnimations: true })));\r\n        this.legend = this.attachLegend('category', Legend);\r\n    }\r\n    addModule(module) {\r\n        if (this.modules[module.optionsKey] != null) {\r\n            throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\r\n        }\r\n        const moduleInstance = new module.instanceConstructor(this.getModuleContext());\r\n        this.modules[module.optionsKey] = { instance: moduleInstance };\r\n        this[module.optionsKey] = moduleInstance; // TODO remove\r\n    }\r\n    removeModule(module) {\r\n        var _a;\r\n        (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance.destroy();\r\n        delete this.modules[module.optionsKey];\r\n        delete this[module.optionsKey]; // TODO remove\r\n    }\r\n    attachLegend(legendType, legendConstructor) {\r\n        const legend = new legendConstructor(this.getModuleContext());\r\n        this.legends.set(legendType, legend);\r\n        legend.attachLegend(this.scene.root);\r\n        return legend;\r\n    }\r\n    addLegendModule(module) {\r\n        if (this.modules[module.optionsKey] != null) {\r\n            throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\r\n        }\r\n        const legend = this.attachLegend(module.identifier, module.instanceConstructor);\r\n        this.modules[module.optionsKey] = { instance: legend };\r\n        this[module.optionsKey] = legend;\r\n    }\r\n    removeLegendModule(module) {\r\n        this.legends.delete(module.identifier);\r\n        this.removeModule(module);\r\n    }\r\n    isModuleEnabled(module) {\r\n        return this.modules[module.optionsKey] != null;\r\n    }\r\n    getModuleContext() {\r\n        const { scene, animationManager, chartEventManager, cursorManager, highlightManager, interactionManager, tooltipManager, zoomManager, dataService, layoutService, updateService, seriesStateManager, seriesLayerManager, mode, callbackCache, specialOverrides: { window, document }, } = this;\r\n        return {\r\n            window,\r\n            document,\r\n            scene,\r\n            animationManager,\r\n            chartEventManager,\r\n            cursorManager,\r\n            highlightManager,\r\n            interactionManager,\r\n            tooltipManager,\r\n            zoomManager,\r\n            dataService,\r\n            layoutService,\r\n            updateService,\r\n            mode,\r\n            seriesStateManager,\r\n            seriesLayerManager,\r\n            callbackCache,\r\n        };\r\n    }\r\n    destroy(opts) {\r\n        if (this._destroyed) {\r\n            return;\r\n        }\r\n        const keepTransferableResources = opts === null || opts === void 0 ? void 0 : opts.keepTransferableResources;\r\n        let result;\r\n        this._performUpdateType = ChartUpdateType.NONE;\r\n        this._destroyFns.forEach((fn) => fn());\r\n        this.processors.forEach((p) => p.destroy());\r\n        this.tooltipManager.destroy();\r\n        this.tooltip.destroy();\r\n        Object.values(this.legends).forEach((legend) => legend.destroy());\r\n        this.legends.clear();\r\n        this.overlays.noData.hide();\r\n        SizeMonitor.unobserve(this.element);\r\n        for (const optionsKey of Object.keys(this.modules)) {\r\n            this.removeModule({ optionsKey });\r\n        }\r\n        this.interactionManager.destroy();\r\n        this.animationManager.stop();\r\n        if (keepTransferableResources) {\r\n            this.scene.strip();\r\n            result = { container: this.container, scene: this.scene, element: this.element };\r\n        }\r\n        else {\r\n            this.scene.destroy();\r\n            this.container = undefined;\r\n        }\r\n        this.removeAllSeries();\r\n        this.seriesLayerManager.destroy();\r\n        this.axes.forEach((a) => a.destroy());\r\n        this.axes = [];\r\n        this.callbackCache.invalidateCache();\r\n        this._destroyed = true;\r\n        return result;\r\n    }\r\n    disablePointer(highlightOnly = false) {\r\n        if (!highlightOnly) {\r\n            this.tooltipManager.removeTooltip(this.id);\r\n        }\r\n        this.highlightManager.updateHighlight(this.id);\r\n        if (this.lastInteractionEvent) {\r\n            this.lastInteractionEvent = undefined;\r\n        }\r\n    }\r\n    requestFactoryUpdate(cb) {\r\n        this._pendingFactoryUpdatesCount++;\r\n        this.updateMutex.acquire(() => __awaiter(this, void 0, void 0, function* () {\r\n            yield cb();\r\n            this._pendingFactoryUpdatesCount--;\r\n        }));\r\n    }\r\n    get performUpdateType() {\r\n        return this._performUpdateType;\r\n    }\r\n    get lastPerformUpdateError() {\r\n        return this._lastPerformUpdateError;\r\n    }\r\n    update(type = ChartUpdateType.FULL, opts) {\r\n        var _a, _b;\r\n        const { forceNodeDataRefresh = false, skipAnimations, seriesToUpdate = this.series, newAnimationBatch, } = opts !== null && opts !== void 0 ? opts : {};\r\n        if (forceNodeDataRefresh) {\r\n            this.series.forEach((series) => series.markNodeDataDirty());\r\n        }\r\n        for (const series of seriesToUpdate) {\r\n            this.seriesToUpdate.add(series);\r\n        }\r\n        if (skipAnimations) {\r\n            this.animationManager.skipCurrentBatch();\r\n            this._performUpdateSkipAnimations = true;\r\n        }\r\n        if (newAnimationBatch) {\r\n            if (this.animationManager.isActive()) {\r\n                this._performUpdateSkipAnimations = true;\r\n            }\r\n            else {\r\n                (_a = this._performUpdateSkipAnimations) !== null && _a !== void 0 ? _a : (this._performUpdateSkipAnimations = false);\r\n            }\r\n        }\r\n        if (Debug.check(true)) {\r\n            let stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<unknown>';\r\n            stack = stack.replace(/\\([^)]*/g, '');\r\n            this.updateRequestors[stack] = type;\r\n        }\r\n        if (type < this._performUpdateType) {\r\n            this._performUpdateType = type;\r\n            this.performUpdateTrigger.schedule(opts === null || opts === void 0 ? void 0 : opts.backOffMs);\r\n        }\r\n    }\r\n    performUpdate(count) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { _performUpdateType: performUpdateType, extraDebugStats } = this;\r\n            const seriesToUpdate = [...this.seriesToUpdate];\r\n            // Clear state immediately so that side-effects can be detected prior to SCENE_RENDER.\r\n            this._performUpdateType = ChartUpdateType.NONE;\r\n            this.seriesToUpdate.clear();\r\n            if (this.updateShortcutCount === 0 && performUpdateType < ChartUpdateType.SCENE_RENDER) {\r\n                this.animationManager.startBatch(this._performUpdateSkipAnimations);\r\n            }\r\n            this.debug('Chart.performUpdate() - start', ChartUpdateType[performUpdateType]);\r\n            const splits = { start: performance.now() };\r\n            switch (performUpdateType) {\r\n                case ChartUpdateType.FULL:\r\n                case ChartUpdateType.PROCESS_DATA:\r\n                    yield this.processData();\r\n                    this.disablePointer(true);\r\n                    splits['🏭'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.PERFORM_LAYOUT:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.PERFORM_LAYOUT))\r\n                        break;\r\n                    if (!this.checkFirstAutoSize(seriesToUpdate))\r\n                        break;\r\n                    yield this.processLayout();\r\n                    splits['⌖'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.SERIES_UPDATE:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.SERIES_UPDATE))\r\n                        break;\r\n                    const { seriesRect } = this;\r\n                    const seriesUpdates = [...seriesToUpdate].map((series) => series.update({ seriesRect }));\r\n                    yield Promise.all(seriesUpdates);\r\n                    splits['🤔'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.TOOLTIP_RECALCULATION:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.TOOLTIP_RECALCULATION))\r\n                        break;\r\n                    const tooltipMeta = this.tooltipManager.getTooltipMeta(this.id);\r\n                    const isHovered = ((_a = tooltipMeta === null || tooltipMeta === void 0 ? void 0 : tooltipMeta.event) === null || _a === void 0 ? void 0 : _a.type) === 'hover';\r\n                    if (performUpdateType <= ChartUpdateType.SERIES_UPDATE && isHovered) {\r\n                        this.handlePointer(tooltipMeta.event);\r\n                    }\r\n                    splits['↖'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.SCENE_RENDER:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.SCENE_RENDER))\r\n                        break;\r\n                    extraDebugStats['updateShortcutCount'] = this.updateShortcutCount;\r\n                    yield this.scene.render({ debugSplitTimes: splits, extraDebugStats });\r\n                    this.extraDebugStats = {};\r\n                // fallthrough\r\n                case ChartUpdateType.NONE:\r\n                    // Do nothing.\r\n                    this.updateShortcutCount = 0;\r\n                    this.updateRequestors = {};\r\n                    this._performUpdateSkipAnimations = undefined;\r\n                    this.animationManager.endBatch();\r\n            }\r\n            this.updateService.dispatchUpdateComplete(this.getMinRect());\r\n            const end = performance.now();\r\n            this.debug('Chart.performUpdate() - end', {\r\n                chart: this,\r\n                durationMs: Math.round((end - splits['start']) * 100) / 100,\r\n                count,\r\n                performUpdateType: ChartUpdateType[performUpdateType],\r\n            });\r\n        });\r\n    }\r\n    checkUpdateShortcut(checkUpdateType) {\r\n        const maxShortcuts = 3;\r\n        if (this.updateShortcutCount > maxShortcuts) {\r\n            Logger.warn(`exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`, this.updateRequestors);\r\n            return false;\r\n        }\r\n        if (this.performUpdateType <= checkUpdateType) {\r\n            // A previous step modified series state, and we need to re-run this or an earlier step before rendering.\r\n            this.updateShortcutCount++;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    checkFirstAutoSize(seriesToUpdate) {\r\n        if (this.autoSize && !this._lastAutoSize) {\r\n            const count = this._performUpdateNoRenderCount++;\r\n            const backOffMs = (count ^ 2) * 10;\r\n            if (count < 8) {\r\n                // Reschedule if canvas size hasn't been set yet to avoid a race.\r\n                this.update(ChartUpdateType.PERFORM_LAYOUT, { seriesToUpdate, backOffMs });\r\n                this.debug('Chart.checkFirstAutoSize() - backing off until first size update', backOffMs);\r\n                return false;\r\n            }\r\n            // After several failed passes, continue and accept there maybe a redundant\r\n            // render. Sometimes this case happens when we already have the correct\r\n            // width/height, and we end up never rendering the chart in that scenario.\r\n            this.debug('Chart.checkFirstAutoSize() - timeout for first size update.');\r\n        }\r\n        this._performUpdateNoRenderCount = 0;\r\n        return true;\r\n    }\r\n    set axes(values) {\r\n        const removedAxes = new Set();\r\n        this._axes.forEach((axis) => {\r\n            axis.detachAxis(this.axisGroup, this.axisGridGroup);\r\n            removedAxes.add(axis);\r\n        });\r\n        // make linked axes go after the regular ones (simulates stable sort by `linkedTo` property)\r\n        this._axes = values.filter((a) => !a.linkedTo).concat(values.filter((a) => a.linkedTo));\r\n        this._axes.forEach((axis) => {\r\n            axis.attachAxis(this.axisGroup, this.axisGridGroup);\r\n            removedAxes.delete(axis);\r\n        });\r\n        this.zoomManager.updateAxes(this._axes);\r\n        removedAxes.forEach((axis) => axis.destroy());\r\n    }\r\n    get axes() {\r\n        return this._axes;\r\n    }\r\n    set series(values) {\r\n        this.removeAllSeries();\r\n        this.seriesLayerManager.setSeriesCount(values.length);\r\n        values.forEach((series) => this.addSeries(series));\r\n    }\r\n    get series() {\r\n        return this._series;\r\n    }\r\n    addSeries(series) {\r\n        const { series: allSeries } = this;\r\n        const canAdd = allSeries.indexOf(series) < 0;\r\n        if (canAdd) {\r\n            allSeries.push(series);\r\n            if (series.rootGroup.parent == null) {\r\n                this.seriesLayerManager.requestGroup(series);\r\n            }\r\n            this.initSeries(series);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    initSeries(series) {\r\n        const chart = this;\r\n        series.chart = {\r\n            get mode() {\r\n                return chart.mode;\r\n            },\r\n            get seriesRect() {\r\n                return chart.seriesRect;\r\n            },\r\n            placeLabels() {\r\n                return chart.placeLabels();\r\n            },\r\n        };\r\n        series.setChartData(this.data);\r\n        this.addSeriesListeners(series);\r\n        series.addChartEventListeners();\r\n    }\r\n    removeAllSeries() {\r\n        this.series.forEach((series) => {\r\n            series.removeEventListener('nodeClick', this.onSeriesNodeClick);\r\n            series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\r\n            series.destroy();\r\n            series.chart = undefined;\r\n        });\r\n        this._series = []; // using `_series` instead of `series` to prevent infinite recursion\r\n    }\r\n    addSeriesListeners(series) {\r\n        if (this.hasEventListener('seriesNodeClick')) {\r\n            series.addEventListener('nodeClick', this.onSeriesNodeClick);\r\n        }\r\n        if (this.hasEventListener('seriesNodeDoubleClick')) {\r\n            series.addEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\r\n        }\r\n    }\r\n    updateAllSeriesListeners() {\r\n        this.series.forEach((series) => {\r\n            series.removeEventListener('nodeClick', this.onSeriesNodeClick);\r\n            series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\r\n            this.addSeriesListeners(series);\r\n        });\r\n    }\r\n    assignSeriesToAxes() {\r\n        this.axes.forEach((axis) => {\r\n            axis.boundSeries = this.series.filter((s) => {\r\n                const seriesAxis = s.axes[axis.direction];\r\n                return seriesAxis === axis;\r\n            });\r\n        });\r\n    }\r\n    assignAxesToSeries() {\r\n        // This method has to run before `assignSeriesToAxes`.\r\n        const directionToAxesMap = {};\r\n        this.axes.forEach((axis) => {\r\n            var _a;\r\n            const direction = axis.direction;\r\n            const directionAxes = ((_a = directionToAxesMap[direction]) !== null && _a !== void 0 ? _a : (directionToAxesMap[direction] = []));\r\n            directionAxes.push(axis);\r\n        });\r\n        this.series.forEach((series) => {\r\n            series.directions.forEach((direction) => {\r\n                const directionAxes = directionToAxesMap[direction];\r\n                if (!directionAxes) {\r\n                    Logger.warnOnce(`no available axis for direction [${direction}]; check series and axes configuration.`);\r\n                    return;\r\n                }\r\n                const seriesKeys = series.getKeys(direction);\r\n                const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);\r\n                if (!newAxis) {\r\n                    Logger.warnOnce(`no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`);\r\n                    return;\r\n                }\r\n                series.axes[direction] = newAxis;\r\n            });\r\n        });\r\n    }\r\n    findMatchingAxis(directionAxes, directionKeys) {\r\n        for (const axis of directionAxes) {\r\n            const axisKeys = axis.keys;\r\n            if (!axisKeys.length) {\r\n                return axis;\r\n            }\r\n            if (!directionKeys) {\r\n                continue;\r\n            }\r\n            for (const directionKey of directionKeys) {\r\n                if (axisKeys.indexOf(directionKey) >= 0) {\r\n                    return axis;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    rawResize(size) {\r\n        var _a;\r\n        let { width, height } = size;\r\n        width = Math.floor(width);\r\n        height = Math.floor(height);\r\n        if (!this.autoSize) {\r\n            return;\r\n        }\r\n        if (width === 0 && height === 0) {\r\n            return;\r\n        }\r\n        const [autoWidth = 0, authHeight = 0] = (_a = this._lastAutoSize) !== null && _a !== void 0 ? _a : [];\r\n        if (autoWidth === width && authHeight === height) {\r\n            return;\r\n        }\r\n        this._lastAutoSize = [width, height];\r\n        this.resize(undefined, undefined, 'SizeMonitor');\r\n    }\r\n    resize(width, height, source) {\r\n        var _a, _b, _c, _d;\r\n        width !== null && width !== void 0 ? width : (width = (_a = this.width) !== null && _a !== void 0 ? _a : (this.autoSize ? (_b = this._lastAutoSize) === null || _b === void 0 ? void 0 : _b[0] : this.scene.canvas.width));\r\n        height !== null && height !== void 0 ? height : (height = (_c = this.height) !== null && _c !== void 0 ? _c : (this.autoSize ? (_d = this._lastAutoSize) === null || _d === void 0 ? void 0 : _d[1] : this.scene.canvas.height));\r\n        this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });\r\n        if (!width || !height || !Number.isFinite(width) || !Number.isFinite(height))\r\n            return;\r\n        if (this.scene.resize(width, height)) {\r\n            this.disablePointer();\r\n            this.animationManager.reset();\r\n            let skipAnimations = true;\r\n            if (this.autoSize && this._firstAutoSize) {\r\n                skipAnimations = false;\r\n                this._firstAutoSize = false;\r\n            }\r\n            this.update(ChartUpdateType.PERFORM_LAYOUT, { forceNodeDataRefresh: true, skipAnimations });\r\n        }\r\n    }\r\n    processData() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.series.some((s) => s.canHaveAxes)) {\r\n                this.assignAxesToSeries();\r\n                this.assignSeriesToAxes();\r\n            }\r\n            const dataController = new DataController(this.mode);\r\n            const seriesPromises = this.series.map((s) => s.processData(dataController));\r\n            yield dataController.execute();\r\n            yield Promise.all(seriesPromises);\r\n            yield this.updateLegend();\r\n        });\r\n    }\r\n    placeLabels() {\r\n        const visibleSeries = [];\r\n        const data = [];\r\n        for (const series of this.series) {\r\n            if (!series.visible) {\r\n                continue;\r\n            }\r\n            const labelData = series.getLabelData();\r\n            if (!(labelData && isPointLabelDatum(labelData[0]))) {\r\n                continue;\r\n            }\r\n            data.push(labelData);\r\n            visibleSeries.push(series);\r\n        }\r\n        const { seriesRect } = this;\r\n        const labels = seriesRect && data.length > 0\r\n            ? placeLabels(data, { x: 0, y: 0, width: seriesRect.width, height: seriesRect.height })\r\n            : [];\r\n        return new Map(labels.map((l, i) => [visibleSeries[i], l]));\r\n    }\r\n    updateLegend() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.legends.forEach((legend, legendType) => {\r\n                const isCategoryLegendData = (data) => data.every((d) => d.legendType === 'category');\r\n                const legendData = this.series.filter((s) => s.showInLegend).flatMap((s) => s.getLegendData(legendType));\r\n                if (isCategoryLegendData(legendData)) {\r\n                    this.validateCategoryLegendData(legendData);\r\n                }\r\n                legend.data = legendData;\r\n            });\r\n        });\r\n    }\r\n    validateCategoryLegendData(legendData) {\r\n        // Validate each series that shares a legend item label uses the same fill colour\r\n        const labelMarkerFills = {};\r\n        legendData.forEach((d) => {\r\n            var _a, _b, _c;\r\n            var _d, _e;\r\n            const seriesType = (_a = this.series.find((s) => s.id === d.seriesId)) === null || _a === void 0 ? void 0 : _a.type;\r\n            if (!seriesType)\r\n                return;\r\n            (_b = labelMarkerFills[seriesType]) !== null && _b !== void 0 ? _b : (labelMarkerFills[seriesType] = {});\r\n            (_c = (_d = labelMarkerFills[seriesType])[_e = d.label.text]) !== null && _c !== void 0 ? _c : (_d[_e] = new Set());\r\n            if (d.marker.fill != null) {\r\n                labelMarkerFills[seriesType][d.label.text].add(d.marker.fill);\r\n            }\r\n        });\r\n        for (const seriesMarkers of Object.values(labelMarkerFills)) {\r\n            for (const [name, fills] of Object.entries(seriesMarkers)) {\r\n                if (fills.size > 1) {\r\n                    Logger.warnOnce(`legend item '${name}' has multiple fill colors, this may cause unexpected behaviour.`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    processLayout() {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const oldRect = this.animationRect;\r\n            yield this.performLayout();\r\n            if (oldRect && !((_a = this.animationRect) === null || _a === void 0 ? void 0 : _a.equals(oldRect))) {\r\n                // Skip animations if the layout changed.\r\n                this.animationManager.skipCurrentBatch();\r\n            }\r\n            this.handleNoDataOverlay();\r\n            this.debug('Chart.performUpdate() - seriesRect', this.seriesRect);\r\n        });\r\n    }\r\n    performLayout() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.scene.root) {\r\n                this.scene.root.visible = true;\r\n            }\r\n            const { width, height } = this.scene;\r\n            let ctx = { shrinkRect: new BBox(0, 0, width, height) };\r\n            ctx = this.layoutService.dispatchPerformLayout('start-layout', ctx);\r\n            ctx = this.layoutService.dispatchPerformLayout('before-series', ctx);\r\n            return ctx.shrinkRect;\r\n        });\r\n    }\r\n    // x/y are local canvas coordinates in CSS pixels, not actual pixels\r\n    pickSeriesNode(point, exactMatchOnly, maxDistance) {\r\n        var _a, _b;\r\n        const start = performance.now();\r\n        // Disable 'nearest match' options if looking for exact matches only\r\n        const pickModes = exactMatchOnly ? [SeriesNodePickMode.EXACT_SHAPE_MATCH] : undefined;\r\n        // Iterate through series in reverse, as later declared series appears on top of earlier\r\n        // declared series.\r\n        const reverseSeries = [...this.series].reverse();\r\n        let result;\r\n        for (const series of reverseSeries) {\r\n            if (!series.visible || !series.rootGroup.visible) {\r\n                continue;\r\n            }\r\n            const { match, distance } = (_a = series.pickNode(point, pickModes)) !== null && _a !== void 0 ? _a : {};\r\n            if (!match || distance == null) {\r\n                continue;\r\n            }\r\n            if ((!result || result.distance > distance) && distance <= (maxDistance !== null && maxDistance !== void 0 ? maxDistance : Infinity)) {\r\n                result = { series, distance, datum: match };\r\n            }\r\n            if (distance === 0) {\r\n                break;\r\n            }\r\n        }\r\n        this.extraDebugStats['pickSeriesNode'] = Math.round(((_b = this.extraDebugStats['pickSeriesNode']) !== null && _b !== void 0 ? _b : 0) + (performance.now() - start));\r\n        return result;\r\n    }\r\n    onMouseMove(event) {\r\n        this.lastInteractionEvent = event;\r\n        this.pointerScheduler.schedule();\r\n        this.extraDebugStats['mouseX'] = event.offsetX;\r\n        this.extraDebugStats['mouseY'] = event.offsetY;\r\n        this.update(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    onLeave(event) {\r\n        if (this.tooltip.pointerLeftOntoTooltip(event)) {\r\n            return;\r\n        }\r\n        this.disablePointer();\r\n    }\r\n    handlePointer(event) {\r\n        const { lastPick, hoverRect } = this;\r\n        const { offsetX, offsetY } = event;\r\n        const disablePointer = (highlightOnly = false) => {\r\n            if (lastPick) {\r\n                // Cursor moved from a non-marker node to empty space.\r\n                this.disablePointer(highlightOnly);\r\n            }\r\n        };\r\n        if (!(hoverRect === null || hoverRect === void 0 ? void 0 : hoverRect.containsPoint(offsetX, offsetY))) {\r\n            disablePointer();\r\n            return;\r\n        }\r\n        // Handle node highlighting and tooltip toggling when pointer within `tooltip.range`\r\n        this.handlePointerTooltip(event, disablePointer);\r\n        // Handle node highlighting and mouse cursor when pointer withing `series[].nodeClickRange`\r\n        this.handlePointerNode(event);\r\n    }\r\n    handlePointerTooltip(event, disablePointer) {\r\n        const { lastPick, tooltip } = this;\r\n        const { range } = tooltip;\r\n        const { offsetX, offsetY } = event;\r\n        let pixelRange;\r\n        if (typeof range === 'number' && Number.isFinite(range)) {\r\n            pixelRange = range;\r\n        }\r\n        const pick = this.pickSeriesNode({ x: offsetX, y: offsetY }, range === 'exact', pixelRange);\r\n        if (!pick) {\r\n            this.tooltipManager.removeTooltip(this.id);\r\n            if (this.highlight.range === 'tooltip')\r\n                disablePointer(true);\r\n            return;\r\n        }\r\n        const isNewDatum = this.highlight.range === 'node' || !lastPick || lastPick.datum !== pick.datum;\r\n        let html;\r\n        if (isNewDatum) {\r\n            html = pick.series.getTooltipHtml(pick.datum);\r\n            if (this.highlight.range === 'tooltip') {\r\n                this.highlightManager.updateHighlight(this.id, pick.datum);\r\n            }\r\n        }\r\n        else if (lastPick) {\r\n            lastPick.event = event.sourceEvent;\r\n        }\r\n        const isPixelRange = pixelRange != null;\r\n        const tooltipEnabled = this.tooltip.enabled && pick.series.tooltip.enabled;\r\n        const exactlyMatched = range === 'exact' && pick.distance === 0;\r\n        const rangeMatched = range === 'nearest' || isPixelRange || exactlyMatched;\r\n        const shouldUpdateTooltip = tooltipEnabled && rangeMatched && (!isNewDatum || html !== undefined);\r\n        const meta = TooltipManager.makeTooltipMeta(event, this.scene.canvas, pick.datum, this.specialOverrides.window);\r\n        if (shouldUpdateTooltip) {\r\n            this.tooltipManager.updateTooltip(this.id, meta, html);\r\n        }\r\n    }\r\n    handlePointerNode(event) {\r\n        const found = this.checkSeriesNodeRange(event, (series, datum) => {\r\n            if (series.hasEventListener('nodeClick') || series.hasEventListener('nodeDoubleClick')) {\r\n                this.cursorManager.updateCursor('chart', 'pointer');\r\n            }\r\n            if (this.highlight.range === 'node') {\r\n                this.highlightManager.updateHighlight(this.id, datum);\r\n            }\r\n        });\r\n        if (!found) {\r\n            this.cursorManager.updateCursor('chart');\r\n            if (this.highlight.range === 'node') {\r\n                this.highlightManager.updateHighlight(this.id);\r\n            }\r\n        }\r\n    }\r\n    onClick(event) {\r\n        if (this.checkSeriesNodeClick(event)) {\r\n            this.update(ChartUpdateType.SERIES_UPDATE);\r\n            return;\r\n        }\r\n        this.fireEvent({\r\n            type: 'click',\r\n            event: event.sourceEvent,\r\n        });\r\n    }\r\n    onDoubleClick(event) {\r\n        if (this.checkSeriesNodeDoubleClick(event)) {\r\n            this.update(ChartUpdateType.SERIES_UPDATE);\r\n            return;\r\n        }\r\n        this.fireEvent({\r\n            type: 'doubleClick',\r\n            event: event.sourceEvent,\r\n        });\r\n    }\r\n    checkSeriesNodeClick(event) {\r\n        return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeClickEvent(event.sourceEvent, datum));\r\n    }\r\n    checkSeriesNodeDoubleClick(event) {\r\n        return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeDoubleClickEvent(event.sourceEvent, datum));\r\n    }\r\n    checkSeriesNodeRange(event, callback) {\r\n        const nearestNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false);\r\n        const datum = nearestNode === null || nearestNode === void 0 ? void 0 : nearestNode.datum;\r\n        const nodeClickRange = datum === null || datum === void 0 ? void 0 : datum.series.nodeClickRange;\r\n        let pixelRange;\r\n        if (typeof nodeClickRange === 'number' && Number.isFinite(nodeClickRange)) {\r\n            pixelRange = nodeClickRange;\r\n        }\r\n        // Find the node if exactly matched and update the highlight picked node\r\n        let pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, true);\r\n        if (pickedNode) {\r\n            this.highlightManager.updatePicked(this.id, pickedNode.datum);\r\n        }\r\n        else {\r\n            this.highlightManager.updatePicked(this.id);\r\n        }\r\n        // First check if we should trigger the callback based on nearest node\r\n        if (datum && nodeClickRange === 'nearest') {\r\n            callback(datum.series, datum);\r\n            return true;\r\n        }\r\n        if (nodeClickRange !== 'exact') {\r\n            pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false, pixelRange);\r\n        }\r\n        if (!pickedNode)\r\n            return false;\r\n        // Then if we've picked a node within the pixel range, or exactly, trigger the callback\r\n        const isPixelRange = pixelRange != null;\r\n        const exactlyMatched = nodeClickRange === 'exact' && pickedNode.distance === 0;\r\n        if (isPixelRange || exactlyMatched) {\r\n            callback(pickedNode.series, pickedNode.datum);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    changeHighlightDatum(event) {\r\n        var _a, _b;\r\n        const seriesToUpdate = new Set();\r\n        const { series: newSeries = undefined, datum: newDatum } = (_a = event.currentHighlight) !== null && _a !== void 0 ? _a : {};\r\n        const { series: lastSeries = undefined, datum: lastDatum } = (_b = event.previousHighlight) !== null && _b !== void 0 ? _b : {};\r\n        if (lastSeries) {\r\n            seriesToUpdate.add(lastSeries);\r\n        }\r\n        if (newSeries) {\r\n            seriesToUpdate.add(newSeries);\r\n        }\r\n        // Adjust cursor if a specific datum is highlighted, rather than just a series.\r\n        if ((lastSeries === null || lastSeries === void 0 ? void 0 : lastSeries.cursor) && lastDatum) {\r\n            this.cursorManager.updateCursor(lastSeries.id);\r\n        }\r\n        if ((newSeries === null || newSeries === void 0 ? void 0 : newSeries.cursor) && newDatum) {\r\n            this.cursorManager.updateCursor(newSeries.id, newSeries.cursor);\r\n        }\r\n        this.lastPick = event.currentHighlight ? { datum: event.currentHighlight } : undefined;\r\n        const updateAll = newSeries == null || lastSeries == null;\r\n        if (updateAll) {\r\n            this.update(ChartUpdateType.SERIES_UPDATE);\r\n        }\r\n        else {\r\n            this.update(ChartUpdateType.SERIES_UPDATE, { seriesToUpdate });\r\n        }\r\n    }\r\n    waitForUpdate(timeoutMs = 5000) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const start = performance.now();\r\n            if (this._pendingFactoryUpdatesCount > 0) {\r\n                // Await until any pending updates are flushed through.\r\n                yield this.updateMutex.waitForClearAcquireQueue();\r\n            }\r\n            while (this._performUpdateType !== ChartUpdateType.NONE) {\r\n                if (performance.now() - start > timeoutMs) {\r\n                    throw new Error('waitForUpdate() timeout reached.');\r\n                }\r\n                yield sleep(5);\r\n            }\r\n            // Await until any remaining updates are flushed through.\r\n            yield this.updateMutex.waitForClearAcquireQueue();\r\n        });\r\n    }\r\n    handleNoDataOverlay() {\r\n        const shouldDisplayNoDataOverlay = !this.series.some((s) => s.hasData());\r\n        if (shouldDisplayNoDataOverlay && this.seriesRect) {\r\n            this.overlays.noData.show(this.seriesRect);\r\n        }\r\n        else {\r\n            this.overlays.noData.hide();\r\n        }\r\n    }\r\n    getMinRect() {\r\n        const minRects = this.series.map((series) => series.getMinRect()).filter((rect) => rect !== undefined);\r\n        if (!minRects.length)\r\n            return undefined;\r\n        return new BBox(0, 0, minRects.reduce((max, rect) => Math.max(max, rect.width), 0), minRects.reduce((max, rect) => Math.max(max, rect.height), 0));\r\n    }\r\n}\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            if (this.destroyed)\r\n                return;\r\n            value.appendChild(this.element);\r\n        },\r\n        oldValue(value) {\r\n            value.removeChild(this.element);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], Chart.prototype, \"container\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.series) === null || _a === void 0 ? void 0 : _a.forEach((series) => {\r\n                series.setChartData(value);\r\n            });\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], Chart.prototype, \"data\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            this.resize(value, undefined, 'width option');\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Chart.prototype, \"width\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            this.resize(undefined, value, 'height option');\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Chart.prototype, \"height\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue(value) {\r\n            this.autoSizeChanged(value);\r\n        },\r\n    }),\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Chart.prototype, \"autoSize\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\r\n        },\r\n        oldValue(oldValue) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Function)\r\n], Chart.prototype, \"title\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\r\n        },\r\n        oldValue(oldValue) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Function)\r\n], Chart.prototype, \"subtitle\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\r\n        },\r\n        oldValue(oldValue) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Function)\r\n], Chart.prototype, \"footnote\", void 0);\r\n__decorate([\r\n    Validate(STRING_UNION('standalone', 'integrated')),\r\n    __metadata(\"design:type\", String)\r\n], Chart.prototype, \"mode\", void 0);\n\nvar ArcType;\r\n(function (ArcType) {\r\n    ArcType[ArcType[\"Open\"] = 0] = \"Open\";\r\n    ArcType[ArcType[\"Chord\"] = 1] = \"Chord\";\r\n    ArcType[ArcType[\"Round\"] = 2] = \"Round\";\r\n})(ArcType || (ArcType = {}));\r\n/**\r\n * Elliptical arc node.\r\n */\r\nclass Arc extends Path {\r\n    constructor() {\r\n        super();\r\n        this.centerX = 0;\r\n        this.centerY = 0;\r\n        this.radius = 10;\r\n        this.startAngle = 0;\r\n        this.endAngle = Math.PI * 2;\r\n        this.counterClockwise = false;\r\n        /**\r\n         * The type of arc to render:\r\n         * - {@link ArcType.Open} - end points of the arc segment are not connected (default)\r\n         * - {@link ArcType.Chord} - end points of the arc segment are connected by a line segment\r\n         * - {@link ArcType.Round} - each of the end points of the arc segment are connected\r\n         *                           to the center of the arc\r\n         * Arcs with {@link ArcType.Open} do not support hit testing, even if they have their\r\n         * {@link Shape.fillStyle} set, because they are not closed paths. Hit testing support\r\n         * would require using two paths - one for rendering, another for hit testing - and there\r\n         * doesn't seem to be a compelling reason to do that, when one can just use {@link ArcType.Chord}\r\n         * to create a closed path.\r\n         */\r\n        this.type = ArcType.Open;\r\n        this.restoreOwnStyles();\r\n    }\r\n    get fullPie() {\r\n        return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\r\n    }\r\n    updatePath() {\r\n        const path = this.path;\r\n        path.clear(); // No need to recreate the Path, can simply clear the existing one.\r\n        path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\r\n        if (this.type === ArcType.Chord) {\r\n            path.closePath();\r\n        }\r\n        else if (this.type === ArcType.Round && !this.fullPie) {\r\n            path.lineTo(this.centerX, this.centerY);\r\n            path.closePath();\r\n        }\r\n    }\r\n    computeBBox() {\r\n        // Only works with full arcs (circles) and untransformed ellipses.\r\n        return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return (this.type !== ArcType.Open &&\r\n            bbox.containsPoint(point.x, point.y) &&\r\n            this.path.isPointInPath(point.x, point.y));\r\n    }\r\n}\r\nArc.className = 'Arc';\r\nArc.defaultStyles = Object.assign({}, Shape.defaultStyles, {\r\n    lineWidth: 1,\r\n    fillStyle: null,\r\n});\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"centerX\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"centerY\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"radius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"startAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"endAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Boolean)\r\n], Arc.prototype, \"counterClockwise\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"type\", void 0);\n\nconst convertColorStringToHsla = (v) => {\r\n    const color = Color.fromString(v);\r\n    const [h, s, l] = Color.RGBtoHSL(color.r, color.g, color.b);\r\n    return { h, s, l, a: color.a };\r\n};\r\nconst interpolateHsla = (x, y, d) => {\r\n    d = Math.min(Math.max(d, 0), 1);\r\n    let h;\r\n    let s;\r\n    if (Number.isNaN(x.h) && Number.isNaN(y.h)) {\r\n        h = 0;\r\n        s = 0;\r\n    }\r\n    else if (Number.isNaN(x.h)) {\r\n        h = y.h;\r\n        s = y.s;\r\n    }\r\n    else if (Number.isNaN(y.h)) {\r\n        h = x.h;\r\n        s = x.s;\r\n    }\r\n    else {\r\n        const xH = x.h;\r\n        let yH = y.h;\r\n        const deltaH = y.h - x.h;\r\n        if (deltaH > 180) {\r\n            yH -= 360;\r\n        }\r\n        else if (deltaH < -180) {\r\n            yH += 360;\r\n        }\r\n        h = xH * (1 - d) + yH * d;\r\n        s = x.s * (1 - d) + y.s * d;\r\n    }\r\n    const l = x.l * (1 - d) + y.l * d;\r\n    const a = x.a * (1 - d) + y.a * d;\r\n    return Color.fromHSL(h, s, l, a);\r\n};\r\nclass ColorScale {\r\n    constructor() {\r\n        this.domain = [0, 1];\r\n        this.range = ['red', 'blue'];\r\n        this.parsedRange = this.range.map(convertColorStringToHsla);\r\n    }\r\n    update() {\r\n        const { domain, range } = this;\r\n        if (domain.length < 2) {\r\n            Logger.warnOnce('`colorDomain` should have at least 2 values.');\r\n            if (domain.length === 0) {\r\n                domain.push(0, 1);\r\n            }\r\n            else if (domain.length === 1) {\r\n                domain.push(domain[0] + 1);\r\n            }\r\n        }\r\n        for (let i = 1; i < domain.length; i++) {\r\n            const a = domain[i - 1];\r\n            const b = domain[i];\r\n            if (a >= b) {\r\n                Logger.warnOnce('`colorDomain` values should be supplied in ascending order.');\r\n                domain.sort((a, b) => a - b);\r\n                break;\r\n            }\r\n        }\r\n        if (range.length < domain.length) {\r\n            for (let i = range.length; i < domain.length; i++) {\r\n                range.push(range.length > 0 ? range[0] : 'black');\r\n            }\r\n        }\r\n        this.parsedRange = this.range.map(convertColorStringToHsla);\r\n    }\r\n    convert(x) {\r\n        const { domain, range, parsedRange } = this;\r\n        const d0 = domain[0];\r\n        const d1 = domain[domain.length - 1];\r\n        const r0 = range[0];\r\n        const r1 = range[range.length - 1];\r\n        if (x <= d0) {\r\n            return r0;\r\n        }\r\n        if (x >= d1) {\r\n            return r1;\r\n        }\r\n        let index;\r\n        let q;\r\n        if (domain.length === 2) {\r\n            const t = (x - d0) / (d1 - d0);\r\n            const step = 1 / (range.length - 1);\r\n            index = range.length <= 2 ? 0 : Math.min(Math.floor(t * (range.length - 1)), range.length - 2);\r\n            q = (t - index * step) / step;\r\n        }\r\n        else {\r\n            for (index = 0; index < domain.length - 2; index++) {\r\n                if (x < domain[index + 1]) {\r\n                    break;\r\n                }\r\n            }\r\n            const a = domain[index];\r\n            const b = domain[index + 1];\r\n            q = (x - a) / (b - a);\r\n        }\r\n        const c0 = parsedRange[index];\r\n        const c1 = parsedRange[index + 1];\r\n        return interpolateHsla(c0, c1, q).toRgbaString();\r\n    }\r\n}\n\nclass LinearGradientFill extends Shape {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.direction = 'to-right';\r\n        this.stops = undefined;\r\n        this._mask = undefined;\r\n    }\r\n    get mask() {\r\n        return this._mask;\r\n    }\r\n    set mask(newMask) {\r\n        if (this._mask != null) {\r\n            this.removeChild(this._mask);\r\n        }\r\n        if (newMask != null) {\r\n            this.appendChild(newMask);\r\n        }\r\n        this._mask = newMask;\r\n    }\r\n    isPointInPath(x, y) {\r\n        var _a, _b;\r\n        return (_b = (_a = this.mask) === null || _a === void 0 ? void 0 : _a.isPointInPath(x, y)) !== null && _b !== void 0 ? _b : false;\r\n    }\r\n    computeBBox() {\r\n        var _a;\r\n        return (_a = this.mask) === null || _a === void 0 ? void 0 : _a.computeBBox();\r\n    }\r\n    render(renderCtx) {\r\n        const { mask, stops } = this;\r\n        const { ctx, devicePixelRatio } = renderCtx;\r\n        const pixelLength = 1 / devicePixelRatio;\r\n        const maskBbox = mask === null || mask === void 0 ? void 0 : mask.computeTransformedBBox();\r\n        if (mask == null || stops == null || maskBbox == null)\r\n            return;\r\n        if (mask.dirtyPath) {\r\n            mask.updatePath();\r\n            mask.dirtyPath = false;\r\n        }\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        mask.path.draw(ctx);\r\n        ctx.clip();\r\n        ctx.resetTransform();\r\n        const x0 = Math.floor(maskBbox.x);\r\n        const x1 = Math.ceil(maskBbox.x + maskBbox.width);\r\n        const y0 = Math.floor(maskBbox.y);\r\n        const y1 = Math.ceil(maskBbox.y + maskBbox.height);\r\n        const colorScale = new ColorScale();\r\n        const [i0, i1] = this.direction === 'to-right' ? [x0, x1] : [y0, y1];\r\n        colorScale.domain = stops.map((_, index) => {\r\n            return i0 + ((i1 - i0) * index) / (stops.length - 1);\r\n        });\r\n        colorScale.range = stops;\r\n        colorScale.update();\r\n        if (this.direction === 'to-right') {\r\n            const height = y1 - y0;\r\n            for (let x = x0; x <= x1; x += pixelLength) {\r\n                ctx.fillStyle = colorScale.convert(x);\r\n                ctx.fillRect(x, y0, pixelLength, height);\r\n            }\r\n        }\r\n        else {\r\n            const width = x1 - x0;\r\n            for (let y = y0; y <= y1; y += pixelLength) {\r\n                ctx.fillStyle = colorScale.convert(y);\r\n                ctx.fillRect(x0, y, width, pixelLength);\r\n            }\r\n        }\r\n        ctx.restore();\r\n    }\r\n}\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], LinearGradientFill.prototype, \"direction\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Array)\r\n], LinearGradientFill.prototype, \"stops\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Function)\r\n], LinearGradientFill.prototype, \"_mask\", void 0);\n\nclass Rect extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.borderPath = new Path2D();\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.width = 10;\r\n        this.height = 10;\r\n        this.radius = 0;\r\n        /**\r\n         * If `true`, the rect is aligned to the pixel grid for crisp looking lines.\r\n         * Animated rects may not look nice with this option enabled, for example\r\n         * when a rect is translated by a sub-pixel value on each frame.\r\n         */\r\n        this.crisp = false;\r\n        this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\r\n        this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\r\n        /**\r\n         * When the rectangle's width or height is less than a pixel\r\n         * and crisp mode is on, the rectangle will still fit into the pixel,\r\n         * but will be less opaque to make an effect of holding less space.\r\n         */\r\n        this.microPixelEffectOpacity = 1;\r\n    }\r\n    isDirtyPath() {\r\n        var _a;\r\n        if (this.lastUpdatePathStrokeWidth !== this.strokeWidth) {\r\n            return true;\r\n        }\r\n        return !!(this.path.isDirty() || this.borderPath.isDirty() || ((_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.isDirty()));\r\n    }\r\n    updatePath() {\r\n        var _a, _b, _c;\r\n        const { path, borderPath, crisp } = this;\r\n        let { x, y, width: w, height: h, strokeWidth } = this;\r\n        const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;\r\n        const pixelSize = 1 / pixelRatio;\r\n        let microPixelEffectOpacity = 1;\r\n        path.clear({ trackChanges: true });\r\n        borderPath.clear({ trackChanges: true });\r\n        if (crisp) {\r\n            if (w <= pixelSize) {\r\n                microPixelEffectOpacity *= w / pixelSize;\r\n            }\r\n            if (h <= pixelSize) {\r\n                microPixelEffectOpacity *= h / pixelSize;\r\n            }\r\n            w = this.align(x, w);\r\n            h = this.align(y, h);\r\n            x = this.align(x);\r\n            y = this.align(y);\r\n        }\r\n        if (strokeWidth) {\r\n            if (w < pixelSize) {\r\n                // Too narrow, draw a vertical stroke\r\n                const lx = x + pixelSize / 2;\r\n                borderPath.moveTo(lx, y);\r\n                borderPath.lineTo(lx, y + h);\r\n                strokeWidth = pixelSize;\r\n                this.borderClipPath = undefined;\r\n            }\r\n            else if (h < pixelSize) {\r\n                // Too narrow, draw a horizontal stroke\r\n                const ly = y + pixelSize / 2;\r\n                borderPath.moveTo(x, ly);\r\n                borderPath.lineTo(x + w, ly);\r\n                strokeWidth = pixelSize;\r\n                this.borderClipPath = undefined;\r\n            }\r\n            else if (strokeWidth < w && strokeWidth < h) {\r\n                const halfStrokeWidth = strokeWidth / 2;\r\n                x += halfStrokeWidth;\r\n                y += halfStrokeWidth;\r\n                w -= strokeWidth;\r\n                h -= strokeWidth;\r\n                // Clipping not needed in this case; fill to center of stroke.\r\n                this.borderClipPath = undefined;\r\n                path.rect(x, y, w, h);\r\n                borderPath.rect(x, y, w, h);\r\n            }\r\n            else {\r\n                // Skip the fill and just render the stroke.\r\n                this.borderClipPath = (_c = this.borderClipPath) !== null && _c !== void 0 ? _c : new Path2D();\r\n                this.borderClipPath.clear({ trackChanges: true });\r\n                this.borderClipPath.rect(x, y, w, h);\r\n                borderPath.rect(x, y, w, h);\r\n            }\r\n        }\r\n        else {\r\n            // No borderPath needed, and thus no clipPath needed either. Fill to full extent of\r\n            // Rect.\r\n            this.borderClipPath = undefined;\r\n            path.rect(x, y, w, h);\r\n        }\r\n        this.effectiveStrokeWidth = strokeWidth;\r\n        this.lastUpdatePathStrokeWidth = strokeWidth;\r\n        this.microPixelEffectOpacity = microPixelEffectOpacity;\r\n    }\r\n    computeBBox() {\r\n        const { x, y, width, height } = this;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return bbox.containsPoint(point.x, point.y);\r\n    }\r\n    applyFillAlpha(ctx) {\r\n        const { fillOpacity, microPixelEffectOpacity, opacity } = this;\r\n        const { globalAlpha } = ctx;\r\n        ctx.globalAlpha = globalAlpha * opacity * fillOpacity * microPixelEffectOpacity;\r\n    }\r\n    renderStroke(ctx) {\r\n        const { stroke, effectiveStrokeWidth, borderPath, borderClipPath, opacity, microPixelEffectOpacity } = this;\r\n        const borderActive = !!stroke && !!effectiveStrokeWidth;\r\n        if (borderActive) {\r\n            const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\r\n            if (borderClipPath) {\r\n                // strokeWidth is larger than width or height, so use clipping to render correctly.\r\n                // This is the simplest way to achieve the correct rendering due to nuances with ~0\r\n                // width/height lines in Canvas operations.\r\n                borderClipPath.draw(ctx);\r\n                ctx.clip();\r\n            }\r\n            borderPath.draw(ctx);\r\n            const { globalAlpha } = ctx;\r\n            ctx.strokeStyle = stroke;\r\n            ctx.globalAlpha = globalAlpha * opacity * strokeOpacity * microPixelEffectOpacity;\r\n            ctx.lineWidth = effectiveStrokeWidth;\r\n            if (lineDash) {\r\n                ctx.setLineDash(lineDash);\r\n            }\r\n            if (lineDashOffset) {\r\n                ctx.lineDashOffset = lineDashOffset;\r\n            }\r\n            if (lineCap) {\r\n                ctx.lineCap = lineCap;\r\n            }\r\n            if (lineJoin) {\r\n                ctx.lineJoin = lineJoin;\r\n            }\r\n            ctx.stroke();\r\n            ctx.globalAlpha = globalAlpha;\r\n        }\r\n    }\r\n}\r\nRect.className = 'Rect';\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"x\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"y\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"width\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"height\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"radius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Boolean)\r\n], Rect.prototype, \"crisp\", void 0);\n\nclass Image extends Node {\r\n    constructor(sourceImage) {\r\n        super();\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.opacity = 1;\r\n        this.sourceImage = sourceImage;\r\n    }\r\n    render(renderCtx) {\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped++;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        const image = this.sourceImage;\r\n        ctx.globalAlpha = this.opacity;\r\n        ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\r\n        super.render(renderCtx);\r\n    }\r\n}\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"x\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"y\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"width\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"height\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"opacity\", void 0);\n\nconst motion = Object.assign(Object.assign({}, fromToMotion$1), resetMotion$1);\n\nvar integratedChartsScene = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    motion: motion,\n    Caption: Caption,\n    DropShadow: DropShadow,\n    Group: Group,\n    Scene: Scene,\n    Node: Node,\n    get PointerEvents () { return PointerEvents; },\n    get RedrawType () { return RedrawType; },\n    SceneChangeDetection: SceneChangeDetection,\n    Selection: Selection,\n    Arc: Arc,\n    Line: Line,\n    LinearGradientFill: LinearGradientFill,\n    Path: Path,\n    ScenePathChangeDetection: ScenePathChangeDetection,\n    Rect: Rect,\n    Sector: Sector,\n    Shape: Shape,\n    Text: Text,\n    getFont: getFont,\n    ContinuousScale: ContinuousScale,\n    BandScale: BandScale,\n    LinearScale: LinearScale,\n    toRadians: toRadians,\n    Label: Label,\n    Marker: Marker,\n    getMarker: getMarker,\n    Circle: Circle,\n    Diamond: Diamond,\n    Square: Square,\n    Triangle: Triangle,\n    Tooltip: Tooltip,\n    toTooltipHtml: toTooltipHtml,\n    BBox: BBox,\n    nearestSquared: nearestSquared,\n    nearestSquaredInContainer: nearestSquaredInContainer,\n    HdpiCanvas: HdpiCanvas,\n    Image: Image,\n    Path2D: Path2D,\n    easing: easing\n});\n\nconst DEFAULT_DIRECTION_KEYS = {\r\n    [ChartAxisDirection.X]: ['xKey'],\r\n    [ChartAxisDirection.Y]: ['yKey'],\r\n};\r\nconst DEFAULT_DIRECTION_NAMES = {\r\n    [ChartAxisDirection.X]: ['xName'],\r\n    [ChartAxisDirection.Y]: ['yName'],\r\n};\r\nclass CartesianSeriesNodeClickEvent extends SeriesNodeClickEvent {\r\n    constructor(type, nativeEvent, datum, series) {\r\n        super(type, nativeEvent, datum, series);\r\n        this.xKey = series.xKey;\r\n        this.yKey = series.yKey;\r\n    }\r\n}\r\nclass CartesianSeries extends DataModelSeries {\r\n    get contextNodeData() {\r\n        return this._contextNodeData.slice();\r\n    }\r\n    constructor(_a) {\r\n        var { pathsPerSeries = 1, hasMarkers = false, hasHighlightedLabels = false, pathsZIndexSubOrderOffset = [], directionKeys = DEFAULT_DIRECTION_KEYS, directionNames = DEFAULT_DIRECTION_NAMES, datumSelectionGarbageCollection = true, markerSelectionGarbageCollection = true, animationResetFns } = _a, otherOpts = __rest(_a, [\"pathsPerSeries\", \"hasMarkers\", \"hasHighlightedLabels\", \"pathsZIndexSubOrderOffset\", \"directionKeys\", \"directionNames\", \"datumSelectionGarbageCollection\", \"markerSelectionGarbageCollection\", \"animationResetFns\"]);\r\n        super(Object.assign({ directionKeys,\r\n            directionNames, useSeriesGroupLayer: true, canHaveAxes: true }, otherOpts));\r\n        this.legendItemName = undefined;\r\n        this._contextNodeData = [];\r\n        this.NodeClickEvent = CartesianSeriesNodeClickEvent;\r\n        this.highlightSelection = Selection.select(this.highlightNode, () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory());\r\n        this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\r\n        this.annotationSelections = new Set();\r\n        this.subGroups = [];\r\n        this.subGroupId = 0;\r\n        this.debug = Debug.create();\r\n        this.opts = {\r\n            pathsPerSeries,\r\n            hasMarkers,\r\n            hasHighlightedLabels,\r\n            pathsZIndexSubOrderOffset,\r\n            directionKeys,\r\n            directionNames,\r\n            animationResetFns,\r\n            datumSelectionGarbageCollection,\r\n            markerSelectionGarbageCollection,\r\n        };\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateEmptyUpdateReady(data),\r\n                },\r\n            },\r\n            ready: {\r\n                updateData: 'waiting',\r\n                clear: 'clearing',\r\n                highlight: (data) => this.animateReadyHighlight(data),\r\n                highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\r\n                resize: (data) => this.animateReadyResize(data),\r\n            },\r\n            waiting: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateWaitingUpdateReady(data),\r\n                },\r\n            },\r\n            clearing: {\r\n                update: {\r\n                    target: 'empty',\r\n                    action: (data) => this.animateClearingUpdateEmpty(data),\r\n                },\r\n            },\r\n        }, () => this.checkProcessedDataAnimatable());\r\n    }\r\n    addChartEventListeners() {\r\n        this.ctx.chartEventManager.addListener('legend-item-click', (event) => this.onLegendItemClick(event));\r\n        this.ctx.chartEventManager.addListener('legend-item-double-click', (event) => this.onLegendItemDoubleClick(event));\r\n    }\r\n    destroy() {\r\n        super.destroy();\r\n        this._contextNodeData.splice(0, this._contextNodeData.length);\r\n        this.subGroups.splice(0, this.subGroups.length);\r\n    }\r\n    update({ seriesRect }) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { visible, _contextNodeData: previousContextData } = this;\r\n            const { series } = (_b = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight()) !== null && _b !== void 0 ? _b : {};\r\n            const seriesHighlighted = series ? series === this : undefined;\r\n            const resize = this.checkResize(seriesRect);\r\n            const highlightItems = yield this.updateHighlightSelection(seriesHighlighted);\r\n            yield this.updateSelections(visible);\r\n            yield this.updateNodes(highlightItems, seriesHighlighted, visible);\r\n            const animationData = this.getAnimationData(seriesRect, previousContextData);\r\n            if (resize) {\r\n                this.animationState.transition('resize', animationData);\r\n            }\r\n            this.animationState.transition('update', animationData);\r\n        });\r\n    }\r\n    updateSelections(anySeriesItemEnabled) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!anySeriesItemEnabled && this.ctx.animationManager.isSkipped()) {\r\n                return;\r\n            }\r\n            if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\r\n                return;\r\n            }\r\n            if (this.nodeDataRefresh) {\r\n                this.nodeDataRefresh = false;\r\n                this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\r\n                this._contextNodeData = yield this.createNodeData();\r\n                const animationValid = this.isProcessedDataAnimatable();\r\n                this._contextNodeData.forEach((nodeData) => {\r\n                    var _a;\r\n                    (_a = nodeData.animationValid) !== null && _a !== void 0 ? _a : (nodeData.animationValid = animationValid);\r\n                });\r\n                yield this.updateSeriesGroups();\r\n                const { dataModel, processedData } = this;\r\n                if (dataModel !== undefined && processedData !== undefined) {\r\n                    this.dispatch('data-update', { dataModel, processedData });\r\n                }\r\n            }\r\n            yield Promise.all(this.subGroups.map((g, i) => this.updateSeriesGroupSelections(g, i)));\r\n        });\r\n    }\r\n    updateSeriesGroupSelections(subGroup, seriesIdx, seriesHighlighted) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { datumSelection, labelSelection, markerSelection, paths } = subGroup;\r\n            const contextData = this._contextNodeData[seriesIdx];\r\n            const { nodeData, labelData, itemId } = contextData;\r\n            yield this.updatePaths({ seriesHighlighted, itemId, contextData, paths, seriesIdx });\r\n            subGroup.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection, seriesIdx });\r\n            subGroup.labelSelection = yield this.updateLabelSelection({ labelData, labelSelection, seriesIdx });\r\n            if (markerSelection) {\r\n                subGroup.markerSelection = yield this.updateMarkerSelection({\r\n                    nodeData,\r\n                    markerSelection,\r\n                    seriesIdx,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    markerFactory() {\r\n        const MarkerShape = getMarker();\r\n        return new MarkerShape();\r\n    }\r\n    updateSeriesGroups() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { _contextNodeData: contextNodeData, contentGroup, subGroups, opts: { pathsPerSeries, hasMarkers, datumSelectionGarbageCollection, markerSelectionGarbageCollection }, } = this;\r\n            if (contextNodeData.length === subGroups.length) {\r\n                return;\r\n            }\r\n            if (contextNodeData.length < subGroups.length) {\r\n                subGroups.splice(contextNodeData.length).forEach(({ dataNodeGroup, markerGroup, labelGroup, paths }) => {\r\n                    contentGroup.removeChild(dataNodeGroup);\r\n                    if (markerGroup) {\r\n                        contentGroup.removeChild(markerGroup);\r\n                    }\r\n                    if (labelGroup) {\r\n                        contentGroup.removeChild(labelGroup);\r\n                    }\r\n                    for (const path of paths) {\r\n                        contentGroup.removeChild(path);\r\n                    }\r\n                });\r\n            }\r\n            const totalGroups = contextNodeData.length;\r\n            while (totalGroups > subGroups.length) {\r\n                const layer = false;\r\n                const subGroupId = this.subGroupId++;\r\n                const dataNodeGroup = new Group({\r\n                    name: `${this.id}-series-sub${subGroupId}-dataNodes`,\r\n                    layer,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: this.getGroupZIndexSubOrder('data', subGroupId),\r\n                });\r\n                const markerGroup = hasMarkers\r\n                    ? new Group({\r\n                        name: `${this.id}-series-sub${this.subGroupId++}-markers`,\r\n                        layer,\r\n                        zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                        zIndexSubOrder: this.getGroupZIndexSubOrder('marker', subGroupId),\r\n                    })\r\n                    : undefined;\r\n                const labelGroup = new Group({\r\n                    name: `${this.id}-series-sub${this.subGroupId++}-labels`,\r\n                    layer,\r\n                    zIndex: Layers.SERIES_LABEL_ZINDEX,\r\n                    zIndexSubOrder: this.getGroupZIndexSubOrder('labels', subGroupId),\r\n                });\r\n                contentGroup.appendChild(dataNodeGroup);\r\n                contentGroup.appendChild(labelGroup);\r\n                if (markerGroup) {\r\n                    contentGroup.appendChild(markerGroup);\r\n                }\r\n                const paths = [];\r\n                for (let index = 0; index < pathsPerSeries; index++) {\r\n                    paths[index] = new Path();\r\n                    paths[index].zIndex = Layers.SERIES_LAYER_ZINDEX;\r\n                    paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder('paths', index);\r\n                    contentGroup.appendChild(paths[index]);\r\n                }\r\n                subGroups.push({\r\n                    paths,\r\n                    dataNodeGroup,\r\n                    markerGroup,\r\n                    labelGroup,\r\n                    labelSelection: Selection.select(labelGroup, Text),\r\n                    datumSelection: Selection.select(dataNodeGroup, () => this.nodeFactory(), datumSelectionGarbageCollection),\r\n                    markerSelection: markerGroup\r\n                        ? Selection.select(markerGroup, () => this.markerFactory(), markerSelectionGarbageCollection)\r\n                        : undefined,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    getGroupZIndexSubOrder(type, subIndex = 0) {\r\n        var _a;\r\n        const result = super.getGroupZIndexSubOrder(type, subIndex);\r\n        if (type === 'paths') {\r\n            const pathOffset = (_a = this.opts.pathsZIndexSubOrderOffset[subIndex]) !== null && _a !== void 0 ? _a : 0;\r\n            const superFn = result[0];\r\n            if (typeof superFn === 'function') {\r\n                result[0] = () => +superFn() + pathOffset;\r\n            }\r\n            else {\r\n                result[0] = +superFn + pathOffset;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { highlightSelection, highlightLabelSelection, opts: { hasMarkers, hasHighlightedLabels }, } = this;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const visible = this.visible && ((_a = this._contextNodeData) === null || _a === void 0 ? void 0 : _a.length) > 0 && anySeriesItemEnabled;\r\n            this.rootGroup.visible = animationEnabled || visible;\r\n            this.contentGroup.visible = animationEnabled || visible;\r\n            this.highlightGroup.visible = (animationEnabled || visible) && !!seriesHighlighted;\r\n            const subGroupOpacity = this.getOpacity();\r\n            if (hasMarkers) {\r\n                yield this.updateMarkerNodes({\r\n                    markerSelection: highlightSelection,\r\n                    isHighlight: true,\r\n                    seriesIdx: -1,\r\n                });\r\n                this.animationState.transition('highlightMarkers', highlightSelection);\r\n            }\r\n            else {\r\n                yield this.updateDatumNodes({\r\n                    datumSelection: highlightSelection,\r\n                    isHighlight: true,\r\n                    seriesIdx: -1,\r\n                });\r\n                this.animationState.transition('highlight', highlightSelection);\r\n            }\r\n            if (hasHighlightedLabels) {\r\n                yield this.updateLabelNodes({ labelSelection: highlightLabelSelection, seriesIdx: -1 });\r\n            }\r\n            yield Promise.all(this.subGroups.map((subGroup, seriesIdx) => __awaiter(this, void 0, void 0, function* () {\r\n                const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup, } = subGroup;\r\n                const { itemId } = this.contextNodeData[seriesIdx];\r\n                const subGroupVisible = visible;\r\n                dataNodeGroup.opacity = subGroupOpacity;\r\n                dataNodeGroup.visible = animationEnabled || subGroupVisible;\r\n                labelGroup.visible = subGroupVisible;\r\n                if (markerGroup) {\r\n                    markerGroup.opacity = subGroupOpacity;\r\n                    markerGroup.zIndex =\r\n                        dataNodeGroup.zIndex >= Layers.SERIES_LAYER_ZINDEX\r\n                            ? dataNodeGroup.zIndex\r\n                            : dataNodeGroup.zIndex + 1;\r\n                    markerGroup.visible = subGroupVisible;\r\n                }\r\n                if (labelGroup) {\r\n                    labelGroup.opacity = subGroupOpacity;\r\n                }\r\n                yield this.updatePathNodes({\r\n                    seriesHighlighted,\r\n                    itemId,\r\n                    paths,\r\n                    seriesIdx,\r\n                    opacity: subGroupOpacity,\r\n                    visible: subGroupVisible,\r\n                    animationEnabled,\r\n                });\r\n                if (!dataNodeGroup.visible) {\r\n                    return;\r\n                }\r\n                yield this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false, seriesIdx });\r\n                yield this.updateLabelNodes({ labelSelection, seriesIdx });\r\n                if (hasMarkers && markerSelection) {\r\n                    yield this.updateMarkerNodes({ markerSelection, isHighlight: false, seriesIdx });\r\n                }\r\n            })));\r\n        });\r\n    }\r\n    getHighlightLabelData(labelData, highlightedItem) {\r\n        const labelItem = labelData.find((ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId);\r\n        return labelItem ? [labelItem] : undefined;\r\n    }\r\n    getHighlightData(_nodeData, highlightedItem) {\r\n        return highlightedItem ? [highlightedItem] : undefined;\r\n    }\r\n    updateHighlightSelection(seriesHighlighted) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\r\n            const highlightedDatum = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();\r\n            const item = seriesHighlighted && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.datum) ? highlightedDatum : undefined;\r\n            let labelItems;\r\n            let highlightItems;\r\n            if (item != null) {\r\n                const labelsEnabled = this.isLabelEnabled();\r\n                for (const { labelData, nodeData } of contextNodeData) {\r\n                    highlightItems = this.getHighlightData(nodeData, item);\r\n                    labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : undefined;\r\n                    if ((!labelsEnabled || labelItems != null) && highlightItems != null) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            this.highlightSelection = yield this.updateHighlightSelectionItem({\r\n                items: highlightItems,\r\n                highlightSelection,\r\n            });\r\n            this.highlightLabelSelection = yield this.updateHighlightSelectionLabel({\r\n                items: labelItems,\r\n                highlightLabelSelection,\r\n            });\r\n            return highlightItems;\r\n        });\r\n    }\r\n    pickNodeExactShape(point) {\r\n        var _a;\r\n        const result = super.pickNodeExactShape(point);\r\n        if (result) {\r\n            return result;\r\n        }\r\n        const { x, y } = point;\r\n        const { opts: { hasMarkers }, } = this;\r\n        for (const { dataNodeGroup, markerGroup } of this.subGroups) {\r\n            let match = dataNodeGroup.pickNode(x, y);\r\n            if (!match && hasMarkers) {\r\n                match = markerGroup === null || markerGroup === void 0 ? void 0 : markerGroup.pickNode(x, y);\r\n            }\r\n            if (match) {\r\n                break;\r\n            }\r\n        }\r\n        {\r\n            for (const mod of this.moduleMap) {\r\n                const { datum } = (_a = mod.pickNodeExact(point)) !== null && _a !== void 0 ? _a : {};\r\n                if (datum !== undefined) {\r\n                    return { datum, distance: 0 };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    pickNodeClosestDatum(point) {\r\n        var _a, _b;\r\n        const { x, y } = point;\r\n        const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        const hitPoint = rootGroup.transformPoint(x, y);\r\n        let minDistance = Infinity;\r\n        let closestDatum;\r\n        for (const context of contextNodeData) {\r\n            for (const datum of context.nodeData) {\r\n                const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\r\n                if (isNaN(datumX) || isNaN(datumY)) {\r\n                    continue;\r\n                }\r\n                const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));\r\n                if (!isInRange) {\r\n                    continue;\r\n                }\r\n                // No need to use Math.sqrt() since x < y implies Math.sqrt(x) < Math.sqrt(y) for\r\n                // values > 1\r\n                const distance = Math.max(Math.pow((hitPoint.x - datumX), 2) + Math.pow((hitPoint.y - datumY), 2), 0);\r\n                if (distance < minDistance) {\r\n                    minDistance = distance;\r\n                    closestDatum = datum;\r\n                }\r\n            }\r\n        }\r\n        for (const mod of this.moduleMap) {\r\n            const modPick = mod.pickNodeNearest(point);\r\n            if (modPick !== undefined && modPick.distanceSquared < minDistance) {\r\n                minDistance = modPick.distanceSquared;\r\n                closestDatum = modPick.datum;\r\n                break;\r\n            }\r\n        }\r\n        if (closestDatum) {\r\n            const distance = Math.max(Math.sqrt(minDistance) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);\r\n            return { datum: closestDatum, distance };\r\n        }\r\n    }\r\n    pickNodeMainAxisFirst(point, requireCategoryAxis) {\r\n        var _a, _b;\r\n        const { x, y } = point;\r\n        const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        // Prefer to start search with any available category axis.\r\n        const directions = [xAxis, yAxis]\r\n            .filter((a) => a instanceof CategoryAxis)\r\n            .map((a) => a.direction);\r\n        if (requireCategoryAxis && directions.length === 0) {\r\n            return;\r\n        }\r\n        // Default to X-axis unless we found a suitable category axis.\r\n        const [primaryDirection = ChartAxisDirection.X] = directions;\r\n        const hitPoint = rootGroup.transformPoint(x, y);\r\n        const hitPointCoords = primaryDirection === ChartAxisDirection.X ? [hitPoint.x, hitPoint.y] : [hitPoint.y, hitPoint.x];\r\n        const minDistance = [Infinity, Infinity];\r\n        let closestDatum;\r\n        for (const context of contextNodeData) {\r\n            for (const datum of context.nodeData) {\r\n                const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\r\n                if (isNaN(datumX) || isNaN(datumY)) {\r\n                    continue;\r\n                }\r\n                const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));\r\n                if (!isInRange) {\r\n                    continue;\r\n                }\r\n                const point = primaryDirection === ChartAxisDirection.X ? [datumX, datumY] : [datumY, datumX];\r\n                // Compare distances from most significant dimension to least.\r\n                let newMinDistance = true;\r\n                for (let i = 0; i < point.length; i++) {\r\n                    const dist = Math.abs(point[i] - hitPointCoords[i]);\r\n                    if (dist > minDistance[i]) {\r\n                        newMinDistance = false;\r\n                        break;\r\n                    }\r\n                    if (dist < minDistance[i]) {\r\n                        minDistance[i] = dist;\r\n                        minDistance.fill(Infinity, i + 1, minDistance.length);\r\n                    }\r\n                }\r\n                if (newMinDistance) {\r\n                    closestDatum = datum;\r\n                }\r\n            }\r\n        }\r\n        if (closestDatum) {\r\n            let closestDistanceSquared = Math.max(Math.pow(minDistance[0], 2) + Math.pow(minDistance[1], 2) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);\r\n            for (const mod of this.moduleMap) {\r\n                const modPick = mod.pickNodeMainAxisFirst(point);\r\n                if (modPick !== undefined && modPick.distanceSquared < closestDistanceSquared) {\r\n                    closestDatum = modPick.datum;\r\n                    closestDistanceSquared = modPick.distanceSquared;\r\n                    break;\r\n                }\r\n            }\r\n            return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\r\n        }\r\n    }\r\n    onLegendItemClick(event) {\r\n        const { enabled, itemId, series, legendItemName } = event;\r\n        const matchedLegendItemName = this.legendItemName != null && this.legendItemName === legendItemName;\r\n        if (series.id === this.id || matchedLegendItemName) {\r\n            this.toggleSeriesItem(itemId, enabled);\r\n        }\r\n    }\r\n    onLegendItemDoubleClick(event) {\r\n        const { enabled, itemId, series, numVisibleItems, legendItemName } = event;\r\n        const totalVisibleItems = Object.values(numVisibleItems).reduce((p, v) => p + v, 0);\r\n        const matchedLegendItemName = this.legendItemName != null && this.legendItemName === legendItemName;\r\n        if (series.id === this.id || matchedLegendItemName) {\r\n            // Double-clicked item should always become visible.\r\n            this.toggleSeriesItem(itemId, true);\r\n        }\r\n        else if (enabled && totalVisibleItems === 1) {\r\n            // Other items should become visible if there is only one existing visible item.\r\n            this.toggleSeriesItem(itemId, true);\r\n        }\r\n        else {\r\n            // Disable other items if not exactly one enabled.\r\n            this.toggleSeriesItem(itemId, false);\r\n        }\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        // Override point to allow more sophisticated dirty selection detection.\r\n        return false;\r\n    }\r\n    getLabelData() {\r\n        return [];\r\n    }\r\n    shouldFlipXY() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\r\n     * may not represent the same two points for both directions. The dimensions represent the greatest distance\r\n     * between any two adjacent nodes.\r\n     */\r\n    getMinRect() {\r\n        const [context] = this._contextNodeData;\r\n        if (!context || context.nodeData.length == 0)\r\n            return;\r\n        const width = context.nodeData\r\n            .map(({ midPoint }) => { var _a; return (_a = midPoint === null || midPoint === void 0 ? void 0 : midPoint.x) !== null && _a !== void 0 ? _a : 0; })\r\n            .sort((a, b) => a - b)\r\n            .reduce((max, x, i, array) => (i > 0 ? Math.max(max, x - array[i - 1]) : max), 0);\r\n        const height = context.nodeData\r\n            .map(({ midPoint }) => { var _a; return (_a = midPoint === null || midPoint === void 0 ? void 0 : midPoint.y) !== null && _a !== void 0 ? _a : 0; })\r\n            .sort((a, b) => a - b)\r\n            .reduce((max, y, i, array) => (i > 0 ? Math.max(max, y - array[i - 1]) : max), 0);\r\n        return new BBox(0, 0, width, height);\r\n    }\r\n    updateHighlightSelectionItem(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { opts: { hasMarkers }, } = this;\r\n            const { items, highlightSelection } = opts;\r\n            const nodeData = items !== null && items !== void 0 ? items : [];\r\n            if (hasMarkers) {\r\n                const markerSelection = highlightSelection;\r\n                return this.updateMarkerSelection({ nodeData, markerSelection, seriesIdx: -1 });\r\n            }\r\n            else {\r\n                return this.updateDatumSelection({\r\n                    nodeData,\r\n                    datumSelection: highlightSelection,\r\n                    seriesIdx: -1,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    updateHighlightSelectionLabel(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { items, highlightLabelSelection } = opts;\r\n            const labelData = items !== null && items !== void 0 ? items : [];\r\n            return this.updateLabelSelection({ labelData, labelSelection: highlightLabelSelection, seriesIdx: -1 });\r\n        });\r\n    }\r\n    updateDatumSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n            return opts.datumSelection;\r\n        });\r\n    }\r\n    updateDatumNodes(_opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n        });\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n            return opts.markerSelection;\r\n        });\r\n    }\r\n    updateMarkerNodes(_opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n        });\r\n    }\r\n    updatePaths(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n            opts.paths.forEach((p) => (p.visible = false));\r\n        });\r\n    }\r\n    updatePathNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { paths, opacity, visible } = opts;\r\n            for (const path of paths) {\r\n                path.opacity = opacity;\r\n                path.visible = visible;\r\n            }\r\n        });\r\n    }\r\n    resetAllAnimation(data) {\r\n        var _a, _b;\r\n        const { path, datum, label, marker } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\r\n        // Stop any running animations by prefix convention.\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        if (path) {\r\n            data.paths.forEach((paths) => {\r\n                resetMotion(paths, path);\r\n            });\r\n        }\r\n        if (datum) {\r\n            resetMotion(data.datumSelections, datum);\r\n        }\r\n        if (label) {\r\n            resetMotion(data.labelSelections, label);\r\n        }\r\n        if (marker) {\r\n            resetMotion(data.markerSelections, marker);\r\n        }\r\n        if (data.contextData.some((d) => d.animationValid === false)) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n    }\r\n    animateEmptyUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateReadyHighlight(data) {\r\n        var _a, _b;\r\n        const { datum } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\r\n        if (datum) {\r\n            resetMotion([data], datum);\r\n        }\r\n    }\r\n    animateReadyHighlightMarkers(data) {\r\n        var _a, _b;\r\n        const { marker } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\r\n        if (marker) {\r\n            resetMotion([data], marker);\r\n        }\r\n    }\r\n    animateReadyResize(data) {\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateClearingUpdateEmpty(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animationTransitionClear() {\r\n        this.animationState.transition('clear', this.getAnimationData());\r\n    }\r\n    getAnimationData(seriesRect, previousContextData) {\r\n        const animationData = {\r\n            datumSelections: this.subGroups.map(({ datumSelection }) => datumSelection),\r\n            markerSelections: this.subGroups\r\n                .filter(({ markerSelection }) => markerSelection !== undefined)\r\n                .map(({ markerSelection }) => markerSelection),\r\n            labelSelections: this.subGroups.map(({ labelSelection }) => labelSelection),\r\n            annotationSelections: [...this.annotationSelections],\r\n            contextData: this._contextNodeData,\r\n            previousContextData,\r\n            paths: this.subGroups.map(({ paths }) => paths),\r\n            seriesRect,\r\n        };\r\n        return animationData;\r\n    }\r\n    calculateScaling() {\r\n        const result = {};\r\n        const addScale = (direction) => {\r\n            const axis = this.axes[direction];\r\n            if (!axis)\r\n                return;\r\n            if (axis.scale instanceof LogScale) {\r\n                const { range, domain } = axis.scale;\r\n                result[direction] = {\r\n                    type: 'log',\r\n                    convert: (domain) => axis.scale.convert(domain),\r\n                    domain: [domain[0], domain[1]],\r\n                    range: [range[0], range[1]],\r\n                };\r\n            }\r\n            else if (axis.scale instanceof ContinuousScale) {\r\n                const { range } = axis.scale;\r\n                const domain = axis.scale.getDomain();\r\n                result[direction] = {\r\n                    type: 'continuous',\r\n                    domain: [domain[0], domain[1]],\r\n                    range: [range[0], range[1]],\r\n                };\r\n            }\r\n            else if (axis.scale) {\r\n                const { domain } = axis.scale;\r\n                result[direction] = {\r\n                    type: 'category',\r\n                    domain,\r\n                    range: domain.map((d) => axis.scale.convert(d)),\r\n                };\r\n            }\r\n        };\r\n        addScale(ChartAxisDirection.X);\r\n        addScale(ChartAxisDirection.Y);\r\n        return result;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianSeries.prototype, \"legendItemName\", void 0);\n\nconst directions = ['top', 'right', 'bottom', 'left'];\r\nclass CartesianChart extends Chart {\r\n    constructor(specialOverrides, resources) {\r\n        super(specialOverrides, resources);\r\n        /** Integrated Charts feature state - not used in Standalone Charts. */\r\n        this.paired = true;\r\n        this._lastAxisWidths = {\r\n            top: 0,\r\n            bottom: 0,\r\n            left: 0,\r\n            right: 0,\r\n        };\r\n        this._lastVisibility = {\r\n            crossLines: true,\r\n            series: true,\r\n        };\r\n    }\r\n    performLayout() {\r\n        const _super = Object.create(null, {\r\n            performLayout: { get: () => super.performLayout }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const shrinkRect = yield _super.performLayout.call(this);\r\n            const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);\r\n            this.seriesRoot.visible = visibility.series;\r\n            this.seriesRect = seriesRect;\r\n            this.animationRect = animationRect;\r\n            this.seriesRoot.translationX = Math.floor(seriesRect.x);\r\n            this.seriesRoot.translationY = Math.floor(seriesRect.y);\r\n            const { seriesArea: { padding }, } = this;\r\n            // Recreate padding object to prevent issues with getters in `BBox.shrink()`\r\n            const seriesPaddedRect = seriesRect.clone().grow({\r\n                top: padding.top,\r\n                right: padding.right,\r\n                bottom: padding.bottom,\r\n                left: padding.left,\r\n            });\r\n            this.hoverRect = seriesPaddedRect;\r\n            this.layoutService.dispatchLayoutComplete({\r\n                type: 'layout-complete',\r\n                chart: { width: this.scene.width, height: this.scene.height },\r\n                clipSeries,\r\n                series: {\r\n                    rect: seriesRect,\r\n                    paddedRect: seriesPaddedRect,\r\n                    visible: visibility.series,\r\n                    shouldFlipXY: this.shouldFlipXY(),\r\n                },\r\n                axes: this.axes.map((axis) => (Object.assign({ id: axis.id }, axis.getLayoutState()))),\r\n            });\r\n            return shrinkRect;\r\n        });\r\n    }\r\n    updateAxes(inputShrinkRect) {\r\n        var _a;\r\n        // Start with a good approximation from the last update - this should mean that in many resize\r\n        // cases that only a single pass is needed \\o/.\r\n        const axisWidths = Object.assign({}, this._lastAxisWidths);\r\n        const visibility = Object.assign({}, this._lastVisibility);\r\n        // Clean any positions which aren't valid with the current axis status (otherwise we end up\r\n        // never being able to find a stable result).\r\n        const liveAxisWidths = new Set(this._axes.map((a) => a.position));\r\n        for (const position of Object.keys(axisWidths)) {\r\n            if (!liveAxisWidths.has(position)) {\r\n                delete axisWidths[position];\r\n            }\r\n        }\r\n        const stableOutputs = (otherAxisWidths, otherVisibility) => {\r\n            // Check for new axis positions.\r\n            if (Object.keys(otherAxisWidths).some((k) => axisWidths[k] == null)) {\r\n                return false;\r\n            }\r\n            return (visibility.crossLines === otherVisibility.crossLines &&\r\n                visibility.series === otherVisibility.series &&\r\n                // Check for existing axis positions and equality.\r\n                Object.entries(axisWidths).every(([p, w]) => {\r\n                    const otherW = otherAxisWidths[p];\r\n                    if (w != null || otherW != null) {\r\n                        return w === otherW;\r\n                    }\r\n                    return true;\r\n                }));\r\n        };\r\n        const ceilValues = (records) => {\r\n            return Object.entries(records).reduce((out, [key, value]) => {\r\n                if (value && Math.abs(value) === Infinity) {\r\n                    value = 0;\r\n                }\r\n                out[key] = value != null ? Math.ceil(value) : value;\r\n                return out;\r\n            }, {});\r\n        };\r\n        // Iteratively try to resolve axis widths - since X axis width affects Y axis range,\r\n        // and vice-versa, we need to iteratively try and find a fit for the axes and their\r\n        // ticks/labels.\r\n        let lastPassAxisWidths = {};\r\n        let lastPassVisibility = {};\r\n        let clipSeries = false;\r\n        let seriesRect = (_a = this.seriesRect) === null || _a === void 0 ? void 0 : _a.clone();\r\n        let count = 0;\r\n        let primaryTickCounts = {};\r\n        do {\r\n            Object.assign(axisWidths, lastPassAxisWidths);\r\n            Object.assign(visibility, lastPassVisibility);\r\n            const result = this.updateAxesPass(axisWidths, inputShrinkRect.clone(), seriesRect);\r\n            lastPassAxisWidths = ceilValues(result.axisWidths);\r\n            lastPassVisibility = result.visibility;\r\n            clipSeries = result.clipSeries;\r\n            seriesRect = result.seriesRect;\r\n            primaryTickCounts = result.primaryTickCounts;\r\n            if (count++ > 10) {\r\n                Logger.warn('unable to find stable axis layout.');\r\n                break;\r\n            }\r\n        } while (!stableOutputs(lastPassAxisWidths, lastPassVisibility));\r\n        this.axes.forEach((axis) => {\r\n            const { direction } = axis;\r\n            const primaryTickCount = primaryTickCounts[direction];\r\n            axis.update(primaryTickCount);\r\n        });\r\n        const clipRectPadding = 5;\r\n        this.axes.forEach((axis) => {\r\n            // update visibility of crosslines\r\n            axis.setCrossLinesVisible(visibility.crossLines);\r\n            if (!seriesRect) {\r\n                return;\r\n            }\r\n            axis.clipGrid(seriesRect.x, seriesRect.y, seriesRect.width + clipRectPadding, seriesRect.height + clipRectPadding);\r\n            switch (axis.position) {\r\n                case 'left':\r\n                case 'right':\r\n                    axis.clipTickLines(inputShrinkRect.x, seriesRect.y, inputShrinkRect.width + clipRectPadding, seriesRect.height + clipRectPadding);\r\n                    break;\r\n                case 'top':\r\n                case 'bottom':\r\n                    axis.clipTickLines(seriesRect.x, inputShrinkRect.y, seriesRect.width + clipRectPadding, inputShrinkRect.height + clipRectPadding);\r\n                    break;\r\n            }\r\n        });\r\n        this._lastAxisWidths = axisWidths;\r\n        this._lastVisibility = visibility;\r\n        return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };\r\n    }\r\n    updateAxesPass(axisWidths, bounds, lastPassSeriesRect) {\r\n        const { axes } = this;\r\n        const visited = {};\r\n        const newAxisWidths = {};\r\n        const visibility = {\r\n            series: true,\r\n            crossLines: true,\r\n        };\r\n        let clipSeries = false;\r\n        const primaryTickCounts = {};\r\n        const paddedBounds = this.applySeriesPadding(bounds);\r\n        const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisWidths) : {};\r\n        const axisBound = this.buildAxisBound(paddedBounds, axisWidths, crossLinePadding, visibility);\r\n        const seriesRect = this.buildSeriesRect(axisBound, axisWidths);\r\n        // Set the number of ticks for continuous axes based on the available range\r\n        // before updating the axis domain via `this.updateAxes()` as the tick count has an effect on the calculated `nice` domain extent\r\n        axes.forEach((axis) => {\r\n            var _a, _b;\r\n            const { position = 'left' } = axis;\r\n            const { clipSeries: newClipSeries, axisThickness, axisOffset, } = this.calculateAxisDimensions({\r\n                axis,\r\n                seriesRect,\r\n                paddedBounds,\r\n                axisWidths,\r\n                newAxisWidths,\r\n                primaryTickCounts,\r\n                clipSeries,\r\n                addInterAxisPadding: ((_a = visited[position]) !== null && _a !== void 0 ? _a : 0) > 0,\r\n            });\r\n            visited[position] = ((_b = visited[position]) !== null && _b !== void 0 ? _b : 0) + 1;\r\n            clipSeries = clipSeries || newClipSeries;\r\n            this.positionAxis({\r\n                axis,\r\n                axisBound,\r\n                axisOffset,\r\n                axisThickness,\r\n                axisWidths,\r\n                primaryTickCounts,\r\n                seriesRect,\r\n            });\r\n        });\r\n        return { clipSeries, seriesRect, axisWidths: newAxisWidths, visibility, primaryTickCounts };\r\n    }\r\n    buildCrossLinePadding(axisWidths) {\r\n        var _a;\r\n        const crossLinePadding = {};\r\n        this.axes.forEach((axis) => {\r\n            if (axis.crossLines) {\r\n                axis.crossLines.forEach((crossLine) => {\r\n                    crossLine.calculatePadding(crossLinePadding);\r\n                });\r\n            }\r\n        });\r\n        // Reduce cross-line padding to account for overlap with axes.\r\n        for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\r\n            crossLinePadding[side] = Math.max(padding - ((_a = axisWidths[side]) !== null && _a !== void 0 ? _a : 0), 0);\r\n        }\r\n        return crossLinePadding;\r\n    }\r\n    applySeriesPadding(bounds) {\r\n        const paddedRect = bounds.clone();\r\n        const reversedAxes = this.axes.slice().reverse();\r\n        directions.forEach((dir) => {\r\n            const padding = this.seriesArea.padding[dir];\r\n            const axis = reversedAxes.find((axis) => axis.position === dir);\r\n            if (axis) {\r\n                axis.seriesAreaPadding = padding;\r\n            }\r\n            else {\r\n                paddedRect.shrink(padding, dir);\r\n            }\r\n        });\r\n        return paddedRect;\r\n    }\r\n    buildAxisBound(bounds, axisWidths, crossLinePadding, visibility) {\r\n        var _a, _b, _c, _d;\r\n        const result = bounds.clone();\r\n        const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\r\n        const horizontalPadding = left + right;\r\n        const verticalPadding = top + bottom;\r\n        const totalWidth = ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0) + ((_b = axisWidths.right) !== null && _b !== void 0 ? _b : 0) + horizontalPadding;\r\n        const totalHeight = ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0) + ((_d = axisWidths.bottom) !== null && _d !== void 0 ? _d : 0) + verticalPadding;\r\n        if (result.width <= totalWidth || result.height <= totalHeight) {\r\n            // Not enough space for crossLines and series\r\n            visibility.crossLines = false;\r\n            visibility.series = false;\r\n            return result;\r\n        }\r\n        result.x += left;\r\n        result.y += top;\r\n        result.width -= horizontalPadding;\r\n        result.height -= verticalPadding;\r\n        return result;\r\n    }\r\n    buildSeriesRect(axisBound, axisWidths) {\r\n        const result = axisBound.clone();\r\n        const { top, bottom, left, right } = axisWidths;\r\n        result.x += left !== null && left !== void 0 ? left : 0;\r\n        result.y += top !== null && top !== void 0 ? top : 0;\r\n        result.width -= (left !== null && left !== void 0 ? left : 0) + (right !== null && right !== void 0 ? right : 0);\r\n        result.height -= (top !== null && top !== void 0 ? top : 0) + (bottom !== null && bottom !== void 0 ? bottom : 0);\r\n        // Width and height should not be negative.\r\n        result.width = Math.max(0, result.width);\r\n        result.height = Math.max(0, result.height);\r\n        return result;\r\n    }\r\n    clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\r\n        const { x, y, width, height } = seriesRect;\r\n        const clampBounds = [x, y, x + width, y + height];\r\n        const fn = direction === 1 ? Math.min : Math.max;\r\n        const compareTo = clampBounds[(dimension === 'x' ? 0 : 1) + (direction === 1 ? 0 : 2)];\r\n        return fn(value, compareTo);\r\n    }\r\n    calculateAxisDimensions(opts) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { axis, seriesRect, paddedBounds, axisWidths, newAxisWidths, primaryTickCounts, addInterAxisPadding } = opts;\r\n        let { clipSeries } = opts;\r\n        const { position = 'left', direction } = axis;\r\n        const axisLeftRightRange = (axis) => {\r\n            if (axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis) {\r\n                return [0, seriesRect.height];\r\n            }\r\n            return [seriesRect.height, 0];\r\n        };\r\n        const axisOffset = (_a = newAxisWidths[position]) !== null && _a !== void 0 ? _a : 0;\r\n        switch (position) {\r\n            case 'top':\r\n            case 'bottom':\r\n                axis.range = [0, seriesRect.width];\r\n                axis.gridLength = seriesRect.height;\r\n                break;\r\n            case 'right':\r\n            case 'left':\r\n                axis.range = axisLeftRightRange(axis);\r\n                axis.gridLength = seriesRect.width;\r\n                break;\r\n        }\r\n        const zoom = this.zoomManager.getAxisZoom(axis.id);\r\n        const { min = 0, max = 1 } = zoom !== null && zoom !== void 0 ? zoom : {};\r\n        axis.visibleRange = [min, max];\r\n        const rangeClipped = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1;\r\n        clipSeries || (clipSeries = rangeClipped);\r\n        let primaryTickCount = axis.nice ? primaryTickCounts[direction] : undefined;\r\n        const paddedBoundsCoefficient = 0.3;\r\n        if (axis.thickness != null && axis.thickness > 0) {\r\n            axis.maxThickness = axis.thickness;\r\n        }\r\n        else if (direction === ChartAxisDirection.Y) {\r\n            axis.maxThickness = paddedBounds.width * paddedBoundsCoefficient;\r\n        }\r\n        else {\r\n            axis.maxThickness = paddedBounds.height * paddedBoundsCoefficient;\r\n        }\r\n        const layout = axis.calculateLayout(primaryTickCount);\r\n        primaryTickCount = layout.primaryTickCount;\r\n        primaryTickCounts[direction] = (_b = primaryTickCounts[direction]) !== null && _b !== void 0 ? _b : primaryTickCount;\r\n        let axisThickness = 0;\r\n        if (axis.thickness != null && axis.thickness > 0) {\r\n            axisThickness = axis.thickness;\r\n        }\r\n        else {\r\n            const { bbox } = layout;\r\n            axisThickness = direction === ChartAxisDirection.X ? bbox.height : bbox.width;\r\n        }\r\n        // for multiple axes in the same direction and position, apply padding at the top of each inner axis (i.e. between axes).\r\n        const axisPadding = 15;\r\n        if (addInterAxisPadding) {\r\n            axisThickness += axisPadding;\r\n        }\r\n        axisThickness = Math.ceil(axisThickness);\r\n        newAxisWidths[position] = ((_c = newAxisWidths[position]) !== null && _c !== void 0 ? _c : 0) + axisThickness;\r\n        axis.gridPadding = ((_d = axisWidths[position]) !== null && _d !== void 0 ? _d : 0) - ((_e = newAxisWidths[position]) !== null && _e !== void 0 ? _e : 0);\r\n        return { clipSeries, axisThickness, axisOffset, primaryTickCount };\r\n    }\r\n    positionAxis(opts) {\r\n        var _a, _b, _c, _d;\r\n        const { axis, axisBound, axisWidths, seriesRect, axisOffset, axisThickness } = opts;\r\n        const { position } = axis;\r\n        switch (position) {\r\n            case 'top':\r\n                axis.translation.x = axisBound.x + ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0);\r\n                axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + 1 + axisOffset + axisThickness, 'y', 1);\r\n                break;\r\n            case 'bottom':\r\n                axis.translation.x = axisBound.x + ((_b = axisWidths.left) !== null && _b !== void 0 ? _b : 0);\r\n                axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + axisBound.height + 1 - axisThickness - axisOffset, 'y', -1);\r\n                break;\r\n            case 'left':\r\n                axis.translation.y = axisBound.y + ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0);\r\n                axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisOffset + axisThickness, 'x', 1);\r\n                break;\r\n            case 'right':\r\n                axis.translation.y = axisBound.y + ((_d = axisWidths.top) !== null && _d !== void 0 ? _d : 0);\r\n                axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisBound.width - axisThickness - axisOffset, 'x', -1);\r\n                break;\r\n        }\r\n        axis.updatePosition({ rotation: toRadians(axis.rotation), sideFlag: axis.label.getSideFlag() });\r\n    }\r\n    shouldFlipXY() {\r\n        // Only flip the xy axes if all the series agree on flipping\r\n        return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));\r\n    }\r\n}\r\nCartesianChart.className = 'CartesianChart';\r\nCartesianChart.type = 'cartesian';\n\n/**\r\n * Proxy class, to allow library users to keep a stable reference to their chart, even if we need\r\n * to switch concrete class (e.g. when switching between CartesianChart vs. PolarChart).\r\n */\r\nclass AgChartInstanceProxy {\r\n    static isInstance(x) {\r\n        var _a;\r\n        if (x instanceof AgChartInstanceProxy) {\r\n            // Simple case.\r\n            return true;\r\n        }\r\n        if (((_a = x.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'AgChartInstanceProxy' && x.chart != null) {\r\n            // instanceof can fail if mixing bundles (e.g. grid all-modules vs. standalone).\r\n            return true;\r\n        }\r\n        return x.chart != null && this.validateImplementation(x);\r\n    }\r\n    static validateImplementation(x) {\r\n        var _a, _b;\r\n        const chartProps = ['getOptions', 'destroy'];\r\n        const signatureProps = Object.keys((_b = (_a = x.constructor) === null || _a === void 0 ? void 0 : _a.prototype) !== null && _b !== void 0 ? _b : {});\r\n        return chartProps.every((prop) => signatureProps.includes(prop));\r\n    }\r\n    constructor(chart) {\r\n        this.chart = chart;\r\n    }\r\n    getOptions() {\r\n        return this.chart.getOptions();\r\n    }\r\n    destroy() {\r\n        this.chart.destroy();\r\n    }\r\n}\n\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount) {\r\n    // Make secondary axis domain nice using strict tick count, matching the tick count from the primary axis.\r\n    // This is to make the secondary axis grid lines/ tick positions align with the ones from the primary axis.\r\n    let start = Math.floor(domain[0]);\r\n    let stop = domain[1];\r\n    start = calculateNiceStart(start, stop, primaryTickCount);\r\n    const step = getTickStep(start, stop, primaryTickCount);\r\n    const segments = primaryTickCount - 1;\r\n    stop = start + segments * step;\r\n    const d = [start, stop];\r\n    const ticks = getTicks(start, step, primaryTickCount);\r\n    return [d, ticks];\r\n}\r\nfunction calculateNiceStart(a, b, count) {\r\n    const rawStep = Math.abs(b - a) / (count - 1);\r\n    const order = Math.floor(Math.log10(rawStep));\r\n    const magnitude = Math.pow(10, order);\r\n    return Math.floor(a / magnitude) * magnitude;\r\n}\r\nfunction getTicks(start, step, count) {\r\n    // power of the step will be negative if the step is a fraction (between 0 and 1)\r\n    const stepPower = Math.floor(Math.log10(step));\r\n    const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\r\n    const f = Math.pow(10, fractionDigits);\r\n    const ticks = new NumericTicks(fractionDigits);\r\n    for (let i = 0; i < count; i++) {\r\n        const tick = start + step * i;\r\n        ticks[i] = Math.round(tick * f) / f;\r\n    }\r\n    return ticks;\r\n}\r\nfunction getTickStep(start, stop, count) {\r\n    const segments = count - 1;\r\n    const rawStep = (stop - start) / segments;\r\n    return calculateNextNiceStep(rawStep);\r\n}\r\nfunction calculateNextNiceStep(rawStep) {\r\n    const order = Math.floor(Math.log10(rawStep));\r\n    const magnitude = Math.pow(10, order);\r\n    // Make order 1\r\n    const step = (rawStep / magnitude) * 10;\r\n    if (step > 0 && step <= 1) {\r\n        return magnitude / 10;\r\n    }\r\n    if (step > 1 && step <= 2) {\r\n        return (2 * magnitude) / 10;\r\n    }\r\n    if (step > 1 && step <= 5) {\r\n        return (5 * magnitude) / 10;\r\n    }\r\n    if (step > 5 && step <= 10) {\r\n        return (10 * magnitude) / 10;\r\n    }\r\n    if (step > 10 && step <= 20) {\r\n        return (20 * magnitude) / 10;\r\n    }\r\n    if (step > 20 && step <= 40) {\r\n        return (40 * magnitude) / 10;\r\n    }\r\n    if (step > 40 && step <= 50) {\r\n        return (50 * magnitude) / 10;\r\n    }\r\n    if (step > 50 && step <= 100) {\r\n        return (100 * magnitude) / 10;\r\n    }\r\n    return step;\r\n}\n\nclass NumberAxisTick extends AxisTick {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.maxSpacing = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], NumberAxisTick.prototype, \"maxSpacing\", void 0);\r\nclass NumberAxis extends CartesianAxis {\r\n    constructor(moduleCtx, scale = new LinearScale()) {\r\n        super(moduleCtx, scale);\r\n        this.min = NaN;\r\n        this.max = NaN;\r\n    }\r\n    normaliseDataDomain(d) {\r\n        const { min, max } = this;\r\n        const { extent, clipped } = normalisedExtentWithMetadata(d, min, max);\r\n        return { domain: extent, clipped };\r\n    }\r\n    formatDatum(datum) {\r\n        if (typeof datum === 'number') {\r\n            return datum.toFixed(2);\r\n        }\r\n        else {\r\n            Logger.warnOnce('data contains Date objects which are being plotted against a number axis, please only use a number axis for numbers.');\r\n            return String(datum);\r\n        }\r\n    }\r\n    createTick() {\r\n        return new NumberAxisTick();\r\n    }\r\n    updateSecondaryAxisTicks(primaryTickCount) {\r\n        if (this.dataDomain == null) {\r\n            throw new Error('AG Charts - dataDomain not calculated, cannot perform tick calculation.');\r\n        }\r\n        if (this.dataDomain.domain.length === 0)\r\n            return [];\r\n        const [d, ticks] = calculateNiceSecondaryAxis(this.dataDomain.domain, primaryTickCount !== null && primaryTickCount !== void 0 ? primaryTickCount : 0);\r\n        this.scale.nice = false;\r\n        this.scale.domain = d;\r\n        this.scale.update();\r\n        return ticks;\r\n    }\r\n}\r\nNumberAxis.className = 'NumberAxis';\r\nNumberAxis.type = 'number';\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], NumberAxis.prototype, \"min\", void 0);\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], NumberAxis.prototype, \"max\", void 0);\n\nfunction NON_ZERO_NUMBER() {\r\n    // Cannot be 0\r\n    const message = `expecting a non-zero Number`;\r\n    return predicateWithMessage((v) => typeof v === 'number' && v !== 0, message);\r\n}\r\nclass LogAxis extends NumberAxis {\r\n    normaliseDataDomain(d) {\r\n        const { min, max } = this;\r\n        const { extent, clipped } = normalisedExtentWithMetadata(d, min, max);\r\n        const isInverted = extent[0] > extent[1];\r\n        const crossesZero = extent[0] < 0 && extent[1] > 0;\r\n        const hasZeroExtent = extent[0] === 0 && extent[1] === 0;\r\n        const invalidDomain = isInverted || crossesZero || hasZeroExtent;\r\n        if (invalidDomain) {\r\n            d = [];\r\n            if (crossesZero) {\r\n                Logger.warn(`the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`);\r\n            }\r\n            else if (hasZeroExtent) {\r\n                Logger.warn(`the data domain has 0 extent, no data is rendered.`);\r\n            }\r\n        }\r\n        if (extent[0] === 0) {\r\n            extent[0] = 1;\r\n        }\r\n        if (extent[1] === 0) {\r\n            extent[1] = -1;\r\n        }\r\n        return { domain: extent, clipped };\r\n    }\r\n    set base(value) {\r\n        this.scale.base = value;\r\n    }\r\n    get base() {\r\n        return this.scale.base;\r\n    }\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new LogScale());\r\n        this.min = NaN;\r\n        this.max = NaN;\r\n    }\r\n}\r\nLogAxis.className = 'LogAxis';\r\nLogAxis.type = 'log';\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'), NON_ZERO_NUMBER())),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], LogAxis.prototype, \"min\", void 0);\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'), NON_ZERO_NUMBER())),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], LogAxis.prototype, \"max\", void 0);\n\nclass TimeAxisTick extends AxisTick {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.maxSpacing = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], TimeAxisTick.prototype, \"maxSpacing\", void 0);\r\nclass TimeAxis extends CartesianAxis {\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new TimeScale());\r\n        this.datumFormat = '%m/%d/%y, %H:%M:%S';\r\n        this.min = undefined;\r\n        this.max = undefined;\r\n        const { scale } = this;\r\n        this.refreshScale();\r\n        this.datumFormatter = scale.tickFormat({\r\n            specifier: this.datumFormat,\r\n        });\r\n    }\r\n    normaliseDataDomain(d) {\r\n        var _a;\r\n        let { min, max } = this;\r\n        let clipped = false;\r\n        if (typeof min === 'number') {\r\n            min = new Date(min);\r\n        }\r\n        if (typeof max === 'number') {\r\n            max = new Date(max);\r\n        }\r\n        if (d.length > 2) {\r\n            d = ((_a = extent(d)) !== null && _a !== void 0 ? _a : [0, 1000]).map((x) => new Date(x));\r\n        }\r\n        if (min instanceof Date) {\r\n            clipped || (clipped = min > d[0]);\r\n            d = [min, d[1]];\r\n        }\r\n        if (max instanceof Date) {\r\n            clipped || (clipped = max < d[1]);\r\n            d = [d[0], max];\r\n        }\r\n        if (d[0] > d[1]) {\r\n            d = [];\r\n        }\r\n        return { domain: d, clipped };\r\n    }\r\n    createTick() {\r\n        return new TimeAxisTick();\r\n    }\r\n    onLabelFormatChange(ticks, format) {\r\n        if (format) {\r\n            super.onLabelFormatChange(ticks, format);\r\n        }\r\n        else {\r\n            // For time axis labels to look nice, even if date format wasn't set.\r\n            this.labelFormatter = this.scale.tickFormat({ ticks });\r\n        }\r\n    }\r\n    formatDatum(datum) {\r\n        var _a;\r\n        return (_a = this.moduleCtx.callbackCache.call(this.datumFormatter, datum)) !== null && _a !== void 0 ? _a : String(datum);\r\n    }\r\n    calculatePadding(_min, _max) {\r\n        // numbers in domain correspond to Unix timestamps\r\n        // automatically expand domain by 1 in forward direction\r\n        return [0, 1];\r\n    }\r\n}\r\nTimeAxis.className = 'TimeAxis';\r\nTimeAxis.type = 'time';\r\n__decorate([\r\n    Validate(AND(OPT_DATE_OR_DATETIME_MS, LESS_THAN('max'))),\r\n    __metadata(\"design:type\", Object)\r\n], TimeAxis.prototype, \"min\", void 0);\r\n__decorate([\r\n    Validate(AND(OPT_DATE_OR_DATETIME_MS, GREATER_THAN('min'))),\r\n    __metadata(\"design:type\", Object)\r\n], TimeAxis.prototype, \"max\", void 0);\n\nconst AXIS_CONSTRUCTORS = {\r\n    [NumberAxis.type]: NumberAxis,\r\n    [CategoryAxis.type]: CategoryAxis,\r\n    [TimeAxis.type]: TimeAxis,\r\n    [GroupedCategoryAxis.type]: GroupedCategoryAxis,\r\n    [LogAxis.type]: LogAxis,\r\n};\r\nfunction registerAxis(axisType, ctor) {\r\n    AXIS_CONSTRUCTORS[axisType] = ctor;\r\n}\r\nfunction getAxis(axisType, moduleCtx) {\r\n    const axisConstructor = AXIS_CONSTRUCTORS[axisType];\r\n    if (axisConstructor) {\r\n        return new axisConstructor(moduleCtx);\r\n    }\r\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\r\n}\r\nconst AXIS_TYPES = {\r\n    has(axisType) {\r\n        return Object.prototype.hasOwnProperty.call(AXIS_CONSTRUCTORS, axisType);\r\n    },\r\n    get axesTypes() {\r\n        return Object.keys(AXIS_CONSTRUCTORS);\r\n    },\r\n};\r\nconst AXIS_THEME_TEMPLATES = {};\r\nfunction registerAxisThemeTemplate(axisType, theme) {\r\n    AXIS_THEME_TEMPLATES[axisType] = theme;\r\n}\r\nfunction getAxisThemeTemplate(axisType) {\r\n    var _a;\r\n    return (_a = AXIS_THEME_TEMPLATES[axisType]) !== null && _a !== void 0 ? _a : {};\r\n}\n\nconst EXPECTED_ENTERPRISE_MODULES = [\r\n    { type: 'root', optionsKey: 'animation', chartTypes: ['cartesian', 'polar', 'hierarchy'] },\r\n    {\r\n        type: 'root',\r\n        optionsKey: 'background',\r\n        chartTypes: ['cartesian', 'polar', 'hierarchy'],\r\n        optionsInnerKey: 'image',\r\n    },\r\n    { type: 'root', optionsKey: 'contextMenu', chartTypes: ['cartesian', 'polar', 'hierarchy'] },\r\n    { type: 'root', optionsKey: 'zoom', chartTypes: ['cartesian'] },\r\n    {\r\n        type: 'legend',\r\n        optionsKey: 'gradientLegend',\r\n        chartTypes: ['cartesian', 'polar', 'hierarchy'],\r\n        identifier: 'gradient',\r\n    },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'angle-category' },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'angle-number' },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'radius-category' },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'radius-number' },\r\n    { type: 'axis-option', optionsKey: 'crosshair', chartTypes: ['cartesian'] },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'box-plot' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'bullet' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'heatmap' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'nightingale' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radar-area' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radar-line' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radial-bar' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radial-column' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'range-area' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'range-bar' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['hierarchy'], identifier: 'sunburst' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['hierarchy'], identifier: 'treemap' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'waterfall' },\r\n    { type: 'series-option', optionsKey: 'errorBar', chartTypes: ['cartesian'], identifier: 'error-bars' },\r\n];\r\nfunction isEnterpriseSeriesType(type) {\r\n    return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === 'series' && s.identifier === type);\r\n}\r\nfunction getEnterpriseSeriesChartTypes(type) {\r\n    var _a;\r\n    return (_a = EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === 'series' && s.identifier === type)) === null || _a === void 0 ? void 0 : _a.chartTypes;\r\n}\r\nfunction isEnterpriseSeriesTypeLoaded(type) {\r\n    var _a, _b;\r\n    return ((_b = (_a = EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === 'series' && s.identifier === type)) === null || _a === void 0 ? void 0 : _a.useCount) !== null && _b !== void 0 ? _b : 0) > 0;\r\n}\r\nfunction isEnterpriseCartesian(seriesType) {\r\n    var _a;\r\n    const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find((v) => v === 'cartesian');\r\n    return type === 'cartesian';\r\n}\r\nfunction isEnterprisePolar(seriesType) {\r\n    var _a;\r\n    const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find((v) => v === 'polar');\r\n    return type === 'polar';\r\n}\r\nfunction isEnterpriseHierarchy(seriesType) {\r\n    var _a;\r\n    const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find((v) => v === 'hierarchy');\r\n    return type === 'hierarchy';\r\n}\r\nfunction verifyIfModuleExpected(module) {\r\n    var _a;\r\n    if (module.packageType !== 'enterprise') {\r\n        throw new Error('AG Charts - internal configuration error, only enterprise modules need verification.');\r\n    }\r\n    const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\r\n        return (s.type === module.type &&\r\n            s.optionsKey === module.optionsKey &&\r\n            s.identifier === module.identifier &&\r\n            module.chartTypes.every((t) => s.chartTypes.includes(t)));\r\n    });\r\n    if (stub) {\r\n        (_a = stub.useCount) !== null && _a !== void 0 ? _a : (stub.useCount = 0);\r\n        stub.useCount++;\r\n    }\r\n    return stub != null;\r\n}\r\nfunction getUnusedExpectedModules() {\r\n    return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\r\n}\n\nconst LEGEND_KEYS = {\r\n    category: 'legend',\r\n};\r\nfunction registerLegend(type, key, ctr, theme) {\r\n    LEGEND_KEYS[type] = key;\r\n    LEGEND_THEME_TEMPLATES[key] = theme;\r\n}\r\nconst LEGEND_THEME_TEMPLATES = {};\r\nfunction getLegendThemeTemplates() {\r\n    return LEGEND_THEME_TEMPLATES;\r\n}\r\nfunction getLegendKeys() {\r\n    return LEGEND_KEYS;\r\n}\n\nclass Background extends BaseModuleInstance {\r\n    constructor(ctx) {\r\n        var _a;\r\n        super();\r\n        this.node = new Group({ name: 'background', zIndex: Layers.SERIES_BACKGROUND_ZINDEX });\r\n        this.rectNode = new Rect();\r\n        this.visible = true;\r\n        this.fill = 'white';\r\n        // placeholder for enterprise module\r\n        this.image = undefined;\r\n        this.node.appendChild(this.rectNode);\r\n        (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(this.node);\r\n        this.destroyFns.push(() => { var _a; return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.node); }, ctx.layoutService.addListener('layout-complete', (e) => this.onLayoutComplete(e)));\r\n    }\r\n    onLayoutComplete(e) {\r\n        const { width, height } = e.chart;\r\n        this.rectNode.width = width;\r\n        this.rectNode.height = height;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    ProxyPropertyOnWrite('node', 'visible'),\r\n    __metadata(\"design:type\", Boolean)\r\n], Background.prototype, \"visible\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    ProxyPropertyOnWrite('rectNode', 'fill'),\r\n    __metadata(\"design:type\", String)\r\n], Background.prototype, \"fill\", void 0);\n\nconst BackgroundModule = {\r\n    type: 'root',\r\n    optionsKey: 'background',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian', 'polar', 'hierarchy'],\r\n    instanceConstructor: Background,\r\n};\n\nclass NavigatorHandle {\r\n    set fill(value) {\r\n        this.rh.fill = value;\r\n    }\r\n    get fill() {\r\n        return this.rh.fill;\r\n    }\r\n    set stroke(value) {\r\n        this.rh.stroke = value;\r\n    }\r\n    get stroke() {\r\n        return this.rh.stroke;\r\n    }\r\n    set strokeWidth(value) {\r\n        this.rh.strokeWidth = value;\r\n    }\r\n    get strokeWidth() {\r\n        return this.rh.strokeWidth;\r\n    }\r\n    set width(value) {\r\n        this.rh.width = value;\r\n    }\r\n    get width() {\r\n        return this.rh.width;\r\n    }\r\n    set height(value) {\r\n        this.rh.height = value;\r\n    }\r\n    get height() {\r\n        return this.rh.height;\r\n    }\r\n    set gripLineGap(value) {\r\n        this.rh.gripLineGap = value;\r\n    }\r\n    get gripLineGap() {\r\n        return this.rh.gripLineGap;\r\n    }\r\n    set gripLineLength(value) {\r\n        this.rh.gripLineLength = value;\r\n    }\r\n    get gripLineLength() {\r\n        return this.rh.gripLineLength;\r\n    }\r\n    constructor(rangeHandle) {\r\n        this.rh = rangeHandle;\r\n    }\r\n}\n\nclass NavigatorMask {\r\n    set fill(value) {\r\n        this.rm.fill = value;\r\n    }\r\n    get fill() {\r\n        return this.rm.fill;\r\n    }\r\n    set stroke(value) {\r\n        this.rm.stroke = value;\r\n    }\r\n    get stroke() {\r\n        return this.rm.stroke;\r\n    }\r\n    set strokeWidth(value) {\r\n        this.rm.strokeWidth = value;\r\n    }\r\n    get strokeWidth() {\r\n        return this.rm.strokeWidth;\r\n    }\r\n    set fillOpacity(value) {\r\n        this.rm.fillOpacity = value;\r\n    }\r\n    get fillOpacity() {\r\n        return this.rm.fillOpacity;\r\n    }\r\n    constructor(rangeMask) {\r\n        this.rm = rangeMask;\r\n    }\r\n}\n\nclass RangeHandle extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._fill = '#f2f2f2';\r\n        this._stroke = '#999999';\r\n        this._strokeWidth = 1;\r\n        this._lineCap = 'square';\r\n        this._centerX = 0;\r\n        this._centerY = 0;\r\n        // Use an even number for better looking results.\r\n        this._width = 8;\r\n        // Use an even number for better looking results.\r\n        this._gripLineGap = 2;\r\n        // Use an even number for better looking results.\r\n        this._gripLineLength = 8;\r\n        this._height = 16;\r\n    }\r\n    set centerX(value) {\r\n        if (this._centerX !== value) {\r\n            this._centerX = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get centerX() {\r\n        return this._centerX;\r\n    }\r\n    set centerY(value) {\r\n        if (this._centerY !== value) {\r\n            this._centerY = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get centerY() {\r\n        return this._centerY;\r\n    }\r\n    set width(value) {\r\n        if (this._width !== value) {\r\n            this._width = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    set gripLineGap(value) {\r\n        if (this._gripLineGap !== value) {\r\n            this._gripLineGap = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get gripLineGap() {\r\n        return this._gripLineGap;\r\n    }\r\n    set gripLineLength(value) {\r\n        if (this._gripLineLength !== value) {\r\n            this._gripLineLength = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get gripLineLength() {\r\n        return this._gripLineLength;\r\n    }\r\n    set height(value) {\r\n        if (this._height !== value) {\r\n            this._height = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    computeBBox() {\r\n        const { centerX, centerY, width, height } = this;\r\n        const x = centerX - width / 2;\r\n        const y = centerY - height / 2;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return bbox.containsPoint(point.x, point.y);\r\n    }\r\n    updatePath() {\r\n        const { path, centerX, centerY, width, height } = this;\r\n        path.clear();\r\n        const x = centerX - width / 2;\r\n        const y = centerY - height / 2;\r\n        const ax = this.align(x);\r\n        const ay = this.align(y);\r\n        const axw = ax + this.align(x, width);\r\n        const ayh = ay + this.align(y, height);\r\n        // Handle.\r\n        path.moveTo(ax, ay);\r\n        path.lineTo(axw, ay);\r\n        path.lineTo(axw, ayh);\r\n        path.lineTo(ax, ayh);\r\n        path.lineTo(ax, ay);\r\n        // Grip lines.\r\n        const dx = this.gripLineGap / 2;\r\n        const dy = this.gripLineLength / 2;\r\n        path.moveTo(this.align(centerX - dx), this.align(centerY - dy));\r\n        path.lineTo(this.align(centerX - dx), this.align(centerY + dy));\r\n        path.moveTo(this.align(centerX + dx), this.align(centerY - dy));\r\n        path.lineTo(this.align(centerX + dx), this.align(centerY + dy));\r\n    }\r\n}\r\nRangeHandle.className = 'RangeHandle';\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_fill\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(LINE_CAP),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_lineCap\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_width\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_gripLineGap\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_gripLineLength\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_height\", void 0);\n\nfunction markDirtyOnChange(newValue, oldValue) {\r\n    if (newValue !== oldValue) {\r\n        this.dirtyPath = true;\r\n    }\r\n}\r\nclass RangeMask extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.width = 200;\r\n        this.height = 30;\r\n        this.minRange = 0.05;\r\n        this._min = 0;\r\n        this._max = 1;\r\n    }\r\n    set min(value) {\r\n        var _a;\r\n        value = clamp(0, value, this.max - this.minRange);\r\n        if (this._min !== value && !isNaN(value)) {\r\n            this._min = value;\r\n            this.dirtyPath = true;\r\n            (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\r\n        }\r\n    }\r\n    get min() {\r\n        return this._min;\r\n    }\r\n    set max(value) {\r\n        var _a;\r\n        value = clamp(this.min + this.minRange, value, 1);\r\n        if (this._max !== value && !isNaN(value)) {\r\n            this._max = value;\r\n            this.dirtyPath = true;\r\n            (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\r\n        }\r\n    }\r\n    get max() {\r\n        return this._max;\r\n    }\r\n    computeBBox() {\r\n        const { x, y, width, height } = this;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    computeVisibleRangeBBox() {\r\n        const { x, y, width, height, min, max } = this;\r\n        const minX = x + width * min;\r\n        const maxX = x + width * max;\r\n        return new BBox(minX, y, maxX - minX, height);\r\n    }\r\n    updatePath() {\r\n        const { path, x, y, width, height, min, max } = this;\r\n        path.clear();\r\n        const ax = this.align(x);\r\n        const ay = this.align(y);\r\n        const axw = ax + this.align(x, width);\r\n        const ayh = ay + this.align(y, height);\r\n        // Whole range.\r\n        path.moveTo(ax, ay);\r\n        path.lineTo(axw, ay);\r\n        path.lineTo(axw, ayh);\r\n        path.lineTo(ax, ayh);\r\n        path.lineTo(ax, ay);\r\n        const minX = this.align(x + width * min);\r\n        const maxX = this.align(x + width * max);\r\n        // Visible range.\r\n        path.moveTo(minX, ay);\r\n        path.lineTo(minX, ayh);\r\n        path.lineTo(maxX, ayh);\r\n        path.lineTo(maxX, ay);\r\n        path.lineTo(minX, ay);\r\n    }\r\n}\r\nRangeMask.className = 'RangeMask';\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"x\", void 0);\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"y\", void 0);\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"width\", void 0);\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"height\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Number)\r\n], RangeMask.prototype, \"_min\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Number)\r\n], RangeMask.prototype, \"_max\", void 0);\n\nclass RangeSelector extends Group {\r\n    set x(value) {\r\n        this.mask.x = value;\r\n        this.updateHandles();\r\n    }\r\n    get x() {\r\n        return this.mask.x;\r\n    }\r\n    set y(value) {\r\n        this.mask.y = value;\r\n        this.updateHandles();\r\n    }\r\n    get y() {\r\n        return this.mask.y;\r\n    }\r\n    set width(value) {\r\n        this.mask.width = value;\r\n        this.updateHandles();\r\n    }\r\n    get width() {\r\n        return this.mask.width;\r\n    }\r\n    set height(value) {\r\n        this.mask.height = value;\r\n        this.updateHandles();\r\n    }\r\n    get height() {\r\n        return this.mask.height;\r\n    }\r\n    set min(value) {\r\n        this.mask.min = value;\r\n    }\r\n    get min() {\r\n        return this.mask.min;\r\n    }\r\n    set max(value) {\r\n        this.mask.max = value;\r\n    }\r\n    get max() {\r\n        return this.mask.max;\r\n    }\r\n    constructor() {\r\n        super({ name: 'rangeSelectorGroup' });\r\n        this.minHandle = new RangeHandle();\r\n        this.maxHandle = new RangeHandle();\r\n        this.mask = (() => {\r\n            const { x, y, width, height, min, max } = RangeSelector.defaults;\r\n            const mask = new RangeMask();\r\n            mask.x = x;\r\n            mask.y = y;\r\n            mask.width = width;\r\n            mask.height = height;\r\n            mask.min = min;\r\n            mask.max = max;\r\n            const { minHandle, maxHandle } = this;\r\n            minHandle.centerX = x;\r\n            maxHandle.centerX = x + width;\r\n            minHandle.centerY = maxHandle.centerY = y + height / 2;\r\n            this.append([mask, minHandle, maxHandle]);\r\n            mask.onRangeChange = () => {\r\n                var _a;\r\n                this.updateHandles();\r\n                (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\r\n            };\r\n            return mask;\r\n        })();\r\n        this._x = RangeSelector.defaults.x;\r\n        this._y = RangeSelector.defaults.y;\r\n        this._width = RangeSelector.defaults.width;\r\n        this._height = RangeSelector.defaults.height;\r\n        this._min = RangeSelector.defaults.min;\r\n        this._max = RangeSelector.defaults.max;\r\n        this.isContainerNode = true;\r\n    }\r\n    updateHandles() {\r\n        const { minHandle, maxHandle, x, y, width, height, mask } = this;\r\n        minHandle.centerX = x + width * mask.min;\r\n        maxHandle.centerX = x + width * mask.max;\r\n        minHandle.centerY = maxHandle.centerY = y + height / 2;\r\n    }\r\n    computeBBox() {\r\n        return this.mask.computeBBox();\r\n    }\r\n    computeVisibleRangeBBox() {\r\n        return this.mask.computeVisibleRangeBBox();\r\n    }\r\n    render(renderCtx) {\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped++;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        const { mask, minHandle, maxHandle } = this;\r\n        [mask, minHandle, maxHandle].forEach((child) => {\r\n            if (child.visible && (forceRender || child.dirty > RedrawType.NONE)) {\r\n                ctx.save();\r\n                child.render(Object.assign(Object.assign({}, renderCtx), { ctx, forceRender }));\r\n                ctx.restore();\r\n            }\r\n        });\r\n        this.markClean({ force: true });\r\n        if (stats)\r\n            stats.nodesRendered++;\r\n    }\r\n}\r\nRangeSelector.className = 'Range';\r\nRangeSelector.defaults = {\r\n    x: 0,\r\n    y: 0,\r\n    width: 200,\r\n    height: 30,\r\n    min: 0,\r\n    max: 1,\r\n};\n\nclass Navigator extends BaseModuleInstance {\r\n    set width(value) {\r\n        this.rs.width = value;\r\n    }\r\n    get width() {\r\n        return this.rs.width;\r\n    }\r\n    set height(value) {\r\n        this.rs.height = value;\r\n    }\r\n    get height() {\r\n        return this.rs.height;\r\n    }\r\n    set min(value) {\r\n        this.rs.min = value;\r\n    }\r\n    get min() {\r\n        return this.rs.min;\r\n    }\r\n    set max(value) {\r\n        this.rs.max = value;\r\n    }\r\n    get max() {\r\n        return this.rs.max;\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    updateGroupVisibility() {\r\n        const visible = this.enabled && this.visible;\r\n        this.rs.visible = visible;\r\n        if (visible) {\r\n            this.ctx.zoomManager.updateZoom('navigator', {\r\n                x: { min: this.rs.min, max: this.rs.max },\r\n                y: { min: 0, max: 1 },\r\n            });\r\n        }\r\n        else {\r\n            this.ctx.zoomManager.updateZoom('navigator');\r\n        }\r\n    }\r\n    constructor(ctx) {\r\n        var _a;\r\n        super();\r\n        this.ctx = ctx;\r\n        this.rs = new RangeSelector();\r\n        // Wrappers to allow option application to the scene graph nodes.\r\n        this.mask = new NavigatorMask(this.rs.mask);\r\n        this.minHandle = new NavigatorHandle(this.rs.minHandle);\r\n        this.maxHandle = new NavigatorHandle(this.rs.maxHandle);\r\n        this.minHandleDragging = false;\r\n        this.maxHandleDragging = false;\r\n        this.panHandleOffset = NaN;\r\n        this.enabled = false;\r\n        this.margin = 10;\r\n        this._visible = true;\r\n        this.rs.onRangeChange = () => ctx.zoomManager.updateZoom('navigator', {\r\n            x: { min: this.rs.min, max: this.rs.max },\r\n            y: { min: 0, max: 1 },\r\n        });\r\n        (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(this.rs);\r\n        const interactionOpts = { bypassPause: ['animation'] };\r\n        this.destroyFns.push(ctx.interactionManager.addListener('drag-start', (event) => this.onDragStart(event), interactionOpts), ctx.interactionManager.addListener('drag', (event) => this.onDrag(event), interactionOpts), ctx.interactionManager.addListener('hover', (event) => this.onDrag(event), interactionOpts), ctx.interactionManager.addListener('drag-end', () => this.onDragStop(), interactionOpts), ctx.layoutService.addListener('before-series', (event) => this.layout(event)), ctx.layoutService.addListener('layout-complete', (event) => this.layoutComplete(event)), () => { var _a; return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.rs); }, () => this.ctx.zoomManager.updateZoom('navigator'));\r\n        this.updateGroupVisibility();\r\n    }\r\n    layout({ shrinkRect }) {\r\n        if (this.enabled) {\r\n            const navigatorTotalHeight = this.rs.height + this.margin;\r\n            shrinkRect.shrink(navigatorTotalHeight, 'bottom');\r\n            this.rs.y = shrinkRect.y + shrinkRect.height + this.margin;\r\n        }\r\n        return { shrinkRect };\r\n    }\r\n    layoutComplete({ series: { rect, visible } }) {\r\n        if (this.enabled && visible) {\r\n            this.rs.x = rect.x;\r\n            this.rs.width = rect.width;\r\n        }\r\n        this.visible = visible;\r\n    }\r\n    onDragStart(offset) {\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n        const { offsetX, offsetY } = offset;\r\n        const { rs } = this;\r\n        const { minHandle, maxHandle, x, width, min } = rs;\r\n        const visibleRange = rs.computeVisibleRangeBBox();\r\n        if (!(this.minHandleDragging || this.maxHandleDragging)) {\r\n            if (minHandle.containsPoint(offsetX, offsetY)) {\r\n                this.minHandleDragging = true;\r\n            }\r\n            else if (maxHandle.containsPoint(offsetX, offsetY)) {\r\n                this.maxHandleDragging = true;\r\n            }\r\n            else if (visibleRange.containsPoint(offsetX, offsetY)) {\r\n                this.panHandleOffset = (offsetX - x) / width - min;\r\n            }\r\n        }\r\n    }\r\n    onDrag(offset) {\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n        const { rs, panHandleOffset } = this;\r\n        const { x, y, width, height, minHandle, maxHandle } = rs;\r\n        const { offsetX, offsetY } = offset;\r\n        const minX = x + width * rs.min;\r\n        const maxX = x + width * rs.max;\r\n        const visibleRange = new BBox(minX, y, maxX - minX, height);\r\n        const getRatio = () => Math.min(Math.max((offsetX - x) / width, 0), 1);\r\n        if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {\r\n            this.ctx.cursorManager.updateCursor('navigator', 'ew-resize');\r\n        }\r\n        else if (visibleRange.containsPoint(offsetX, offsetY)) {\r\n            this.ctx.cursorManager.updateCursor('navigator', 'grab');\r\n        }\r\n        else {\r\n            this.ctx.cursorManager.updateCursor('navigator');\r\n        }\r\n        if (this.minHandleDragging) {\r\n            rs.min = getRatio();\r\n        }\r\n        else if (this.maxHandleDragging) {\r\n            rs.max = getRatio();\r\n        }\r\n        else if (!isNaN(panHandleOffset)) {\r\n            const span = rs.max - rs.min;\r\n            const min = Math.min(getRatio() - panHandleOffset, 1 - span);\r\n            if (min <= rs.min) {\r\n                // pan left\r\n                rs.min = min;\r\n                rs.max = rs.min + span;\r\n            }\r\n            else {\r\n                // pan right\r\n                rs.max = min + span;\r\n                rs.min = rs.max - span;\r\n            }\r\n        }\r\n    }\r\n    onDragStop() {\r\n        this.stopHandleDragging();\r\n    }\r\n    stopHandleDragging() {\r\n        this.minHandleDragging = this.maxHandleDragging = false;\r\n        this.panHandleOffset = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue(newValue) {\r\n            if (newValue) {\r\n                this.min = 0;\r\n                this.max = 1;\r\n            }\r\n            this.updateGroupVisibility();\r\n        },\r\n    }),\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Navigator.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], Navigator.prototype, \"margin\", void 0);\n\nconst NavigatorModule = {\r\n    type: 'root',\r\n    optionsKey: 'navigator',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    instanceConstructor: Navigator,\r\n    themeTemplate: {\r\n        navigator: {\r\n            enabled: false,\r\n            height: 30,\r\n            mask: {\r\n                fill: '#999999',\r\n                stroke: '#999999',\r\n                strokeWidth: 1,\r\n                fillOpacity: 0.2,\r\n            },\r\n            minHandle: {\r\n                fill: '#f2f2f2',\r\n                stroke: '#999999',\r\n                strokeWidth: 1,\r\n                width: 8,\r\n                height: 16,\r\n                gripLineGap: 2,\r\n                gripLineLength: 8,\r\n            },\r\n            maxHandle: {\r\n                fill: '#f2f2f2',\r\n                stroke: '#999999',\r\n                strokeWidth: 1,\r\n                width: 8,\r\n                height: 16,\r\n                gripLineGap: 2,\r\n                gripLineLength: 8,\r\n            },\r\n        },\r\n    },\r\n};\n\nconst singleSeriesPaletteFactory = ({ takeColors }) => {\r\n    const { fills: [fill], strokes: [stroke], } = takeColors(1);\r\n    return { fill, stroke };\r\n};\r\nconst markerPaletteFactory = (params) => {\r\n    const { fill, stroke } = singleSeriesPaletteFactory(params);\r\n    return { marker: { fill, stroke } };\r\n};\n\nconst FONT_SIZE = {\r\n    SMALL: 12,\r\n    MEDIUM: 13,\r\n    LARGE: 17,\r\n};\r\nconst BOLD = 'bold';\r\nconst NORMAL = 'normal';\r\nconst BOTTOM = 'bottom';\r\nconst LEFT = 'left';\r\nconst TOP = 'top';\r\nconst CARTESIAN_AXIS_POSITIONS = {\r\n    BOTTOM,\r\n    LEFT,\r\n    TOP,\r\n};\r\nconst CATEGORY = 'category';\r\nconst NUMBER = 'number';\r\nconst TIME = 'time';\r\nconst LOG = 'log';\r\nconst CARTESIAN_AXIS_TYPES = {\r\n    CATEGORY,\r\n    NUMBER,\r\n    TIME,\r\n    LOG,\r\n};\r\nconst ANGLE_CATEGORY = 'angle-category';\r\nconst ANGLE_NUMBER = 'angle-number';\r\nconst RADIUS_CATEGORY = 'radius-category';\r\nconst RADIUS_NUMBER = 'radius-number';\r\nconst POLAR_AXIS_TYPES = {\r\n    ANGLE_CATEGORY,\r\n    ANGLE_NUMBER,\r\n    RADIUS_CATEGORY,\r\n    RADIUS_NUMBER,\r\n};\r\nconst CIRCLE = 'circle';\n\nconst TYPES = {};\r\nconst DEFAULTS = {};\r\nconst CHART_TYPES = {\r\n    has(seriesType) {\r\n        return Object.prototype.hasOwnProperty.call(TYPES, seriesType);\r\n    },\r\n    isCartesian(seriesType) {\r\n        return TYPES[seriesType] === 'cartesian';\r\n    },\r\n    isPolar(seriesType) {\r\n        return TYPES[seriesType] === 'polar';\r\n    },\r\n    isHierarchy(seriesType) {\r\n        return TYPES[seriesType] === 'hierarchy';\r\n    },\r\n    get seriesTypes() {\r\n        return Object.keys(TYPES);\r\n    },\r\n    get cartesianTypes() {\r\n        return this.seriesTypes.filter((t) => this.isCartesian(t));\r\n    },\r\n    get polarTypes() {\r\n        return this.seriesTypes.filter((t) => this.isPolar(t));\r\n    },\r\n    get hierarchyTypes() {\r\n        return this.seriesTypes.filter((t) => this.isHierarchy(t));\r\n    },\r\n};\r\nfunction registerChartSeriesType(seriesType, chartType) {\r\n    TYPES[seriesType] = chartType;\r\n}\r\nfunction registerChartDefaults(chartType, defaults) {\r\n    var _a;\r\n    DEFAULTS[chartType] = jsonMerge([(_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {}, defaults]);\r\n}\r\nfunction getChartDefaults(chartType) {\r\n    var _a;\r\n    return (_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {};\r\n}\r\nfunction getChartType(seriesType) {\r\n    var _a;\r\n    return (_a = TYPES[seriesType]) !== null && _a !== void 0 ? _a : 'unknown';\r\n}\n\nfunction optionsType(input) {\r\n    var _a, _b, _c, _d;\r\n    return (_d = (_a = input.type) !== null && _a !== void 0 ? _a : (_c = (_b = input.series) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : 'line';\r\n}\r\nfunction isAgCartesianChartOptions(input) {\r\n    const specifiedType = optionsType(input);\r\n    if (specifiedType == null) {\r\n        return true;\r\n    }\r\n    if (specifiedType === 'cartesian') {\r\n        Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\r\n        return true;\r\n    }\r\n    return CHART_TYPES.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\r\n}\r\nfunction isAgHierarchyChartOptions(input) {\r\n    const specifiedType = optionsType(input);\r\n    if (specifiedType == null) {\r\n        return false;\r\n    }\r\n    if (specifiedType === 'hierarchy') {\r\n        Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\r\n        return true;\r\n    }\r\n    return CHART_TYPES.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\r\n}\r\nfunction isAgPolarChartOptions(input) {\r\n    const specifiedType = optionsType(input);\r\n    if (specifiedType == null) {\r\n        return false;\r\n    }\r\n    if (specifiedType === 'polar') {\r\n        Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\r\n        return true;\r\n    }\r\n    return CHART_TYPES.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\r\n}\r\nfunction isSeriesOptionType(input) {\r\n    if (input == null) {\r\n        return false;\r\n    }\r\n    return CHART_TYPES.has(input);\r\n}\r\nfunction isAxisOptionType(input) {\r\n    if (input == null) {\r\n        return false;\r\n    }\r\n    return AXIS_TYPES.has(input);\r\n}\n\nconst DEFAULT_CARTESIAN_CHART_OVERRIDES = {\r\n    axes: [\r\n        {\r\n            type: CARTESIAN_AXIS_TYPES.NUMBER,\r\n            position: CARTESIAN_AXIS_POSITIONS.LEFT,\r\n        },\r\n        {\r\n            type: CARTESIAN_AXIS_TYPES.CATEGORY,\r\n            position: CARTESIAN_AXIS_POSITIONS.BOTTOM,\r\n        },\r\n    ],\r\n};\r\nfunction swapAxes(opts) {\r\n    var _a;\r\n    if (!isAgCartesianChartOptions(opts)) {\r\n        return opts;\r\n    }\r\n    const [axis0, axis1] = (_a = opts.axes) !== null && _a !== void 0 ? _a : [];\r\n    return Object.assign(Object.assign({}, opts), { axes: [\r\n            Object.assign(Object.assign({}, axis0), { position: axis1.position }),\r\n            Object.assign(Object.assign({}, axis1), { position: axis0.position }),\r\n        ] });\r\n}\r\nfunction resolveModuleConflicts(opts) {\r\n    var _a, _b, _c, _d;\r\n    const conflictOverrides = {};\r\n    for (const [source, conflicts] of MODULE_CONFLICTS.entries()) {\r\n        if (opts[source] == null || !conflicts.length) {\r\n            continue;\r\n        }\r\n        (_a = conflictOverrides[source]) !== null && _a !== void 0 ? _a : (conflictOverrides[source] = {});\r\n        for (const conflict of conflicts) {\r\n            if (((_b = opts[source]) === null || _b === void 0 ? void 0 : _b.enabled) && ((_c = opts[conflict]) === null || _c === void 0 ? void 0 : _c.enabled)) {\r\n                Logger.warnOnce(`the [${source}] module can not be used at the same time as [${conflict}], it will be disabled.`);\r\n                conflictOverrides[source].enabled = false;\r\n            }\r\n            else {\r\n                conflictOverrides[source].enabled = (_d = opts[source]) === null || _d === void 0 ? void 0 : _d.enabled;\r\n            }\r\n        }\r\n    }\r\n    return conflictOverrides;\r\n}\n\nconst EXTENDS_CHART_DEFAULTS = Symbol('extends-chart-defaults');\r\nconst EXTENDS_LEGEND_DEFAULTS = Symbol('extends-legend-defaults');\r\nconst EXTENDS_LEGEND_ITEM_DEFAULTS = Symbol('extends-legend-item-defaults');\r\nconst EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS = Symbol('extends-legend-item-marker-defaults');\r\nconst EXTENDS_AXES_DEFAULTS = Symbol('extends-axes-defaults');\r\nconst EXTENDS_AXES_LABEL_DEFAULTS = Symbol('extends-axes-label-defaults');\r\nconst EXTENDS_AXES_LINE_DEFAULTS = Symbol('extends-axes-line-defaults');\r\nconst EXTENDS_AXES_TICK_DEFAULTS = Symbol('extends-axes-tick-defaults');\r\nconst EXTENDS_AXES_GRID_LINE_DEFAULTS = Symbol('extends-axes-grid-line-defaults');\r\nconst EXTENDS_SERIES_DEFAULTS = Symbol('extends-series-defaults');\r\nconst EXTENDS_CARTESIAN_MARKER_DEFAULTS = Symbol('extends-cartesian-marker-defaults');\r\nconst OVERRIDE_SERIES_LABEL_DEFAULTS = Symbol('override-series-label-defaults');\r\nconst DEFAULT_FONT_FAMILY = Symbol('default-font');\r\nconst DEFAULT_LABEL_COLOUR = Symbol('default-label-colour');\r\nconst DEFAULT_INVERTED_LABEL_COLOUR = Symbol('default-inverted-label-colour');\r\nconst DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol('default-inside-series-label-colour');\r\nconst DEFAULT_MUTED_LABEL_COLOUR = Symbol('default-muted-label-colour');\r\nconst DEFAULT_AXIS_GRID_COLOUR = Symbol('default-axis-grid-colour');\r\nconst DEFAULT_AXIS_LINE_COLOUR = Symbol('default-axis-line-colour');\r\nconst DEFAULT_CROSS_LINES_COLOUR = Symbol('default-cross-lines-colour');\r\nconst DEFAULT_BACKGROUND_COLOUR = Symbol('default-background-colour');\r\nconst DEFAULT_SHADOW_COLOUR = Symbol('default-shadow-colour');\r\nconst DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS = Symbol('default-waterfall-series-positive-colors');\r\nconst DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS = Symbol('default-waterfall-series-negative-colors');\r\nconst DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS = Symbol('default-waterfall-series-total-colors');\r\nconst DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE = Symbol('default-waterfall-series-connector-line-stroke');\r\nconst DEFAULT_POLAR_SERIES_STROKE = Symbol('default-polar-series-stroke');\r\nconst DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol('default-diverging-series-colour-range');\r\nconst DEFAULT_HIERARCHY_FILLS = Symbol('default-hierarchy-fills');\r\nconst DEFAULT_HIERARCHY_STROKES = Symbol('default-hierarchy-strokes');\n\n/**\r\n * Implements a per-path \"to/from\" animation.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param paths contains paths to be animated\r\n * @param intermediateFn callback to update path\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n */\r\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\r\n    const { defaultDuration } = animationManager;\r\n    const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\r\n    const animate = (phase, path, updateFn) => {\r\n        animationManager.animate({\r\n            id: `${groupId}_${subId}_${path.id}_${phase}`,\r\n            groupId,\r\n            from: 0,\r\n            to: 1,\r\n            ease: easeOut,\r\n            onUpdate(ratio, preInit) {\r\n                if (preInit && phase !== 'removed')\r\n                    return;\r\n                path.path.clear({ trackChanges: true });\r\n                updateFn(ratio, path);\r\n                path.checkPathDirty();\r\n            },\r\n            onStop() {\r\n                if (phase !== 'added')\r\n                    return;\r\n                path.path.clear({ trackChanges: true });\r\n                updateFn(1, path);\r\n                path.checkPathDirty();\r\n            },\r\n            duration: FROM_TO_MIXINS[phase].animationDuration * defaultDuration,\r\n            delay: FROM_TO_MIXINS[phase].animationDelay * defaultDuration,\r\n        });\r\n    };\r\n    for (const path of paths) {\r\n        if (!animationManager.isSkipped()) {\r\n            animate('removed', path, removePhaseFn);\r\n            animate('updated', path, updatePhaseFn);\r\n        }\r\n        animate('added', path, addPhaseFn);\r\n    }\r\n}\n\nconst MARKER_SHAPE = predicateWithMessage((v) => isMarkerShape(v) || Object.getPrototypeOf(v) === Marker, `expecting a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`);\r\nclass SeriesMarker extends ChangeDetectable {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.enabled = true;\r\n        /** One of the predefined marker names, or a marker constructor function (for user-defined markers). */\r\n        this.shape = Circle;\r\n        this.size = 6;\r\n        this.fillOpacity = 1;\r\n        this.strokeWidth = 1;\r\n        this.strokeOpacity = 1;\r\n    }\r\n    getStyle() {\r\n        const { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\r\n        return { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\r\n    }\r\n    getDiameter() {\r\n        return this.size + this.strokeWidth;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesMarker.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(MARKER_SHAPE),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesMarker.prototype, \"shape\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], SeriesMarker.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], SeriesMarker.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Function)\r\n], SeriesMarker.prototype, \"formatter\", void 0);\n\nfunction markerFadeInAnimation({ id }, animationManager, markerSelections, status = 'unknown') {\r\n    const params = Object.assign({}, FROM_TO_MIXINS[status]);\r\n    staticFromToMotion(id, 'markers', animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\r\n    markerSelections.forEach((s) => s.cleanup());\r\n}\r\nfunction markerScaleInAnimation({ id }, animationManager, markerSelections) {\r\n    staticFromToMotion(id, 'markers', animationManager, markerSelections, { scalingX: 0, scalingY: 0 }, { scalingX: 1, scalingY: 1 });\r\n    markerSelections.forEach((s) => s.cleanup());\r\n}\r\nfunction markerSwipeScaleInAnimation({ id }, animationManager, markerSelections, seriesWidth) {\r\n    // Improves consistency with matching parallel animations.\r\n    const tweakFactor = 0.1;\r\n    const fromFn = (_, datum) => {\r\n        var _a, _b;\r\n        const x = (_b = (_a = datum.midPoint) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : seriesWidth;\r\n        // Calculate a delay that depends on the X position of the datum, so that nodes appear\r\n        // gradually from left to right. Use easeInOut to match any parallel swipe animations.\r\n        const delayRatio = easeInOut(x / seriesWidth) - tweakFactor;\r\n        const delay = Math.max(Math.min(delayRatio, 1), 0);\r\n        return { scalingX: 0, scalingY: 0, animationDelay: delay, animationDuration: QUICK_TRANSITION };\r\n    };\r\n    const toFn = () => {\r\n        return { scalingX: 1, scalingY: 1 };\r\n    };\r\n    fromToMotion(id, 'markers', animationManager, markerSelections, { fromFn, toFn });\r\n}\r\nfunction resetMarkerFn(_node) {\r\n    return { opacity: 1, scalingX: 1, scalingY: 1 };\r\n}\r\nfunction resetMarkerPositionFn(_node, datum) {\r\n    var _a, _b, _c, _d;\r\n    return {\r\n        translationX: (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : NaN,\r\n        translationY: (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : NaN,\r\n    };\r\n}\r\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\r\n    const readFirstPair = (xValue, type) => {\r\n        const val = pairMap[type][xValue];\r\n        return Array.isArray(val) ? val[0] : val;\r\n    };\r\n    const markerStatus = (datum) => {\r\n        const { xValue } = datum;\r\n        if (pairMap.moved[xValue]) {\r\n            return { point: readFirstPair(xValue, 'moved'), status: 'updated' };\r\n        }\r\n        else if (pairMap.removed[xValue]) {\r\n            return { point: readFirstPair(xValue, 'removed'), status: 'removed' };\r\n        }\r\n        else if (pairMap.added[xValue]) {\r\n            return { point: readFirstPair(xValue, 'added'), status: 'added' };\r\n        }\r\n        return { status: 'unknown' };\r\n    };\r\n    const fromFn = (marker, datum) => {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const { status, point } = markerStatus(datum);\r\n        if (status === 'unknown')\r\n            return { opacity: 0 };\r\n        const defaults = Object.assign({ translationX: (_b = (_a = point === null || point === void 0 ? void 0 : point.from) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : marker.translationX, translationY: (_d = (_c = point === null || point === void 0 ? void 0 : point.from) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : marker.translationY, opacity: marker.opacity }, FROM_TO_MIXINS[status]);\r\n        if (parentStatus === 'added') {\r\n            return Object.assign(Object.assign(Object.assign({}, defaults), { opacity: 0, translationX: (_e = point === null || point === void 0 ? void 0 : point.to) === null || _e === void 0 ? void 0 : _e.x, translationY: (_f = point === null || point === void 0 ? void 0 : point.to) === null || _f === void 0 ? void 0 : _f.y }), FROM_TO_MIXINS['added']);\r\n        }\r\n        if (status === 'added') {\r\n            defaults.opacity = 0;\r\n        }\r\n        return defaults;\r\n    };\r\n    const toFn = (_marker, datum) => {\r\n        var _a, _b;\r\n        const { status, point } = markerStatus(datum);\r\n        if (status === 'unknown')\r\n            return { opacity: 0 };\r\n        const defaults = Object.assign({ translationX: datum.point.x, translationY: datum.point.y, opacity: 1 }, FROM_TO_MIXINS[status]);\r\n        if (status === 'removed' || parentStatus === 'removed') {\r\n            return Object.assign(Object.assign(Object.assign({}, defaults), { translationX: (_a = point === null || point === void 0 ? void 0 : point.to) === null || _a === void 0 ? void 0 : _a.x, translationY: (_b = point === null || point === void 0 ? void 0 : point.to) === null || _b === void 0 ? void 0 : _b.y, opacity: 0 }), FROM_TO_MIXINS['removed']);\r\n        }\r\n        return defaults;\r\n    };\r\n    return { fromFn, toFn };\r\n}\n\nfunction minMax(nodeData) {\r\n    return nodeData.reduce(({ min, max }, node) => {\r\n        if (min == null || min.point.x > node.point.x) {\r\n            min = node;\r\n        }\r\n        if (max == null || max.point.x < node.point.x) {\r\n            max = node;\r\n        }\r\n        return { min, max };\r\n    }, {});\r\n}\r\nfunction intersectionOnLine(a, b, targetX) {\r\n    const m = (b.y - a.y) / (b.x - a.x);\r\n    // Find a point a distance along the line from `a` and `b`\r\n    const y = (targetX - a.x) * m + a.y;\r\n    return { x: targetX, y };\r\n}\r\nfunction backfillPathPoint(results, process, skip, processFn) {\r\n    let prevMarkerIdx = -1, nextMarkerIdx = 0;\r\n    const toProcess = [];\r\n    while (nextMarkerIdx < results.length) {\r\n        if (results[nextMarkerIdx].change === process) {\r\n            toProcess.push(results[nextMarkerIdx]);\r\n            nextMarkerIdx++;\r\n            continue;\r\n        }\r\n        if (results[nextMarkerIdx].change === skip) {\r\n            nextMarkerIdx++;\r\n            continue;\r\n        }\r\n        if (toProcess.length > 0) {\r\n            processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\r\n            toProcess.length = 0;\r\n        }\r\n        prevMarkerIdx = nextMarkerIdx;\r\n        nextMarkerIdx++;\r\n    }\r\n    if (toProcess.length > 0) {\r\n        processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\r\n    }\r\n}\r\nfunction backfillPathPointData(result, splitMode) {\r\n    backfillPathPoint(result, 'out', 'in', (toProcess, sIdx, eIdx) => {\r\n        var _a, _b;\r\n        if (sIdx === -1 && result[eIdx]) {\r\n            toProcess.forEach((d) => (d.to = result[eIdx].from));\r\n        }\r\n        else if (eIdx === result.length && result[sIdx]) {\r\n            toProcess.forEach((d) => (d.to = result[sIdx].from));\r\n        }\r\n        else if (splitMode === 'intersect' && ((_a = result[sIdx]) === null || _a === void 0 ? void 0 : _a.from) && ((_b = result[eIdx]) === null || _b === void 0 ? void 0 : _b.from)) {\r\n            toProcess.forEach((d) => (d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x)));\r\n        }\r\n        else {\r\n            toProcess.forEach((d) => (d.to = d.from));\r\n        }\r\n    });\r\n    backfillPathPoint(result, 'in', 'out', (toProcess, sIdx, eIdx) => {\r\n        var _a, _b;\r\n        if (sIdx === -1 && result[eIdx]) {\r\n            toProcess.forEach((d) => (d.from = result[eIdx].to));\r\n        }\r\n        else if (eIdx === result.length && result[sIdx]) {\r\n            toProcess.forEach((d) => (d.from = result[sIdx].to));\r\n        }\r\n        else if (splitMode === 'intersect' && ((_a = result[sIdx]) === null || _a === void 0 ? void 0 : _a.to) && ((_b = result[eIdx]) === null || _b === void 0 ? void 0 : _b.to)) {\r\n            toProcess.forEach((d) => (d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x)));\r\n        }\r\n        else {\r\n            toProcess.forEach((d) => (d.from = d.to));\r\n        }\r\n    });\r\n}\r\nfunction calculatePoint(from, to, ratio) {\r\n    const x1 = isNaN(from.x) ? to.x : from.x;\r\n    const y1 = isNaN(from.y) ? to.y : from.y;\r\n    const xd = to.x - from.x;\r\n    const yd = to.y - from.y;\r\n    const xr = isNaN(xd) ? 0 : xd * ratio;\r\n    const yr = isNaN(yd) ? 0 : yd * ratio;\r\n    return {\r\n        x: x1 + xr,\r\n        y: y1 + yr,\r\n    };\r\n}\r\nfunction renderPartialPath(pairData, ratios, path) {\r\n    const { path: linePath } = path;\r\n    let previousTo;\r\n    for (const data of pairData) {\r\n        const ratio = ratios[data.change];\r\n        if (ratio == null)\r\n            continue;\r\n        const { from, to } = data;\r\n        if (from == null || to == null)\r\n            continue;\r\n        const { x, y } = calculatePoint(from, to, ratio);\r\n        if (data.moveTo === false) {\r\n            linePath.lineTo(x, y);\r\n        }\r\n        else if (data.moveTo === true || !previousTo) {\r\n            linePath.moveTo(x, y);\r\n        }\r\n        else if (previousTo) {\r\n            const moveToRatio = data.moveTo === 'in' ? ratio : 1 - ratio;\r\n            const { x: midPointX, y: midPointY } = calculatePoint(previousTo, { x, y }, moveToRatio);\r\n            linePath.lineTo(midPointX, midPointY);\r\n            linePath.moveTo(x, y);\r\n        }\r\n        previousTo = { x, y };\r\n    }\r\n}\r\nfunction pathSwipeInAnimation({ id }, animationManager, paths) {\r\n    staticFromToMotion(id, 'path_properties', animationManager, paths, { clipScalingX: 0 }, { clipScalingX: 1 }, {\r\n        start: { clipMode: 'normal' },\r\n        finish: { clipMode: undefined },\r\n    });\r\n}\r\nfunction pathFadeInAnimation({ id }, subId, animationManager, selection) {\r\n    staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, LABEL_PHASE);\r\n}\r\nfunction pathFadeOutAnimation({ id }, subId, animationManager, selection) {\r\n    staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, LABEL_PHASE);\r\n}\r\nfunction buildResetPathFn(opts) {\r\n    return (_node) => {\r\n        return { opacity: opts.getOpacity(), clipScalingX: 1, clipMode: undefined };\r\n    };\r\n}\n\nfunction scale(val, scaling) {\r\n    if (!scaling)\r\n        return NaN;\r\n    if (val instanceof Date) {\r\n        val = val.getTime();\r\n    }\r\n    if (scaling.type === 'continuous' && typeof val === 'number') {\r\n        const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\r\n        return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\r\n    }\r\n    if (scaling.type === 'log' && typeof val === 'number') {\r\n        return scaling.convert(val);\r\n    }\r\n    // Category axis case.\r\n    const matchingIndex = scaling.domain.findIndex((d) => d === val);\r\n    if (matchingIndex >= 0) {\r\n        return scaling.range[matchingIndex];\r\n    }\r\n    // We failed to convert using the scale.\r\n    return NaN;\r\n}\r\nfunction closeMatch(a, b) {\r\n    const an = Number(a);\r\n    const bn = Number(b);\r\n    if (!isNaN(an) && !isNaN(bn)) {\r\n        return Math.abs(bn - an) < 0.25;\r\n    }\r\n    return a === b;\r\n}\r\nfunction calculateMoveTo(from = false, to = false) {\r\n    if (from === to) {\r\n        return !!from;\r\n    }\r\n    return from ? 'in' : 'out';\r\n}\r\nfunction pairContinuousData(newData, oldData, opts = {}) {\r\n    var _a, _b, _c, _d;\r\n    const { backfillSplitMode = 'intersect' } = opts;\r\n    const toNewScale = (oldDatum) => {\r\n        var _a, _b;\r\n        return {\r\n            x: scale((_a = oldDatum.xValue) !== null && _a !== void 0 ? _a : NaN, newData.scales.x),\r\n            y: scale((_b = oldDatum.yValue) !== null && _b !== void 0 ? _b : NaN, newData.scales.y),\r\n        };\r\n    };\r\n    const toOldScale = (newDatum) => {\r\n        var _a, _b;\r\n        return {\r\n            x: scale((_a = newDatum.xValue) !== null && _a !== void 0 ? _a : NaN, oldData.scales.x),\r\n            y: scale((_b = newDatum.yValue) !== null && _b !== void 0 ? _b : NaN, oldData.scales.y),\r\n        };\r\n    };\r\n    const result = [];\r\n    const resultMap = {\r\n        added: {},\r\n        moved: {},\r\n        removed: {},\r\n    };\r\n    const pairUp = (from, to, xValue, change = 'move') => {\r\n        if (from && (isNaN(from.point.x) || isNaN(from.point.y))) {\r\n            // Default to 'to' position if 'from' is invalid.\r\n            from = to;\r\n        }\r\n        const resultPoint = {\r\n            from: from === null || from === void 0 ? void 0 : from.point,\r\n            to: to === null || to === void 0 ? void 0 : to.point,\r\n            moveTo: calculateMoveTo(from === null || from === void 0 ? void 0 : from.point.moveTo, to === null || to === void 0 ? void 0 : to.point.moveTo),\r\n            change,\r\n        };\r\n        if (change === 'move') {\r\n            resultMap.moved[xValue] = resultPoint;\r\n            oldIdx++;\r\n            newIdx++;\r\n        }\r\n        else if (change === 'in') {\r\n            resultMap.added[xValue] = resultPoint;\r\n            newIdx++;\r\n        }\r\n        else if (change === 'out') {\r\n            resultMap.removed[xValue] = resultPoint;\r\n            oldIdx++;\r\n        }\r\n        result.push(resultPoint);\r\n    };\r\n    const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\r\n    const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\r\n    let oldIdx = 0;\r\n    let newIdx = 0;\r\n    while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\r\n        const from = oldData.nodeData[oldIdx];\r\n        const to = newData.nodeData[newIdx];\r\n        const fromShifted = from ? toNewScale(from) : undefined;\r\n        const toUnshifted = to ? toOldScale(to) : undefined;\r\n        const NA = undefined;\r\n        if (fromShifted && closeMatch(fromShifted.x, to === null || to === void 0 ? void 0 : to.point.x)) {\r\n            pairUp(from, to, to.xValue, 'move');\r\n        }\r\n        else if (fromShifted && fromShifted.x < ((_a = minToNode === null || minToNode === void 0 ? void 0 : minToNode.point.x) !== null && _a !== void 0 ? _a : -Infinity)) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (fromShifted && fromShifted.x > ((_b = maxToNode === null || maxToNode === void 0 ? void 0 : maxToNode.point.x) !== null && _b !== void 0 ? _b : Infinity)) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (toUnshifted && toUnshifted.x < ((_c = minFromNode === null || minFromNode === void 0 ? void 0 : minFromNode.point.x) !== null && _c !== void 0 ? _c : -Infinity)) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else if (toUnshifted && toUnshifted.x > ((_d = maxFromNode === null || maxFromNode === void 0 ? void 0 : maxFromNode.point.x) !== null && _d !== void 0 ? _d : Infinity)) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else if (fromShifted && fromShifted.x < (to === null || to === void 0 ? void 0 : to.point.x)) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (toUnshifted && toUnshifted.x < (from === null || from === void 0 ? void 0 : from.point.x)) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else if (from) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (to) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else {\r\n            throw new Error('Unable to process points');\r\n        }\r\n    }\r\n    backfillPathPointData(result, backfillSplitMode);\r\n    return { result, resultMap };\r\n}\r\nfunction pairCategoryData(newData, oldData, diff, opts = {}) {\r\n    var _a, _b, _c;\r\n    const { backfillSplitMode = 'intersect', multiDatum = false } = opts;\r\n    const result = [];\r\n    const resultMapSingle = {\r\n        added: {},\r\n        moved: {},\r\n        removed: {},\r\n    };\r\n    const resultMapMulti = {\r\n        added: {},\r\n        moved: {},\r\n        removed: {},\r\n    };\r\n    let previousResultPoint = undefined;\r\n    let previousXValue = undefined;\r\n    const addToResultMap = (xValue, result) => {\r\n        var _a;\r\n        var _b;\r\n        const type = result.change === 'move' ? 'moved' : result.change === 'in' ? 'added' : 'removed';\r\n        if (multiDatum) {\r\n            (_a = (_b = resultMapMulti[type])[xValue]) !== null && _a !== void 0 ? _a : (_b[xValue] = []);\r\n            resultMapMulti[type][xValue].push(result);\r\n        }\r\n        else {\r\n            resultMapSingle[type][xValue] = result;\r\n        }\r\n        previousResultPoint = result;\r\n        previousXValue = xValue;\r\n    };\r\n    let oldIndex = 0;\r\n    let newIndex = 0;\r\n    let isXUnordered = false;\r\n    while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\r\n        const before = oldData.nodeData[oldIndex];\r\n        const after = newData.nodeData[newIndex];\r\n        let resultPoint;\r\n        if ((before === null || before === void 0 ? void 0 : before.xValue) === (after === null || after === void 0 ? void 0 : after.xValue)) {\r\n            resultPoint = {\r\n                change: 'move',\r\n                moveTo: calculateMoveTo((_a = before.point.moveTo) !== null && _a !== void 0 ? _a : false, after.point.moveTo),\r\n                from: before.point,\r\n                to: after.point,\r\n            };\r\n            addToResultMap(before.xValue, resultPoint);\r\n            oldIndex++;\r\n            newIndex++;\r\n        }\r\n        else if (diff.removed.indexOf(before === null || before === void 0 ? void 0 : before.xValue) >= 0) {\r\n            resultPoint = {\r\n                change: 'out',\r\n                moveTo: (_b = before.point.moveTo) !== null && _b !== void 0 ? _b : false,\r\n                from: before.point,\r\n            };\r\n            addToResultMap(before.xValue, resultPoint);\r\n            oldIndex++;\r\n        }\r\n        else if (diff.added.indexOf(after === null || after === void 0 ? void 0 : after.xValue) >= 0) {\r\n            resultPoint = {\r\n                change: 'in',\r\n                moveTo: (_c = after.point.moveTo) !== null && _c !== void 0 ? _c : false,\r\n                to: after.point,\r\n            };\r\n            addToResultMap(after.xValue, resultPoint);\r\n            newIndex++;\r\n        }\r\n        else if (multiDatum && previousResultPoint && previousXValue === (before === null || before === void 0 ? void 0 : before.xValue)) {\r\n            resultPoint = Object.assign({}, previousResultPoint);\r\n            addToResultMap(before.xValue, resultPoint);\r\n            oldIndex++;\r\n        }\r\n        else if (multiDatum && previousResultPoint && previousXValue === (after === null || after === void 0 ? void 0 : after.xValue)) {\r\n            resultPoint = Object.assign({}, previousResultPoint);\r\n            addToResultMap(after.xValue, resultPoint);\r\n            newIndex++;\r\n        }\r\n        else {\r\n            isXUnordered = true;\r\n            break;\r\n        }\r\n        result.push(resultPoint);\r\n    }\r\n    let previousX = -Infinity;\r\n    isXUnordered || (isXUnordered = result.some((pathPoint) => {\r\n        const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\r\n        if (marker === 'out')\r\n            return;\r\n        const result = x < previousX;\r\n        previousX = x;\r\n        return result;\r\n    }));\r\n    if (isXUnordered) {\r\n        return { result: undefined, resultMap: undefined };\r\n    }\r\n    backfillPathPointData(result, backfillSplitMode);\r\n    if (multiDatum) {\r\n        return { result, resultMap: resultMapMulti };\r\n    }\r\n    return { result, resultMap: resultMapSingle };\r\n}\r\nfunction determinePathStatus(newData, oldData) {\r\n    let status = 'updated';\r\n    const visible = (data) => {\r\n        return data.visible;\r\n    };\r\n    if (!visible(oldData) && visible(newData)) {\r\n        status = 'added';\r\n    }\r\n    else if (visible(oldData) && !visible(newData)) {\r\n        status = 'removed';\r\n    }\r\n    return status;\r\n}\r\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\r\n    const phase = visibleToggleMode === 'none' ? 'updated' : status;\r\n    const result = {\r\n        fromFn: (_path) => {\r\n            let mixin;\r\n            if (status === 'removed') {\r\n                mixin = { finish: { visible: false } };\r\n            }\r\n            else if (status === 'added') {\r\n                mixin = { start: { visible: true } };\r\n            }\r\n            else {\r\n                mixin = {};\r\n            }\r\n            return Object.assign(Object.assign({}, FROM_TO_MIXINS[phase]), mixin);\r\n        },\r\n        toFn: (_path) => {\r\n            return Object.assign({}, FROM_TO_MIXINS[phase]);\r\n        },\r\n    };\r\n    if (visibleToggleMode === 'fade') {\r\n        return {\r\n            fromFn: (path) => {\r\n                const opacity = status === 'added' ? 0 : path.opacity;\r\n                return Object.assign({ opacity }, result.fromFn(path));\r\n            },\r\n            toFn: (path) => {\r\n                const opacity = status === 'removed' ? 0 : 1;\r\n                return Object.assign({ opacity }, result.toFn(path));\r\n            },\r\n        };\r\n    }\r\n    return result;\r\n}\r\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, render) {\r\n    const status = determinePathStatus(newData, oldData);\r\n    const removePhaseFn = (ratio, path) => {\r\n        render(pairData, { move: 0, out: ratio }, path);\r\n    };\r\n    const updatePhaseFn = (ratio, path) => {\r\n        render(pairData, { move: ratio }, path);\r\n    };\r\n    const addPhaseFn = (ratio, path) => {\r\n        render(pairData, { move: 1, in: ratio }, path);\r\n    };\r\n    const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\r\n    return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\r\n}\r\nfunction prepareLinePathAnimation(newData, oldData, diff) {\r\n    var _a;\r\n    const isCategoryBased = ((_a = newData.scales.x) === null || _a === void 0 ? void 0 : _a.type) === 'category';\r\n    const { result: pairData, resultMap: pairMap } = isCategoryBased && diff ? pairCategoryData(newData, oldData, diff) : pairContinuousData(newData, oldData);\r\n    let status = 'updated';\r\n    if (oldData.visible && !newData.visible) {\r\n        status = 'removed';\r\n    }\r\n    else if (!oldData.visible && newData.visible) {\r\n        status = 'added';\r\n    }\r\n    if (pairData === undefined || pairMap === undefined) {\r\n        return;\r\n    }\r\n    const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, 'fade', renderPartialPath);\r\n    const marker = prepareMarkerAnimation(pairMap, status);\r\n    return Object.assign(Object.assign({}, pathFns), { marker });\r\n}\n\nvar AreaSeriesTag;\r\n(function (AreaSeriesTag) {\r\n    AreaSeriesTag[AreaSeriesTag[\"Fill\"] = 0] = \"Fill\";\r\n    AreaSeriesTag[AreaSeriesTag[\"Stroke\"] = 1] = \"Stroke\";\r\n    AreaSeriesTag[AreaSeriesTag[\"Marker\"] = 2] = \"Marker\";\r\n    AreaSeriesTag[AreaSeriesTag[\"Label\"] = 3] = \"Label\";\r\n})(AreaSeriesTag || (AreaSeriesTag = {}));\r\nfunction splitFillPoints(context) {\r\n    const { points } = context.fillData;\r\n    return { top: points.slice(0, points.length / 2), bottom: points.slice(points.length / 2).reverse() };\r\n}\r\nfunction prepPoints(key, ctx, points) {\r\n    return {\r\n        scales: ctx.scales,\r\n        nodeData: points[key],\r\n        visible: ctx.visible,\r\n    };\r\n}\r\nfunction pairFillCategoryData(newData, oldData, diff) {\r\n    const oldPoints = splitFillPoints(oldData);\r\n    const newPoints = splitFillPoints(newData);\r\n    const pairOpts = { multiDatum: true };\r\n    return {\r\n        top: pairCategoryData(prepPoints('top', newData, newPoints), prepPoints('top', oldData, oldPoints), diff, pairOpts),\r\n        bottom: pairCategoryData(prepPoints('bottom', newData, newPoints), prepPoints('bottom', oldData, oldPoints), diff, pairOpts),\r\n    };\r\n}\r\nfunction pairFillContinuousData(newData, oldData) {\r\n    const oldPoints = splitFillPoints(oldData);\r\n    const newPoints = splitFillPoints(newData);\r\n    return {\r\n        top: pairContinuousData(prepPoints('top', newData, newPoints), prepPoints('top', oldData, oldPoints)),\r\n        bottom: pairContinuousData(prepPoints('bottom', newData, newPoints), prepPoints('bottom', oldData, oldPoints)),\r\n    };\r\n}\r\nfunction prepareAreaPathAnimation(newData, oldData, diff) {\r\n    var _a;\r\n    const isCategoryBased = ((_a = newData.scales.x) === null || _a === void 0 ? void 0 : _a.type) === 'category';\r\n    let status = 'updated';\r\n    if (oldData.visible && !newData.visible) {\r\n        status = 'removed';\r\n    }\r\n    else if (!oldData.visible && newData.visible) {\r\n        status = 'added';\r\n    }\r\n    const prepareMarkerPairs = () => {\r\n        if (isCategoryBased && diff) {\r\n            return pairCategoryData(newData, oldData, diff, { backfillSplitMode: 'static', multiDatum: true });\r\n        }\r\n        return pairContinuousData(newData, oldData, { backfillSplitMode: 'static' });\r\n    };\r\n    const prepareFillPairs = () => {\r\n        if (isCategoryBased && diff) {\r\n            return pairFillCategoryData(newData, oldData, diff);\r\n        }\r\n        return pairFillContinuousData(newData, oldData);\r\n    };\r\n    const { resultMap: markerPairMap } = prepareMarkerPairs();\r\n    const { top, bottom } = prepareFillPairs();\r\n    if (markerPairMap === undefined || top.result === undefined || bottom.result === undefined) {\r\n        return;\r\n    }\r\n    const pairData = [...top.result, ...bottom.result.reverse()];\r\n    const fill = prepareLinePathAnimationFns(newData, oldData, pairData, 'none', renderPartialPath);\r\n    const marker = prepareMarkerAnimation(markerPairMap, status);\r\n    return { fill, marker };\r\n}\n\nclass AreaSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pathsPerSeries: 2,\r\n            pathsZIndexSubOrderOffset: [0, 1000],\r\n            hasMarkers: true,\r\n            markerSelectionGarbageCollection: false,\r\n            pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST, SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            animationResetFns: {\r\n                path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),\r\n                label: resetLabelFn,\r\n                marker: (node, datum) => (Object.assign(Object.assign({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))),\r\n            },\r\n        });\r\n        this.tooltip = new SeriesTooltip();\r\n        this.marker = new SeriesMarker();\r\n        this.label = new Label();\r\n        this.fill = '#c16068';\r\n        this.stroke = '#874349';\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.xKey = undefined;\r\n        this.xName = undefined;\r\n        this.strokeWidth = 2;\r\n        this.shadow = undefined;\r\n    }\r\n    processData(dataController) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, normalizedTo, data, visible, seriesGrouping: { groupIndex = this.id } = {} } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const ids = [\r\n                `area-stack-${groupIndex}-yValues`,\r\n                `area-stack-${groupIndex}-yValues-trailing`,\r\n                `area-stack-${groupIndex}-yValues-prev`,\r\n                `area-stack-${groupIndex}-yValues-trailing-prev`,\r\n                `area-stack-${groupIndex}-yValues-marker`,\r\n            ];\r\n            const extraProps = [];\r\n            const normaliseTo = normalizedTo && isFinite(normalizedTo) ? normalizedTo : undefined;\r\n            if (normaliseTo) {\r\n                extraProps.push(normaliseGroupTo(this, [ids[0], ids[1], ids[4]], normaliseTo, 'range'));\r\n                extraProps.push(normaliseGroupTo(this, [ids[2], ids[3]], normaliseTo, 'range'));\r\n            }\r\n            // If two or more datums share an x-value, i.e. lined up vertically, they will have the same datum id.\r\n            // They must be identified this way when animated to ensure they can be tracked when their y-value\r\n            // is updated. If this is a static chart, we can instead not bother with identifying datums and\r\n            // automatically garbage collect the marker selection.\r\n            if (!isContinuousX && animationEnabled && this.processedData) {\r\n                extraProps.push(diff(this.processedData));\r\n            }\r\n            if (animationEnabled) {\r\n                extraProps.push(animationValidation(this));\r\n            }\r\n            const common = { invalidValue: null };\r\n            if (!visible) {\r\n                common.forceValue = 0;\r\n            }\r\n            yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xValue' }),\r\n                    valueProperty(this, yKey, isContinuousY, Object.assign({ id: `yValueRaw` }, common)),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window', 'current', Object.assign(Object.assign({ id: `yValueEnd` }, common), { groupId: ids[0] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window-trailing', 'current', Object.assign(Object.assign({ id: `yValueStart` }, common), { groupId: ids[1] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window', 'last', Object.assign(Object.assign({ id: `yValuePreviousEnd` }, common), { groupId: ids[2] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window-trailing', 'last', Object.assign(Object.assign({ id: `yValuePreviousStart` }, common), { groupId: ids[3] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'normal', 'current', Object.assign(Object.assign({ id: `yValueCumulative` }, common), { groupId: ids[4] })),\r\n                    ...extraProps,\r\n                ],\r\n                groupByKeys: true,\r\n            });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { processedData, dataModel, axes } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\r\n        const keys = dataModel.getDomain(this, `xValue`, 'key', processedData);\r\n        const yExtent = dataModel.getDomain(this, `yValueEnd`, 'value', processedData);\r\n        if (direction === ChartAxisDirection.X) {\r\n            if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === 'key' && keyDef.def.valueType === 'category') {\r\n                return keys;\r\n            }\r\n            return fixNumericExtent(extent(keys), xAxis);\r\n        }\r\n        else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\r\n            return fixNumericExtent(yExtent, yAxis);\r\n        }\r\n        else {\r\n            const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\r\n            return fixNumericExtent(fixedYExtent, yAxis);\r\n        }\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!xAxis || !yAxis || !data || !dataModel) {\r\n                return [];\r\n            }\r\n            const { yKey = '', xKey = '', marker, label, fill: seriesFill, stroke: seriesStroke } = this;\r\n            const { scale: xScale } = xAxis;\r\n            const { scale: yScale } = yAxis;\r\n            const continuousY = ContinuousScale.is(yScale);\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const defs = dataModel.resolveProcessedDataDefsByIds(this, [\r\n                `yValueStart`,\r\n                `yValueEnd`,\r\n                `yValueRaw`,\r\n                `yValuePreviousStart`,\r\n                `yValuePreviousEnd`,\r\n                `yValueCumulative`,\r\n            ]);\r\n            const createMovePoint = (plainPoint) => {\r\n                const { point } = plainPoint, stroke = __rest(plainPoint, [\"point\"]);\r\n                return Object.assign(Object.assign({}, stroke), { point: Object.assign(Object.assign({}, point), { moveTo: true }) });\r\n            };\r\n            const createPathCoordinates = (xValue, lastYEnd, yEnd) => {\r\n                const x = xScale.convert(xValue) + xOffset;\r\n                const prevYCoordinate = yScale.convert(lastYEnd);\r\n                const currYCoordinate = yScale.convert(yEnd);\r\n                return [\r\n                    { point: { x, y: currYCoordinate }, yValue: yEnd, xValue },\r\n                    { point: { x, y: prevYCoordinate }, yValue: lastYEnd, xValue },\r\n                ];\r\n            };\r\n            const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\r\n                let currY;\r\n                // if not normalized, the invalid data points will be processed as `undefined` in processData()\r\n                // if normalized, the invalid data points will be processed as 0 rather than `undefined`\r\n                // check if unprocessed datum is valid as we only want to show markers for valid points\r\n                const normalized = this.normalizedTo && isFinite(this.normalizedTo);\r\n                const normalizedAndValid = normalized && continuousY && isContinuous(rawYDatum);\r\n                const valid = (!normalized && !isNaN(rawYDatum)) || normalizedAndValid;\r\n                if (valid) {\r\n                    currY = yEnd;\r\n                }\r\n                const x = xScale.convert(xDatum) + xOffset;\r\n                const y = yScale.convert(currY);\r\n                return { x, y, size: marker.size };\r\n            };\r\n            const itemId = yKey;\r\n            const labelData = [];\r\n            const markerData = [];\r\n            const context = {\r\n                itemId,\r\n                fillData: { itemId, points: [] },\r\n                strokeData: { itemId, points: [] },\r\n                labelData,\r\n                nodeData: markerData,\r\n                scales: _super.calculateScaling.call(this),\r\n                visible: this.visible,\r\n            };\r\n            const fillPoints = context.fillData.points;\r\n            const fillPhantomPoints = [];\r\n            const strokePoints = context.strokeData.points;\r\n            let datumIdx = -1;\r\n            let lastXDatum;\r\n            let lastYDatum = -Infinity;\r\n            groupedData === null || groupedData === void 0 ? void 0 : groupedData.forEach((datumGroup) => {\r\n                const { keys, keys: [xDatum], datum: datumArray, values: valuesArray, } = datumGroup;\r\n                valuesArray.forEach((values, valueIdx) => {\r\n                    var _a, _b, _c;\r\n                    datumIdx++;\r\n                    const seriesDatum = datumArray[valueIdx];\r\n                    const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\r\n                    const { yValueRaw: yDatum, yValueCumulative } = dataValues;\r\n                    let { yValueStart, yValueEnd, yValuePreviousStart, yValuePreviousEnd } = dataValues;\r\n                    const validPoint = yDatum != null;\r\n                    // marker data\r\n                    const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\r\n                    if (validPoint && marker) {\r\n                        markerData.push({\r\n                            index: datumIdx,\r\n                            series: this,\r\n                            itemId,\r\n                            datum: seriesDatum,\r\n                            midPoint: { x: point.x, y: point.y },\r\n                            cumulativeValue: yValueEnd,\r\n                            yValue: yDatum,\r\n                            xValue: xDatum,\r\n                            yKey,\r\n                            xKey,\r\n                            point,\r\n                            fill: (_a = marker.fill) !== null && _a !== void 0 ? _a : seriesFill,\r\n                            stroke: (_b = marker.stroke) !== null && _b !== void 0 ? _b : seriesStroke,\r\n                            strokeWidth: (_c = marker.strokeWidth) !== null && _c !== void 0 ? _c : this.getStrokeWidth(this.strokeWidth),\r\n                        });\r\n                    }\r\n                    // label data\r\n                    if (validPoint && label) {\r\n                        const labelText = this.getLabelText(label, {\r\n                            value: yDatum,\r\n                            datum: seriesDatum,\r\n                            xKey,\r\n                            yKey,\r\n                            xName: this.xName,\r\n                            yName: this.yName,\r\n                        }, (value) => (isNumber(value) ? value.toFixed(2) : String(value)));\r\n                        labelData.push({\r\n                            index: datumIdx,\r\n                            series: this,\r\n                            itemId: yKey,\r\n                            datum: seriesDatum,\r\n                            x: point.x,\r\n                            y: point.y,\r\n                            label: labelText\r\n                                ? {\r\n                                    text: labelText,\r\n                                    fontStyle: label.fontStyle,\r\n                                    fontWeight: label.fontWeight,\r\n                                    fontSize: label.fontSize,\r\n                                    fontFamily: label.fontFamily,\r\n                                    textAlign: 'center',\r\n                                    textBaseline: 'bottom',\r\n                                    fill: label.color,\r\n                                }\r\n                                : undefined,\r\n                        });\r\n                    }\r\n                    // fill data\r\n                    if (lastYDatum == null || yDatum == null) {\r\n                        // Reset all coordinates to 'zero' value.\r\n                        yValueStart = yValueStart !== null && yValueStart !== void 0 ? yValueStart : 0;\r\n                        yValueEnd = yValueStart !== null && yValueStart !== void 0 ? yValueStart : 0;\r\n                        yValuePreviousStart = yValuePreviousStart !== null && yValuePreviousStart !== void 0 ? yValuePreviousStart : 0;\r\n                        yValuePreviousEnd = yValuePreviousStart !== null && yValuePreviousStart !== void 0 ? yValuePreviousStart : 0;\r\n                    }\r\n                    const [prevTop, prevBottom] = createPathCoordinates(lastXDatum, yValuePreviousStart, yValuePreviousEnd);\r\n                    const [top, bottom] = createPathCoordinates(xDatum, yValueStart, yValueEnd);\r\n                    const xValid = lastXDatum != null && xDatum != null;\r\n                    if (xValid) {\r\n                        fillPoints.push(prevTop);\r\n                        fillPhantomPoints.push(prevBottom);\r\n                        fillPoints.push(top);\r\n                        fillPhantomPoints.push(bottom);\r\n                    }\r\n                    // stroke data\r\n                    if (validPoint && lastYDatum != null && datumIdx > 0) {\r\n                        strokePoints.push(createMovePoint(prevTop));\r\n                        strokePoints.push(top);\r\n                    }\r\n                    lastXDatum = xDatum;\r\n                    lastYDatum = yDatum;\r\n                });\r\n            });\r\n            if (strokePoints.length > 0) {\r\n                strokePoints[0] = createMovePoint(strokePoints[0]);\r\n            }\r\n            fillPhantomPoints.reverse();\r\n            fillPoints.push(...fillPhantomPoints);\r\n            return [context];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updatePathNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { opacity, visible, animationEnabled } = opts;\r\n            const [fill, stroke] = opts.paths;\r\n            const { seriesRectHeight: height, seriesRectWidth: width } = this.nodeDataDependencies;\r\n            const strokeWidth = this.getStrokeWidth(this.strokeWidth);\r\n            stroke.setProperties({\r\n                tag: AreaSeriesTag.Stroke,\r\n                fill: undefined,\r\n                lineJoin: (stroke.lineCap = 'round'),\r\n                pointerEvents: PointerEvents.None,\r\n                stroke: this.stroke,\r\n                strokeWidth,\r\n                strokeOpacity: this.strokeOpacity,\r\n                lineDash: this.lineDash,\r\n                lineDashOffset: this.lineDashOffset,\r\n                opacity,\r\n                visible,\r\n            });\r\n            fill.setProperties({\r\n                tag: AreaSeriesTag.Fill,\r\n                stroke: undefined,\r\n                lineJoin: 'round',\r\n                pointerEvents: PointerEvents.None,\r\n                fill: this.fill,\r\n                fillOpacity: this.fillOpacity,\r\n                lineDash: this.lineDash,\r\n                lineDashOffset: this.lineDashOffset,\r\n                strokeOpacity: this.strokeOpacity,\r\n                fillShadow: this.shadow,\r\n                opacity,\r\n                visible: visible || animationEnabled,\r\n                strokeWidth,\r\n            });\r\n            const updateClipPath = (path) => {\r\n                var _a, _b;\r\n                if (path.clipPath == null) {\r\n                    path.clipPath = new Path2D();\r\n                    path.clipScalingX = 1;\r\n                    path.clipScalingY = 1;\r\n                }\r\n                (_a = path.clipPath) === null || _a === void 0 ? void 0 : _a.clear({ trackChanges: true });\r\n                (_b = path.clipPath) === null || _b === void 0 ? void 0 : _b.rect(-25, -25, (width !== null && width !== void 0 ? width : 0) + 50, (height !== null && height !== void 0 ? height : 0) + 50);\r\n            };\r\n            updateClipPath(stroke);\r\n            updateClipPath(fill);\r\n        });\r\n    }\r\n    updatePaths(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.updateAreaPaths([opts.paths], [opts.contextData]);\r\n        });\r\n    }\r\n    updateAreaPaths(paths, contextData) {\r\n        this.updateFillPath(paths, contextData);\r\n        this.updateStrokePath(paths, contextData);\r\n    }\r\n    updateFillPath(paths, contextData) {\r\n        contextData.forEach(({ fillData }, contextDataIndex) => {\r\n            const [fill] = paths[contextDataIndex];\r\n            const { path: fillPath } = fill;\r\n            fillPath.clear({ trackChanges: true });\r\n            for (const { point } of fillData.points) {\r\n                if (point.moveTo) {\r\n                    fillPath.moveTo(point.x, point.y);\r\n                }\r\n                else {\r\n                    fillPath.lineTo(point.x, point.y);\r\n                }\r\n            }\r\n            fillPath.closePath();\r\n            fill.checkPathDirty();\r\n        });\r\n    }\r\n    updateStrokePath(paths, contextData) {\r\n        contextData.forEach(({ strokeData }, contextDataIndex) => {\r\n            const [, stroke] = paths[contextDataIndex];\r\n            const { path: strokePath } = stroke;\r\n            strokePath.clear({ trackChanges: true });\r\n            for (const { point } of strokeData.points) {\r\n                if (point.moveTo) {\r\n                    strokePath.moveTo(point.x, point.y);\r\n                }\r\n                else {\r\n                    strokePath.lineTo(point.x, point.y);\r\n                }\r\n            }\r\n            stroke.checkPathDirty();\r\n        });\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, markerSelection } = opts;\r\n            const { marker: { enabled }, } = this;\r\n            const data = enabled && nodeData ? nodeData : [];\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            return markerSelection.update(data);\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const { xKey = '', yKey = '', marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity } = this;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle(), {\r\n                fill,\r\n                stroke,\r\n                strokeWidth,\r\n                fillOpacity,\r\n                strokeOpacity,\r\n            });\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelData, labelSelection } = opts;\r\n            return labelSelection.update(labelData, (text) => {\r\n                text.tag = AreaSeriesTag.Label;\r\n            });\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.label;\r\n            labelSelection.each((text, datum) => {\r\n                const { x, y, label } = datum;\r\n                if (label && labelEnabled && this.visible) {\r\n                    text.fontStyle = fontStyle;\r\n                    text.fontWeight = fontWeight;\r\n                    text.fontSize = fontSize;\r\n                    text.fontFamily = fontFamily;\r\n                    text.textAlign = label.textAlign;\r\n                    text.textBaseline = label.textBaseline;\r\n                    text.text = label.text;\r\n                    text.x = x;\r\n                    text.y = y - 10;\r\n                    text.fill = color;\r\n                    text.visible = true;\r\n                }\r\n                else {\r\n                    text.visible = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        const { xKey, id: seriesId, axes, xName, yName, tooltip, marker, dataModel } = this;\r\n        const { yKey, xValue, yValue, datum } = nodeDatum;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!(xKey && yKey) || !(xAxis && yAxis && isNumber(yValue)) || !dataModel) {\r\n            return '';\r\n        }\r\n        const xString = xAxis.formatDatum(xValue);\r\n        const yString = yAxis.formatDatum(yValue);\r\n        const title = sanitizeHtml(yName);\r\n        const content = sanitizeHtml(xString + ': ' + yString);\r\n        const baseStyle = mergeDefaults({ fill: this.fill }, marker.getStyle(), {\r\n            stroke: this.stroke,\r\n            strokeWidth: this.strokeWidth,\r\n        });\r\n        const { fill: color } = this.getMarkerStyle(marker, { datum: nodeDatum, xKey, yKey, highlighted: false }, baseStyle);\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, {\r\n            datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            color,\r\n            title,\r\n            seriesId,\r\n        });\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { data, id, xKey, yKey, yName, marker, fill, stroke, fillOpacity, strokeOpacity, visible } = this;\r\n        if (!(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKey || legendType !== 'category') {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType,\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: yName !== null && yName !== void 0 ? yName : yKey,\r\n                },\r\n                marker: {\r\n                    shape: marker.shape,\r\n                    fill: (_a = marker.fill) !== null && _a !== void 0 ? _a : fill,\r\n                    stroke: (_b = marker.stroke) !== null && _b !== void 0 ? _b : stroke,\r\n                    fillOpacity: (_c = marker.fillOpacity) !== null && _c !== void 0 ? _c : fillOpacity,\r\n                    strokeOpacity: (_d = marker.strokeOpacity) !== null && _d !== void 0 ? _d : strokeOpacity,\r\n                    strokeWidth: (_e = marker.strokeWidth) !== null && _e !== void 0 ? _e : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady(animationData) {\r\n        const { markerSelections, labelSelections, contextData, paths } = animationData;\r\n        const { animationManager } = this.ctx;\r\n        const { seriesRectWidth: width = 0 } = this.nodeDataDependencies;\r\n        this.updateAreaPaths(paths, contextData);\r\n        pathSwipeInAnimation(this, animationManager, paths.flat());\r\n        resetMotion(markerSelections, resetMarkerPositionFn);\r\n        markerSwipeScaleInAnimation(this, animationManager, markerSelections, width);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n    }\r\n    animateReadyResize(animationData) {\r\n        const { contextData, paths } = animationData;\r\n        this.updateAreaPaths(paths, contextData);\r\n        super.animateReadyResize(animationData);\r\n    }\r\n    animateWaitingUpdateReady(animationData) {\r\n        var _a, _b;\r\n        const { animationManager } = this.ctx;\r\n        const { markerSelections, labelSelections, contextData, paths, previousContextData } = animationData;\r\n        super.resetAllAnimation(animationData);\r\n        if (contextData.length === 0 || !previousContextData || previousContextData.length === 0) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateAreaPaths(paths, contextData);\r\n            return;\r\n        }\r\n        const [[fill, stroke]] = paths;\r\n        const [newData] = contextData;\r\n        const [oldData] = previousContextData;\r\n        const fns = prepareAreaPathAnimation(newData, oldData, (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff);\r\n        if (fns === undefined) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateAreaPaths(paths, contextData);\r\n            return;\r\n        }\r\n        fromToMotion(this.id, 'marker_update', animationManager, markerSelections, fns.marker);\r\n        fromToMotion(this.id, 'fill_path_properties', animationManager, [fill], fns.fill.pathProperties);\r\n        pathMotion(this.id, 'fill_path_update', animationManager, [fill], fns.fill.path);\r\n        this.updateStrokePath(paths, contextData);\r\n        pathFadeInAnimation(this, 'stroke', animationManager, [stroke]);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nAreaSeries.className = 'AreaSeries';\r\nAreaSeries.type = 'area';\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], AreaSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], AreaSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], AreaSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AreaSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AreaSeries.prototype, \"normalizedTo\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], AreaSeries.prototype, \"strokeWidth\", void 0);\n\nconst AreaSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'area',\r\n    instanceConstructor: AreaSeries,\r\n    stackable: true,\r\n    seriesDefaults: DEFAULT_CARTESIAN_CHART_OVERRIDES,\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        nodeClickRange: 'nearest',\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        fillOpacity: 0.8,\r\n        strokeOpacity: 1,\r\n        strokeWidth: 0,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            enabled: false,\r\n            fillOpacity: 1,\r\n            strokeOpacity: 1,\r\n            strokeWidth: 0,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            formatter: undefined,\r\n        },\r\n    },\r\n    paletteFactory: (params) => {\r\n        const { marker } = markerPaletteFactory(params);\r\n        return {\r\n            fill: marker.fill,\r\n            stroke: marker.stroke,\r\n            marker,\r\n        };\r\n    },\r\n};\n\nclass AbstractBarSeries extends CartesianSeries {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.direction = 'vertical';\r\n    }\r\n    getBandScalePadding() {\r\n        return { inner: 0.2, outer: 0.1 };\r\n    }\r\n    shouldFlipXY() {\r\n        return this.direction === 'horizontal';\r\n    }\r\n    getBarDirection() {\r\n        return this.shouldFlipXY() ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n    }\r\n    getCategoryDirection() {\r\n        return this.shouldFlipXY() ? ChartAxisDirection.Y : ChartAxisDirection.X;\r\n    }\r\n    getValueAxis() {\r\n        const direction = this.getBarDirection();\r\n        return this.axes[direction];\r\n    }\r\n    getCategoryAxis() {\r\n        const direction = this.getCategoryDirection();\r\n        return this.axes[direction];\r\n    }\r\n}\r\n__decorate([\r\n    Validate(DIRECTION),\r\n    __metadata(\"design:type\", String)\r\n], AbstractBarSeries.prototype, \"direction\", void 0);\n\nfunction updateRect({ rect, config }) {\r\n    const { crisp = true, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, lineDash, lineDashOffset, fillShadow, visible = true, } = config;\r\n    rect.crisp = crisp;\r\n    rect.fill = fill;\r\n    rect.stroke = stroke;\r\n    rect.strokeWidth = strokeWidth;\r\n    rect.fillOpacity = fillOpacity;\r\n    rect.strokeOpacity = strokeOpacity;\r\n    rect.lineDash = lineDash;\r\n    rect.lineDashOffset = lineDashOffset;\r\n    rect.fillShadow = fillShadow;\r\n    rect.visible = visible;\r\n}\r\nfunction getRectConfig(_a) {\r\n    var _b, _c, _d, _e, _f;\r\n    var { datum, isHighlighted, style, highlightStyle, formatter, seriesId, ctx: { callbackCache } } = _a, opts = __rest(_a, [\"datum\", \"isHighlighted\", \"style\", \"highlightStyle\", \"formatter\", \"seriesId\", \"ctx\"]);\r\n    const { fill, fillOpacity, stroke, strokeWidth } = mergeDefaults(isHighlighted && highlightStyle, style);\r\n    const { strokeOpacity, fillShadow, lineDash, lineDashOffset } = style;\r\n    let format;\r\n    if (formatter) {\r\n        format = callbackCache.call(formatter, Object.assign({ datum: datum.datum, xKey: datum.xKey, fill,\r\n            stroke,\r\n            strokeWidth, highlighted: isHighlighted, seriesId }, opts));\r\n    }\r\n    return {\r\n        fill: (_b = format === null || format === void 0 ? void 0 : format.fill) !== null && _b !== void 0 ? _b : fill,\r\n        stroke: (_c = format === null || format === void 0 ? void 0 : format.stroke) !== null && _c !== void 0 ? _c : stroke,\r\n        strokeWidth: (_d = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _d !== void 0 ? _d : strokeWidth,\r\n        fillOpacity: (_e = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _e !== void 0 ? _e : fillOpacity,\r\n        strokeOpacity: (_f = format === null || format === void 0 ? void 0 : format.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity,\r\n        lineDash,\r\n        lineDashOffset,\r\n        fillShadow,\r\n    };\r\n}\r\nfunction checkCrisp(visibleRange = []) {\r\n    const [visibleMin, visibleMax] = visibleRange;\r\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\r\n    return !isZoomed;\r\n}\r\nfunction collapsedStartingBarPosition(isVertical, axes) {\r\n    const { startingX, startingY } = getStartingValues(isVertical, axes);\r\n    const isDatumNegative = (datum) => {\r\n        var _a;\r\n        return isNegative((_a = datum['yValue']) !== null && _a !== void 0 ? _a : 0);\r\n    };\r\n    const calculate = (datum, prevDatum) => {\r\n        let x = isVertical ? datum.x : startingX;\r\n        let y = isVertical ? startingY : datum.y;\r\n        let width = isVertical ? datum.width : 0;\r\n        let height = isVertical ? 0 : datum.height;\r\n        if (prevDatum && (isNaN(x) || isNaN(y))) {\r\n            // Fallback\r\n            ({ x, y } = prevDatum);\r\n            width = isVertical ? prevDatum.width : 0;\r\n            height = isVertical ? 0 : prevDatum.height;\r\n            if (isVertical && !isDatumNegative(prevDatum)) {\r\n                y += prevDatum.height;\r\n            }\r\n            else if (!isVertical && isDatumNegative(prevDatum)) {\r\n                x += prevDatum.width;\r\n            }\r\n        }\r\n        return { x, y, width, height };\r\n    };\r\n    return { isVertical, calculate };\r\n}\r\nfunction midpointStartingBarPosition(isVertical) {\r\n    return {\r\n        isVertical,\r\n        calculate: (datum) => {\r\n            return {\r\n                x: isVertical ? datum.x : datum.x + datum.width / 2,\r\n                y: isVertical ? datum.y + datum.height / 2 : datum.y,\r\n                width: isVertical ? datum.width : 0,\r\n                height: isVertical ? 0 : datum.height,\r\n            };\r\n        },\r\n    };\r\n}\r\nfunction prepareBarAnimationFunctions(initPos) {\r\n    const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\r\n    const fromFn = (rect, datum, status) => {\r\n        if (status === 'updated' && isRemoved(datum)) {\r\n            status = 'removed';\r\n        }\r\n        else if (status === 'updated' && isRemoved(rect.previousDatum)) {\r\n            status = 'added';\r\n        }\r\n        // Continue from current rendering location.\r\n        let source = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };\r\n        if (status === 'unknown' || status === 'added') {\r\n            source = initPos.calculate(datum, rect.previousDatum);\r\n        }\r\n        return Object.assign(Object.assign({}, source), FROM_TO_MIXINS[status]);\r\n    };\r\n    const toFn = (rect, datum, status) => {\r\n        if (status === 'removed' || isRemoved(datum)) {\r\n            return initPos.calculate(datum, rect.previousDatum);\r\n        }\r\n        return { x: datum.x, y: datum.y, width: datum.width, height: datum.height };\r\n    };\r\n    return { toFn, fromFn };\r\n}\r\nfunction getStartingValues(isVertical, axes) {\r\n    const axis = axes[isVertical ? ChartAxisDirection.Y : ChartAxisDirection.X];\r\n    let startingX = Infinity;\r\n    let startingY = 0;\r\n    if (!axis) {\r\n        return { startingX, startingY };\r\n    }\r\n    if (isVertical) {\r\n        startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\r\n    }\r\n    else {\r\n        startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\r\n    }\r\n    return { startingX, startingY };\r\n}\r\nfunction resetBarSelectionsFn(_node, { x, y, width, height }) {\r\n    return { x, y, width, height };\r\n}\n\nfunction updateLabelNode(textNode, label, labelDatum) {\r\n    if (label.enabled && labelDatum) {\r\n        const { x, y, text, textAlign, textBaseline } = labelDatum;\r\n        const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\r\n        textNode.setProperties({\r\n            visible: true,\r\n            x,\r\n            y,\r\n            text,\r\n            fill,\r\n            fontStyle,\r\n            fontWeight,\r\n            fontSize,\r\n            fontFamily,\r\n            textAlign,\r\n            textBaseline,\r\n        });\r\n    }\r\n    else {\r\n        textNode.visible = false;\r\n    }\r\n}\r\nfunction adjustLabelPlacement({ isPositive, isVertical, placement, padding = 0, rect, }) {\r\n    let x = rect.x + rect.width / 2;\r\n    let y = rect.y + rect.height / 2;\r\n    let textAlign = 'center';\r\n    let textBaseline = 'middle';\r\n    switch (placement) {\r\n        case 'start': {\r\n            if (isVertical) {\r\n                y = isPositive ? rect.y + rect.height + padding : rect.y - padding;\r\n                textBaseline = isPositive ? 'top' : 'bottom';\r\n            }\r\n            else {\r\n                x = isPositive ? rect.x - padding : rect.x + rect.width + padding;\r\n                textAlign = isPositive ? 'start' : 'end';\r\n            }\r\n            break;\r\n        }\r\n        case 'outside':\r\n        case 'end': {\r\n            if (isVertical) {\r\n                y = isPositive ? rect.y - padding : rect.y + rect.height + padding;\r\n                textBaseline = isPositive ? 'bottom' : 'top';\r\n            }\r\n            else {\r\n                x = isPositive ? rect.x + rect.width + padding : rect.x - padding;\r\n                textAlign = isPositive ? 'start' : 'end';\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return { x, y, textAlign, textBaseline };\r\n}\n\nvar BarSeriesNodeTag;\r\n(function (BarSeriesNodeTag) {\r\n    BarSeriesNodeTag[BarSeriesNodeTag[\"Bar\"] = 0] = \"Bar\";\r\n    BarSeriesNodeTag[BarSeriesNodeTag[\"Label\"] = 1] = \"Label\";\r\n})(BarSeriesNodeTag || (BarSeriesNodeTag = {}));\r\nclass BarSeriesLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.placement = 'inside';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(STRING_UNION('inside', 'outside')),\r\n    __metadata(\"design:type\", String)\r\n], BarSeriesLabel.prototype, \"placement\", void 0);\r\nclass BarSeries extends AbstractBarSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            pathsPerSeries: 0,\r\n            hasHighlightedLabels: true,\r\n            datumSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                datum: resetBarSelectionsFn,\r\n                label: resetLabelFn,\r\n            },\r\n        });\r\n        this.label = new BarSeriesLabel();\r\n        this.tooltip = new SeriesTooltip();\r\n        this.fill = '#c16068';\r\n        this.stroke = '#874349';\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.formatter = undefined;\r\n        this.xKey = undefined;\r\n        this.xName = undefined;\r\n        this.yKey = undefined;\r\n        this.yName = undefined;\r\n        this.stackGroup = undefined;\r\n        this.strokeWidth = 1;\r\n        this.shadow = undefined;\r\n        /**\r\n         * Used to get the position of bars within each group.\r\n         */\r\n        this.groupScale = new BandScale();\r\n        this.smallestDataInterval = undefined;\r\n    }\r\n    resolveKeyDirection(direction) {\r\n        if (this.getBarDirection() === ChartAxisDirection.X) {\r\n            if (direction === ChartAxisDirection.X) {\r\n                return ChartAxisDirection.Y;\r\n            }\r\n            return ChartAxisDirection.X;\r\n        }\r\n        return direction;\r\n    }\r\n    processData(dataController) {\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, normalizedTo, seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const normalizedToAbs = Math.abs(normalizedTo !== null && normalizedTo !== void 0 ? normalizedTo : NaN);\r\n            const isContinuousX = ContinuousScale.is((_a = this.getCategoryAxis()) === null || _a === void 0 ? void 0 : _a.scale);\r\n            const isContinuousY = ContinuousScale.is((_b = this.getValueAxis()) === null || _b === void 0 ? void 0 : _b.scale);\r\n            const stackGroupName = `bar-stack-${groupIndex}-yValues`;\r\n            const stackGroupTrailingName = `${stackGroupName}-trailing`;\r\n            const normaliseTo = normalizedToAbs && isFinite(normalizedToAbs) ? normalizedToAbs : undefined;\r\n            const extraProps = [];\r\n            if (normaliseTo) {\r\n                extraProps.push(normaliseGroupTo(this, [stackGroupName, stackGroupTrailingName], normaliseTo, 'range'));\r\n            }\r\n            if (animationEnabled && this.processedData) {\r\n                extraProps.push(diff(this.processedData));\r\n            }\r\n            if (animationEnabled) {\r\n                extraProps.push(animationValidation(this));\r\n            }\r\n            const visibleProps = !this.visible ? { forceValue: 0 } : {};\r\n            const { processedData } = yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xValue' }),\r\n                    valueProperty(this, yKey, isContinuousY, Object.assign({ id: `yValue-raw`, invalidValue: null }, visibleProps)),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'normal', 'current', Object.assign({ id: `yValue-end`, invalidValue: null, missingValue: 0, groupId: stackGroupName, separateNegative: true }, visibleProps)),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'trailing', 'current', Object.assign({ id: `yValue-start`, invalidValue: null, missingValue: 0, groupId: stackGroupTrailingName, separateNegative: true }, visibleProps)),\r\n                    ...(isContinuousX ? [SMALLEST_KEY_INTERVAL] : []),\r\n                    ...extraProps,\r\n                ],\r\n                groupByKeys: true,\r\n            });\r\n            this.smallestDataInterval = {\r\n                x: (_d = (_c = processedData.reduced) === null || _c === void 0 ? void 0 : _c.smallestKeyInterval) !== null && _d !== void 0 ? _d : Infinity,\r\n                y: Infinity,\r\n            };\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        var _a;\r\n        const { processedData, dataModel } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const { reduced: { [SMALLEST_KEY_INTERVAL.property]: smallestX } = {} } = processedData;\r\n        const categoryAxis = this.getCategoryAxis();\r\n        const valueAxis = this.getValueAxis();\r\n        const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\r\n        const keys = dataModel.getDomain(this, `xValue`, 'key', processedData);\r\n        const yExtent = dataModel.getDomain(this, `yValue-end`, 'value', processedData);\r\n        if (direction === this.getCategoryDirection()) {\r\n            if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === 'key' && (keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.valueType) === 'category') {\r\n                return keys;\r\n            }\r\n            const scalePadding = smallestX != null && isFinite(smallestX) ? smallestX : 0;\r\n            const keysExtent = (_a = extent(keys)) !== null && _a !== void 0 ? _a : [NaN, NaN];\r\n            if (direction === ChartAxisDirection.Y) {\r\n                return fixNumericExtent([keysExtent[0] + -scalePadding, keysExtent[1]], categoryAxis);\r\n            }\r\n            return fixNumericExtent([keysExtent[0], keysExtent[1] + scalePadding], categoryAxis);\r\n        }\r\n        else if (this.getValueAxis() instanceof LogAxis) {\r\n            return fixNumericExtent(yExtent, valueAxis);\r\n        }\r\n        else {\r\n            const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\r\n            return fixNumericExtent(fixedYExtent, valueAxis);\r\n        }\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { dataModel } = this;\r\n            const xAxis = this.getCategoryAxis();\r\n            const yAxis = this.getValueAxis();\r\n            if (!(dataModel && xAxis && yAxis)) {\r\n                return [];\r\n            }\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const { groupScale, yKey = '', xKey = '', fill, stroke, strokeWidth, label, processedData, ctx: { seriesStateManager }, smallestDataInterval, } = this;\r\n            const xBandWidth = ContinuousScale.is(xScale)\r\n                ? xScale.calcBandwidth(smallestDataInterval === null || smallestDataInterval === void 0 ? void 0 : smallestDataInterval.x)\r\n                : xScale.bandwidth;\r\n            const domain = [];\r\n            const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);\r\n            for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\r\n                domain.push(String(groupIdx));\r\n            }\r\n            groupScale.domain = domain;\r\n            groupScale.range = [0, xBandWidth !== null && xBandWidth !== void 0 ? xBandWidth : 0];\r\n            if (xAxis instanceof CategoryAxis) {\r\n                groupScale.paddingInner = xAxis.groupPaddingInner;\r\n            }\r\n            else if (xAxis instanceof GroupedCategoryAxis) {\r\n                groupScale.padding = 0.1;\r\n            }\r\n            else {\r\n                // Number or Time axis\r\n                groupScale.padding = 0;\r\n            }\r\n            // To get exactly `0` padding we need to turn off rounding\r\n            groupScale.round = groupScale.padding !== 0;\r\n            const barWidth = groupScale.bandwidth >= 1\r\n                ? // Pixel-rounded value for low-volume bar charts.\r\n                    groupScale.bandwidth\r\n                : // Handle high-volume bar charts gracefully.\r\n                    groupScale.rawBandwidth;\r\n            const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`).index;\r\n            const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`).index;\r\n            const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`).index;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const context = {\r\n                itemId: yKey,\r\n                nodeData: [],\r\n                labelData: [],\r\n                scales: _super.calculateScaling.call(this),\r\n                visible: this.visible || animationEnabled,\r\n            };\r\n            processedData === null || processedData === void 0 ? void 0 : processedData.data.forEach(({ keys, datum: seriesDatum, values }) => {\r\n                const xValue = keys[xIndex];\r\n                const x = xScale.convert(xValue);\r\n                const currY = +values[0][yEndIndex];\r\n                const prevY = +values[0][yStartIndex];\r\n                const yRawValue = values[0][yRawIndex];\r\n                const barX = x + groupScale.convert(String(groupIndex));\r\n                if (isNaN(currY)) {\r\n                    return;\r\n                }\r\n                const y = yScale.convert(currY);\r\n                const bottomY = yScale.convert(prevY);\r\n                const barAlongX = this.getBarDirection() === ChartAxisDirection.X;\r\n                const rect = {\r\n                    x: barAlongX ? Math.min(y, bottomY) : barX,\r\n                    y: barAlongX ? barX : Math.min(y, bottomY),\r\n                    width: barAlongX ? Math.abs(bottomY - y) : barWidth,\r\n                    height: barAlongX ? barWidth : Math.abs(bottomY - y),\r\n                };\r\n                const { fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily, color: labelColor, placement, } = label;\r\n                const labelText = this.getLabelText(this.label, {\r\n                    datum: seriesDatum[0],\r\n                    value: yRawValue,\r\n                    xKey,\r\n                    yKey,\r\n                    xName: this.xName,\r\n                    yName: this.yName,\r\n                    legendItemName: this.legendItemName,\r\n                }, (value) => (isNumber(value) ? value.toFixed(2) : ''));\r\n                const labelDatum = labelText\r\n                    ? Object.assign({ text: labelText, fill: labelColor, fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily }, adjustLabelPlacement({\r\n                        isPositive: yRawValue >= 0,\r\n                        isVertical: !barAlongX,\r\n                        placement,\r\n                        rect,\r\n                    })) : undefined;\r\n                const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\r\n                const nodeData = {\r\n                    series: this,\r\n                    itemId: yKey,\r\n                    datum: seriesDatum[0],\r\n                    cumulativeValue: currY,\r\n                    xValue,\r\n                    yValue: yRawValue,\r\n                    yKey,\r\n                    xKey,\r\n                    capDefaults: {\r\n                        lengthRatioMultiplier: lengthRatioMultiplier,\r\n                        lengthMax: lengthRatioMultiplier,\r\n                    },\r\n                    x: rect.x,\r\n                    y: rect.y,\r\n                    width: rect.width,\r\n                    height: rect.height,\r\n                    midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\r\n                    fill,\r\n                    stroke,\r\n                    strokeWidth,\r\n                    label: labelDatum,\r\n                };\r\n                context.nodeData.push(nodeData);\r\n                context.labelData.push(nodeData);\r\n            });\r\n            return [context];\r\n        });\r\n    }\r\n    nodeFactory() {\r\n        return new Rect();\r\n    }\r\n    updateDatumSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return opts.datumSelection.update(opts.nodeData, (rect) => {\r\n                rect.tag = BarSeriesNodeTag.Bar;\r\n            }, (datum) => datum.xValue);\r\n        });\r\n    }\r\n    updateDatumNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { datumSelection, isHighlight } = opts;\r\n            const { yKey = '', fill, stroke, fillOpacity, strokeOpacity, lineDash, lineDashOffset, shadow, formatter, id: seriesId, highlightStyle: { item: itemHighlightStyle }, ctx, stackGroup, } = this;\r\n            const xAxis = this.axes[ChartAxisDirection.X];\r\n            const crisp = checkCrisp(xAxis === null || xAxis === void 0 ? void 0 : xAxis.visibleRange);\r\n            const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection.X;\r\n            datumSelection.each((rect, datum) => {\r\n                const style = {\r\n                    fill,\r\n                    stroke,\r\n                    fillOpacity,\r\n                    strokeOpacity,\r\n                    lineDash,\r\n                    lineDashOffset,\r\n                    fillShadow: shadow,\r\n                    strokeWidth: this.getStrokeWidth(this.strokeWidth),\r\n                };\r\n                const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;\r\n                const config = getRectConfig({\r\n                    datum,\r\n                    isHighlighted: isHighlight,\r\n                    style,\r\n                    highlightStyle: itemHighlightStyle,\r\n                    formatter,\r\n                    seriesId,\r\n                    stackGroup,\r\n                    ctx,\r\n                    yKey,\r\n                });\r\n                config.crisp = crisp;\r\n                config.visible = visible;\r\n                updateRect({ rect, config });\r\n            });\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const data = this.label.enabled ? opts.labelData : [];\r\n            return opts.labelSelection.update(data, (text) => {\r\n                text.tag = BarSeriesNodeTag.Label;\r\n                text.pointerEvents = PointerEvents.None;\r\n            });\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            opts.labelSelection.each((textNode, datum) => {\r\n                updateLabelNode(textNode, this.label, datum.label);\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        const { xKey, yKey, processedData, ctx: { callbackCache }, } = this;\r\n        const xAxis = this.getCategoryAxis();\r\n        const yAxis = this.getValueAxis();\r\n        const { xValue, yValue, datum } = nodeDatum;\r\n        if (!processedData || !xKey || !yKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { xName, yName, fill, stroke, tooltip, formatter, id: seriesId, stackGroup } = this;\r\n        const strokeWidth = this.getStrokeWidth(this.strokeWidth);\r\n        const xString = xAxis.formatDatum(xValue);\r\n        const yString = yAxis.formatDatum(yValue);\r\n        const title = sanitizeHtml(yName);\r\n        const content = sanitizeHtml(xString + ': ' + yString);\r\n        let format;\r\n        if (formatter) {\r\n            format = callbackCache.call(formatter, {\r\n                datum,\r\n                fill,\r\n                stroke,\r\n                strokeWidth,\r\n                highlighted: false,\r\n                xKey,\r\n                yKey,\r\n                seriesId,\r\n                stackGroup,\r\n            });\r\n        }\r\n        const color = (_a = format === null || format === void 0 ? void 0 : format.fill) !== null && _a !== void 0 ? _a : fill;\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, Object.assign({ datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            color,\r\n            title,\r\n            seriesId,\r\n            stackGroup }, this.getModuleTooltipParams(datum)));\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a;\r\n        const { id, data, xKey, yKey, yName, legendItemName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, visible, showInLegend, } = this;\r\n        if (legendType !== 'category' || !showInLegend || !(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKey) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: { text: (_a = legendItemName !== null && legendItemName !== void 0 ? legendItemName : yName) !== null && _a !== void 0 ? _a : yKey },\r\n                marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth },\r\n                legendItemName,\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady({ datumSelections, labelSelections, annotationSelections }) {\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.direction === 'vertical', this.axes));\r\n        fromToMotion(this.id, 'nodes', this.ctx.animationManager, datumSelections, fns);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        var _a, _b;\r\n        const { datumSelections, labelSelections, annotationSelections } = data;\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        const diff = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff;\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.direction === 'vertical', this.axes));\r\n        fromToMotion(this.id, 'nodes', this.ctx.animationManager, datumSelections, fns, (_, datum) => String(datum.xValue), diff);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n}\r\nBarSeries.className = 'BarSeries';\r\nBarSeries.type = 'bar';\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], BarSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], BarSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], BarSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], BarSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], BarSeries.prototype, \"formatter\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"stackGroup\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER()),\r\n    __metadata(\"design:type\", Number)\r\n], BarSeries.prototype, \"normalizedTo\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], BarSeries.prototype, \"strokeWidth\", void 0);\n\nconst BarSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'bar',\r\n    instanceConstructor: BarSeries,\r\n    stackable: true,\r\n    groupable: true,\r\n    seriesDefaults: {\r\n        axes: [\r\n            {\r\n                type: CARTESIAN_AXIS_TYPES.NUMBER,\r\n                position: CARTESIAN_AXIS_POSITIONS.LEFT,\r\n            },\r\n            {\r\n                type: CARTESIAN_AXIS_TYPES.CATEGORY,\r\n                position: CARTESIAN_AXIS_POSITIONS.BOTTOM,\r\n            },\r\n        ],\r\n    },\r\n    swapDefaultAxesCondition: (series) => (series === null || series === void 0 ? void 0 : series.direction) === 'horizontal',\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        fillOpacity: 1,\r\n        strokeWidth: 0,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: NORMAL,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\r\n            formatter: undefined,\r\n            placement: 'inside',\r\n        },\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n    },\r\n    enterpriseThemeTemplate: {\r\n        errorBar: {\r\n            cap: {\r\n                lengthRatio: 0.3,\r\n            },\r\n        },\r\n    },\r\n    paletteFactory: singleSeriesPaletteFactory,\r\n};\n\nclass BubbleSeriesNodeClickEvent extends CartesianSeriesNodeClickEvent {\r\n    constructor(type, nativeEvent, datum, series) {\r\n        super(type, nativeEvent, datum, series);\r\n        this.sizeKey = series.sizeKey;\r\n    }\r\n}\r\nclass BubbleSeriesMarker extends SeriesMarker {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * The series `sizeKey` values along with the `size` and `maxSize` configs will be used to\r\n         * determine the size of the marker. All values will be mapped to a marker size within the\r\n         * `[size, maxSize]` range, where the largest values will correspond to the `maxSize` and the\r\n         * lowest to the `size`.\r\n         */\r\n        this.maxSize = 30;\r\n        this.domain = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], BubbleSeriesMarker.prototype, \"maxSize\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER_ARRAY),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Array)\r\n], BubbleSeriesMarker.prototype, \"domain\", void 0);\r\nclass BubbleSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [\r\n                SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,\r\n                SeriesNodePickMode.NEAREST_NODE,\r\n                SeriesNodePickMode.EXACT_SHAPE_MATCH,\r\n            ],\r\n            pathsPerSeries: 0,\r\n            hasMarkers: true,\r\n            markerSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                label: resetLabelFn,\r\n                marker: resetMarkerFn,\r\n            },\r\n        });\r\n        this.NodeClickEvent = BubbleSeriesNodeClickEvent;\r\n        this.sizeScale = new LinearScale();\r\n        this.marker = new BubbleSeriesMarker();\r\n        this.label = new Label();\r\n        this.title = undefined;\r\n        this.labelKey = undefined;\r\n        this.xName = undefined;\r\n        this.yName = undefined;\r\n        this.sizeName = 'Size';\r\n        this.labelName = 'Label';\r\n        this.xKey = undefined;\r\n        this.yKey = undefined;\r\n        this.sizeKey = undefined;\r\n        this.colorKey = undefined;\r\n        this.colorName = 'Color';\r\n        this.colorRange = ['#ffff00', '#00ff00', '#0000ff'];\r\n        this.colorScale = new ColorScale();\r\n        this.tooltip = new SeriesTooltip();\r\n    }\r\n    processData(dataController) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, sizeKey, labelKey, colorScale, colorDomain, colorRange, colorKey, marker, data } = this;\r\n            if (xKey == null || yKey == null || sizeKey == null || data == null)\r\n                return;\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const { dataModel, processedData } = yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xKey-raw' }),\r\n                    keyProperty(this, yKey, isContinuousY, { id: 'yKey-raw' }),\r\n                    ...(labelKey ? [keyProperty(this, labelKey, false, { id: `labelKey-raw` })] : []),\r\n                    valueProperty(this, xKey, isContinuousX, { id: `xValue` }),\r\n                    valueProperty(this, yKey, isContinuousY, { id: `yValue` }),\r\n                    valueProperty(this, sizeKey, true, { id: `sizeValue` }),\r\n                    ...(colorKey ? [valueProperty(this, colorKey, true, { id: `colorValue` })] : []),\r\n                    ...(labelKey ? [valueProperty(this, labelKey, false, { id: `labelValue` })] : []),\r\n                ],\r\n                dataVisible: this.visible,\r\n            });\r\n            const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index;\r\n            const processedSize = (_a = processedData.domain.values[sizeKeyIdx]) !== null && _a !== void 0 ? _a : [];\r\n            this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\r\n            if (colorKey) {\r\n                const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;\r\n                colorScale.domain = (_b = colorDomain !== null && colorDomain !== void 0 ? colorDomain : processedData.domain.values[colorKeyIdx]) !== null && _b !== void 0 ? _b : [];\r\n                colorScale.range = colorRange;\r\n                colorScale.update();\r\n            }\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { dataModel, processedData } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const id = direction === ChartAxisDirection.X ? `xValue` : `yValue`;\r\n        const dataDef = dataModel.resolveProcessedDataDefById(this, id);\r\n        const domain = dataModel.getDomain(this, id, 'value', processedData);\r\n        if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.type) === 'value' && (dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.valueType) === 'category') {\r\n            return domain;\r\n        }\r\n        const axis = this.axes[direction];\r\n        return fixNumericExtent(extent(domain), axis);\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { visible, axes, yKey = '', xKey = '', label, labelKey, dataModel, processedData, colorScale, sizeKey = '', colorKey, } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!(dataModel && processedData && visible && xAxis && yAxis))\r\n                return [];\r\n            const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\r\n            const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index : -1;\r\n            const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;\r\n            const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\r\n            const { sizeScale, marker } = this;\r\n            const nodeData = [];\r\n            sizeScale.range = [marker.size, marker.maxSize];\r\n            const font = label.getFont();\r\n            for (const { values, datum } of (_c = processedData.data) !== null && _c !== void 0 ? _c : []) {\r\n                const xDatum = values[xDataIdx];\r\n                const yDatum = values[yDataIdx];\r\n                const x = xScale.convert(xDatum) + xOffset;\r\n                const y = yScale.convert(yDatum) + yOffset;\r\n                const labelText = this.getLabelText(label, {\r\n                    value: labelKey ? values[labelDataIdx] : yDatum,\r\n                    datum,\r\n                    xKey,\r\n                    yKey,\r\n                    sizeKey,\r\n                    labelKey,\r\n                    xName: this.xName,\r\n                    yName: this.yName,\r\n                    sizeName: this.sizeName,\r\n                    labelName: this.labelName,\r\n                });\r\n                const size = HdpiCanvas.getTextSize(String(labelText), font);\r\n                const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;\r\n                const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : undefined;\r\n                nodeData.push({\r\n                    series: this,\r\n                    itemId: yKey,\r\n                    yKey,\r\n                    xKey,\r\n                    datum,\r\n                    xValue: xDatum,\r\n                    yValue: yDatum,\r\n                    sizeValue: values[sizeDataIdx],\r\n                    point: { x, y, size: markerSize },\r\n                    midPoint: { x, y },\r\n                    fill,\r\n                    label: Object.assign({ text: labelText }, size),\r\n                });\r\n            }\r\n            return [\r\n                {\r\n                    itemId: (_d = this.yKey) !== null && _d !== void 0 ? _d : this.id,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    getLabelData() {\r\n        var _a;\r\n        return (_a = this.contextNodeData) === null || _a === void 0 ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, markerSelection } = opts;\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            const data = this.marker.enabled ? nodeData : [];\r\n            return markerSelection.update(data, undefined, (datum) => this.getDatumId(datum));\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const { xKey = '', yKey = '', sizeKey = '', labelKey, marker } = this;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle());\r\n            this.sizeScale.range = [marker.size, marker.maxSize];\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label: { enabled }, } = this;\r\n            const placedLabels = enabled ? (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.placeLabels().get(this)) !== null && _b !== void 0 ? _b : [] : [];\r\n            const placedNodeDatum = placedLabels.map((v) => (Object.assign(Object.assign({}, v.datum), { point: {\r\n                    x: v.x,\r\n                    y: v.y,\r\n                    size: v.datum.point.size,\r\n                } })));\r\n            return labelSelection.update(placedNodeDatum);\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label } = this;\r\n            labelSelection.each((text, datum) => {\r\n                var _a, _b, _c, _d;\r\n                text.text = datum.label.text;\r\n                text.fill = label.color;\r\n                text.x = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;\r\n                text.y = (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;\r\n                text.fontStyle = label.fontStyle;\r\n                text.fontWeight = label.fontWeight;\r\n                text.fontSize = label.fontSize;\r\n                text.fontFamily = label.fontFamily;\r\n                text.textAlign = 'left';\r\n                text.textBaseline = 'top';\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        const { xKey, yKey, sizeKey, axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !yKey || !xAxis || !yAxis || !sizeKey) {\r\n            return '';\r\n        }\r\n        const { marker, tooltip, xName, yName, sizeName, labelKey, labelName, id: seriesId } = this;\r\n        const baseStyle = mergeDefaults({ fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) }, marker.getStyle());\r\n        const { fill: color = 'gray' } = this.getMarkerStyle(marker, { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey }, baseStyle);\r\n        const title = (_a = this.title) !== null && _a !== void 0 ? _a : yName;\r\n        const { datum, xValue, yValue, sizeValue, label: { text: labelText }, } = nodeDatum;\r\n        const xString = sanitizeHtml(xAxis.formatDatum(xValue));\r\n        const yString = sanitizeHtml(yAxis.formatDatum(yValue));\r\n        let content = `<b>${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}</b>: ${xString}<br>` +\r\n            `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)}</b>: ${yString}`;\r\n        if (sizeKey) {\r\n            content += `<br><b>${sanitizeHtml(sizeName !== null && sizeName !== void 0 ? sizeName : sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\r\n        }\r\n        if (labelKey) {\r\n            content = `<b>${sanitizeHtml(labelName !== null && labelName !== void 0 ? labelName : labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\r\n        }\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, {\r\n            datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            sizeKey,\r\n            sizeName,\r\n            labelKey,\r\n            labelName,\r\n            title,\r\n            color,\r\n            seriesId,\r\n        });\r\n    }\r\n    getLegendData() {\r\n        var _a;\r\n        const { id, data, xKey, yKey, sizeKey, yName, title, visible, marker } = this;\r\n        const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\r\n        if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && sizeKey)) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey,\r\n                },\r\n                marker: {\r\n                    shape,\r\n                    fill: fill !== null && fill !== void 0 ? fill : 'rgba(0, 0, 0, 0)',\r\n                    stroke: stroke !== null && stroke !== void 0 ? stroke : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1,\r\n                    strokeOpacity: strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1,\r\n                    strokeWidth: strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady({ markerSelections, labelSelections }) {\r\n        markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n    }\r\n    getDatumId(datum) {\r\n        return createDatumId([`${datum.xValue}`, `${datum.yValue}`, datum.label.text]);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nBubbleSeries.className = 'BubbleSeries';\r\nBubbleSeries.type = 'bubble';\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"title\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"labelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"sizeName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"labelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"sizeKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"colorKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"colorName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], BubbleSeries.prototype, \"colorDomain\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], BubbleSeries.prototype, \"colorRange\", void 0);\n\nconst BubbleSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'bubble',\r\n    instanceConstructor: BubbleSeries,\r\n    seriesDefaults: {\r\n        axes: [\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.BOTTOM },\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.LEFT },\r\n        ],\r\n    },\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            maxSize: 30,\r\n            fillOpacity: 0.8,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n        },\r\n    },\r\n    paletteFactory: markerPaletteFactory,\r\n};\n\nconst HISTOGRAM_AGGREGATIONS = ['count', 'sum', 'mean'];\r\nconst HISTOGRAM_AGGREGATION = predicateWithMessage((v) => HISTOGRAM_AGGREGATIONS.includes(v), `expecting a histogram aggregation keyword such as 'count', 'sum' or 'mean`);\r\nvar HistogramSeriesNodeTag;\r\n(function (HistogramSeriesNodeTag) {\r\n    HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Bin\"] = 0] = \"Bin\";\r\n    HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Label\"] = 1] = \"Label\";\r\n})(HistogramSeriesNodeTag || (HistogramSeriesNodeTag = {}));\r\nconst defaultBinCount = 10;\r\nclass HistogramSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            datumSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                datum: resetBarSelectionsFn,\r\n                label: resetLabelFn,\r\n            },\r\n        });\r\n        this.label = new Label();\r\n        this.tooltip = new SeriesTooltip();\r\n        this.fill = undefined;\r\n        this.stroke = undefined;\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.xKey = undefined;\r\n        this.areaPlot = false;\r\n        this.aggregation = 'sum';\r\n        this.binCount = undefined;\r\n        this.xName = undefined;\r\n        this.yKey = undefined;\r\n        this.yName = undefined;\r\n        this.strokeWidth = 1;\r\n        this.shadow = undefined;\r\n        this.calculatedBins = [];\r\n    }\r\n    // During processData phase, used to unify different ways of the user specifying\r\n    // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\r\n    deriveBins(xDomain) {\r\n        if (this.binCount === undefined) {\r\n            const binStarts = ticks(xDomain[0], xDomain[1], defaultBinCount);\r\n            const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\r\n            const firstBinEnd = binStarts[0];\r\n            const expandStartToBin = (n) => [n, n + binSize];\r\n            return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\r\n        }\r\n        else {\r\n            return this.calculateNiceBins(xDomain, this.binCount);\r\n        }\r\n    }\r\n    calculateNiceBins(domain, binCount) {\r\n        const startGuess = Math.floor(domain[0]);\r\n        const stop = domain[1];\r\n        const segments = binCount || 1;\r\n        const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);\r\n        return this.getBins(start, stop, binSize, segments);\r\n    }\r\n    getBins(start, stop, step, count) {\r\n        const bins = [];\r\n        for (let i = 0; i < count; i++) {\r\n            const a = Math.round((start + i * step) * 10) / 10;\r\n            let b = Math.round((start + (i + 1) * step) * 10) / 10;\r\n            if (i === count - 1) {\r\n                b = Math.max(b, stop);\r\n            }\r\n            bins[i] = [a, b];\r\n        }\r\n        return bins;\r\n    }\r\n    calculateNiceStart(a, b, segments) {\r\n        const binSize = Math.abs(b - a) / segments;\r\n        const order = Math.floor(Math.log10(binSize));\r\n        const magnitude = Math.pow(10, order);\r\n        const start = Math.floor(a / magnitude) * magnitude;\r\n        return {\r\n            start,\r\n            binSize,\r\n        };\r\n    }\r\n    processData(dataController) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, data, areaPlot, aggregation } = this;\r\n            const props = [keyProperty(this, xKey, true), SORT_DOMAIN_GROUPS];\r\n            if (yKey) {\r\n                let aggProp = groupCount(this, 'groupCount');\r\n                if (aggregation === 'count') ;\r\n                else if (aggregation === 'sum') {\r\n                    aggProp = groupSum(this, 'groupAgg');\r\n                }\r\n                else if (aggregation === 'mean') {\r\n                    aggProp = groupAverage(this, 'groupAgg');\r\n                }\r\n                if (areaPlot) {\r\n                    aggProp = area(this, 'groupAgg', aggProp);\r\n                }\r\n                props.push(valueProperty(this, yKey, true, { invalidValue: undefined }), aggProp);\r\n            }\r\n            else {\r\n                let aggProp = groupCount(this, 'groupAgg');\r\n                if (areaPlot) {\r\n                    aggProp = area(this, 'groupAgg', aggProp);\r\n                }\r\n                props.push(aggProp);\r\n            }\r\n            const groupByFn = (dataSet) => {\r\n                var _a;\r\n                const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\r\n                if (xExtent.length === 0) {\r\n                    // No buckets can be calculated.\r\n                    dataSet.domain.groups = [];\r\n                    return () => [];\r\n                }\r\n                const bins = (_a = this.bins) !== null && _a !== void 0 ? _a : this.deriveBins(xExtent);\r\n                const binCount = bins.length;\r\n                this.calculatedBins = [...bins];\r\n                return (item) => {\r\n                    const xValue = item.keys[0];\r\n                    for (let i = 0; i < binCount; i++) {\r\n                        const nextBin = bins[i];\r\n                        if (xValue >= nextBin[0] && xValue < nextBin[1]) {\r\n                            return nextBin;\r\n                        }\r\n                        if (i === binCount - 1 && xValue <= nextBin[1]) {\r\n                            // Handle edge case of a value being at the maximum extent, and the\r\n                            // final bin aligning with it.\r\n                            return nextBin;\r\n                        }\r\n                    }\r\n                    return [];\r\n                };\r\n            };\r\n            if (!this.ctx.animationManager.isSkipped() && this.processedData) {\r\n                props.push(diff(this.processedData, false));\r\n            }\r\n            yield this.requestDataModel(dataController, data !== null && data !== void 0 ? data : [], {\r\n                props,\r\n                dataVisible: this.visible,\r\n                groupByFn,\r\n            });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        var _a, _b, _c, _d;\r\n        const { processedData, dataModel } = this;\r\n        if (!processedData || !dataModel || !this.calculatedBins.length)\r\n            return [];\r\n        const yDomain = dataModel.getDomain(this, `groupAgg`, 'aggregate', processedData);\r\n        const xDomainMin = (_a = this.calculatedBins) === null || _a === void 0 ? void 0 : _a[0][0];\r\n        const xDomainMax = (_b = this.calculatedBins) === null || _b === void 0 ? void 0 : _b[((_d = (_c = this.calculatedBins) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) - 1][1];\r\n        if (direction === ChartAxisDirection.X) {\r\n            return fixNumericExtent([xDomainMin, xDomainMax]);\r\n        }\r\n        return fixNumericExtent(yDomain);\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { axes, processedData, ctx: { callbackCache }, } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!this.visible || !xAxis || !yAxis || !processedData || processedData.type !== 'grouped') {\r\n                return [];\r\n            }\r\n            const { scale: xScale } = xAxis;\r\n            const { scale: yScale } = yAxis;\r\n            const { fill, stroke, strokeWidth, id: seriesId, yKey = '', xKey = '' } = this;\r\n            const nodeData = [];\r\n            const { label: { formatter: labelFormatter = (params) => String(params.value), fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily, color: labelColor, }, } = this;\r\n            processedData.data.forEach((group) => {\r\n                var _a;\r\n                const { aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]], datum, datum: { length: frequency }, keys: domain, keys: [xDomainMin, xDomainMax], } = group;\r\n                const xMinPx = xScale.convert(xDomainMin);\r\n                const xMaxPx = xScale.convert(xDomainMax);\r\n                const total = negativeAgg + positiveAgg;\r\n                const yZeroPx = yScale.convert(0);\r\n                const yMaxPx = yScale.convert(total);\r\n                const w = xMaxPx - xMinPx;\r\n                const h = Math.abs(yMaxPx - yZeroPx);\r\n                const selectionDatumLabel = total !== 0\r\n                    ? {\r\n                        text: (_a = callbackCache.call(labelFormatter, {\r\n                            value: total,\r\n                            datum,\r\n                            seriesId,\r\n                            xKey,\r\n                            yKey,\r\n                            xName: this.xName,\r\n                            yName: this.yName,\r\n                        })) !== null && _a !== void 0 ? _a : String(total),\r\n                        fontStyle: labelFontStyle,\r\n                        fontWeight: labelFontWeight,\r\n                        fontSize: labelFontSize,\r\n                        fontFamily: labelFontFamily,\r\n                        fill: labelColor,\r\n                        x: xMinPx + w / 2,\r\n                        y: yMaxPx + h / 2,\r\n                    }\r\n                    : undefined;\r\n                const nodeMidPoint = {\r\n                    x: xMinPx + w / 2,\r\n                    y: yMaxPx + h / 2,\r\n                };\r\n                nodeData.push({\r\n                    series: this,\r\n                    datum,\r\n                    // since each selection is an aggregation of multiple data.\r\n                    aggregatedValue: total,\r\n                    frequency,\r\n                    domain: domain,\r\n                    yKey,\r\n                    xKey,\r\n                    x: xMinPx,\r\n                    y: yMaxPx,\r\n                    xValue: xMinPx,\r\n                    yValue: yMaxPx,\r\n                    width: w,\r\n                    height: h,\r\n                    midPoint: nodeMidPoint,\r\n                    fill: fill,\r\n                    stroke: stroke,\r\n                    strokeWidth: strokeWidth,\r\n                    label: selectionDatumLabel,\r\n                });\r\n            });\r\n            return [\r\n                {\r\n                    itemId: (_a = this.yKey) !== null && _a !== void 0 ? _a : this.id,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    animationValid: true,\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    nodeFactory() {\r\n        return new Rect();\r\n    }\r\n    updateDatumSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, datumSelection } = opts;\r\n            return datumSelection.update(nodeData, (rect) => {\r\n                rect.tag = HistogramSeriesNodeTag.Bin;\r\n                rect.crisp = true;\r\n            }, (datum) => datum.domain.join('_'));\r\n        });\r\n    }\r\n    updateDatumNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { datumSelection, isHighlight: isDatumHighlighted } = opts;\r\n            const { fillOpacity: seriesFillOpacity, strokeOpacity, shadow, highlightStyle: { item: { fill: highlightedFill, fillOpacity: highlightFillOpacity = seriesFillOpacity, stroke: highlightedStroke, strokeWidth: highlightedDatumStrokeWidth, }, }, } = this;\r\n            datumSelection.each((rect, datum, index) => {\r\n                var _a, _b;\r\n                const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== undefined\r\n                    ? highlightedDatumStrokeWidth\r\n                    : datum.strokeWidth;\r\n                const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\r\n                rect.fill = (_a = (isDatumHighlighted ? highlightedFill : undefined)) !== null && _a !== void 0 ? _a : datum.fill;\r\n                rect.stroke = (_b = (isDatumHighlighted ? highlightedStroke : undefined)) !== null && _b !== void 0 ? _b : datum.stroke;\r\n                rect.fillOpacity = fillOpacity;\r\n                rect.strokeOpacity = strokeOpacity;\r\n                rect.strokeWidth = strokeWidth;\r\n                rect.lineDash = this.lineDash;\r\n                rect.lineDashOffset = this.lineDashOffset;\r\n                rect.fillShadow = shadow;\r\n                rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\r\n                rect.visible = datum.height > 0; // prevent stroke from rendering for zero height columns\r\n            });\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelData, labelSelection } = opts;\r\n            return labelSelection.update(labelData, (text) => {\r\n                text.tag = HistogramSeriesNodeTag.Label;\r\n                text.pointerEvents = PointerEvents.None;\r\n                text.textAlign = 'center';\r\n                text.textBaseline = 'middle';\r\n            });\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const labelEnabled = this.label.enabled;\r\n            labelSelection.each((text, datum) => {\r\n                const label = datum.label;\r\n                if (label && labelEnabled) {\r\n                    text.text = label.text;\r\n                    text.x = label.x;\r\n                    text.y = label.y;\r\n                    text.fontStyle = label.fontStyle;\r\n                    text.fontWeight = label.fontWeight;\r\n                    text.fontSize = label.fontSize;\r\n                    text.fontFamily = label.fontFamily;\r\n                    text.fill = label.fill;\r\n                    text.visible = true;\r\n                }\r\n                else {\r\n                    text.visible = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        const { xKey, yKey = '', axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { xName, yName, fill: color, tooltip, aggregation, id: seriesId } = this;\r\n        const { aggregatedValue, frequency, domain: [rangeMin, rangeMax], } = nodeDatum;\r\n        const title = `${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\r\n        let content = yKey\r\n            ? `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>`\r\n            : '';\r\n        content += `<b>Frequency</b>: ${frequency}`;\r\n        const defaults = {\r\n            title,\r\n            backgroundColor: color,\r\n            content,\r\n        };\r\n        return tooltip.toTooltipHtml(defaults, {\r\n            datum: {\r\n                data: nodeDatum.datum,\r\n                aggregatedValue: nodeDatum.aggregatedValue,\r\n                domain: nodeDatum.domain,\r\n                frequency: nodeDatum.frequency,\r\n            },\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            color,\r\n            title,\r\n            seriesId,\r\n        });\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a;\r\n        const { id, data, xKey, yName, visible, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = this;\r\n        if (!data || data.length === 0 || legendType !== 'category') {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: xKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = yName !== null && yName !== void 0 ? yName : xKey) !== null && _a !== void 0 ? _a : 'Frequency',\r\n                },\r\n                marker: {\r\n                    fill: fill !== null && fill !== void 0 ? fill : 'rgba(0, 0, 0, 0)',\r\n                    stroke: stroke !== null && stroke !== void 0 ? stroke : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: fillOpacity,\r\n                    strokeOpacity: strokeOpacity,\r\n                    strokeWidth,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady({ datumSelections, labelSelections }) {\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes));\r\n        fromToMotion(this.id, 'datums', this.ctx.animationManager, datumSelections, fns);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        var _a, _b;\r\n        const diff = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff;\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes));\r\n        fromToMotion(this.id, 'datums', this.ctx.animationManager, data.datumSelections, fns, (_, datum) => this.getDatumId(datum), diff);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, data.labelSelections);\r\n    }\r\n    getDatumId(datum) {\r\n        return createDatumId(datum.domain.map((d) => `${d}`));\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n}\r\nHistogramSeries.className = 'HistogramSeries';\r\nHistogramSeries.type = 'histogram';\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], HistogramSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], HistogramSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], HistogramSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], HistogramSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], HistogramSeries.prototype, \"areaPlot\", void 0);\r\n__decorate([\r\n    Validate(OPT_ARRAY()),\r\n    __metadata(\"design:type\", Array)\r\n], HistogramSeries.prototype, \"bins\", void 0);\r\n__decorate([\r\n    Validate(HISTOGRAM_AGGREGATION),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"aggregation\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], HistogramSeries.prototype, \"binCount\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], HistogramSeries.prototype, \"strokeWidth\", void 0);\n\nconst HistogramSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'histogram',\r\n    instanceConstructor: HistogramSeries,\r\n    seriesDefaults: {\r\n        axes: [\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.BOTTOM },\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.LEFT },\r\n        ],\r\n    },\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        strokeWidth: 1,\r\n        fillOpacity: 1,\r\n        strokeOpacity: 1,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\r\n            formatter: undefined,\r\n        },\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n    },\r\n    paletteFactory: ({ takeColors }) => {\r\n        const { fills: [fill], strokes: [stroke], } = takeColors(1);\r\n        return { fill, stroke };\r\n    },\r\n};\n\nclass LineSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            hasMarkers: true,\r\n            pickModes: [\r\n                SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,\r\n                SeriesNodePickMode.NEAREST_NODE,\r\n                SeriesNodePickMode.EXACT_SHAPE_MATCH,\r\n            ],\r\n            markerSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),\r\n                label: resetLabelFn,\r\n                marker: (node, datum) => (Object.assign(Object.assign({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))),\r\n            },\r\n        });\r\n        this.label = new Label();\r\n        this.marker = new SeriesMarker();\r\n        this.tooltip = new SeriesTooltip();\r\n        this.title = undefined;\r\n        this.stroke = '#874349';\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.strokeWidth = 2;\r\n        this.strokeOpacity = 1;\r\n        this.xKey = undefined;\r\n        this.xName = undefined;\r\n        this.yKey = undefined;\r\n        this.yName = undefined;\r\n    }\r\n    processData(dataController) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, data } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const props = [];\r\n            // If two or more datums share an x-value, i.e. lined up vertically, they will have the same datum id.\r\n            // They must be identified this way when animated to ensure they can be tracked when their y-value\r\n            // is updated. If this is a static chart, we can instead not bother with identifying datums and\r\n            // automatically garbage collect the marker selection.\r\n            if (!isContinuousX) {\r\n                props.push(keyProperty(this, xKey, isContinuousX, { id: 'xKey' }));\r\n                if (animationEnabled && this.processedData) {\r\n                    props.push(diff(this.processedData));\r\n                }\r\n            }\r\n            if (animationEnabled) {\r\n                props.push(animationValidation(this, isContinuousX ? ['xValue'] : []));\r\n            }\r\n            props.push(valueProperty(this, xKey, isContinuousX, { id: 'xValue' }), valueProperty(this, yKey, isContinuousY, { id: 'yValue', invalidValue: undefined }));\r\n            yield this.requestDataModel(dataController, data, { props });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { axes, dataModel, processedData } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\r\n        if (direction === ChartAxisDirection.X) {\r\n            const domain = dataModel.getDomain(this, `xValue`, 'value', processedData);\r\n            if ((xDef === null || xDef === void 0 ? void 0 : xDef.def.type) === 'value' && xDef.def.valueType === 'category') {\r\n                return domain;\r\n            }\r\n            return fixNumericExtent(extent(domain), xAxis);\r\n        }\r\n        else {\r\n            const domain = dataModel.getDomain(this, `yValue`, 'value', processedData);\r\n            return fixNumericExtent(domain, yAxis);\r\n        }\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { processedData, dataModel, axes } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!processedData || !dataModel || !xAxis || !yAxis) {\r\n                return [];\r\n            }\r\n            const { label, yKey = '', xKey = '' } = this;\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\r\n            const nodeData = [];\r\n            const size = this.marker.enabled ? this.marker.size : 0;\r\n            const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\r\n            let moveTo = true;\r\n            let nextPoint;\r\n            for (let i = 0; i < processedData.data.length; i++) {\r\n                const { datum, values } = nextPoint !== null && nextPoint !== void 0 ? nextPoint : processedData.data[i];\r\n                const xDatum = values[xIdx];\r\n                const yDatum = values[yIdx];\r\n                if (yDatum === undefined) {\r\n                    moveTo = true;\r\n                }\r\n                else {\r\n                    const x = xScale.convert(xDatum) + xOffset;\r\n                    if (isNaN(x)) {\r\n                        moveTo = true;\r\n                        nextPoint = undefined;\r\n                        continue;\r\n                    }\r\n                    nextPoint =\r\n                        ((_c = processedData.data[i + 1]) === null || _c === void 0 ? void 0 : _c.values[yIdx]) === undefined ? undefined : processedData.data[i + 1];\r\n                    const y = yScale.convert(yDatum) + yOffset;\r\n                    const labelText = this.getLabelText(label, {\r\n                        value: yDatum,\r\n                        datum,\r\n                        xKey,\r\n                        yKey,\r\n                        xName: this.xName,\r\n                        yName: this.yName,\r\n                    }, (value) => (isNumber(value) ? value.toFixed(2) : String(value)));\r\n                    nodeData.push({\r\n                        series: this,\r\n                        datum,\r\n                        yKey,\r\n                        xKey,\r\n                        point: { x, y, moveTo, size },\r\n                        midPoint: { x, y },\r\n                        yValue: yDatum,\r\n                        xValue: xDatum,\r\n                        capDefaults: { lengthRatioMultiplier: this.marker.getDiameter(), lengthMax: Infinity },\r\n                        label: labelText\r\n                            ? {\r\n                                text: labelText,\r\n                                fontStyle: label.fontStyle,\r\n                                fontWeight: label.fontWeight,\r\n                                fontSize: label.fontSize,\r\n                                fontFamily: label.fontFamily,\r\n                                textAlign: 'center',\r\n                                textBaseline: 'bottom',\r\n                                fill: label.color,\r\n                            }\r\n                            : undefined,\r\n                    });\r\n                    moveTo = false;\r\n                }\r\n            }\r\n            return [\r\n                {\r\n                    itemId: yKey,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updatePathNodes(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { paths: [lineNode], opacity, visible, animationEnabled, } = opts;\r\n            const { seriesRectHeight: height, seriesRectWidth: width } = this.nodeDataDependencies;\r\n            lineNode.setProperties({\r\n                fill: undefined,\r\n                lineJoin: 'round',\r\n                pointerEvents: PointerEvents.None,\r\n                opacity,\r\n                stroke: this.stroke,\r\n                strokeWidth: this.getStrokeWidth(this.strokeWidth),\r\n                strokeOpacity: this.strokeOpacity,\r\n                lineDash: this.lineDash,\r\n                lineDashOffset: this.lineDashOffset,\r\n            });\r\n            if (!animationEnabled) {\r\n                lineNode.visible = visible;\r\n            }\r\n            if (lineNode.clipPath == null) {\r\n                lineNode.clipPath = new Path2D();\r\n                lineNode.clipScalingX = 1;\r\n                lineNode.clipScalingY = 1;\r\n            }\r\n            (_a = lineNode.clipPath) === null || _a === void 0 ? void 0 : _a.clear({ trackChanges: true });\r\n            (_b = lineNode.clipPath) === null || _b === void 0 ? void 0 : _b.rect(-25, -25, (width !== null && width !== void 0 ? width : 0) + 50, (height !== null && height !== void 0 ? height : 0) + 50);\r\n        });\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let { nodeData } = opts;\r\n            const { markerSelection } = opts;\r\n            const { shape, enabled } = this.marker;\r\n            nodeData = shape && enabled ? nodeData : [];\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            return markerSelection.update(nodeData, undefined, (datum) => this.getDatumId(datum));\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const { xKey = '', yKey = '', marker, stroke, strokeWidth, strokeOpacity } = this;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle(), {\r\n                stroke,\r\n                strokeWidth,\r\n                strokeOpacity,\r\n            });\r\n            const applyTranslation = this.ctx.animationManager.isSkipped();\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let { labelData } = opts;\r\n            const { labelSelection } = opts;\r\n            const { shape, enabled } = this.marker;\r\n            labelData = shape && enabled ? labelData : [];\r\n            return labelSelection.update(labelData);\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.label;\r\n            labelSelection.each((text, datum) => {\r\n                const { point, label } = datum;\r\n                if (datum && label && labelEnabled) {\r\n                    text.fontStyle = fontStyle;\r\n                    text.fontWeight = fontWeight;\r\n                    text.fontSize = fontSize;\r\n                    text.fontFamily = fontFamily;\r\n                    text.textAlign = label.textAlign;\r\n                    text.textBaseline = label.textBaseline;\r\n                    text.text = label.text;\r\n                    text.x = point.x;\r\n                    text.y = point.y - 10;\r\n                    text.fill = color;\r\n                    text.visible = true;\r\n                }\r\n                else {\r\n                    text.visible = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        const { xKey, yKey, axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !yKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { xName, yName, tooltip, marker, id: seriesId } = this;\r\n        const { datum, xValue, yValue } = nodeDatum;\r\n        const xString = xAxis.formatDatum(xValue);\r\n        const yString = yAxis.formatDatum(yValue);\r\n        const title = sanitizeHtml((_a = this.title) !== null && _a !== void 0 ? _a : yName);\r\n        const content = sanitizeHtml(xString + ': ' + yString);\r\n        const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth: this.strokeWidth });\r\n        const { fill: color } = this.getMarkerStyle(marker, { datum: nodeDatum, xKey, yKey, highlighted: false }, baseStyle);\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, Object.assign({ datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            title,\r\n            color,\r\n            seriesId }, this.getModuleTooltipParams(datum)));\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        const { id, data, xKey, yKey, yName, visible, title, marker, stroke, strokeOpacity } = this;\r\n        if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && legendType === 'category')) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id: id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey,\r\n                },\r\n                marker: {\r\n                    shape: marker.shape,\r\n                    fill: (_b = marker.fill) !== null && _b !== void 0 ? _b : 'rgba(0, 0, 0, 0)',\r\n                    stroke: (_d = (_c = marker.stroke) !== null && _c !== void 0 ? _c : stroke) !== null && _d !== void 0 ? _d : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: (_e = marker.fillOpacity) !== null && _e !== void 0 ? _e : 1,\r\n                    strokeOpacity: (_g = (_f = marker.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity) !== null && _g !== void 0 ? _g : 1,\r\n                    strokeWidth: (_h = marker.strokeWidth) !== null && _h !== void 0 ? _h : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    updatePaths(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.updateLinePaths([opts.paths], [opts.contextData]);\r\n        });\r\n    }\r\n    updateLinePaths(paths, contextData) {\r\n        contextData.forEach(({ nodeData }, contextDataIndex) => {\r\n            const [lineNode] = paths[contextDataIndex];\r\n            const { path: linePath } = lineNode;\r\n            linePath.clear({ trackChanges: true });\r\n            for (const data of nodeData) {\r\n                if (data.point.moveTo) {\r\n                    linePath.moveTo(data.point.x, data.point.y);\r\n                }\r\n                else {\r\n                    linePath.lineTo(data.point.x, data.point.y);\r\n                }\r\n            }\r\n            lineNode.checkPathDirty();\r\n        });\r\n    }\r\n    animateEmptyUpdateReady(animationData) {\r\n        const { markerSelections, labelSelections, annotationSelections, contextData, paths } = animationData;\r\n        const { animationManager } = this.ctx;\r\n        const { seriesRectWidth: width = 0 } = this.nodeDataDependencies;\r\n        this.updateLinePaths(paths, contextData);\r\n        pathSwipeInAnimation(this, animationManager, paths.flat());\r\n        resetMotion(markerSelections, resetMarkerPositionFn);\r\n        markerSwipeScaleInAnimation(this, animationManager, markerSelections, width);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', animationManager, annotationSelections);\r\n    }\r\n    animateReadyResize(animationData) {\r\n        const { contextData, paths } = animationData;\r\n        this.updateLinePaths(paths, contextData);\r\n        super.animateReadyResize(animationData);\r\n    }\r\n    animateWaitingUpdateReady(animationData) {\r\n        var _a, _b;\r\n        const { animationManager } = this.ctx;\r\n        const { markerSelections, labelSelections, annotationSelections, contextData, paths, previousContextData } = animationData;\r\n        super.resetAllAnimation(animationData);\r\n        if (contextData.length === 0 || !previousContextData || previousContextData.length === 0) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateLinePaths(paths, contextData);\r\n            return;\r\n        }\r\n        const [path] = paths;\r\n        const [newData] = contextData;\r\n        const [oldData] = previousContextData;\r\n        const fns = prepareLinePathAnimation(newData, oldData, (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff);\r\n        if (fns === undefined) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateLinePaths(paths, contextData);\r\n            return;\r\n        }\r\n        fromToMotion(this.id, 'marker', animationManager, markerSelections, fns.marker);\r\n        fromToMotion(this.id, 'path_properties', animationManager, path, fns.pathProperties);\r\n        pathMotion(this.id, 'path_update', animationManager, path, fns.path);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', animationManager, annotationSelections);\r\n    }\r\n    getDatumId(datum) {\r\n        return createDatumId([`${datum.xValue}`]);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    getBandScalePadding() {\r\n        return { inner: 1, outer: 0.1 };\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nLineSeries.className = 'LineSeries';\r\nLineSeries.type = 'line';\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"title\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], LineSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LineSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LineSeries.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], LineSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"yName\", void 0);\n\nconst LineSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'line',\r\n    instanceConstructor: LineSeries,\r\n    seriesDefaults: DEFAULT_CARTESIAN_CHART_OVERRIDES,\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        strokeWidth: 2,\r\n        strokeOpacity: 1,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            fillOpacity: 1,\r\n            strokeOpacity: 1,\r\n            strokeWidth: 0,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            formatter: undefined,\r\n        },\r\n    },\r\n    enterpriseThemeTemplate: {\r\n        errorBar: {\r\n            cap: {\r\n                lengthRatio: 1,\r\n            },\r\n        },\r\n    },\r\n    paletteFactory: (params) => {\r\n        const { marker } = markerPaletteFactory(params);\r\n        return {\r\n            stroke: marker.fill,\r\n            marker,\r\n        };\r\n    },\r\n};\n\nclass ScatterSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [\r\n                SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,\r\n                SeriesNodePickMode.NEAREST_NODE,\r\n                SeriesNodePickMode.EXACT_SHAPE_MATCH,\r\n            ],\r\n            pathsPerSeries: 0,\r\n            hasMarkers: true,\r\n            markerSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                marker: resetMarkerFn,\r\n                label: resetLabelFn,\r\n            },\r\n        });\r\n        this.marker = new SeriesMarker();\r\n        this.label = new Label();\r\n        this.title = undefined;\r\n        this.labelKey = undefined;\r\n        this.xName = undefined;\r\n        this.yName = undefined;\r\n        this.labelName = 'Label';\r\n        this.xKey = undefined;\r\n        this.yKey = undefined;\r\n        this.colorKey = undefined;\r\n        this.colorName = 'Color';\r\n        this.colorRange = ['#ffff00', '#00ff00', '#0000ff'];\r\n        this.colorScale = new ColorScale();\r\n        this.tooltip = new SeriesTooltip();\r\n    }\r\n    processData(dataController) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, labelKey, data } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const { colorScale, colorDomain, colorRange, colorKey } = this;\r\n            const { dataModel, processedData } = yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xKey-raw' }),\r\n                    keyProperty(this, yKey, isContinuousY, { id: 'yKey-raw' }),\r\n                    ...(labelKey ? [keyProperty(this, labelKey, false, { id: `labelKey-raw` })] : []),\r\n                    valueProperty(this, xKey, isContinuousX, { id: `xValue` }),\r\n                    valueProperty(this, yKey, isContinuousY, { id: `yValue` }),\r\n                    ...(colorKey ? [valueProperty(this, colorKey, true, { id: `colorValue` })] : []),\r\n                    ...(labelKey ? [valueProperty(this, labelKey, false, { id: `labelValue` })] : []),\r\n                ],\r\n                dataVisible: this.visible,\r\n            });\r\n            if (colorKey) {\r\n                const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;\r\n                colorScale.domain = (_a = colorDomain !== null && colorDomain !== void 0 ? colorDomain : processedData.domain.values[colorKeyIdx]) !== null && _a !== void 0 ? _a : [];\r\n                colorScale.range = colorRange;\r\n                colorScale.update();\r\n            }\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { dataModel, processedData } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const id = direction === ChartAxisDirection.X ? `xValue` : `yValue`;\r\n        const dataDef = dataModel.resolveProcessedDataDefById(this, id);\r\n        const domain = dataModel.getDomain(this, id, 'value', processedData);\r\n        if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.type) === 'value' && (dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.valueType) === 'category') {\r\n            return domain;\r\n        }\r\n        const axis = this.axes[direction];\r\n        return fixNumericExtent(extent(domain), axis);\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { visible, axes, yKey = '', xKey = '', label, labelKey, dataModel, processedData } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!(dataModel && processedData && visible && xAxis && yAxis))\r\n                return [];\r\n            const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\r\n            const colorDataIdx = this.colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;\r\n            const labelDataIdx = this.labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;\r\n            const { colorScale, colorKey } = this;\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\r\n            const { marker } = this;\r\n            const nodeData = [];\r\n            const font = label.getFont();\r\n            for (const { values, datum } of (_c = processedData.data) !== null && _c !== void 0 ? _c : []) {\r\n                const xDatum = values[xDataIdx];\r\n                const yDatum = values[yDataIdx];\r\n                const x = xScale.convert(xDatum) + xOffset;\r\n                const y = yScale.convert(yDatum) + yOffset;\r\n                const labelText = this.getLabelText(this.label, {\r\n                    value: labelKey ? values[labelDataIdx] : yDatum,\r\n                    datum,\r\n                    xKey,\r\n                    yKey,\r\n                    labelKey,\r\n                    xName: this.xName,\r\n                    yName: this.yName,\r\n                    labelName: this.labelName,\r\n                });\r\n                const size = HdpiCanvas.getTextSize(labelText, font);\r\n                const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : undefined;\r\n                nodeData.push({\r\n                    series: this,\r\n                    itemId: yKey,\r\n                    yKey,\r\n                    xKey,\r\n                    datum,\r\n                    xValue: xDatum,\r\n                    yValue: yDatum,\r\n                    capDefaults: { lengthRatioMultiplier: this.marker.getDiameter(), lengthMax: Infinity },\r\n                    point: { x, y, size: marker.size },\r\n                    midPoint: { x, y },\r\n                    fill,\r\n                    label: Object.assign({ text: labelText }, size),\r\n                });\r\n            }\r\n            return [\r\n                {\r\n                    itemId: (_d = this.yKey) !== null && _d !== void 0 ? _d : this.id,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    getLabelData() {\r\n        var _a;\r\n        return (_a = this.contextNodeData) === null || _a === void 0 ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, markerSelection } = opts;\r\n            const { marker: { enabled }, } = this;\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            const data = enabled ? nodeData : [];\r\n            return markerSelection.update(data);\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey = '', yKey = '', labelKey, marker } = this;\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle());\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label: { enabled }, } = this;\r\n            const placedLabels = enabled ? (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.placeLabels().get(this)) !== null && _b !== void 0 ? _b : [] : [];\r\n            const placedNodeDatum = placedLabels.map((v) => (Object.assign(Object.assign({}, v.datum), { point: {\r\n                    x: v.x,\r\n                    y: v.y,\r\n                    size: v.datum.point.size,\r\n                } })));\r\n            return labelSelection.update(placedNodeDatum);\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label } = this;\r\n            labelSelection.each((text, datum) => {\r\n                var _a, _b, _c, _d;\r\n                text.text = datum.label.text;\r\n                text.fill = label.color;\r\n                text.x = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;\r\n                text.y = (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;\r\n                text.fontStyle = label.fontStyle;\r\n                text.fontWeight = label.fontWeight;\r\n                text.fontSize = label.fontSize;\r\n                text.fontFamily = label.fontFamily;\r\n                text.textAlign = 'left';\r\n                text.textBaseline = 'top';\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        const { xKey, yKey, axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !yKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { marker, tooltip, xName, yName, labelKey, labelName, id: seriesId, title = yName } = this;\r\n        const baseStyle = mergeDefaults({ fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) }, marker.getStyle());\r\n        const { fill: color = 'gray' } = this.getMarkerStyle(marker, { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey }, baseStyle);\r\n        const { datum, xValue, yValue, label } = nodeDatum;\r\n        const xString = sanitizeHtml(xAxis.formatDatum(xValue));\r\n        const yString = sanitizeHtml(yAxis.formatDatum(yValue));\r\n        let content = `<b>${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}</b>: ${xString}<br>` +\r\n            `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)}</b>: ${yString}`;\r\n        if (labelKey) {\r\n            content = `<b>${sanitizeHtml(labelName !== null && labelName !== void 0 ? labelName : labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\r\n        }\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, Object.assign({ datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            labelKey,\r\n            labelName,\r\n            title,\r\n            color,\r\n            seriesId }, this.getModuleTooltipParams(datum)));\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { id, data, xKey, yKey, yName, title, visible, marker } = this;\r\n        const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\r\n        if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && legendType === 'category')) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey,\r\n                },\r\n                marker: {\r\n                    shape: marker.shape,\r\n                    fill: (_c = (_b = marker.fill) !== null && _b !== void 0 ? _b : fill) !== null && _c !== void 0 ? _c : 'rgba(0, 0, 0, 0)',\r\n                    stroke: (_e = (_d = marker.stroke) !== null && _d !== void 0 ? _d : stroke) !== null && _e !== void 0 ? _e : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1,\r\n                    strokeOpacity: strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1,\r\n                    strokeWidth: strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady(data) {\r\n        const { markerSelections, labelSelections, annotationSelections } = data;\r\n        markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nScatterSeries.className = 'ScatterSeries';\r\nScatterSeries.type = 'scatter';\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"title\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"labelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"labelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"colorKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"colorName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], ScatterSeries.prototype, \"colorDomain\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], ScatterSeries.prototype, \"colorRange\", void 0);\n\nconst ScatterSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'scatter',\r\n    instanceConstructor: ScatterSeries,\r\n    seriesDefaults: {\r\n        axes: [\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.BOTTOM },\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.LEFT },\r\n        ],\r\n    },\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            fillOpacity: 0.8,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n        },\r\n    },\r\n    enterpriseThemeTemplate: {\r\n        errorBar: {\r\n            cap: {\r\n                lengthRatio: 1,\r\n            },\r\n        },\r\n    },\r\n    paletteFactory: markerPaletteFactory,\r\n};\n\nconst PieSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['polar'],\r\n    identifier: 'pie',\r\n    instanceConstructor: PieSeries,\r\n    seriesDefaults: {},\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        title: {\r\n            enabled: true,\r\n            fontStyle: undefined,\r\n            fontWeight: NORMAL,\r\n            fontSize: 14,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_MUTED_LABEL_COLOUR,\r\n            spacing: 5,\r\n        },\r\n        calloutLabel: {\r\n            enabled: true,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            offset: 3,\r\n            minAngle: 0,\r\n        },\r\n        sectorLabel: {\r\n            enabled: true,\r\n            fontStyle: undefined,\r\n            fontWeight: NORMAL,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\r\n            positionOffset: 0,\r\n            positionRatio: 0.5,\r\n        },\r\n        calloutLine: {\r\n            length: 10,\r\n            strokeWidth: 2,\r\n        },\r\n        fillOpacity: 1,\r\n        strokeOpacity: 1,\r\n        strokeWidth: 1,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        rotation: 0,\r\n        outerRadiusOffset: 0,\r\n        innerRadiusOffset: 0,\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n        innerLabels: {\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            margin: 2,\r\n        },\r\n    },\r\n    paletteFactory: ({ takeColors, colorsCount, userPalette }) => {\r\n        const { fills, strokes } = takeColors(colorsCount);\r\n        return {\r\n            fills,\r\n            strokes: userPalette ? strokes : [DEFAULT_POLAR_SERIES_STROKE],\r\n            calloutLine: {\r\n                colors: strokes,\r\n            },\r\n        };\r\n    },\r\n};\n\nfunction registerInbuiltModules() {\r\n    registerModule(BackgroundModule);\r\n    registerModule(NavigatorModule);\r\n    registerModule(AreaSeriesModule);\r\n    registerModule(BarSeriesModule);\r\n    registerModule(BubbleSeriesModule);\r\n    registerModule(LineSeriesModule);\r\n    registerModule(ScatterSeriesModule);\r\n    registerModule(PieSeriesModule);\r\n    registerModule(HistogramSeriesModule);\r\n}\n\nfunction invertShapeDirection(...supportedShapes) {\r\n    for (const shape of supportedShapes) {\r\n        if (shape instanceof Rect) {\r\n            const { x, y, width, height } = shape;\r\n            shape.setProperties({ x: y, y: x, width: height, height: width });\r\n        }\r\n        else if (shape instanceof Line) {\r\n            const { x1, y1, x2, y2 } = shape;\r\n            shape.setProperties({ x1: y1, y1: x1, x2: y2, y2: x2 });\r\n        }\r\n    }\r\n}\n\nclass HierarchyNode {\r\n    constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\r\n        this.series = series;\r\n        this.index = index;\r\n        this.datum = datum;\r\n        this.size = size;\r\n        this.colorValue = colorValue;\r\n        this.fill = fill;\r\n        this.stroke = stroke;\r\n        this.sumSize = sumSize;\r\n        this.depth = depth;\r\n        this.parent = parent;\r\n        this.children = children;\r\n        this.midPoint = { x: 0, y: 0 };\r\n    }\r\n    contains(other) {\r\n        let current = other;\r\n        // Index check is a performance optimization - it does not affect correctness\r\n        while (current != null && current.index >= this.index) {\r\n            if (current === this) {\r\n                return true;\r\n            }\r\n            current = current.parent;\r\n        }\r\n        return false;\r\n    }\r\n    walk(callback, order = HierarchyNode.Walk.PreOrder) {\r\n        if (order === HierarchyNode.Walk.PreOrder) {\r\n            callback(this);\r\n        }\r\n        this.children.forEach((child) => {\r\n            child.walk(callback, order);\r\n        });\r\n        if (order === HierarchyNode.Walk.PostOrder) {\r\n            callback(this);\r\n        }\r\n    }\r\n    *[Symbol.iterator]() {\r\n        yield this;\r\n        for (const child of this.children) {\r\n            yield* child;\r\n        }\r\n    }\r\n}\r\nHierarchyNode.Walk = {\r\n    PreOrder: 0,\r\n    PostOrder: 1,\r\n};\r\nclass HierarchySeries extends Series {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            contentGroupVirtual: false,\r\n        });\r\n        this.childrenKey = 'children';\r\n        this.sizeKey = undefined;\r\n        this.colorKey = undefined;\r\n        this.colorName = undefined;\r\n        this.fills = Object.values(DEFAULT_FILLS);\r\n        this.strokes = Object.values(DEFAULT_STROKES);\r\n        this.colorRange = undefined;\r\n        this.rootNode = new HierarchyNode(this, 0, undefined, 0, undefined, undefined, undefined, 0, undefined, undefined, []);\r\n        this.colorDomain = [0, 0];\r\n        this.maxDepth = 0;\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateEmptyUpdateReady(data),\r\n                },\r\n            },\r\n            ready: {\r\n                updateData: 'waiting',\r\n                clear: 'clearing',\r\n                highlight: (data) => this.animateReadyHighlight(data),\r\n                resize: (data) => this.animateReadyResize(data),\r\n            },\r\n            waiting: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateWaitingUpdateReady(data),\r\n                },\r\n            },\r\n            clearing: {\r\n                update: {\r\n                    target: 'empty',\r\n                    action: (data) => this.animateClearingUpdateEmpty(data),\r\n                },\r\n            },\r\n        }, () => this.checkProcessedDataAnimatable());\r\n    }\r\n    hasData() {\r\n        return Array.isArray(this.data) && this.data.length > 0;\r\n    }\r\n    processData() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this;\r\n            let index = 0;\r\n            const getIndex = () => {\r\n                index += 1;\r\n                return index;\r\n            };\r\n            let maxDepth = 0;\r\n            let minColor = Infinity;\r\n            let maxColor = -Infinity;\r\n            const colors = new Array(((_b = (_a = this.data) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + 1).fill(undefined);\r\n            const createNode = (datum, parent) => {\r\n                const index = getIndex();\r\n                const depth = parent.depth != null ? parent.depth + 1 : 0;\r\n                const children = childrenKey != null ? datum[childrenKey] : undefined;\r\n                const isLeaf = children == null || children.length === 0;\r\n                let size = sizeKey != null ? datum[sizeKey] : undefined;\r\n                if (Number.isFinite(size)) {\r\n                    size = Math.max(size, 0);\r\n                }\r\n                else {\r\n                    size = isLeaf ? 1 : 0;\r\n                }\r\n                const sumSize = size;\r\n                maxDepth = Math.max(maxDepth, depth);\r\n                const color = colorKey != null ? datum[colorKey] : undefined;\r\n                if (typeof color === 'number') {\r\n                    colors[index] = color;\r\n                    minColor = Math.min(minColor, color);\r\n                    maxColor = Math.max(maxColor, color);\r\n                }\r\n                return appendChildren(new HierarchyNode(this, index, datum, size, color, undefined, undefined, sumSize, depth, parent, []), children);\r\n            };\r\n            const appendChildren = (node, data) => {\r\n                data === null || data === void 0 ? void 0 : data.forEach((datum) => {\r\n                    const child = createNode(datum, node);\r\n                    node.children.push(child);\r\n                    node.sumSize += child.sumSize;\r\n                });\r\n                return node;\r\n            };\r\n            const rootNode = appendChildren(new HierarchyNode(this, 0, undefined, 0, undefined, undefined, undefined, 0, undefined, undefined, []), this.data);\r\n            const colorDomain = [minColor, maxColor];\r\n            let colorScale;\r\n            if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\r\n                colorScale = new ColorScale();\r\n                colorScale.domain = colorDomain;\r\n                colorScale.range = colorRange;\r\n                colorScale.update();\r\n            }\r\n            rootNode.children.forEach((child, index) => {\r\n                child.walk((node) => {\r\n                    let fill;\r\n                    const color = colors[node.index];\r\n                    if (color != null) {\r\n                        fill = colorScale === null || colorScale === void 0 ? void 0 : colorScale.convert(color);\r\n                    }\r\n                    fill !== null && fill !== void 0 ? fill : (fill = fills === null || fills === void 0 ? void 0 : fills[index % fills.length]);\r\n                    node.fill = fill;\r\n                    // FIXME: If there's a color scale, the strokes won't make sense. For now, just hard-code this default\r\n                    node.stroke = colorScale == null ? strokes === null || strokes === void 0 ? void 0 : strokes[index % strokes.length] : 'rgba(0, 0, 0, 0.2)';\r\n                });\r\n            });\r\n            this.rootNode = rootNode;\r\n            this.maxDepth = maxDepth;\r\n            this.colorDomain = colorDomain;\r\n        });\r\n    }\r\n    update({ seriesRect }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.updateSelections();\r\n            yield this.updateNodes();\r\n            const animationData = this.getAnimationData();\r\n            const resize = this.checkResize(seriesRect);\r\n            if (resize) {\r\n                this.animationState.transition('resize', animationData);\r\n            }\r\n            this.animationState.transition('update', animationData);\r\n        });\r\n    }\r\n    resetAllAnimation(data) {\r\n        var _a;\r\n        const datum = (_a = this.animationResetFns) === null || _a === void 0 ? void 0 : _a.datum;\r\n        // Stop any running animations by prefix convention.\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        if (datum != null) {\r\n            resetMotion(data.datumSelections, datum);\r\n        }\r\n    }\r\n    animateEmptyUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateReadyHighlight(data) {\r\n        var _a;\r\n        const datum = (_a = this.animationResetFns) === null || _a === void 0 ? void 0 : _a.datum;\r\n        if (datum != null) {\r\n            resetMotion([data], datum);\r\n        }\r\n    }\r\n    animateReadyResize(data) {\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateClearingUpdateEmpty(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animationTransitionClear() {\r\n        this.animationState.transition('clear', this.getAnimationData());\r\n    }\r\n    getAnimationData() {\r\n        const animationData = {\r\n            datumSelections: [this.groupSelection],\r\n        };\r\n        return animationData;\r\n    }\r\n    isProcessedDataAnimatable() {\r\n        return true;\r\n    }\r\n    checkProcessedDataAnimatable() {\r\n        if (!this.isProcessedDataAnimatable()) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n    }\r\n    getLabelData() {\r\n        return [];\r\n    }\r\n    getSeriesDomain() {\r\n        return [NaN, NaN];\r\n    }\r\n    getLegendData(legendType) {\r\n        return legendType === 'gradient' && this.colorKey != null && this.colorRange != null\r\n            ? [\r\n                {\r\n                    legendType: 'gradient',\r\n                    enabled: this.visible,\r\n                    seriesId: this.id,\r\n                    colorName: this.colorName,\r\n                    colorDomain: this.colorDomain,\r\n                    colorRange: this.colorRange,\r\n                },\r\n            ]\r\n            : [];\r\n    }\r\n    getDatumIdFromData(node) {\r\n        return `${node.index}`;\r\n    }\r\n    getDatumId(node) {\r\n        return this.getDatumIdFromData(node);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"childrenKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"sizeKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"colorKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"colorName\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], HierarchySeries.prototype, \"fills\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], HierarchySeries.prototype, \"strokes\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], HierarchySeries.prototype, \"colorRange\", void 0);\n\nclass PolarAxis extends Axis {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.shape = 'polygon';\r\n        this.innerRadiusRatio = 0;\r\n        this.defaultTickMinSpacing = 20;\r\n    }\r\n    computeLabelsBBox(_options, _seriesRect) {\r\n        return null;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], PolarAxis.prototype, \"innerRadiusRatio\", void 0);\n\n/**\r\n * Internal Use Only: Used to ensure this file is treated as a module until we can use moduleDetection flag in Ts v4.7\r\n */\r\nconst __FORCE_MODULE_DETECTION = 0;\n\nvar moduleSupport = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    extractDecoratedProperties: extractDecoratedProperties,\n    isDecoratedObject: isDecoratedObject,\n    listDecoratedProperties: listDecoratedProperties,\n    assignJsonApplyConstructedArray: assignJsonApplyConstructedArray,\n    Motion: easing,\n    resetIds: resetIds,\n    get ChartUpdateType () { return ChartUpdateType; },\n    extent: extent,\n    normalisedExtent: normalisedExtent,\n    normalisedExtentWithMetadata: normalisedExtentWithMetadata,\n    arraysEqual: arraysEqual,\n    toArray: toArray,\n    Validate: Validate,\n    predicateWithMessage: predicateWithMessage,\n    OPTIONAL: OPTIONAL,\n    ARRAY: ARRAY,\n    OPT_ARRAY: OPT_ARRAY,\n    NON_EMPTY_ARRAY: NON_EMPTY_ARRAY,\n    OPT_NON_EMPTY_ARRAY: OPT_NON_EMPTY_ARRAY,\n    AND: AND,\n    OR: OR,\n    LESS_THAN: LESS_THAN,\n    GREATER_THAN: GREATER_THAN,\n    FUNCTION: FUNCTION,\n    OPT_FUNCTION: OPT_FUNCTION,\n    BOOLEAN: BOOLEAN,\n    OPT_BOOLEAN: OPT_BOOLEAN,\n    STRING: STRING,\n    OPT_STRING: OPT_STRING,\n    DATE: DATE,\n    OPT_DATE: OPT_DATE,\n    DATE_ARRAY: DATE_ARRAY,\n    DATETIME_MS: DATETIME_MS,\n    OPT_DATETIME_MS: OPT_DATETIME_MS,\n    OPT_DATE_OR_DATETIME_MS: OPT_DATE_OR_DATETIME_MS,\n    COLOR_STRING: COLOR_STRING,\n    OPT_COLOR_STRING: OPT_COLOR_STRING,\n    COLOR_STRING_ARRAY: COLOR_STRING_ARRAY,\n    OPT_COLOR_STRING_ARRAY: OPT_COLOR_STRING_ARRAY,\n    NUMBER: NUMBER$1,\n    OPT_NUMBER: OPT_NUMBER,\n    NUMBER_OR_NAN: NUMBER_OR_NAN,\n    NUMBER_ARRAY: NUMBER_ARRAY,\n    OPT_NUMBER_ARRAY: OPT_NUMBER_ARRAY,\n    STRING_ARRAY: STRING_ARRAY,\n    OPT_STRING_ARRAY: OPT_STRING_ARRAY,\n    STRING_UNION: STRING_UNION,\n    BOOLEAN_ARRAY: BOOLEAN_ARRAY,\n    OPT_BOOLEAN_ARRAY: OPT_BOOLEAN_ARRAY,\n    FONT_STYLE: FONT_STYLE,\n    OPT_FONT_STYLE: OPT_FONT_STYLE,\n    FONT_WEIGHT: FONT_WEIGHT,\n    OPT_FONT_WEIGHT: OPT_FONT_WEIGHT,\n    LINE_DASH: LINE_DASH,\n    OPT_LINE_DASH: OPT_LINE_DASH,\n    LINE_CAP: LINE_CAP,\n    OPT_LINE_CAP: OPT_LINE_CAP,\n    LINE_JOIN: LINE_JOIN,\n    OPT_LINE_JOIN: OPT_LINE_JOIN,\n    POSITION: POSITION,\n    INTERACTION_RANGE: INTERACTION_RANGE,\n    TEXT_WRAP: TEXT_WRAP,\n    OVERFLOW_STRATEGY: OVERFLOW_STRATEGY,\n    TEXT_ALIGN: TEXT_ALIGN,\n    VERTICAL_ALIGN: VERTICAL_ALIGN,\n    DIRECTION: DIRECTION,\n    OPT_DIRECTION: OPT_DIRECTION,\n    Default: Default,\n    injectStyle: injectStyle,\n    clamp: clamp,\n    isEqual: isEqual,\n    isNegative: isNegative,\n    round: round$1,\n    toFixed: toFixed,\n    mod: mod,\n    deepMerge: deepMerge,\n    mergeDefaults: mergeDefaults,\n    partialAssign: partialAssign,\n    ProxyOnWrite: ProxyOnWrite,\n    ProxyPropertyOnWrite: ProxyPropertyOnWrite,\n    ActionOnSet: ActionOnSet,\n    invertShapeDirection: invertShapeDirection,\n    singleSeriesPaletteFactory: singleSeriesPaletteFactory,\n    markerPaletteFactory: markerPaletteFactory,\n    BaseModuleInstance: BaseModuleInstance,\n    REGISTERED_MODULES: REGISTERED_MODULES,\n    registerModule: registerModule,\n    hasRegisteredEnterpriseModules: hasRegisteredEnterpriseModules,\n    MODULE_CONFLICTS: MODULE_CONFLICTS,\n    registerModuleConflicts: registerModuleConflicts,\n    enterpriseModule: enterpriseModule,\n    Background: Background,\n    BackgroundModule: BackgroundModule,\n    get ChartAxisDirection () { return ChartAxisDirection; },\n    prepareAxisAnimationContext: prepareAxisAnimationContext,\n    prepareAxisAnimationFunctions: prepareAxisAnimationFunctions,\n    resetAxisGroupFn: resetAxisGroupFn,\n    resetAxisSelectionFn: resetAxisSelectionFn,\n    resetAxisLabelSelectionFn: resetAxisLabelSelectionFn,\n    resetAxisLineSelectionFn: resetAxisLineSelectionFn,\n    fixNumericExtent: fixNumericExtent,\n    DataModel: DataModel,\n    DataController: DataController,\n    SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL,\n    AGG_VALUES_EXTENT: AGG_VALUES_EXTENT,\n    SORT_DOMAIN_GROUPS: SORT_DOMAIN_GROUPS,\n    normaliseGroupTo: normaliseGroupTo,\n    normalisePropertyTo: normalisePropertyTo,\n    animationValidation: animationValidation,\n    accumulateGroup: accumulateGroup,\n    diff: diff,\n    createDatumId: createDatumId,\n    sum: sum,\n    groupSum: groupSum,\n    range: range,\n    count: count,\n    groupCount: groupCount,\n    average: average,\n    groupAverage: groupAverage,\n    area: area,\n    accumulatedValue: accumulatedValue,\n    trailingAccumulatedValue: trailingAccumulatedValue,\n    UpdateService: UpdateService,\n    LayoutService: LayoutService,\n    AnimationManager: AnimationManager,\n    ChartEventManager: ChartEventManager,\n    CursorManager: CursorManager,\n    HighlightManager: HighlightManager,\n    InteractionManager: InteractionManager,\n    TooltipManager: TooltipManager,\n    ZoomManager: ZoomManager,\n    get Layers () { return Layers; },\n    get SeriesNodePickMode () { return SeriesNodePickMode; },\n    keyProperty: keyProperty,\n    valueProperty: valueProperty,\n    rangedValueProperty: rangedValueProperty,\n    trailingValueProperty: trailingValueProperty,\n    trailingValue: trailingValue,\n    accumulativeValueProperty: accumulativeValueProperty,\n    trailingAccumulatedValueProperty: trailingAccumulatedValueProperty,\n    groupAccumulativeValueProperty: groupAccumulativeValueProperty,\n    SeriesNodeClickEvent: SeriesNodeClickEvent,\n    SeriesItemHighlightStyle: SeriesItemHighlightStyle,\n    HighlightStyle: HighlightStyle,\n    Series: Series,\n    seriesLabelFadeInAnimation: seriesLabelFadeInAnimation,\n    seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation,\n    resetLabelFn: resetLabelFn,\n    SeriesMarker: SeriesMarker,\n    SeriesTooltip: SeriesTooltip,\n    AbstractBarSeries: AbstractBarSeries,\n    CartesianSeriesNodeClickEvent: CartesianSeriesNodeClickEvent,\n    CartesianSeries: CartesianSeries,\n    pairContinuousData: pairContinuousData,\n    pairCategoryData: pairCategoryData,\n    determinePathStatus: determinePathStatus,\n    prepareLinePathAnimationFns: prepareLinePathAnimationFns,\n    prepareLinePathAnimation: prepareLinePathAnimation,\n    updateRect: updateRect,\n    getRectConfig: getRectConfig,\n    checkCrisp: checkCrisp,\n    collapsedStartingBarPosition: collapsedStartingBarPosition,\n    midpointStartingBarPosition: midpointStartingBarPosition,\n    prepareBarAnimationFunctions: prepareBarAnimationFunctions,\n    resetBarSelectionsFn: resetBarSelectionsFn,\n    get AreaSeriesTag () { return AreaSeriesTag; },\n    prepareAreaPathAnimation: prepareAreaPathAnimation,\n    markerFadeInAnimation: markerFadeInAnimation,\n    markerScaleInAnimation: markerScaleInAnimation,\n    markerSwipeScaleInAnimation: markerSwipeScaleInAnimation,\n    resetMarkerFn: resetMarkerFn,\n    resetMarkerPositionFn: resetMarkerPositionFn,\n    prepareMarkerAnimation: prepareMarkerAnimation,\n    updateLabelNode: updateLabelNode,\n    adjustLabelPlacement: adjustLabelPlacement,\n    minMax: minMax,\n    backfillPathPointData: backfillPathPointData,\n    renderPartialPath: renderPartialPath,\n    pathSwipeInAnimation: pathSwipeInAnimation,\n    pathFadeInAnimation: pathFadeInAnimation,\n    pathFadeOutAnimation: pathFadeOutAnimation,\n    buildResetPathFn: buildResetPathFn,\n    PolarSeries: PolarSeries,\n    HierarchyNode: HierarchyNode,\n    HierarchySeries: HierarchySeries,\n    get Tags () { return Tags; },\n    Axis: Axis,\n    AxisLabel: AxisLabel,\n    AxisTick: AxisTick,\n    PolarAxis: PolarAxis,\n    CategoryAxis: CategoryAxis,\n    __FORCE_MODULE_DETECTION: __FORCE_MODULE_DETECTION,\n    QUICK_TRANSITION: QUICK_TRANSITION,\n    INITIAL_LOAD: INITIAL_LOAD,\n    REMOVE_PHASE: REMOVE_PHASE,\n    UPDATE_PHASE: UPDATE_PHASE,\n    ADD_PHASE: ADD_PHASE,\n    LABEL_PHASE: LABEL_PHASE,\n    get RepeatType () { return RepeatType; },\n    isNodeArray: isNodeArray,\n    Animation: Animation,\n    StateMachine: StateMachine,\n    resetMotion: resetMotion,\n    NODE_UPDATE_PHASES: NODE_UPDATE_PHASES,\n    FROM_TO_MIXINS: FROM_TO_MIXINS,\n    fromToMotion: fromToMotion,\n    staticFromToMotion: staticFromToMotion\n});\n\nconst SERIES_FACTORIES = {};\r\nconst SERIES_DEFAULTS = {};\r\nconst SERIES_THEME_TEMPLATES = {};\r\nconst ENTERPRISE_SERIES_THEME_TEMPLATES = {};\r\nconst SERIES_PALETTE_FACTORIES = {};\r\nconst SOLO_SERIES_TYPES = new Set();\r\nconst STACKABLE_SERIES_TYPES = new Set();\r\nconst GROUPABLE_SERIES_TYPES = new Set();\r\nconst STACKED_BY_DEFAULT_SERIES_TYPES = new Set();\r\nconst SWAP_DEFAULT_AXES_CONDITIONS = {};\r\nconst CUSTOM_DEFAULTS_FUNCTIONS = {};\r\nfunction registerSeries(seriesType, chartType, cstr, defaults, theme, enterpriseTheme, paletteFactory, solo, stackable, groupable, stackedByDefault, swapDefaultAxesCondition, customDefaultsFunction) {\r\n    SERIES_FACTORIES[seriesType] = cstr;\r\n    SERIES_DEFAULTS[seriesType] = defaults;\r\n    registerSeriesThemeTemplate(seriesType, theme, enterpriseTheme);\r\n    if (paletteFactory) {\r\n        addSeriesPaletteFactory(seriesType, paletteFactory);\r\n    }\r\n    if (solo) {\r\n        addSoloSeriesType(seriesType);\r\n    }\r\n    if (stackable) {\r\n        addStackableSeriesType(seriesType);\r\n    }\r\n    if (groupable) {\r\n        addGroupableSeriesType(seriesType);\r\n    }\r\n    if (stackedByDefault) {\r\n        addStackedByDefaultSeriesType(seriesType);\r\n    }\r\n    if (swapDefaultAxesCondition) {\r\n        addSwapDefaultAxesCondition(seriesType, swapDefaultAxesCondition);\r\n    }\r\n    if (customDefaultsFunction) {\r\n        addCustomDefaultsFunctions(seriesType, customDefaultsFunction);\r\n    }\r\n    registerChartSeriesType(seriesType, chartType);\r\n}\r\nfunction registerSeriesThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate = {}) {\r\n    const existingTemplate = SERIES_THEME_TEMPLATES[seriesType];\r\n    SERIES_THEME_TEMPLATES[seriesType] = jsonMerge([existingTemplate, themeTemplate]);\r\n    ENTERPRISE_SERIES_THEME_TEMPLATES[seriesType] = jsonMerge([\r\n        existingTemplate,\r\n        themeTemplate,\r\n        enterpriseThemeTemplate,\r\n    ]);\r\n}\r\nfunction getSeries(chartType, moduleCtx) {\r\n    const seriesConstructor = SERIES_FACTORIES[chartType];\r\n    if (seriesConstructor) {\r\n        return new seriesConstructor(moduleCtx);\r\n    }\r\n    throw new Error(`AG Charts - unknown series type: ${chartType}`);\r\n}\r\nfunction getSeriesDefaults(chartType) {\r\n    return SERIES_DEFAULTS[chartType];\r\n}\r\nfunction getSeriesThemeTemplate(chartType) {\r\n    if (hasRegisteredEnterpriseModules()) {\r\n        return ENTERPRISE_SERIES_THEME_TEMPLATES[chartType];\r\n    }\r\n    return SERIES_THEME_TEMPLATES[chartType];\r\n}\r\nfunction addSeriesPaletteFactory(seriesType, factory) {\r\n    SERIES_PALETTE_FACTORIES[seriesType] = factory;\r\n}\r\nfunction getSeriesPaletteFactory(seriesType) {\r\n    return SERIES_PALETTE_FACTORIES[seriesType];\r\n}\r\nfunction isSoloSeries(seriesType) {\r\n    return SOLO_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction isStackableSeries(seriesType) {\r\n    return STACKABLE_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction isGroupableSeries(seriesType) {\r\n    return GROUPABLE_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction isSeriesStackedByDefault(seriesType) {\r\n    return STACKED_BY_DEFAULT_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction addGroupableSeriesType(seriesType) {\r\n    GROUPABLE_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addSoloSeriesType(seriesType) {\r\n    SOLO_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addStackableSeriesType(seriesType) {\r\n    STACKABLE_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addStackedByDefaultSeriesType(seriesType) {\r\n    STACKED_BY_DEFAULT_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addSwapDefaultAxesCondition(seriesType, predicate) {\r\n    SWAP_DEFAULT_AXES_CONDITIONS[seriesType] = predicate;\r\n}\r\nfunction addCustomDefaultsFunctions(seriesType, predicate) {\r\n    CUSTOM_DEFAULTS_FUNCTIONS[seriesType] = predicate;\r\n}\r\nfunction isDefaultAxisSwapNeeded(opts) {\r\n    var _a, _b;\r\n    let result;\r\n    for (const series of (_a = opts.series) !== null && _a !== void 0 ? _a : []) {\r\n        const { type = 'line' } = series;\r\n        const isDefaultAxisSwapped = (_b = SWAP_DEFAULT_AXES_CONDITIONS[type]) === null || _b === void 0 ? void 0 : _b.call(SWAP_DEFAULT_AXES_CONDITIONS, series);\r\n        if (isDefaultAxisSwapped != null) {\r\n            if (result != null && result != isDefaultAxisSwapped) {\r\n                throw new Error('AG Charts - The provided series have incompatible directions');\r\n            }\r\n            result = isDefaultAxisSwapped;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction executeCustomDefaultsFunctions(opts, initialDefaults) {\r\n    var _a;\r\n    let result = initialDefaults;\r\n    for (const series of (_a = opts.series) !== null && _a !== void 0 ? _a : []) {\r\n        const { type } = series;\r\n        const fn = type != null ? CUSTOM_DEFAULTS_FUNCTIONS[type] : undefined;\r\n        if (fn !== undefined) {\r\n            result = Object.assign(Object.assign({}, result), fn(series));\r\n        }\r\n    }\r\n    return result;\r\n}\n\nfunction setupModules() {\r\n    var _a;\r\n    for (const m of REGISTERED_MODULES) {\r\n        if (m.packageType === 'enterprise' && !verifyIfModuleExpected(m)) {\r\n            Logger.errorOnce('Unexpected enterprise module registered: ' + m.identifier);\r\n        }\r\n        if (JSON_APPLY_PLUGINS.constructors != null && m.optionConstructors != null) {\r\n            Object.assign(JSON_APPLY_PLUGINS.constructors, m.optionConstructors);\r\n        }\r\n        if (m.type === 'root' && m.themeTemplate) {\r\n            for (const chartType of m.chartTypes) {\r\n                registerChartDefaults(chartType, m.themeTemplate);\r\n            }\r\n        }\r\n        if (m.type === 'root' && ((_a = m.conflicts) === null || _a === void 0 ? void 0 : _a.length)) {\r\n            registerModuleConflicts(m.optionsKey, m.conflicts);\r\n        }\r\n        if (m.type === 'series') {\r\n            if (m.chartTypes.length > 1)\r\n                throw new Error('AG Charts - Module definition error: ' + m.identifier);\r\n            registerSeries(m.identifier, m.chartTypes[0], m.instanceConstructor, m.seriesDefaults, m.themeTemplate, m.enterpriseThemeTemplate, m.paletteFactory, m.solo, m.stackable, m.groupable, m.stackedByDefault, m.swapDefaultAxesCondition, m.customDefaultsFunction);\r\n        }\r\n        if (m.type === 'series-option' && m.themeTemplate) {\r\n            for (const seriesType of m.seriesTypes) {\r\n                registerSeriesThemeTemplate(seriesType, m.themeTemplate);\r\n            }\r\n        }\r\n        if (m.type === 'axis-option' && m.themeTemplate) {\r\n            for (const axisType of m.axisTypes) {\r\n                const axisTypeTheme = m.themeTemplate[axisType];\r\n                const theme = Object.assign(Object.assign({}, m.themeTemplate), (typeof axisTypeTheme === 'object' ? axisTypeTheme : {}));\r\n                for (const axisType of m.axisTypes) {\r\n                    delete theme[axisType];\r\n                }\r\n                registerAxisThemeTemplate(axisType, theme);\r\n            }\r\n        }\r\n        if (m.type === 'axis') {\r\n            registerAxis(m.identifier, m.instanceConstructor);\r\n            if (m.themeTemplate) {\r\n                registerAxisThemeTemplate(m.identifier, m.themeTemplate);\r\n            }\r\n        }\r\n        if (m.type === 'legend') {\r\n            registerLegend(m.identifier, m.optionsKey, m.instanceConstructor, m.themeTemplate);\r\n        }\r\n    }\r\n    if (hasRegisteredEnterpriseModules()) {\r\n        const expectedButUnused = getUnusedExpectedModules();\r\n        if (expectedButUnused.length > 0) {\r\n            Logger.errorOnce('Enterprise modules expected but not registered: ', expectedButUnused);\r\n        }\r\n    }\r\n}\n\nclass HierarchyChart extends Chart {\r\n    constructor(specialOverrides, resources) {\r\n        super(specialOverrides, resources);\r\n        this._data = {};\r\n    }\r\n    performLayout() {\r\n        const _super = Object.create(null, {\r\n            performLayout: { get: () => super.performLayout }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const shrinkRect = yield _super.performLayout.call(this);\r\n            const { seriesArea: { padding }, seriesRoot, } = this;\r\n            const fullSeriesRect = shrinkRect.clone();\r\n            shrinkRect.shrink(padding.left, 'left');\r\n            shrinkRect.shrink(padding.top, 'top');\r\n            shrinkRect.shrink(padding.right, 'right');\r\n            shrinkRect.shrink(padding.bottom, 'bottom');\r\n            this.seriesRect = shrinkRect;\r\n            this.animationRect = shrinkRect;\r\n            this.hoverRect = shrinkRect;\r\n            seriesRoot.translationX = Math.floor(shrinkRect.x);\r\n            seriesRoot.translationY = Math.floor(shrinkRect.y);\r\n            yield Promise.all(this.series.map((series) => __awaiter(this, void 0, void 0, function* () {\r\n                yield series.update({ seriesRect: shrinkRect }); // this has to happen after the `updateAxes` call\r\n            })));\r\n            seriesRoot.visible = this.series[0].visible;\r\n            seriesRoot.setClipRectInGroupCoordinateSpace(new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height));\r\n            this.layoutService.dispatchLayoutComplete({\r\n                type: 'layout-complete',\r\n                chart: { width: this.scene.width, height: this.scene.height },\r\n                clipSeries: false,\r\n                series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\r\n                axes: [],\r\n            });\r\n            return shrinkRect;\r\n        });\r\n    }\r\n}\r\nHierarchyChart.className = 'HierarchyChart';\r\nHierarchyChart.type = 'hierarchy';\n\nfunction removeUsedEnterpriseOptions(options) {\r\n    var _a, _b, _c, _d;\r\n    const usedOptions = [];\r\n    const optionsChartType = getChartType(optionsType(options));\r\n    for (const { type, chartTypes, optionsKey, optionsInnerKey, identifier } of EXPECTED_ENTERPRISE_MODULES) {\r\n        if (optionsChartType !== 'unknown' && !chartTypes.includes(optionsChartType))\r\n            continue;\r\n        if (type === 'root' || type === 'legend') {\r\n            const optionValue = options[optionsKey];\r\n            if (optionValue == null)\r\n                continue;\r\n            if (!optionsInnerKey) {\r\n                usedOptions.push(optionsKey);\r\n                delete options[optionsKey];\r\n            }\r\n            else if (optionValue[optionsInnerKey]) {\r\n                usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\r\n                delete optionValue[optionsInnerKey];\r\n            }\r\n        }\r\n        else if (type === 'axis') {\r\n            if (!('axes' in options) || !((_a = options.axes) === null || _a === void 0 ? void 0 : _a.some((axis) => axis.type === identifier)))\r\n                continue;\r\n            usedOptions.push(`axis[type=${identifier}]`);\r\n            options.axes = options.axes.filter((axis) => axis.type !== identifier);\r\n        }\r\n        else if (type === 'axis-option') {\r\n            if (!('axes' in options) || !((_b = options.axes) === null || _b === void 0 ? void 0 : _b.some((axis) => axis[optionsKey])))\r\n                continue;\r\n            usedOptions.push(`axis.${optionsKey}`);\r\n            options.axes.forEach((axis) => {\r\n                if (axis[optionsKey]) {\r\n                    delete axis[optionsKey];\r\n                }\r\n            });\r\n        }\r\n        else if (type === 'series') {\r\n            if (!((_c = options.series) === null || _c === void 0 ? void 0 : _c.some((series) => series.type === identifier)))\r\n                continue;\r\n            usedOptions.push(`series[type=${identifier}]`);\r\n            options.series = options.series.filter((series) => series.type !== identifier);\r\n        }\r\n        else if (type === 'series-option') {\r\n            if (!((_d = options.series) === null || _d === void 0 ? void 0 : _d.some((series) => series[optionsKey])))\r\n                continue;\r\n            usedOptions.push(`series.${optionsKey}`);\r\n            options.series.forEach((series) => {\r\n                if (series[optionsKey]) {\r\n                    delete series[optionsKey];\r\n                }\r\n            });\r\n        }\r\n    }\r\n    if (usedOptions.length > 0) {\r\n        Logger.warnOnce([\r\n            `unable to use these enterprise features as 'ag-charts-enterprise' has not been loaded:`,\r\n            ``,\r\n            ...usedOptions,\r\n            ``,\r\n            'See: https://charts.ag-grid.com/javascript/installation/',\r\n        ].join('\\n'));\r\n    }\r\n}\n\n/**\r\n * Groups the series options objects if they are of type `column` or `bar` and places them in an array at the index where the first instance of this series type was found.\r\n * Returns an array of arrays containing the ordered and grouped series options objects.\r\n */\r\nfunction groupSeriesByType(seriesOptions) {\r\n    var _a, _b, _c, _d;\r\n    const groupMap = {};\r\n    const stackMap = {};\r\n    const anyStacked = {};\r\n    const defaultUnstackedGroup = 'default-ag-charts-group';\r\n    const result = [];\r\n    for (const s of seriesOptions) {\r\n        const type = (_a = s.type) !== null && _a !== void 0 ? _a : 'line';\r\n        const stackable = isStackableSeries(type);\r\n        const groupable = isGroupableSeries(type);\r\n        if (!stackable && !groupable) {\r\n            // No need to use index for these cases.\r\n            result.push({ type: 'ungrouped', opts: [s] });\r\n            continue;\r\n        }\r\n        const { stacked: sStacked, stackGroup: sStackGroup, grouped: sGrouped = undefined, xKey } = s;\r\n        const stacked = sStackGroup != null || sStacked === true;\r\n        (_b = anyStacked[type]) !== null && _b !== void 0 ? _b : (anyStacked[type] = false);\r\n        anyStacked[type] || (anyStacked[type] = stacked && stackable);\r\n        const grouped = sGrouped === true;\r\n        let groupingKey = [sStackGroup !== null && sStackGroup !== void 0 ? sStackGroup : (sStacked === true ? 'stacked' : undefined), grouped ? 'grouped' : undefined]\r\n            .filter((v) => v != null)\r\n            .join('-');\r\n        if (!groupingKey) {\r\n            groupingKey = defaultUnstackedGroup;\r\n        }\r\n        const indexKey = `${type}-${xKey}-${groupingKey}`;\r\n        if (stacked && stackable) {\r\n            const updated = ((_c = stackMap[indexKey]) !== null && _c !== void 0 ? _c : (stackMap[indexKey] = { type: 'stack', opts: [] }));\r\n            if (updated.opts.length === 0)\r\n                result.push(updated);\r\n            updated.opts.push(s);\r\n        }\r\n        else if (grouped && groupable) {\r\n            const updated = ((_d = groupMap[indexKey]) !== null && _d !== void 0 ? _d : (groupMap[indexKey] = { type: 'group', opts: [] }));\r\n            if (updated.opts.length === 0)\r\n                result.push(updated);\r\n            updated.opts.push(s);\r\n        }\r\n        else {\r\n            result.push({ type: 'ungrouped', opts: [s] });\r\n        }\r\n    }\r\n    if (!Object.values(anyStacked).some((v) => v)) {\r\n        return result;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Transforms provided series options array into an array containing series options which are compatible with standalone charts series options.\r\n */\r\nfunction processSeriesOptions(_opts, seriesOptions) {\r\n    var _a;\r\n    const result = [];\r\n    const preprocessed = seriesOptions.map((series) => {\r\n        var _a;\r\n        // Change the default for bar/columns when yKey is used to be grouped rather than stacked.\r\n        const sType = (_a = series.type) !== null && _a !== void 0 ? _a : 'line';\r\n        const groupable = isGroupableSeries(sType);\r\n        const stackable = isStackableSeries(sType);\r\n        const stackedByDefault = isSeriesStackedByDefault(sType);\r\n        if (series.grouped && !groupable) {\r\n            Logger.warnOnce(`unsupported grouping of series type: ${sType}`);\r\n        }\r\n        if (series.stacked && !stackable) {\r\n            Logger.warnOnce(`unsupported stacking of series type: ${sType}`);\r\n        }\r\n        if (!groupable && !stackable) {\r\n            return series;\r\n        }\r\n        let stacked = false;\r\n        let grouped = false;\r\n        if (series.stacked === undefined && series.grouped === undefined) {\r\n            stacked = stackable && stackedByDefault;\r\n            grouped = groupable && !stacked;\r\n        }\r\n        else if (series.stacked === undefined) {\r\n            stacked = stackable && stackedByDefault && !(series.grouped && groupable);\r\n            grouped = groupable && !stacked && !!series.grouped;\r\n        }\r\n        else if (series.grouped === undefined) {\r\n            stacked = stackable && series.stacked;\r\n            grouped = groupable && !stacked;\r\n        }\r\n        else {\r\n            stacked = stackable && series.stacked;\r\n            grouped = groupable && !stacked && series.grouped;\r\n        }\r\n        return Object.assign(Object.assign({}, series), { stacked, grouped });\r\n    });\r\n    const grouped = groupSeriesByType(preprocessed);\r\n    const groupCount = grouped.reduce((result, next) => {\r\n        var _a, _b;\r\n        if (next.type === 'ungrouped')\r\n            return result;\r\n        const seriesType = (_a = next.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\r\n        (_b = result[seriesType]) !== null && _b !== void 0 ? _b : (result[seriesType] = 0);\r\n        result[seriesType] += next.type === 'stack' ? 1 : next.opts.length;\r\n        return result;\r\n    }, {});\r\n    const groupIdx = {};\r\n    const addSeriesGroupingMeta = (group) => {\r\n        var _a, _b;\r\n        let stackIdx = 0;\r\n        const seriesType = (_a = group.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\r\n        (_b = groupIdx[seriesType]) !== null && _b !== void 0 ? _b : (groupIdx[seriesType] = 0);\r\n        if (group.type === 'stack') {\r\n            for (const opts of group.opts) {\r\n                opts.seriesGrouping = {\r\n                    groupIndex: groupIdx[seriesType],\r\n                    groupCount: groupCount[seriesType],\r\n                    stackIndex: stackIdx++,\r\n                    stackCount: group.opts.length,\r\n                };\r\n            }\r\n            groupIdx[seriesType]++;\r\n        }\r\n        else if (group.type === 'group') {\r\n            for (const opts of group.opts) {\r\n                opts.seriesGrouping = {\r\n                    groupIndex: groupIdx[seriesType],\r\n                    groupCount: groupCount[seriesType],\r\n                    stackIndex: 0,\r\n                    stackCount: 0,\r\n                };\r\n                groupIdx[seriesType]++;\r\n            }\r\n        }\r\n        else {\r\n            for (const opts of group.opts) {\r\n                opts.seriesGrouping = undefined;\r\n            }\r\n        }\r\n        return group.opts;\r\n    };\r\n    Debug.create(true, 'opts')('processSeriesOptions() - series grouping: ', grouped);\r\n    for (const group of grouped) {\r\n        const seriesType = (_a = group.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\r\n        if (isGroupableSeries(seriesType) || isStackableSeries(seriesType)) {\r\n            result.push(...addSeriesGroupingMeta(group));\r\n        }\r\n        else {\r\n            result.push(...group.opts);\r\n        }\r\n    }\r\n    return result;\r\n}\n\nconst DEFAULT_BACKGROUND_FILL = 'white';\r\nconst palette$9 = {\r\n    fills: Array.from(Object.values(DEFAULT_FILLS)),\r\n    strokes: Array.from(Object.values(DEFAULT_STROKES)),\r\n};\r\nconst CHART_TYPE_CONFIG = {\r\n    get cartesian() {\r\n        return { seriesTypes: CHART_TYPES.cartesianTypes, commonOptions: ['zoom', 'navigator'] };\r\n    },\r\n    get polar() {\r\n        return { seriesTypes: CHART_TYPES.polarTypes, commonOptions: [] };\r\n    },\r\n    get hierarchy() {\r\n        return { seriesTypes: CHART_TYPES.hierarchyTypes, commonOptions: [] };\r\n    },\r\n};\r\nconst CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => [...r, ...commonOptions], []);\r\nclass ChartTheme {\r\n    getPalette() {\r\n        return palette$9;\r\n    }\r\n    static getAxisDefaults() {\r\n        return {\r\n            top: {},\r\n            right: {},\r\n            bottom: {},\r\n            left: {},\r\n            title: {\r\n                enabled: false,\r\n                text: 'Axis Title',\r\n                spacing: 25,\r\n                fontStyle: undefined,\r\n                fontWeight: NORMAL,\r\n                fontSize: FONT_SIZE.MEDIUM,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: DEFAULT_LABEL_COLOUR,\r\n            },\r\n            label: {\r\n                fontStyle: undefined,\r\n                fontWeight: undefined,\r\n                fontSize: FONT_SIZE.SMALL,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                padding: 5,\r\n                rotation: undefined,\r\n                color: DEFAULT_LABEL_COLOUR,\r\n                formatter: undefined,\r\n                avoidCollisions: true,\r\n            },\r\n            line: {\r\n                enabled: true,\r\n                width: 1,\r\n                color: DEFAULT_AXIS_LINE_COLOUR,\r\n            },\r\n            tick: {\r\n                enabled: false,\r\n                width: 1,\r\n                color: DEFAULT_AXIS_LINE_COLOUR,\r\n            },\r\n            gridLine: {\r\n                enabled: true,\r\n                style: [\r\n                    {\r\n                        stroke: DEFAULT_AXIS_GRID_COLOUR,\r\n                        lineDash: [],\r\n                    },\r\n                ],\r\n            },\r\n            crossLines: {\r\n                enabled: false,\r\n                fill: DEFAULT_CROSS_LINES_COLOUR,\r\n                stroke: DEFAULT_CROSS_LINES_COLOUR,\r\n                fillOpacity: 0.1,\r\n                strokeWidth: 1,\r\n                label: {\r\n                    enabled: false,\r\n                    fontStyle: undefined,\r\n                    fontWeight: undefined,\r\n                    fontSize: FONT_SIZE.SMALL,\r\n                    fontFamily: DEFAULT_FONT_FAMILY,\r\n                    padding: 5,\r\n                    color: DEFAULT_LABEL_COLOUR,\r\n                },\r\n            },\r\n        };\r\n    }\r\n    static getSeriesDefaults() {\r\n        return {\r\n            tooltip: {\r\n                enabled: true,\r\n                renderer: undefined,\r\n            },\r\n            visible: true,\r\n            showInLegend: true,\r\n            highlightStyle: {\r\n                item: {\r\n                    fill: 'rgba(255,255,255, 0.33)',\r\n                    stroke: `rgba(0, 0, 0, 0.4)`,\r\n                    strokeWidth: 2,\r\n                },\r\n                series: {\r\n                    dimOpacity: 1,\r\n                },\r\n                text: {\r\n                    color: 'black',\r\n                },\r\n            },\r\n            nodeClickRange: 'exact',\r\n        };\r\n    }\r\n    static getCartesianSeriesMarkerDefaults() {\r\n        return {\r\n            enabled: true,\r\n            shape: 'circle',\r\n            size: 7,\r\n            strokeWidth: 1,\r\n            formatter: undefined,\r\n        };\r\n    }\r\n    static getLegendItemMarkerDefaults() {\r\n        return {\r\n            shape: undefined,\r\n            size: 15,\r\n            padding: 8,\r\n        };\r\n    }\r\n    static getCaptionWrappingDefaults() {\r\n        return 'hyphenate';\r\n    }\r\n    static getChartDefaults() {\r\n        return {\r\n            background: {\r\n                visible: true,\r\n                fill: DEFAULT_BACKGROUND_COLOUR,\r\n            },\r\n            padding: {\r\n                top: 20,\r\n                right: 20,\r\n                bottom: 20,\r\n                left: 20,\r\n            },\r\n            title: {\r\n                enabled: false,\r\n                text: 'Title',\r\n                fontStyle: undefined,\r\n                fontWeight: NORMAL,\r\n                fontSize: FONT_SIZE.LARGE,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: DEFAULT_LABEL_COLOUR,\r\n                wrapping: ChartTheme.getCaptionWrappingDefaults(),\r\n            },\r\n            subtitle: {\r\n                enabled: false,\r\n                text: 'Subtitle',\r\n                spacing: 20,\r\n                fontStyle: undefined,\r\n                fontWeight: undefined,\r\n                fontSize: FONT_SIZE.MEDIUM,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: DEFAULT_MUTED_LABEL_COLOUR,\r\n                wrapping: ChartTheme.getCaptionWrappingDefaults(),\r\n            },\r\n            footnote: {\r\n                enabled: false,\r\n                text: 'Footnote',\r\n                spacing: 20,\r\n                fontStyle: undefined,\r\n                fontWeight: undefined,\r\n                fontSize: FONT_SIZE.MEDIUM,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: 'rgb(140, 140, 140)',\r\n                wrapping: ChartTheme.getCaptionWrappingDefaults(),\r\n            },\r\n            legend: {\r\n                position: BOTTOM,\r\n                spacing: 30,\r\n                listeners: {},\r\n                item: {\r\n                    paddingX: 16,\r\n                    paddingY: 8,\r\n                    marker: ChartTheme.getLegendItemMarkerDefaults(),\r\n                    label: {\r\n                        color: DEFAULT_LABEL_COLOUR,\r\n                        fontStyle: undefined,\r\n                        fontWeight: undefined,\r\n                        fontSize: FONT_SIZE.SMALL,\r\n                        fontFamily: DEFAULT_FONT_FAMILY,\r\n                        formatter: undefined,\r\n                    },\r\n                },\r\n                reverseOrder: false,\r\n                pagination: {\r\n                    marker: {\r\n                        size: 12,\r\n                    },\r\n                    activeStyle: {\r\n                        fill: DEFAULT_LABEL_COLOUR,\r\n                    },\r\n                    inactiveStyle: {\r\n                        fill: DEFAULT_MUTED_LABEL_COLOUR,\r\n                    },\r\n                    highlightStyle: {\r\n                        fill: DEFAULT_LABEL_COLOUR,\r\n                    },\r\n                    label: {\r\n                        color: DEFAULT_LABEL_COLOUR,\r\n                    },\r\n                },\r\n            },\r\n            tooltip: {\r\n                enabled: true,\r\n                range: 'nearest',\r\n                delay: 0,\r\n            },\r\n            listeners: {},\r\n        };\r\n    }\r\n    constructor(options) {\r\n        options = deepMerge({}, options !== null && options !== void 0 ? options : {});\r\n        const { overrides = null, palette = null } = options;\r\n        const defaults = this.createChartConfigPerChartType(this.getDefaults());\r\n        if (overrides) {\r\n            const { common } = overrides;\r\n            const applyOverrides = (seriesTypes, overrideOpts) => {\r\n                if (!overrideOpts)\r\n                    return;\r\n                for (const s of seriesTypes) {\r\n                    const seriesType = s;\r\n                    defaults[seriesType] = deepMerge(defaults[seriesType], overrideOpts);\r\n                }\r\n            };\r\n            for (const [, { seriesTypes, commonOptions }] of Object.entries(CHART_TYPE_CONFIG)) {\r\n                const cleanedCommon = Object.assign({}, common);\r\n                for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\r\n                    if (!commonOptions.includes(commonKey)) {\r\n                        delete cleanedCommon[commonKey];\r\n                    }\r\n                }\r\n                applyOverrides(seriesTypes, cleanedCommon);\r\n            }\r\n            CHART_TYPES.seriesTypes.forEach((s) => {\r\n                const seriesType = s;\r\n                if (overrides[seriesType]) {\r\n                    defaults[seriesType] = deepMerge(defaults[seriesType], overrides[seriesType]);\r\n                }\r\n            });\r\n        }\r\n        this.palette = palette !== null && palette !== void 0 ? palette : this.getPalette();\r\n        this.config = Object.freeze(this.templateTheme(defaults));\r\n    }\r\n    createChartConfigPerChartType(config) {\r\n        Object.entries(CHART_TYPE_CONFIG).forEach(([nextType, { seriesTypes }]) => {\r\n            const typeDefaults = getChartDefaults(nextType);\r\n            seriesTypes.forEach((next) => {\r\n                const alias = next;\r\n                if (!config[alias]) {\r\n                    config[alias] = {};\r\n                    deepMerge(config[alias], typeDefaults);\r\n                }\r\n            });\r\n        });\r\n        return config;\r\n    }\r\n    getDefaults() {\r\n        let defaults = {};\r\n        const getChartTypeDefaults = (chartType) => {\r\n            return Object.assign(Object.assign(Object.assign({}, getLegendThemeTemplates()), ChartTheme.getChartDefaults()), getChartDefaults(chartType));\r\n        };\r\n        const getOverridesByType = (chartType, seriesTypes) => {\r\n            var _a, _b, _c;\r\n            var _d;\r\n            const chartDefaults = getChartTypeDefaults(chartType);\r\n            const result = {};\r\n            for (const seriesType of seriesTypes) {\r\n                (_a = result[seriesType]) !== null && _a !== void 0 ? _a : (result[seriesType] = deepMerge({}, chartDefaults));\r\n                const axes = ((_b = (_d = result[seriesType]).axes) !== null && _b !== void 0 ? _b : (_d.axes = {}));\r\n                const template = getSeriesThemeTemplate(seriesType);\r\n                if (template) {\r\n                    result[seriesType].series = deepMerge(result[seriesType].series, template);\r\n                }\r\n                for (const axisType of AXIS_TYPES.axesTypes) {\r\n                    const template = getAxisThemeTemplate(axisType);\r\n                    if (chartType === 'cartesian') {\r\n                        axes[axisType] = deepMerge(axes[axisType], (_c = ChartTheme.cartesianAxisDefault[axisType]) !== null && _c !== void 0 ? _c : {});\r\n                    }\r\n                    if (template) {\r\n                        axes[axisType] = deepMerge(axes[axisType], template);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        defaults = deepMerge(defaults, getOverridesByType('cartesian', CHART_TYPES.cartesianTypes));\r\n        defaults = deepMerge(defaults, getOverridesByType('polar', CHART_TYPES.polarTypes));\r\n        defaults = deepMerge(defaults, getOverridesByType('hierarchy', CHART_TYPES.hierarchyTypes));\r\n        return defaults;\r\n    }\r\n    templateTheme(themeTemplate) {\r\n        const themeInstance = jsonMerge([themeTemplate]);\r\n        const { extensions, properties } = this.getTemplateParameters();\r\n        jsonWalk(themeInstance, (_, node) => {\r\n            if (node['__extends__']) {\r\n                const key = node['__extends__'];\r\n                const source = extensions.get(key);\r\n                if (source == null) {\r\n                    throw new Error('AG Charts - no template variable provided for: ' + key);\r\n                }\r\n                Object.keys(source).forEach((key) => {\r\n                    if (!(key in node)) {\r\n                        node[key] = source[key];\r\n                    }\r\n                });\r\n                delete node['__extends__'];\r\n            }\r\n            if (node['__overrides__']) {\r\n                const key = node['__overrides__'];\r\n                const source = extensions.get(key);\r\n                if (source == null) {\r\n                    throw new Error('AG Charts - no template variable provided for: ' + key);\r\n                }\r\n                Object.assign(node, source);\r\n                delete node['__overrides__'];\r\n            }\r\n            if (Array.isArray(node)) {\r\n                for (let i = 0; i < node.length; i++) {\r\n                    const symbol = node[i];\r\n                    if (properties.has(symbol)) {\r\n                        node[i] = properties.get(symbol);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (const [name, value] of Object.entries(node)) {\r\n                    if (properties.has(value)) {\r\n                        node[name] = properties.get(value);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return themeInstance;\r\n    }\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: DEFAULT_FILLS.BLUE,\r\n            stroke: DEFAULT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: DEFAULT_FILLS.ORANGE,\r\n            stroke: DEFAULT_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: DEFAULT_FILLS.GRAY,\r\n            stroke: DEFAULT_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const extensions = new Map();\r\n        extensions.set(EXTENDS_CHART_DEFAULTS, ChartTheme.getChartDefaults());\r\n        extensions.set(EXTENDS_AXES_DEFAULTS, ChartTheme.getAxisDefaults());\r\n        extensions.set(EXTENDS_LEGEND_DEFAULTS, ChartTheme.getChartDefaults().legend);\r\n        extensions.set(EXTENDS_LEGEND_ITEM_DEFAULTS, ChartTheme.getChartDefaults().legend.item);\r\n        extensions.set(EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS, ChartTheme.getLegendItemMarkerDefaults());\r\n        extensions.set(EXTENDS_AXES_LABEL_DEFAULTS, ChartTheme.getAxisDefaults().label);\r\n        extensions.set(EXTENDS_AXES_LINE_DEFAULTS, ChartTheme.getAxisDefaults().line);\r\n        extensions.set(EXTENDS_AXES_TICK_DEFAULTS, ChartTheme.getAxisDefaults().tick);\r\n        extensions.set(EXTENDS_AXES_GRID_LINE_DEFAULTS, ChartTheme.getAxisDefaults().gridLine);\r\n        extensions.set(EXTENDS_SERIES_DEFAULTS, ChartTheme.getSeriesDefaults());\r\n        extensions.set(OVERRIDE_SERIES_LABEL_DEFAULTS, {});\r\n        extensions.set(EXTENDS_CARTESIAN_MARKER_DEFAULTS, ChartTheme.getCartesianSeriesMarkerDefaults());\r\n        const properties = new Map();\r\n        properties.set(DEFAULT_FONT_FAMILY, 'Verdana, sans-serif');\r\n        properties.set(DEFAULT_LABEL_COLOUR, 'rgb(70, 70, 70)');\r\n        properties.set(DEFAULT_INVERTED_LABEL_COLOUR, 'white');\r\n        properties.set(DEFAULT_MUTED_LABEL_COLOUR, 'rgb(140, 140, 140)');\r\n        properties.set(DEFAULT_AXIS_GRID_COLOUR, 'rgb(224,234,241)');\r\n        properties.set(DEFAULT_AXIS_LINE_COLOUR, 'rgb(195, 195, 195)');\r\n        properties.set(DEFAULT_CROSS_LINES_COLOUR, 'rgb(70, 70, 70)');\r\n        properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\r\n        properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\r\n        properties.set(DEFAULT_SHADOW_COLOUR, 'rgba(0, 0, 0, 0.5)');\r\n        properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            DEFAULT_FILLS.ORANGE,\r\n            DEFAULT_FILLS.YELLOW,\r\n            DEFAULT_FILLS.GREEN,\r\n        ]);\r\n        properties.set(DEFAULT_HIERARCHY_FILLS, ['#ffffff', '#e0e5ea', '#c1ccd5', '#a3b4c1', '#859cad']);\r\n        properties.set(DEFAULT_HIERARCHY_STROKES, ['#ffffff', '#c5cbd1', '#a4b1bd', '#8498a9', '#648096']);\r\n        properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\r\n        properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, ChartTheme.getWaterfallSeriesDefaultPositiveColors());\r\n        properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, ChartTheme.getWaterfallSeriesDefaultNegativeColors());\r\n        properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, ChartTheme.getWaterfallSeriesDefaultTotalColors());\r\n        properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, ChartTheme.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return {\r\n            extensions,\r\n            properties,\r\n        };\r\n    }\r\n}\r\nChartTheme.cartesianAxisDefault = {\r\n    number: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { line: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().line), { enabled: false }) }),\r\n    log: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { base: 10, line: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().line), { enabled: false }) }),\r\n    category: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { groupPaddingInner: 0.1, label: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().label), { autoRotate: true }), gridLine: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().gridLine), { enabled: false }) }),\r\n    'grouped-category': Object.assign({}, ChartTheme.getAxisDefaults()),\r\n    time: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { gridLine: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().gridLine), { enabled: false }) }),\r\n};\n\nconst DEFAULT_DARK_BACKGROUND_FILL = '#182732';\r\nconst DEFAULT_DARK_FILLS = {\r\n    BLUE: '#5090dc',\r\n    ORANGE: '#ffa03a',\r\n    GREEN: '#459d55',\r\n    CYAN: '#34bfe1',\r\n    YELLOW: '#e1cc00',\r\n    VIOLET: '#9669cb',\r\n    GRAY: '#b5b5b5',\r\n    MAGENTA: '#bd5aa7',\r\n    BROWN: '#8a6224',\r\n    RED: '#ef5452',\r\n};\r\nconst DEFAULT_DARK_STROKES = {\r\n    BLUE: '#74a8e6',\r\n    ORANGE: '#ffbe70',\r\n    GREEN: '#6cb176',\r\n    CYAN: '#75d4ef',\r\n    YELLOW: '#f6e559',\r\n    VIOLET: '#aa86d8',\r\n    GRAY: '#a1a1a1',\r\n    MAGENTA: '#ce7ab9',\r\n    BROWN: '#997b52',\r\n    RED: '#ff7872',\r\n};\r\nconst palette$8 = {\r\n    fills: Array.from(Object.values(DEFAULT_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(DEFAULT_DARK_STROKES)),\r\n};\r\nclass DarkTheme extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: DEFAULT_DARK_FILLS.BLUE,\r\n            stroke: DEFAULT_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: DEFAULT_DARK_FILLS.ORANGE,\r\n            stroke: DEFAULT_DARK_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: DEFAULT_DARK_FILLS.GRAY,\r\n            stroke: DEFAULT_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, DarkTheme.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, DarkTheme.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, DarkTheme.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, DarkTheme.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        result.properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\r\n        result.properties.set(DEFAULT_LABEL_COLOUR, 'white');\r\n        result.properties.set(DEFAULT_MUTED_LABEL_COLOUR, '#7D91A0');\r\n        result.properties.set(DEFAULT_AXIS_GRID_COLOUR, '#545A6E');\r\n        result.properties.set(DEFAULT_CROSS_LINES_COLOUR, 'white');\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            DEFAULT_DARK_FILLS.ORANGE,\r\n            DEFAULT_DARK_FILLS.YELLOW,\r\n            DEFAULT_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_HIERARCHY_FILLS, ['#192834', '#253746', '#324859', '#3f596c', '#4d6a80']);\r\n        result.properties.set(DEFAULT_HIERARCHY_STROKES, ['#192834', '#3b5164', '#496275', '#577287', '#668399']);\r\n        result.properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\r\n        result.properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$8;\r\n    }\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n}\n\nconst MATERIAL_DARK_FILLS = {\r\n    BLUE: '#2196F3',\r\n    ORANGE: '#FF9800',\r\n    GREEN: '#4CAF50',\r\n    CYAN: '#00BCD4',\r\n    YELLOW: '#FFEB3B',\r\n    VIOLET: '#7E57C2',\r\n    GRAY: '#9E9E9E',\r\n    MAGENTA: '#F06292',\r\n    BROWN: '#795548',\r\n    RED: '#F44336',\r\n};\r\nconst MATERIAL_DARK_STROKES = {\r\n    BLUE: '#90CAF9',\r\n    ORANGE: '#FFCC80',\r\n    GREEN: '#A5D6A7',\r\n    CYAN: '#80DEEA',\r\n    YELLOW: '#FFF9C4',\r\n    VIOLET: '#B39DDB',\r\n    GRAY: '#E0E0E0',\r\n    MAGENTA: '#F48FB1',\r\n    BROWN: '#A1887F',\r\n    RED: '#EF9A9A',\r\n};\r\nconst palette$7 = {\r\n    fills: Array.from(Object.values(MATERIAL_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(MATERIAL_DARK_STROKES)),\r\n};\r\nclass MaterialDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: MATERIAL_DARK_FILLS.BLUE,\r\n            stroke: MATERIAL_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: MATERIAL_DARK_FILLS.RED,\r\n            stroke: MATERIAL_DARK_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: MATERIAL_DARK_FILLS.GRAY,\r\n            stroke: MATERIAL_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, MaterialDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, MaterialDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, MaterialDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            MATERIAL_DARK_FILLS.ORANGE,\r\n            MATERIAL_DARK_FILLS.YELLOW,\r\n            MATERIAL_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, MaterialDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$7;\r\n    }\r\n}\n\nconst MATERIAL_LIGHT_FILLS = {\r\n    BLUE: '#2196F3',\r\n    ORANGE: '#FF9800',\r\n    GREEN: '#4CAF50',\r\n    CYAN: '#00BCD4',\r\n    YELLOW: '#FFEB3B',\r\n    VIOLET: '#7E57C2',\r\n    GRAY: '#9E9E9E',\r\n    MAGENTA: '#F06292',\r\n    BROWN: '#795548',\r\n    RED: '#F44336',\r\n};\r\nconst MATERIAL_LIGHT_STROKES = {\r\n    BLUE: '#1565C0',\r\n    ORANGE: '#E65100',\r\n    GREEN: '#2E7D32',\r\n    CYAN: '#00838F',\r\n    YELLOW: '#F9A825',\r\n    VIOLET: '#4527A0',\r\n    GRAY: '#616161',\r\n    MAGENTA: '#C2185B',\r\n    BROWN: '#4E342E',\r\n    RED: '#B71C1C',\r\n};\r\nconst palette$6 = {\r\n    fills: Array.from(Object.values(MATERIAL_LIGHT_FILLS)),\r\n    strokes: Array.from(Object.values(MATERIAL_LIGHT_STROKES)),\r\n};\r\nclass MaterialLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: MATERIAL_LIGHT_FILLS.BLUE,\r\n            stroke: MATERIAL_LIGHT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: MATERIAL_LIGHT_FILLS.RED,\r\n            stroke: MATERIAL_LIGHT_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: MATERIAL_LIGHT_FILLS.GRAY,\r\n            stroke: MATERIAL_LIGHT_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, MaterialLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, MaterialLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, MaterialLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            MATERIAL_LIGHT_FILLS.ORANGE,\r\n            MATERIAL_LIGHT_FILLS.YELLOW,\r\n            MATERIAL_LIGHT_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, MaterialLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$6;\r\n    }\r\n}\n\nconst POLYCHROMA_DARK_FILLS = {\r\n    BLUE: '#436ff4',\r\n    PURPLE: '#9a7bff',\r\n    MAGENTA: '#d165d2',\r\n    PINK: '#f0598b',\r\n    RED: '#f47348',\r\n    ORANGE: '#f2a602',\r\n    YELLOW: '#e9e201',\r\n    GREEN: '#21b448',\r\n    CYAN: '#00b9a2',\r\n    MODERATE_BLUE: '#00aee4',\r\n};\r\nconst POLYCHROMA_DARK_STROKES = {\r\n    BLUE: '#6698ff',\r\n    PURPLE: '#c0a3ff',\r\n    MAGENTA: '#fc8dfc',\r\n    PINK: '#ff82b1',\r\n    RED: '#ff9b70',\r\n    ORANGE: '#ffcf4e',\r\n    YELLOW: '#ffff58',\r\n    GREEN: '#58dd70',\r\n    CYAN: '#51e2c9',\r\n    MODERATE_BLUE: '#4fd7ff',\r\n};\r\nconst POLYCHROMA_DARK_FILL_GRAY = '#bbbbbb';\r\nconst POLYCHROMA_DARK_STROKE_GRAY = '#eeeeee';\r\nconst palette$5 = {\r\n    fills: Array.from(Object.values(POLYCHROMA_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(POLYCHROMA_DARK_STROKES)),\r\n};\r\nclass PolychromaDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: POLYCHROMA_DARK_FILLS.BLUE,\r\n            stroke: POLYCHROMA_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: POLYCHROMA_DARK_FILLS.RED,\r\n            stroke: POLYCHROMA_DARK_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: POLYCHROMA_DARK_FILL_GRAY,\r\n            stroke: POLYCHROMA_DARK_STROKE_GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, PolychromaDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, PolychromaDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, PolychromaDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            POLYCHROMA_DARK_FILLS.BLUE,\r\n            POLYCHROMA_DARK_FILLS.RED,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, PolychromaDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$5;\r\n    }\r\n}\n\nconst POLYCHROMA_LIGHT_FILLS = {\r\n    BLUE: '#436ff4',\r\n    PURPLE: '#9a7bff',\r\n    MAGENTA: '#d165d2',\r\n    PINK: '#f0598b',\r\n    RED: '#f47348',\r\n    ORANGE: '#f2a602',\r\n    YELLOW: '#e9e201',\r\n    GREEN: '#21b448',\r\n    CYAN: '#00b9a2',\r\n    MODERATE_BLUE: '#00aee4',\r\n};\r\nconst POLYCHROMA_LIGHT_STROKES = {\r\n    BLUE: '#2346c9',\r\n    PURPLE: '#7653d4',\r\n    MAGENTA: '#a73da9',\r\n    PINK: '#c32d66',\r\n    RED: '#c84b1c',\r\n    ORANGE: '#c87f00',\r\n    YELLOW: '#c1b900',\r\n    GREEN: '#008c1c',\r\n    CYAN: '#00927c',\r\n    MODERATE_BLUE: '#0087bb',\r\n};\r\nconst POLYCHROMA_LIGHT_FILL_GRAY = '#bbbbbb';\r\nconst POLYCHROMA_LIGHT_STROKE_GRAY = '#888888';\r\nconst palette$4 = {\r\n    fills: Array.from(Object.values(POLYCHROMA_LIGHT_FILLS)),\r\n    strokes: Array.from(Object.values(POLYCHROMA_LIGHT_STROKES)),\r\n};\r\nclass PolychromaLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: POLYCHROMA_LIGHT_FILLS.BLUE,\r\n            stroke: POLYCHROMA_LIGHT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: POLYCHROMA_LIGHT_FILLS.RED,\r\n            stroke: POLYCHROMA_LIGHT_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: POLYCHROMA_LIGHT_FILL_GRAY,\r\n            stroke: POLYCHROMA_LIGHT_STROKE_GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, PolychromaLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, PolychromaLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, PolychromaLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            POLYCHROMA_LIGHT_FILLS.BLUE,\r\n            POLYCHROMA_LIGHT_FILLS.RED,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, PolychromaLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$4;\r\n    }\r\n}\n\nconst SHEETS_DARK_FILLS = {\r\n    BLUE: '#4472C4',\r\n    ORANGE: '#ED7D31',\r\n    GRAY: '#A5A5A5',\r\n    YELLOW: '#FFC000',\r\n    MODERATE_BLUE: '#5B9BD5',\r\n    GREEN: '#70AD47',\r\n    DARK_GRAY: '#7B7B7B',\r\n    DARK_BLUE: '#264478',\r\n    VERY_DARK_GRAY: '#636363',\r\n    DARK_YELLOW: '#997300',\r\n};\r\nconst SHEETS_DARK_STROKES = {\r\n    BLUE: '#6899ee',\r\n    ORANGE: '#ffa55d',\r\n    GRAY: '#cdcdcd',\r\n    YELLOW: '#ffea53',\r\n    MODERATE_BLUE: '#82c3ff',\r\n    GREEN: '#96d56f',\r\n    DARK_GRAY: '#a1a1a1',\r\n    DARK_BLUE: '#47689f',\r\n    VERY_DARK_GRAY: '#878787',\r\n    DARK_YELLOW: '#c0993d',\r\n};\r\nconst palette$3 = {\r\n    fills: Array.from(Object.values(SHEETS_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(SHEETS_DARK_STROKES)),\r\n};\r\nclass SheetsDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: SHEETS_DARK_FILLS.BLUE,\r\n            stroke: SHEETS_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: SHEETS_DARK_FILLS.ORANGE,\r\n            stroke: SHEETS_DARK_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: SHEETS_DARK_FILLS.GRAY,\r\n            stroke: SHEETS_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, SheetsDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, SheetsDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, SheetsDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            SHEETS_DARK_FILLS.ORANGE,\r\n            SHEETS_DARK_FILLS.YELLOW,\r\n            SHEETS_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, SheetsDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$3;\r\n    }\r\n}\n\nconst SHEETS_LIGHT_FILLS = {\r\n    BLUE: '#5281d5',\r\n    ORANGE: '#ff8d44',\r\n    GRAY: '#b5b5b5',\r\n    YELLOW: '#ffd02f',\r\n    MODERATE_BLUE: '#6aabe6',\r\n    GREEN: '#7fbd57',\r\n    DARK_GRAY: '#8a8a8a',\r\n    DARK_BLUE: '#335287',\r\n    VERY_DARK_GRAY: '#717171',\r\n    DARK_YELLOW: '#a98220',\r\n};\r\nconst SHEETS_LIGHT_STROKES = {\r\n    BLUE: '#214d9b',\r\n    ORANGE: '#c25600',\r\n    GRAY: '#7f7f7f',\r\n    YELLOW: '#d59800',\r\n    MODERATE_BLUE: '#3575ac',\r\n    GREEN: '#4b861a',\r\n    DARK_GRAY: '#575757',\r\n    DARK_BLUE: '#062253',\r\n    VERY_DARK_GRAY: '#414141',\r\n    DARK_YELLOW: '#734f00',\r\n};\r\nconst palette$2 = {\r\n    fills: Array.from(Object.values(SHEETS_LIGHT_FILLS)),\r\n    strokes: Array.from(Object.values(SHEETS_LIGHT_STROKES)),\r\n};\r\nclass SheetsLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: SHEETS_LIGHT_FILLS.BLUE,\r\n            stroke: SHEETS_LIGHT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: SHEETS_LIGHT_FILLS.ORANGE,\r\n            stroke: SHEETS_LIGHT_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: SHEETS_LIGHT_FILLS.GRAY,\r\n            stroke: SHEETS_LIGHT_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, SheetsLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, SheetsLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, SheetsLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            SHEETS_LIGHT_FILLS.ORANGE,\r\n            SHEETS_LIGHT_FILLS.YELLOW,\r\n            SHEETS_LIGHT_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, SheetsLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$2;\r\n    }\r\n}\n\nconst VIVID_DARK_FILLS = {\r\n    BLUE: '#0083ff',\r\n    ORANGE: '#ff6600',\r\n    GREEN: '#00af00',\r\n    CYAN: '#00ccff',\r\n    YELLOW: '#f7c700',\r\n    VIOLET: '#ac26ff',\r\n    GRAY: '#a7a7b7',\r\n    MAGENTA: '#e800c5',\r\n    BROWN: '#b54300',\r\n    RED: '#ff0000',\r\n};\r\nconst VIVID_DARK_STROKES = {\r\n    BLUE: '#67b7ff',\r\n    ORANGE: '#ffc24d',\r\n    GREEN: '#5cc86f',\r\n    CYAN: '#54ebff',\r\n    VIOLET: '#c18aff',\r\n    YELLOW: '#fff653',\r\n    GRAY: '#aeaeae',\r\n    MAGENTA: '#f078d4',\r\n    BROWN: '#ba8438',\r\n    RED: '#ff726e',\r\n};\r\nconst palette$1 = {\r\n    fills: Array.from(Object.values(VIVID_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(VIVID_DARK_STROKES)),\r\n};\r\nclass VividDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: VIVID_DARK_FILLS.BLUE,\r\n            stroke: VIVID_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: VIVID_DARK_FILLS.ORANGE,\r\n            stroke: VIVID_DARK_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: VIVID_DARK_FILLS.GRAY,\r\n            stroke: VIVID_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, VividDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, VividDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, VividDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            VIVID_DARK_FILLS.ORANGE,\r\n            VIVID_DARK_FILLS.YELLOW,\r\n            VIVID_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, VividDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$1;\r\n    }\r\n}\n\nconst VIVID_FILLS = {\r\n    BLUE: '#0083ff',\r\n    ORANGE: '#ff6600',\r\n    GREEN: '#00af00',\r\n    CYAN: '#00ccff',\r\n    YELLOW: '#f7c700',\r\n    VIOLET: '#ac26ff',\r\n    GRAY: '#a7a7b7',\r\n    MAGENTA: '#e800c5',\r\n    BROWN: '#b54300',\r\n    RED: '#ff0000',\r\n};\r\nconst VIVID_STROKES = {\r\n    BLUE: '#0f68c0',\r\n    ORANGE: '#d47100',\r\n    GREEN: '#007922',\r\n    CYAN: '#009ac2',\r\n    VIOLET: '#bca400',\r\n    YELLOW: '#753cac',\r\n    GRAY: '#646464',\r\n    MAGENTA: '#9b2685',\r\n    BROWN: '#6c3b00',\r\n    RED: '#cb0021',\r\n};\r\nconst palette = {\r\n    fills: Array.from(Object.values(VIVID_FILLS)),\r\n    strokes: Array.from(Object.values(VIVID_STROKES)),\r\n};\r\nclass VividLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: VIVID_FILLS.BLUE,\r\n            stroke: VIVID_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: VIVID_FILLS.ORANGE,\r\n            stroke: VIVID_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: VIVID_FILLS.GRAY,\r\n            stroke: VIVID_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, VividLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, VividLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, VividLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            VIVID_FILLS.ORANGE,\r\n            VIVID_FILLS.YELLOW,\r\n            VIVID_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, VividLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette;\r\n    }\r\n}\n\nconst lightTheme = () => new ChartTheme();\r\nconst darkTheme = () => new DarkTheme();\r\nconst lightThemes = {\r\n    undefined: lightTheme,\r\n    null: lightTheme,\r\n    'ag-default': lightTheme,\r\n    'ag-sheets': () => new SheetsLight(),\r\n    'ag-polychroma': () => new PolychromaLight(),\r\n    'ag-vivid': () => new VividLight(),\r\n    'ag-material': () => new MaterialLight(),\r\n};\r\nconst darkThemes = {\r\n    undefined: darkTheme,\r\n    null: darkTheme,\r\n    'ag-default-dark': darkTheme,\r\n    'ag-sheets-dark': () => new SheetsDark(),\r\n    'ag-polychroma-dark': () => new PolychromaDark(),\r\n    'ag-vivid-dark': () => new VividDark(),\r\n    'ag-material-dark': () => new MaterialDark(),\r\n};\r\nconst themes$1 = Object.assign(Object.assign({}, darkThemes), lightThemes);\r\nfunction validateChartThemeObject(unknownObject) {\r\n    if (unknownObject === null) {\r\n        return undefined;\r\n    }\r\n    let valid = true;\r\n    const { baseTheme, palette, overrides } = unknownObject;\r\n    if (baseTheme !== undefined && typeof baseTheme !== 'string' && typeof baseTheme !== 'object') {\r\n        Logger.warn(`invalid theme.baseTheme type ${typeof baseTheme}, expected (string | object).`);\r\n        valid = false;\r\n    }\r\n    if (overrides !== undefined && typeof overrides !== 'object') {\r\n        Logger.warn(`invalid theme.overrides type ${typeof overrides}, expected object.`);\r\n        valid = false;\r\n    }\r\n    if (typeof palette === 'object') {\r\n        if (palette !== null) {\r\n            const { fills, strokes } = palette;\r\n            if (!Array.isArray(fills)) {\r\n                Logger.warn(`theme.overrides.fills must be a defined array`);\r\n                valid = false;\r\n            }\r\n            if (!Array.isArray(strokes)) {\r\n                Logger.warn(`theme.overrides.strokes must be a defined array`);\r\n                valid = false;\r\n            }\r\n        }\r\n    }\r\n    else if (palette !== undefined) {\r\n        Logger.warn(`invalid theme.palette type ${typeof palette}, expected object.`);\r\n        valid = false;\r\n    }\r\n    if (valid) {\r\n        return unknownObject;\r\n    }\r\n    return undefined;\r\n}\r\nfunction validateChartTheme(value) {\r\n    if (value === undefined || typeof value === 'string' || value instanceof ChartTheme) {\r\n        return value;\r\n    }\r\n    if (typeof value === 'object') {\r\n        return validateChartThemeObject(value);\r\n    }\r\n    Logger.warn(`invalid theme value type ${typeof value}, expected object.`);\r\n    return undefined;\r\n}\r\nfunction getChartTheme(unvalidatedValue) {\r\n    var _a;\r\n    // unvalidatedValue is either a built-in theme (`string | ChartTheme`) or a user defined\r\n    // theme (`AgChartTheme`). In the latter case, we can't make any assumption about the\r\n    // property types, hence why the input parameter is `unknown`. This abnormal validation\r\n    // is tech debt; the ideal solution would be to integrate user themes with the @Validate\r\n    // decorator like other chart options.\r\n    let value = validateChartTheme(unvalidatedValue);\r\n    if (value instanceof ChartTheme) {\r\n        return value;\r\n    }\r\n    if (value === undefined || typeof value === 'string') {\r\n        const stockTheme = themes$1[value];\r\n        if (stockTheme) {\r\n            return stockTheme();\r\n        }\r\n        Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\r\n        return lightTheme();\r\n    }\r\n    // Flatten recursive themes.\r\n    const overrides = [];\r\n    let palette;\r\n    while (typeof value === 'object') {\r\n        overrides.push((_a = value.overrides) !== null && _a !== void 0 ? _a : {});\r\n        // Use first palette found, they can't be merged.\r\n        if (value.palette && palette == null) {\r\n            palette = value.palette;\r\n        }\r\n        value = value.baseTheme;\r\n    }\r\n    overrides.reverse();\r\n    const flattenedTheme = Object.assign({ baseTheme: value, overrides: jsonMerge(overrides) }, (palette ? { palette } : {}));\r\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\r\n    return new baseTheme.constructor(flattenedTheme);\r\n}\n\nfunction takeColours(context, colours, maxCount) {\r\n    const result = [];\r\n    for (let count = 0; count < maxCount; count++) {\r\n        result.push(colours[(count + context.colourIndex) % colours.length]);\r\n    }\r\n    return result;\r\n}\r\nconst noDataCloneMergeOptions = {\r\n    avoidDeepClone: ['data'],\r\n};\r\nfunction getGlobalTooltipPositionOptions(position) {\r\n    // Note: we do not need to show a warning message if the validation fails. These global tooltip options\r\n    // are already processed at the root of the chart options. Logging a message here would trigger duplicate\r\n    // validation warnings.\r\n    if (position === undefined || typeof position !== 'object' || position === null) {\r\n        return {};\r\n    }\r\n    const { type, xOffset, yOffset } = position;\r\n    const result = {};\r\n    const AgTooltipPositionTypeMap = { pointer: true, node: true };\r\n    const isTooltipPositionType = (value) => Object.keys(AgTooltipPositionTypeMap).includes(value);\r\n    if (typeof type === 'string' && isTooltipPositionType(type)) {\r\n        result.type = type;\r\n    }\r\n    if (typeof xOffset === 'number' && !isNaN(xOffset) && isFinite(xOffset)) {\r\n        result.xOffset = xOffset;\r\n    }\r\n    if (typeof yOffset === 'number' && !isNaN(yOffset) && isFinite(yOffset)) {\r\n        result.yOffset = yOffset;\r\n    }\r\n    return result;\r\n}\r\nfunction prepareOptions(options) {\r\n    var _a, _b, _c, _d;\r\n    sanityCheckOptions(options);\r\n    // Determine type and ensure it's explicit in the options config.\r\n    const type = optionsType(options);\r\n    const globalTooltipPositionOptions = getGlobalTooltipPositionOptions((_a = options.tooltip) === null || _a === void 0 ? void 0 : _a.position);\r\n    const checkSeriesType = (type) => {\r\n        if (type != null && !(isSeriesOptionType(type) || isEnterpriseSeriesType(type) || getSeriesDefaults(type))) {\r\n            throw new Error(`AG Charts - unknown series type: ${type}; expected one of: ${CHART_TYPES.seriesTypes}`);\r\n        }\r\n    };\r\n    checkSeriesType(type);\r\n    for (const { type: seriesType } of (_b = options.series) !== null && _b !== void 0 ? _b : []) {\r\n        if (seriesType == null)\r\n            continue;\r\n        checkSeriesType(seriesType);\r\n    }\r\n    options = validateSoloSeries(Object.assign(Object.assign({}, options), { type }));\r\n    let defaultSeriesType = 'line';\r\n    if (isAgCartesianChartOptions(options)) {\r\n        defaultSeriesType = 'line';\r\n    }\r\n    else if (isAgHierarchyChartOptions(options)) {\r\n        defaultSeriesType = 'treemap';\r\n    }\r\n    else if (isAgPolarChartOptions(options)) {\r\n        defaultSeriesType = 'pie';\r\n    }\r\n    let defaultOverrides = getSeriesDefaults(type);\r\n    if (isDefaultAxisSwapNeeded(options)) {\r\n        defaultOverrides = swapAxes(defaultOverrides);\r\n    }\r\n    defaultOverrides = executeCustomDefaultsFunctions(options, defaultOverrides);\r\n    const conflictOverrides = resolveModuleConflicts(options);\r\n    removeDisabledOptions(options);\r\n    const { context, mergedOptions, axesThemes, seriesThemes, theme } = prepareMainOptions(defaultOverrides, options, conflictOverrides);\r\n    // Special cases where we have arrays of elements which need their own defaults.\r\n    // Apply series themes before calling processSeriesOptions() as it reduces and renames some\r\n    // properties, and in that case then cannot correctly have themes applied.\r\n    mergedOptions.series = processSeriesOptions(mergedOptions, ((_c = mergedOptions.series) !== null && _c !== void 0 ? _c : []).map((s) => {\r\n        var _a;\r\n        const type = (_a = s.type) !== null && _a !== void 0 ? _a : defaultSeriesType;\r\n        const mergedSeries = mergeSeriesOptions(s, type, seriesThemes, globalTooltipPositionOptions);\r\n        if (type === 'pie') {\r\n            preparePieOptions(seriesThemes.pie, s, mergedSeries);\r\n        }\r\n        return mergedSeries;\r\n    }))\r\n        .map((s) => prepareSeries(context, s))\r\n        .map((s) => theme.templateTheme(s));\r\n    const checkAxisType = (type) => {\r\n        const isAxisType = isAxisOptionType(type);\r\n        if (!isAxisType) {\r\n            Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${AXIS_TYPES.axesTypes}, ignoring.`);\r\n        }\r\n        return isAxisType;\r\n    };\r\n    if ('axes' in mergedOptions) {\r\n        let validAxesTypes = true;\r\n        for (const { type: axisType } of (_d = mergedOptions.axes) !== null && _d !== void 0 ? _d : []) {\r\n            validAxesTypes && (validAxesTypes = checkAxisType(axisType));\r\n        }\r\n        const axisSource = validAxesTypes ? mergedOptions.axes : defaultOverrides.axes;\r\n        mergedOptions.axes = axisSource === null || axisSource === void 0 ? void 0 : axisSource.map((axis) => {\r\n            var _a, _b, _c, _d, _e;\r\n            const axisType = axis.type;\r\n            let axisDefaults;\r\n            if (validAxesTypes) {\r\n                axisDefaults = (_a = defaultOverrides.axes) === null || _a === void 0 ? void 0 : _a.find(({ type }) => type === axisType);\r\n            }\r\n            const axesTheme = jsonMerge([\r\n                (_b = axesThemes[axisType]) !== null && _b !== void 0 ? _b : {},\r\n                (_e = (_c = axesThemes[axisType]) === null || _c === void 0 ? void 0 : _c[(_d = axis.position) !== null && _d !== void 0 ? _d : 'unknown']) !== null && _e !== void 0 ? _e : {},\r\n                axisDefaults,\r\n            ]);\r\n            return prepareAxis(axis, axesTheme);\r\n        });\r\n        prepareLegendEnabledOption(options, mergedOptions);\r\n    }\r\n    prepareEnabledOptions(options, mergedOptions);\r\n    return mergedOptions;\r\n}\r\nfunction sanityCheckOptions(options) {\r\n    const deprecatedArrayProps = {\r\n        yKeys: 'yKey',\r\n        yNames: 'yName',\r\n    };\r\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\r\n        var _a;\r\n        if ((_a = options.series) === null || _a === void 0 ? void 0 : _a.some((s) => s[oldProp] != null)) {\r\n            Logger.warnOnce(`Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`);\r\n        }\r\n    });\r\n}\r\nfunction hasSoloSeries(options) {\r\n    for (const series of options) {\r\n        if (isSoloSeries(series.type))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction validateSoloSeries(options) {\r\n    if (options.series === undefined || options.series.length <= 1 || !hasSoloSeries(options.series)) {\r\n        return options;\r\n    }\r\n    // If the first series is a solo-series, remove all trailing series.\r\n    // If the frist series is not a solo-series, remove all solo-series.\r\n    let series = [...options.series];\r\n    if (isSoloSeries(series[0].type)) {\r\n        Logger.warn(`series[0] of type '${series[0].type}' is incompatible with other series types. Only processing series[0]`);\r\n        series = series.slice(0, 1);\r\n    }\r\n    else {\r\n        const rejects = Array.from(new Set(series.filter((s) => isSoloSeries(s.type)).map((s) => s.type)));\r\n        Logger.warnOnce(`Unable to mix these series types with the lead series type: ${rejects}`);\r\n        series = series.filter((s) => !isSoloSeries(s.type));\r\n    }\r\n    return Object.assign(Object.assign({}, options), { series });\r\n}\r\nfunction mergeSeriesOptions(series, type, seriesThemes, globalTooltipPositionOptions) {\r\n    var _a, _b;\r\n    const mergedTooltipPosition = jsonMerge([Object.assign({}, globalTooltipPositionOptions), (_a = series.tooltip) === null || _a === void 0 ? void 0 : _a.position], noDataCloneMergeOptions);\r\n    return jsonMerge([\r\n        (_b = seriesThemes[type]) !== null && _b !== void 0 ? _b : {},\r\n        Object.assign(Object.assign({}, series), { type, tooltip: Object.assign(Object.assign({}, series.tooltip), { position: mergedTooltipPosition }) }),\r\n    ], noDataCloneMergeOptions);\r\n}\r\nfunction prepareMainOptions(defaultOverrides, options, conflictOverrides) {\r\n    const { theme, cleanedTheme, axesThemes, seriesThemes, userPalette } = prepareTheme(options);\r\n    const context = { colourIndex: 0, palette: theme.palette, userPalette, theme };\r\n    defaultOverrides = theme.templateTheme(defaultOverrides);\r\n    const mergedOptions = jsonMerge([defaultOverrides, cleanedTheme, options, conflictOverrides], noDataCloneMergeOptions);\r\n    if (!enterpriseModule.isEnterprise) {\r\n        removeUsedEnterpriseOptions(mergedOptions);\r\n    }\r\n    return { context, mergedOptions, axesThemes, seriesThemes, theme };\r\n}\r\nfunction prepareTheme(options) {\r\n    var _a;\r\n    const theme = getChartTheme(options.theme);\r\n    const themeConfig = theme.config[optionsType(options)];\r\n    const seriesThemes = Object.entries(theme.config).reduce((result, [seriesType, { series }]) => {\r\n        result[seriesType] = series;\r\n        return result;\r\n    }, {});\r\n    const userTheme = options.theme;\r\n    const userPalette = typeof userTheme === 'object' && userTheme.palette ? userTheme.palette : null;\r\n    return {\r\n        theme,\r\n        axesThemes: (_a = themeConfig === null || themeConfig === void 0 ? void 0 : themeConfig['axes']) !== null && _a !== void 0 ? _a : {},\r\n        seriesThemes: seriesThemes,\r\n        cleanedTheme: jsonMerge([themeConfig !== null && themeConfig !== void 0 ? themeConfig : {}, { axes: DELETE, series: DELETE }]),\r\n        userPalette,\r\n    };\r\n}\r\nfunction prepareSeries(context, input, ...defaults) {\r\n    const paletteOptions = calculateSeriesPalette(context, input);\r\n    // Part of the options interface, but not directly consumed by the series implementations.\r\n    const removeOptions = { stacked: DELETE, grouped: DELETE };\r\n    return jsonMerge([...defaults, paletteOptions, input, removeOptions], noDataCloneMergeOptions);\r\n}\r\nfunction calculateSeriesPalette(context, input) {\r\n    const paletteFactory = getSeriesPaletteFactory(input.type);\r\n    if (!paletteFactory) {\r\n        return {};\r\n    }\r\n    const { palette: { fills, strokes }, userPalette, theme, } = context;\r\n    const colorsCount = Math.max(fills.length, strokes.length);\r\n    return paletteFactory({\r\n        userPalette,\r\n        themeTemplateParameters: theme.getTemplateParameters(),\r\n        colorsCount,\r\n        takeColors: (count) => {\r\n            const colors = {\r\n                fills: takeColours(context, fills, count),\r\n                strokes: takeColours(context, strokes, count),\r\n            };\r\n            context.colourIndex += count;\r\n            return colors;\r\n        },\r\n    });\r\n}\r\nfunction prepareAxis(axis, axisTheme) {\r\n    // Remove redundant theme overload keys.\r\n    const removeOptions = { top: DELETE, bottom: DELETE, left: DELETE, right: DELETE };\r\n    // Special cross lines case where we have an array of cross line elements which need their own defaults.\r\n    if (axis.crossLines) {\r\n        if (!Array.isArray(axis.crossLines)) {\r\n            Logger.warn('axis[].crossLines should be an array.');\r\n            axis.crossLines = [];\r\n        }\r\n        const { crossLines: crossLinesTheme } = axisTheme;\r\n        axis.crossLines = axis.crossLines.map((crossLine) => jsonMerge([crossLinesTheme, crossLine]));\r\n    }\r\n    const cleanTheme = { crossLines: DELETE };\r\n    return jsonMerge([axisTheme, cleanTheme, axis, removeOptions], noDataCloneMergeOptions);\r\n}\r\nfunction removeDisabledOptions(options) {\r\n    // Remove configurations from all option objects with a `false` value for the `enabled` property.\r\n    jsonWalk(options, (_, visitingUserOpts) => {\r\n        if (visitingUserOpts.enabled === false) {\r\n            Object.keys(visitingUserOpts).forEach((key) => {\r\n                if (key === 'enabled')\r\n                    return;\r\n                delete visitingUserOpts[key];\r\n            });\r\n        }\r\n    }, { skip: ['data', 'theme'] });\r\n}\r\nfunction prepareLegendEnabledOption(options, mergedOptions) {\r\n    var _a, _b, _c, _d;\r\n    // Disable legend by default for single series cartesian charts\r\n    if (((_a = options.legend) === null || _a === void 0 ? void 0 : _a.enabled) !== undefined || ((_b = mergedOptions.legend) === null || _b === void 0 ? void 0 : _b.enabled) !== undefined) {\r\n        return;\r\n    }\r\n    (_c = mergedOptions.legend) !== null && _c !== void 0 ? _c : (mergedOptions.legend = {});\r\n    if (((_d = options.series) !== null && _d !== void 0 ? _d : []).length > 1) {\r\n        mergedOptions.legend.enabled = true;\r\n        return;\r\n    }\r\n    mergedOptions.legend.enabled = false;\r\n}\r\nfunction prepareEnabledOptions(options, mergedOptions) {\r\n    // Set `enabled: true` for all option objects where the user has provided values.\r\n    jsonWalk(options, (_, visitingUserOpts, visitingMergedOpts) => {\r\n        if (!visitingMergedOpts)\r\n            return;\r\n        const { _enabledFromTheme } = visitingMergedOpts;\r\n        if (_enabledFromTheme != null) {\r\n            // Do not apply special handling, base enablement on theme.\r\n            delete visitingMergedOpts._enabledFromTheme;\r\n        }\r\n        if (!('enabled' in visitingMergedOpts))\r\n            return;\r\n        if (_enabledFromTheme)\r\n            return;\r\n        if (visitingUserOpts.enabled == null) {\r\n            visitingMergedOpts.enabled = true;\r\n        }\r\n    }, { skip: ['data', 'theme'] }, mergedOptions);\r\n    // Cleanup any special properties.\r\n    jsonWalk(mergedOptions, (_, visitingMergedOpts) => {\r\n        if (visitingMergedOpts._enabledFromTheme != null) {\r\n            // Do not apply special handling, base enablement on theme.\r\n            delete visitingMergedOpts._enabledFromTheme;\r\n        }\r\n    }, { skip: ['data', 'theme'] });\r\n}\r\nfunction preparePieOptions(pieSeriesTheme, seriesOptions, mergedSeries) {\r\n    if (Array.isArray(seriesOptions.innerLabels)) {\r\n        mergedSeries.innerLabels = seriesOptions.innerLabels.map((ln) => {\r\n            return jsonMerge([pieSeriesTheme.innerLabels, ln]);\r\n        });\r\n    }\r\n    else {\r\n        mergedSeries.innerLabels = DELETE;\r\n    }\r\n}\n\nclass PolarChart extends Chart {\r\n    constructor(specialOverrides, resources) {\r\n        super(specialOverrides, resources);\r\n        this.padding = new Padding(40);\r\n        this.axisGroup.zIndex = Layers.AXIS_FOREGROUND_ZINDEX;\r\n    }\r\n    performLayout() {\r\n        const _super = Object.create(null, {\r\n            performLayout: { get: () => super.performLayout }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const shrinkRect = yield _super.performLayout.call(this);\r\n            const fullSeriesRect = shrinkRect.clone();\r\n            this.computeSeriesRect(shrinkRect);\r\n            yield this.computeCircle(shrinkRect);\r\n            this.axes.forEach((axis) => axis.update());\r\n            this.hoverRect = shrinkRect;\r\n            this.layoutService.dispatchLayoutComplete({\r\n                type: 'layout-complete',\r\n                chart: { width: this.scene.width, height: this.scene.height },\r\n                clipSeries: false,\r\n                series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\r\n                axes: [],\r\n            });\r\n            return shrinkRect;\r\n        });\r\n    }\r\n    updateAxes(cx, cy, radius) {\r\n        var _a, _b;\r\n        const angleAxis = this.axes.find((axis) => axis.direction === ChartAxisDirection.X);\r\n        const radiusAxis = this.axes.find((axis) => axis.direction === ChartAxisDirection.Y);\r\n        if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {\r\n            return;\r\n        }\r\n        const angleScale = angleAxis.scale;\r\n        const angles = (_a = angleScale.ticks) === null || _a === void 0 ? void 0 : _a.call(angleScale).map((value) => angleScale.convert(value));\r\n        const innerRadiusRatio = radiusAxis.innerRadiusRatio;\r\n        angleAxis.innerRadiusRatio = innerRadiusRatio;\r\n        (_b = angleAxis.computeRange) === null || _b === void 0 ? void 0 : _b.call(angleAxis);\r\n        angleAxis.gridLength = radius;\r\n        radiusAxis.gridAngles = angles;\r\n        radiusAxis.gridRange = angleAxis.range;\r\n        radiusAxis.range = [radius, radius * innerRadiusRatio];\r\n        [angleAxis, radiusAxis].forEach((axis) => {\r\n            axis.translation.x = cx;\r\n            axis.translation.y = cy;\r\n            axis.calculateLayout();\r\n        });\r\n    }\r\n    computeSeriesRect(shrinkRect) {\r\n        const { seriesArea: { padding }, } = this;\r\n        shrinkRect.shrink(padding.left, 'left');\r\n        shrinkRect.shrink(padding.top, 'top');\r\n        shrinkRect.shrink(padding.right, 'right');\r\n        shrinkRect.shrink(padding.bottom, 'bottom');\r\n        this.seriesRect = shrinkRect;\r\n        this.animationRect = shrinkRect;\r\n    }\r\n    computeCircle(seriesBox) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const polarSeries = this.series.filter((series) => {\r\n                return series instanceof PolarSeries;\r\n            });\r\n            const polarAxes = this.axes.filter((axis) => {\r\n                return axis instanceof PolarAxis;\r\n            });\r\n            const setSeriesCircle = (cx, cy, r) => {\r\n                this.updateAxes(cx, cy, r);\r\n                polarSeries.forEach((series) => {\r\n                    series.centerX = cx;\r\n                    series.centerY = cy;\r\n                    series.radius = r;\r\n                });\r\n                const pieSeries = polarSeries.filter((s) => s instanceof PieSeries);\r\n                if (pieSeries.length > 1) {\r\n                    const innerRadii = pieSeries\r\n                        .map((series) => {\r\n                        const innerRadius = series.getInnerRadius();\r\n                        return { series, innerRadius };\r\n                    })\r\n                        .sort((a, b) => a.innerRadius - b.innerRadius);\r\n                    innerRadii[innerRadii.length - 1].series.surroundingRadius = undefined;\r\n                    for (let i = 0; i < innerRadii.length - 1; i++) {\r\n                        innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\r\n                    }\r\n                }\r\n            };\r\n            const centerX = seriesBox.x + seriesBox.width / 2;\r\n            const centerY = seriesBox.y + seriesBox.height / 2;\r\n            const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\r\n            let radius = initialRadius;\r\n            setSeriesCircle(centerX, centerY, radius);\r\n            const shake = ({ hideWhenNecessary = false } = {}) => __awaiter(this, void 0, void 0, function* () {\r\n                const labelBoxes = [];\r\n                for (const series of [...polarAxes, ...polarSeries]) {\r\n                    const box = yield series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\r\n                    if (box) {\r\n                        labelBoxes.push(box);\r\n                    }\r\n                }\r\n                if (labelBoxes.length === 0) {\r\n                    setSeriesCircle(centerX, centerY, initialRadius);\r\n                    return;\r\n                }\r\n                const labelBox = BBox.merge(labelBoxes);\r\n                const refined = this.refineCircle(labelBox, radius, seriesBox);\r\n                setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\r\n                if (refined.radius === radius) {\r\n                    return;\r\n                }\r\n                radius = refined.radius;\r\n            });\r\n            yield shake(); // Initial attempt\r\n            yield shake(); // Precise attempt\r\n            yield shake(); // Just in case\r\n            yield shake({ hideWhenNecessary: true }); // Hide unnecessary labels\r\n            yield shake({ hideWhenNecessary: true }); // Final result\r\n            return { radius, centerX, centerY };\r\n        });\r\n    }\r\n    refineCircle(labelsBox, radius, seriesBox) {\r\n        const minCircleRatio = 0.5; // Prevents reduced circle to be too small\r\n        const circleLeft = -radius;\r\n        const circleTop = -radius;\r\n        const circleRight = radius;\r\n        const circleBottom = radius;\r\n        // Label padding around the circle\r\n        let padLeft = Math.max(0, circleLeft - labelsBox.x);\r\n        let padTop = Math.max(0, circleTop - labelsBox.y);\r\n        let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\r\n        let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\r\n        padLeft = padRight = Math.max(padLeft, padRight);\r\n        padTop = padBottom = Math.max(padTop, padBottom);\r\n        // Available area for the circle (after the padding will be applied)\r\n        const availCircleWidth = seriesBox.width - padLeft - padRight;\r\n        const availCircleHeight = seriesBox.height - padTop - padBottom;\r\n        let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\r\n        const minHorizontalRadius = (minCircleRatio * seriesBox.width) / 2;\r\n        const minVerticalRadius = (minCircleRatio * seriesBox.height) / 2;\r\n        const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\r\n        if (newRadius < minRadius) {\r\n            // If the radius is too small, reduce the label padding\r\n            newRadius = minRadius;\r\n            const horizontalPadding = padLeft + padRight;\r\n            const verticalPadding = padTop + padBottom;\r\n            if (2 * newRadius + verticalPadding > seriesBox.height) {\r\n                const padHeight = seriesBox.height - 2 * newRadius;\r\n                if (Math.min(padTop, padBottom) * 2 > padHeight) {\r\n                    padTop = padHeight / 2;\r\n                    padBottom = padHeight / 2;\r\n                }\r\n                else if (padTop > padBottom) {\r\n                    padTop = padHeight - padBottom;\r\n                }\r\n                else {\r\n                    padBottom = padHeight - padTop;\r\n                }\r\n            }\r\n            if (2 * newRadius + horizontalPadding > seriesBox.width) {\r\n                const padWidth = seriesBox.width - 2 * newRadius;\r\n                if (Math.min(padLeft, padRight) * 2 > padWidth) {\r\n                    padLeft = padWidth / 2;\r\n                    padRight = padWidth / 2;\r\n                }\r\n                else if (padLeft > padRight) {\r\n                    padLeft = padWidth - padRight;\r\n                }\r\n                else {\r\n                    padRight = padWidth - padLeft;\r\n                }\r\n            }\r\n        }\r\n        const newWidth = padLeft + 2 * newRadius + padRight;\r\n        const newHeight = padTop + 2 * newRadius + padBottom;\r\n        return {\r\n            centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\r\n            centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\r\n            radius: newRadius,\r\n        };\r\n    }\r\n}\r\nPolarChart.className = 'PolarChart';\r\nPolarChart.type = 'polar';\n\nconst debug = Debug.create(true, 'opts');\r\nfunction chartType(options) {\r\n    if (isAgCartesianChartOptions(options)) {\r\n        return 'cartesian';\r\n    }\r\n    else if (isAgPolarChartOptions(options)) {\r\n        return 'polar';\r\n    }\r\n    else if (isAgHierarchyChartOptions(options)) {\r\n        return 'hierarchy';\r\n    }\r\n    throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\r\n}\r\n/**\r\n * Factory for creating and updating instances of AgChartInstance.\r\n *\r\n * @docsInterface\r\n */\r\nclass AgCharts {\r\n    static licenseCheck(options) {\r\n        var _a, _b, _c;\r\n        if (this.licenseChecked)\r\n            return;\r\n        this.licenseManager = (_a = enterpriseModule.licenseManager) === null || _a === void 0 ? void 0 : _a.call(enterpriseModule, options);\r\n        (_b = this.licenseManager) === null || _b === void 0 ? void 0 : _b.setLicenseKey(this.licenseKey);\r\n        (_c = this.licenseManager) === null || _c === void 0 ? void 0 : _c.validateLicense();\r\n        this.licenseChecked = true;\r\n    }\r\n    static setLicenseKey(licenseKey) {\r\n        this.licenseKey = licenseKey;\r\n    }\r\n    /**\r\n     * Create a new `AgChartInstance` based upon the given configuration options.\r\n     */\r\n    static create(options) {\r\n        var _a, _b, _c;\r\n        this.licenseCheck(options);\r\n        const chart = AgChartsInternal.createOrUpdate(options);\r\n        if ((_a = this.licenseManager) === null || _a === void 0 ? void 0 : _a.isDisplayWatermark()) {\r\n            (_b = enterpriseModule.injectWatermark) === null || _b === void 0 ? void 0 : _b.call(enterpriseModule, (_c = options.document) !== null && _c !== void 0 ? _c : document, chart.chart.element, this.licenseManager.getWatermarkMessage());\r\n        }\r\n        return chart;\r\n    }\r\n    /**\r\n     * Update an existing `AgChartInstance`. Options provided should be complete and not\r\n     * partial.\r\n     *\r\n     * __NOTE__: As each call could trigger a chart redraw, multiple calls to update options in\r\n     * quick succession could result in undesirable flickering, so callers should batch up and/or\r\n     * debounce changes to avoid unintended partial update renderings.\r\n     */\r\n    static update(chart, options) {\r\n        if (!AgChartInstanceProxy.isInstance(chart)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        AgChartsInternal.createOrUpdate(options, chart);\r\n    }\r\n    /**\r\n     * Update an existing `AgChartInstance` by applying a partial set of option changes.\r\n     *\r\n     * __NOTE__: As each call could trigger a chart redraw, each individual delta options update\r\n     * should leave the chart in a valid options state. Also, multiple calls to update options in\r\n     * quick succession could result in undesirable flickering, so callers should batch up and/or\r\n     * debounce changes to avoid unintended partial update renderings.\r\n     */\r\n    static updateDelta(chart, deltaOptions) {\r\n        if (!AgChartInstanceProxy.isInstance(chart)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        AgChartsInternal.updateUserDelta(chart, deltaOptions);\r\n    }\r\n    /**\r\n     * Starts a browser-based image download for the given `AgChartInstance`.\r\n     */\r\n    static download(chart, options) {\r\n        if (!(chart instanceof AgChartInstanceProxy)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        AgChartsInternal.download(chart, options);\r\n    }\r\n    /**\r\n     * Returns a base64-encoded image data URL for the given `AgChartInstance`.\r\n     */\r\n    static getImageDataURL(chart, options) {\r\n        if (!(chart instanceof AgChartInstanceProxy)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        return AgChartsInternal.getImageDataURL(chart, options);\r\n    }\r\n}\r\nAgCharts.INVALID_CHART_REF_MESSAGE = 'AG Charts - invalid chart reference passed';\r\nAgCharts.licenseChecked = false;\r\n/** @deprecated use AgCharts instead */\r\nclass AgChart {\r\n    static warnDeprecated(memberName) {\r\n        const warnDeprecated = createDeprecationWarning();\r\n        warnDeprecated(`AgChart.${memberName}`, `Use AgCharts.${memberName} instead`);\r\n    }\r\n    static create(options) {\r\n        AgChart.warnDeprecated('create');\r\n        return AgCharts.create(options);\r\n    }\r\n    static update(chart, options) {\r\n        AgChart.warnDeprecated('update');\r\n        return AgCharts.update(chart, options);\r\n    }\r\n    static updateDelta(chart, deltaOptions) {\r\n        AgChart.warnDeprecated('updateDelta');\r\n        return AgCharts.updateDelta(chart, deltaOptions);\r\n    }\r\n    static download(chart, options) {\r\n        AgChart.warnDeprecated('download');\r\n        return AgCharts.download(chart, options);\r\n    }\r\n    static getImageDataURL(chart, options) {\r\n        AgChart.warnDeprecated('getImageDataURL');\r\n        return AgCharts.getImageDataURL(chart, options);\r\n    }\r\n}\r\nclass AgChartsInternal {\r\n    static initialiseModules() {\r\n        if (AgChartsInternal.initialised)\r\n            return;\r\n        registerInbuiltModules();\r\n        setupModules();\r\n        AgChartsInternal.initialised = true;\r\n    }\r\n    static createOrUpdate(userOptions, proxy) {\r\n        var _a;\r\n        var _b;\r\n        AgChartsInternal.initialiseModules();\r\n        debug('>>> AgChartV2.createOrUpdate() user options', userOptions);\r\n        const { overrideDevicePixelRatio, document, window: userWindow } = userOptions, chartOptions = __rest(userOptions, [\"overrideDevicePixelRatio\", \"document\", \"window\"]);\r\n        const specialOverrides = { overrideDevicePixelRatio, document, window: userWindow };\r\n        const processedOptions = prepareOptions(chartOptions);\r\n        let chart = proxy === null || proxy === void 0 ? void 0 : proxy.chart;\r\n        if (chart == null || chartType(chartOptions) !== chartType(chart.processedOptions)) {\r\n            chart = AgChartsInternal.createChartInstance(processedOptions, specialOverrides, chart);\r\n        }\r\n        if (proxy == null) {\r\n            proxy = new AgChartInstanceProxy(chart);\r\n        }\r\n        else {\r\n            proxy.chart = chart;\r\n        }\r\n        if (Debug.check() && typeof window !== 'undefined') {\r\n            (_a = (_b = window).agChartInstances) !== null && _a !== void 0 ? _a : (_b.agChartInstances = {});\r\n            window.agChartInstances[chart.id] = chart;\r\n        }\r\n        const chartToUpdate = chart;\r\n        chartToUpdate.queuedUserOptions.push(chartOptions);\r\n        const dequeue = () => {\r\n            // If there are a lot of update calls, `requestFactoryUpdate()` may skip callbacks,\r\n            // so we need to remove all queue items up to the last successfully applied item.\r\n            const queuedOptionsIdx = chartToUpdate.queuedUserOptions.indexOf(chartOptions);\r\n            chartToUpdate.queuedUserOptions.splice(0, queuedOptionsIdx);\r\n        };\r\n        chartToUpdate.requestFactoryUpdate(() => __awaiter(this, void 0, void 0, function* () {\r\n            // Chart destroyed, skip processing.\r\n            if (chartToUpdate.destroyed)\r\n                return;\r\n            const deltaOptions = jsonDiff(chartToUpdate.processedOptions, processedOptions);\r\n            if (deltaOptions == null) {\r\n                dequeue();\r\n                return;\r\n            }\r\n            yield AgChartsInternal.updateDelta(chartToUpdate, deltaOptions, chartOptions);\r\n            dequeue();\r\n        }));\r\n        return proxy;\r\n    }\r\n    static updateUserDelta(proxy, deltaOptions) {\r\n        var _a;\r\n        const { chart, chart: { queuedUserOptions }, } = proxy;\r\n        const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : chart.userOptions;\r\n        const userOptions = jsonMerge([lastUpdateOptions, deltaOptions]);\r\n        debug('>>> AgChartV2.updateUserDelta() user delta', deltaOptions);\r\n        debug('AgChartV2.updateUserDelta() - base options', lastUpdateOptions);\r\n        AgChartsInternal.createOrUpdate(userOptions, proxy);\r\n    }\r\n    /**\r\n     * Returns the content of the current canvas as an image.\r\n     * @param opts The download options including `width` and `height` of the image as well as `fileName` and `fileFormat`.\r\n     */\r\n    static download(proxy, opts) {\r\n        const asyncDownload = () => __awaiter(this, void 0, void 0, function* () {\r\n            const maybeClone = yield AgChartsInternal.prepareResizedChart(proxy, opts);\r\n            const { chart } = maybeClone;\r\n            chart.scene.download(opts === null || opts === void 0 ? void 0 : opts.fileName, opts === null || opts === void 0 ? void 0 : opts.fileFormat);\r\n            if (maybeClone !== proxy) {\r\n                maybeClone.destroy();\r\n            }\r\n        });\r\n        asyncDownload().catch((e) => Logger.errorOnce(e));\r\n    }\r\n    static getImageDataURL(proxy, opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const maybeClone = yield AgChartsInternal.prepareResizedChart(proxy, opts);\r\n            const { chart } = maybeClone;\r\n            const result = chart.scene.canvas.getDataURL(opts === null || opts === void 0 ? void 0 : opts.fileFormat);\r\n            if (maybeClone !== proxy) {\r\n                maybeClone.destroy();\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    static prepareResizedChart(proxy, opts) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { chart } = proxy;\r\n            let { width, height } = opts !== null && opts !== void 0 ? opts : {};\r\n            const currentWidth = chart.width;\r\n            const currentHeight = chart.height;\r\n            const unchanged = (width === undefined && height === undefined) ||\r\n                (chart.scene.canvas.pixelRatio === 1 && currentWidth === width && currentHeight === height);\r\n            if (unchanged) {\r\n                return proxy;\r\n            }\r\n            width !== null && width !== void 0 ? width : (width = currentWidth);\r\n            height !== null && height !== void 0 ? height : (height = currentHeight);\r\n            const options = Object.assign(Object.assign({}, chart.userOptions), { container: document.createElement('div'), width,\r\n                height, autoSize: false, overrideDevicePixelRatio: 1 });\r\n            if (hasRegisteredEnterpriseModules()) {\r\n                // Disable enterprise features that may interfere with image generation.\r\n                (_a = options.animation) !== null && _a !== void 0 ? _a : (options.animation = {});\r\n                options.animation.enabled = false;\r\n            }\r\n            const clonedChart = AgChartsInternal.createOrUpdate(options);\r\n            yield clonedChart.chart.waitForUpdate();\r\n            return clonedChart;\r\n        });\r\n    }\r\n    static createChartInstance(options, specialOverrides, oldChart) {\r\n        const transferableResource = oldChart === null || oldChart === void 0 ? void 0 : oldChart.destroy({ keepTransferableResources: true });\r\n        if (isAgCartesianChartOptions(options)) {\r\n            return new CartesianChart(specialOverrides, transferableResource);\r\n        }\r\n        else if (isAgHierarchyChartOptions(options)) {\r\n            return new HierarchyChart(specialOverrides, transferableResource);\r\n        }\r\n        else if (isAgPolarChartOptions(options)) {\r\n            return new PolarChart(specialOverrides, transferableResource);\r\n        }\r\n        throw new Error(`AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`);\r\n    }\r\n    static updateDelta(chart, processedOptions, userOptions) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (processedOptions.type == null) {\r\n                processedOptions = Object.assign(Object.assign({}, processedOptions), { type: (_a = chart.processedOptions.type) !== null && _a !== void 0 ? _a : optionsType(processedOptions) });\r\n            }\r\n            if (chart.destroyed)\r\n                return;\r\n            debug('AgChartV2.updateDelta() - applying delta', processedOptions);\r\n            applyChartOptions(chart, processedOptions, userOptions);\r\n        });\r\n    }\r\n}\r\nAgChartsInternal.initialised = false;\r\nfunction applyChartOptions(chart, processedOptions, userOptions) {\r\n    var _a, _b, _c, _d;\r\n    const completeOptions = jsonMerge([(_a = chart.processedOptions) !== null && _a !== void 0 ? _a : {}, processedOptions], noDataCloneMergeOptions);\r\n    const modulesChanged = applyModules(chart, completeOptions);\r\n    const skip = ['type', 'data', 'series', 'listeners', 'theme', 'legend.listeners'];\r\n    if (isAgCartesianChartOptions(processedOptions) || isAgPolarChartOptions(processedOptions)) {\r\n        // Append axes to defaults.\r\n        skip.push('axes');\r\n    }\r\n    else if (isAgHierarchyChartOptions(processedOptions)) ;\r\n    else {\r\n        throw new Error(`AG Charts - couldn't apply configuration, check type of options and chart: ${processedOptions['type']}`);\r\n    }\r\n    // Needs to be done before applying the series to detect if a seriesNode[Double]Click listener has been added\r\n    if (processedOptions.listeners) {\r\n        registerListeners(chart, processedOptions.listeners);\r\n    }\r\n    applyOptionValues(chart, processedOptions, { skip });\r\n    let forceNodeDataRefresh = false;\r\n    let seriesRecreated = false;\r\n    if (processedOptions.series && processedOptions.series.length > 0) {\r\n        seriesRecreated = applySeries(chart, processedOptions);\r\n        forceNodeDataRefresh = true;\r\n    }\r\n    if ('axes' in completeOptions && Array.isArray(completeOptions.axes)) {\r\n        const axesPresent = applyAxes(chart, completeOptions, seriesRecreated);\r\n        if (axesPresent) {\r\n            forceNodeDataRefresh = true;\r\n        }\r\n    }\r\n    const seriesOpts = processedOptions.series;\r\n    const seriesDataUpdate = !!processedOptions.data || (seriesOpts === null || seriesOpts === void 0 ? void 0 : seriesOpts.some((s) => s.data != null));\r\n    const legendKeys = getLegendKeys();\r\n    const optionsHaveLegend = Object.values(legendKeys).some((legendKey) => processedOptions[legendKey] != null);\r\n    const otherRefreshUpdate = processedOptions.title != null && processedOptions.subtitle != null;\r\n    forceNodeDataRefresh = forceNodeDataRefresh || seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\r\n    if (processedOptions.data) {\r\n        chart.data = processedOptions.data;\r\n    }\r\n    if ((_b = processedOptions.legend) === null || _b === void 0 ? void 0 : _b.listeners) {\r\n        Object.assign(chart.legend.listeners, (_c = processedOptions.legend.listeners) !== null && _c !== void 0 ? _c : {});\r\n    }\r\n    if (processedOptions.listeners) {\r\n        chart.updateAllSeriesListeners();\r\n    }\r\n    chart.processedOptions = completeOptions;\r\n    chart.userOptions = jsonMerge([(_d = chart.userOptions) !== null && _d !== void 0 ? _d : {}, userOptions], noDataCloneMergeOptions);\r\n    const majorChange = forceNodeDataRefresh || modulesChanged;\r\n    const updateType = majorChange ? ChartUpdateType.PROCESS_DATA : ChartUpdateType.PERFORM_LAYOUT;\r\n    debug('AgChartV2.applyChartOptions() - update type', ChartUpdateType[updateType]);\r\n    chart.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\r\n}\r\nfunction applyModules(chart, options) {\r\n    const matchingChartType = (module) => {\r\n        return ((chart instanceof CartesianChart && module.chartTypes.includes('cartesian')) ||\r\n            (chart instanceof PolarChart && module.chartTypes.includes('polar')) ||\r\n            (chart instanceof HierarchyChart && module.chartTypes.includes('hierarchy')));\r\n    };\r\n    let modulesChanged = false;\r\n    const processModules = (moduleType, add, remove) => {\r\n        const modules = REGISTERED_MODULES.filter((m) => m.type === moduleType);\r\n        for (const next of modules) {\r\n            const shouldBeEnabled = matchingChartType(next) && options[next.optionsKey] != null;\r\n            const isEnabled = chart.isModuleEnabled(next);\r\n            if (shouldBeEnabled === isEnabled)\r\n                continue;\r\n            modulesChanged = true;\r\n            if (shouldBeEnabled) {\r\n                add(next);\r\n            }\r\n            else {\r\n                remove(next);\r\n            }\r\n        }\r\n    };\r\n    processModules('root', (next) => chart.addModule(next), (next) => chart.removeModule(next));\r\n    processModules('legend', (next) => chart.addLegendModule(next), (next) => chart.removeLegendModule(next));\r\n    return modulesChanged;\r\n}\r\nfunction applySeries(chart, options) {\r\n    const optSeries = options.series;\r\n    if (!optSeries) {\r\n        return false;\r\n    }\r\n    const keysToConsider = ['type', 'direction', 'xKey', 'yKey', 'sizeKey', 'angleKey', 'stacked', 'stackGroup'];\r\n    let matchingTypes = chart.series.length === optSeries.length;\r\n    for (let i = 0; i < chart.series.length && matchingTypes; i++) {\r\n        for (const key of keysToConsider) {\r\n            matchingTypes && (matchingTypes = chart.series[i][key] === optSeries[i][key]);\r\n        }\r\n    }\r\n    // Try to optimise series updates if series count and types didn't change.\r\n    if (matchingTypes) {\r\n        chart.series.forEach((s, i) => {\r\n            var _a, _b, _c, _d;\r\n            const previousOpts = (_c = (_b = (_a = chart.processedOptions) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[i]) !== null && _c !== void 0 ? _c : {};\r\n            const seriesDiff = jsonDiff(previousOpts, (_d = optSeries[i]) !== null && _d !== void 0 ? _d : {});\r\n            if (!seriesDiff) {\r\n                return;\r\n            }\r\n            debug(`AgChartV2.applySeries() - applying series diff idx ${i}`, seriesDiff);\r\n            applySeriesValues(s, seriesDiff, { path: `series[${i}]`, index: i });\r\n            s.markNodeDataDirty();\r\n        });\r\n        return false;\r\n    }\r\n    debug(`AgChartV2.applySeries() - creating new series instances`);\r\n    chart.series = createSeries(chart, optSeries);\r\n    return true;\r\n}\r\nfunction applyAxes(chart, options, forceRecreate) {\r\n    const optAxes = options.axes;\r\n    if (!optAxes) {\r\n        return false;\r\n    }\r\n    const matchingTypes = !forceRecreate &&\r\n        chart.axes.length === optAxes.length &&\r\n        chart.axes.every((a, i) => a.type === optAxes[i].type);\r\n    // Try to optimise series updates if series count and types didn't change.\r\n    if (matchingTypes) {\r\n        const oldOpts = chart.processedOptions;\r\n        if (isAgCartesianChartOptions(oldOpts)) {\r\n            chart.axes.forEach((a, i) => {\r\n                var _a, _b;\r\n                const previousOpts = (_b = (_a = oldOpts.axes) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : {};\r\n                const axisDiff = jsonDiff(previousOpts, optAxes[i]);\r\n                debug(`AgChartV2.applyAxes() - applying axis diff idx ${i}`, axisDiff);\r\n                const path = `axes[${i}]`;\r\n                const skip = ['axes[].type'];\r\n                applyOptionValues(a, axisDiff, { path, skip });\r\n            });\r\n            return true;\r\n        }\r\n    }\r\n    chart.axes = createAxis(chart, optAxes);\r\n    return true;\r\n}\r\nfunction createSeries(chart, options) {\r\n    var _a;\r\n    const series = [];\r\n    const moduleContext = chart.getModuleContext();\r\n    let index = 0;\r\n    for (const seriesOptions of options !== null && options !== void 0 ? options : []) {\r\n        const path = `series[${index++}]`;\r\n        const type = (_a = seriesOptions.type) !== null && _a !== void 0 ? _a : 'unknown';\r\n        if (isEnterpriseSeriesType(type) && !isEnterpriseSeriesTypeLoaded(type)) {\r\n            continue;\r\n        }\r\n        const seriesInstance = getSeries(type, moduleContext);\r\n        applySeriesOptionModules(seriesInstance, seriesOptions);\r\n        applySeriesValues(seriesInstance, seriesOptions, { path, index });\r\n        series.push(seriesInstance);\r\n    }\r\n    return series;\r\n}\r\nfunction applySeriesOptionModules(series, options) {\r\n    const seriesOptionModules = REGISTERED_MODULES.filter((m) => m.type === 'series-option');\r\n    for (const mod of seriesOptionModules) {\r\n        const supportedSeriesTypes = mod.seriesTypes;\r\n        if (mod.optionsKey in options && supportedSeriesTypes.includes(series.type)) {\r\n            series.getModuleMap().addModule(mod);\r\n        }\r\n    }\r\n}\r\nfunction createAxis(chart, options) {\r\n    const axes = [];\r\n    const skip = ['axes[].type'];\r\n    const moduleContext = chart.getModuleContext();\r\n    let index = 0;\r\n    for (const axisOptions of options !== null && options !== void 0 ? options : []) {\r\n        const axis = getAxis(axisOptions.type, moduleContext);\r\n        const path = `axes[${index++}]`;\r\n        applyAxisModules(axis, axisOptions);\r\n        applyOptionValues(axis, axisOptions, { path, skip });\r\n        axes.push(axis);\r\n    }\r\n    return axes;\r\n}\r\nfunction applyAxisModules(axis, options) {\r\n    let modulesChanged = false;\r\n    const rootModules = REGISTERED_MODULES.filter((m) => m.type === 'axis-option');\r\n    for (const next of rootModules) {\r\n        const shouldBeEnabled = options[next.optionsKey] != null;\r\n        const moduleMap = axis.getModuleMap();\r\n        const isEnabled = moduleMap.isModuleEnabled(next);\r\n        if (shouldBeEnabled === isEnabled)\r\n            continue;\r\n        modulesChanged = true;\r\n        if (shouldBeEnabled) {\r\n            moduleMap.addModule(next);\r\n        }\r\n        else {\r\n            moduleMap.removeModule(next);\r\n        }\r\n    }\r\n    return modulesChanged;\r\n}\r\nfunction registerListeners(source, listeners) {\r\n    source.clearEventListeners();\r\n    const entries = Object.entries(listeners !== null && listeners !== void 0 ? listeners : {});\r\n    for (const [property, listener] of entries) {\r\n        if (typeof listener !== 'function')\r\n            continue;\r\n        source.addEventListener(property, listener);\r\n    }\r\n}\r\nfunction applyOptionValues(target, options, { skip, path } = {}) {\r\n    const applyOpts = Object.assign(Object.assign(Object.assign({}, getJsonApplyOptions()), { skip }), (path ? { path } : {}));\r\n    return jsonApply(target, options, applyOpts);\r\n}\r\nfunction applySeriesValues(target, options, { path, index } = {}) {\r\n    var _a, _b;\r\n    const skip = ['series[].listeners', 'series[].seriesGrouping'];\r\n    const jsonApplyOptions = getJsonApplyOptions();\r\n    const ctrs = (_a = jsonApplyOptions.constructors) !== null && _a !== void 0 ? _a : {};\r\n    const seriesTypeOverrides = {\r\n        constructors: Object.assign(Object.assign({}, ctrs), { title: target.type === 'pie' ? PieTitle : ctrs['title'] }),\r\n    };\r\n    const applyOpts = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, jsonApplyOptions), seriesTypeOverrides), { skip: ['series[].type', ...(skip !== null && skip !== void 0 ? skip : [])] }), (path ? { path } : {})), { idx: index !== null && index !== void 0 ? index : -1 });\r\n    const result = jsonApply(target, options, applyOpts);\r\n    if ((options === null || options === void 0 ? void 0 : options.listeners) != null) {\r\n        registerListeners(target, options.listeners);\r\n    }\r\n    const { seriesGrouping } = options;\r\n    if ('seriesGrouping' in (options !== null && options !== void 0 ? options : {})) {\r\n        if (seriesGrouping) {\r\n            target.seriesGrouping = Object.freeze(Object.assign(Object.assign({}, ((_b = target.seriesGrouping) !== null && _b !== void 0 ? _b : {})), seriesGrouping));\r\n        }\r\n        else {\r\n            target.seriesGrouping = seriesGrouping;\r\n        }\r\n    }\r\n    return result;\r\n}\n\n// DO NOT UPDATE MANUALLY: Generated from script during build time\r\nconst VERSION = '9.0.1';\n\nconst themes = Object.entries(themes$1).reduce((obj, [name, factory]) => {\r\n    obj[name] = factory();\r\n    return obj;\r\n}, {});\n\nvar integratedChartsTheme = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    themes: themes,\n    getChartTheme: getChartTheme,\n    ChartTheme: ChartTheme,\n    EXTENDS_CHART_DEFAULTS: EXTENDS_CHART_DEFAULTS,\n    EXTENDS_LEGEND_DEFAULTS: EXTENDS_LEGEND_DEFAULTS,\n    EXTENDS_LEGEND_ITEM_DEFAULTS: EXTENDS_LEGEND_ITEM_DEFAULTS,\n    EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS: EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS,\n    EXTENDS_AXES_DEFAULTS: EXTENDS_AXES_DEFAULTS,\n    EXTENDS_AXES_LABEL_DEFAULTS: EXTENDS_AXES_LABEL_DEFAULTS,\n    EXTENDS_AXES_LINE_DEFAULTS: EXTENDS_AXES_LINE_DEFAULTS,\n    EXTENDS_AXES_TICK_DEFAULTS: EXTENDS_AXES_TICK_DEFAULTS,\n    EXTENDS_AXES_GRID_LINE_DEFAULTS: EXTENDS_AXES_GRID_LINE_DEFAULTS,\n    EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS,\n    EXTENDS_CARTESIAN_MARKER_DEFAULTS: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\n    OVERRIDE_SERIES_LABEL_DEFAULTS: OVERRIDE_SERIES_LABEL_DEFAULTS,\n    DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY,\n    DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR,\n    DEFAULT_INVERTED_LABEL_COLOUR: DEFAULT_INVERTED_LABEL_COLOUR,\n    DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n    DEFAULT_MUTED_LABEL_COLOUR: DEFAULT_MUTED_LABEL_COLOUR,\n    DEFAULT_AXIS_GRID_COLOUR: DEFAULT_AXIS_GRID_COLOUR,\n    DEFAULT_AXIS_LINE_COLOUR: DEFAULT_AXIS_LINE_COLOUR,\n    DEFAULT_CROSS_LINES_COLOUR: DEFAULT_CROSS_LINES_COLOUR,\n    DEFAULT_BACKGROUND_COLOUR: DEFAULT_BACKGROUND_COLOUR,\n    DEFAULT_SHADOW_COLOUR: DEFAULT_SHADOW_COLOUR,\n    DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS: DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,\n    DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS: DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,\n    DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS: DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,\n    DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE: DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,\n    DEFAULT_POLAR_SERIES_STROKE: DEFAULT_POLAR_SERIES_STROKE,\n    DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,\n    DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS,\n    DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES,\n    FONT_SIZE: FONT_SIZE,\n    BOLD: BOLD,\n    NORMAL: NORMAL,\n    BOTTOM: BOTTOM,\n    CARTESIAN_AXIS_POSITIONS: CARTESIAN_AXIS_POSITIONS,\n    CARTESIAN_AXIS_TYPES: CARTESIAN_AXIS_TYPES,\n    POLAR_AXIS_TYPES: POLAR_AXIS_TYPES,\n    CIRCLE: CIRCLE\n});\n\nvar sparklinesScale = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    TimeScale: TimeScale,\n    BandScale: BandScale,\n    ContinuousScale: ContinuousScale,\n    ColorScale: ColorScale,\n    LinearScale: LinearScale\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLWNvbW11bml0eS9kaXN0L3BhY2thZ2UvbWFpbi5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFt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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRCwyQ0FBMkMsU0FBUyxFQUFFLGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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MkI7QUFDM0M7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNLHFDQUFxQyxZQUFZO0FBQzFGO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSw4QkFBOEIsa0JBQWtCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUIsUUFBUSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUIsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzSUFBc0k7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtGQUFrRjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBa0U7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxSUFBcUk7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekMsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxFQUFFLElBQUksRUFBRTtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSx3Q0FBd0MscUNBQXFDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUF1RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxtQkFBbUIsSUFBSSw4QkFBOEI7QUFDN0UsZ0JBQWdCLGdFQUFnRTtBQUNoRixjQUFjLDZCQUE2QjtBQUMzQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRkFBa0Y7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwRUFBMEU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSwyQkFBMkIsMEVBQTBFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixnQkFBZ0IsNEJBQTRCO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRkFBbUY7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEtBQUs7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnREFBZ0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUE2QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWdEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBLDRCQUE0QixxREFBcUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUVBQW1FO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFvRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQyxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQjtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGtCQUFrQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0NBQXNDLElBQUk7QUFDMUMsdUVBQXVFLFlBQVksSUFBSSxZQUFZO0FBQ25HO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0MsdUVBQXVFLFlBQVksSUFBSSxZQUFZO0FBQ25HO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssRUFBRSw2Q0FBNkMsRUFBRSw2Q0FBNkM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQyxFQUFFLE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBEQUEwRDtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQXlDO0FBQy9ELGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtFQUFrRTtBQUNsRTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0Q0FBNEM7QUFDbkYsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxnQkFBZ0IsU0FBUyxNQUFNLFdBQVcsTUFBTSxJQUFJO0FBQ3BELGNBQWMsU0FBUyxlQUFlLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLGtCQUFrQix1QkFBdUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdDQUFnQyx5QkFBeUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUSxzRkFBc0Y7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNB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QUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDBCQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0saUJBQWlCO0FBQ3ZCLE1BQU0sYUFBYTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQ0FBMkM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9EQUFvRCxvREFBb0QsSUFBSTtBQUM1SCw0QkFBNEIsaUJBQWlCLElBQUksTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1SUFBdUk7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJEQUEyRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx5REFBeUQsa0JBQWtCLG1DQUFtQztBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0Isa0JBQWtCO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sd0ZBQXdGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSwwRkFBMEY7QUFDaEcsTUFBTSw2REFBNkQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNLHlGQUF5RjtBQUMvRixNQUFNLHVGQUF1RjtBQUM3RixNQUFNLDBGQUEwRjtBQUNoRyxNQUFNLHdGQUF3RjtBQUM5RixNQUFNLHlFQUF5RTtBQUMvRSxNQUFNLDJGQUEyRjtBQUNqRyxNQUFNLHlGQUF5RjtBQUMvRixNQUFNLDBGQUEwRjtBQUNoRyxNQUFNLDBGQUEwRjtBQUNoRyxNQUFNLHlGQUF5RjtBQUMvRixNQUFNLHlGQUF5RjtBQUMvRixNQUFNLHlGQUF5RjtBQUMvRixNQUFNLDRGQUE0RjtBQUNsRyxNQUFNLDZGQUE2RjtBQUNuRyxNQUFNLDRGQUE0RjtBQUNsRyxNQUFNLDJGQUEyRjtBQUNqRyxNQUFNLDBGQUEwRjtBQUNoRyxNQUFNLDRGQUE0RjtBQUNsRyxNQUFNLG9HQUFvRztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkRBQTZEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVEsOEZBQThGO0FBQzNJO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Z0JBQWdCLEdBQUc7QUFDbEw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RixtRUFBbUU7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFMlMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FnLWNoYXJ0cy1jb21tdW5pdHkvZGlzdC9wYWNrYWdlL21haW4uZXNtLmpzP2QwMzciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQWdFcnJvckJhclN1cHBvcnRlZFNlcmllc1R5cGVzID0gWydiYXInLCAnbGluZScsICdzY2F0dGVyJ107XG5cbi8qKlxyXG4gKiBJbnRlcm5hbCBVc2UgT25seTogVXNlZCB0byBlbnN1cmUgdGhpcyBmaWxlIGlzIHRyZWF0ZWQgYXMgYSBtb2R1bGUgdW50aWwgd2UgY2FuIHVzZSBtb2R1bGVEZXRlY3Rpb24gZmxhZyBpbiBUcyB2NC43XHJcbiAqL1xyXG5jb25zdCBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT04kMSA9IDA7XG5cbi8qKlxyXG4gKiBUaGUgaW50ZXJ2YWwgbWV0aG9kcyBkb24ndCBtdXRhdGUgRGF0ZSBwYXJhbWV0ZXJzLlxyXG4gKi9cclxuY2xhc3MgVGltZUludGVydmFsIHtcclxuICAgIGNvbnN0cnVjdG9yKF9lbmNvZGUsIF9kZWNvZGUsIF9yYW5nZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fZW5jb2RlID0gX2VuY29kZTtcclxuICAgICAgICB0aGlzLl9kZWNvZGUgPSBfZGVjb2RlO1xyXG4gICAgICAgIHRoaXMuX3JhbmdlQ2FsbGJhY2sgPSBfcmFuZ2VDYWxsYmFjaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBkYXRlIHJlcHJlc2VudGluZyB0aGUgbGF0ZXN0IGludGVydmFsIGJvdW5kYXJ5IGRhdGUgYmVmb3JlIG9yIGVxdWFsIHRvIGRhdGUuXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgYGRheS5mbG9vcihkYXRlKWAgdHlwaWNhbGx5IHJldHVybnMgMTI6MDAgQU0gbG9jYWwgdGltZSBvbiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAqIEBwYXJhbSBkYXRlXHJcbiAgICAgKi9cclxuICAgIGZsb29yKGRhdGUpIHtcclxuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGRhdGUgcmVwcmVzZW50aW5nIHRoZSBlYXJsaWVzdCBpbnRlcnZhbCBib3VuZGFyeSBkYXRlIGFmdGVyIG9yIGVxdWFsIHRvIGRhdGUuXHJcbiAgICAgKiBAcGFyYW0gZGF0ZVxyXG4gICAgICovXHJcbiAgICBjZWlsKGRhdGUpIHtcclxuICAgICAgICBjb25zdCBkID0gbmV3IERhdGUoTnVtYmVyKGRhdGUpIC0gMSk7XHJcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGUgKyAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBkYXRlcyByZXByZXNlbnRpbmcgZXZlcnkgaW50ZXJ2YWwgYm91bmRhcnkgYWZ0ZXIgb3IgZXF1YWwgdG8gc3RhcnQgKGluY2x1c2l2ZSkgYW5kIGJlZm9yZSBzdG9wIChleGNsdXNpdmUpLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0IFJhbmdlIHN0YXJ0LlxyXG4gICAgICogQHBhcmFtIHN0b3AgUmFuZ2UgZW5kLlxyXG4gICAgICogQHBhcmFtIGV4dGVuZCBJZiBzcGVjaWZpZWQsIHRoZSByZXF1ZXN0ZWQgcmFuZ2Ugd2lsbCBiZSBleHRlbmRlZCB0byB0aGUgY2xvc2VzdCBcIm5pY2VcIiB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIHJhbmdlKHN0YXJ0LCBzdG9wLCBleHRlbmQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgcmFuZ2VDYWxsYmFjayA9IChfYSA9IHRoaXMuX3JhbmdlQ2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHN0YXJ0LCBzdG9wKTtcclxuICAgICAgICBjb25zdCBlMCA9IHRoaXMuX2VuY29kZShleHRlbmQgPyB0aGlzLmZsb29yKHN0YXJ0KSA6IHRoaXMuY2VpbChzdGFydCkpO1xyXG4gICAgICAgIGNvbnN0IGUxID0gdGhpcy5fZW5jb2RlKGV4dGVuZCA/IHRoaXMuY2VpbChzdG9wKSA6IHRoaXMuZmxvb3Ioc3RvcCkpO1xyXG4gICAgICAgIGlmIChlMSA8IGUwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBlID0gZTA7IGUgPD0gZTE7IGUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5fZGVjb2RlKGUpO1xyXG4gICAgICAgICAgICByYW5nZS5wdXNoKGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByYW5nZUNhbGxiYWNrID09PSBudWxsIHx8IHJhbmdlQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhbmdlQ2FsbGJhY2soKTtcclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ291bnRhYmxlVGltZUludGVydmFsIGV4dGVuZHMgVGltZUludGVydmFsIHtcclxuICAgIGdldE9mZnNldChzbmFwVG8sIHN0ZXApIHtcclxuICAgICAgICBjb25zdCBzID0gdHlwZW9mIHNuYXBUbyA9PT0gJ251bWJlcicgfHwgc25hcFRvIGluc3RhbmNlb2YgRGF0ZSA/IHRoaXMuX2VuY29kZShuZXcgRGF0ZShzbmFwVG8pKSA6IDA7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocykgJSBzdGVwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZmlsdGVyZWQgdmlldyBvZiB0aGlzIGludGVydmFsIHJlcHJlc2VudGluZyBldmVyeSBzdGVwJ3RoIGRhdGUuXHJcbiAgICAgKiBJdCBjYW4gYmUgYSBudW1iZXIgb2YgbWludXRlcywgaG91cnMsIGRheXMgZXRjLlxyXG4gICAgICogTXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0gc3RlcFxyXG4gICAgICovXHJcbiAgICBldmVyeShzdGVwLCBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHJhbmdlQ2FsbGJhY2s7XHJcbiAgICAgICAgY29uc3QgeyBzbmFwVG8gPSAnc3RhcnQnIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIHNuYXBUbyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmFuZ2VDYWxsYmFjayA9IChzdGFydCwgc3RvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHNuYXBUbyA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogc3RvcDtcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KHMsIHN0ZXApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IChvZmZzZXQgPSBpbml0aWFsT2Zmc2V0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNuYXBUbyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXQobmV3IERhdGUoc25hcFRvKSwgc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNuYXBUbyBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXQoc25hcFRvLCBzdGVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5jb2RlID0gKGRhdGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGUgLSBvZmZzZXQpIC8gc3RlcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZWNvZGUgPSAoZW5jb2RlZCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlKGVuY29kZWQgKiBzdGVwICsgb2Zmc2V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBuZXcgVGltZUludGVydmFsKGVuY29kZSwgZGVjb2RlLCByYW5nZUNhbGxiYWNrKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBlbmNvZGUkYihkYXRlKSB7XHJcbiAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVjb2RlJGIoZW5jb2RlZCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQpO1xyXG59XHJcbmNvbnN0IG1pbGxpc2Vjb25kID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUkYiwgZGVjb2RlJGIpO1xuXG4vLyBDb21tb24gdGltZSB1bml0IHNpemVzIGluIG1pbGxpc2Vjb25kcy5cclxubmV3IERhdGUoMCkuZ2V0RnVsbFllYXIoKTtcclxuY29uc3QgZHVyYXRpb25TZWNvbmQgPSAxMDAwO1xyXG5jb25zdCBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjA7XHJcbmNvbnN0IGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjA7XHJcbmNvbnN0IGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XHJcbmNvbnN0IGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNztcclxuY29uc3QgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzA7XHJcbmNvbnN0IGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG5jb25zdCBvZmZzZXQkMiA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xyXG5mdW5jdGlvbiBlbmNvZGUkYShkYXRlKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBvZmZzZXQkMikgLyBkdXJhdGlvblNlY29uZCk7XHJcbn1cclxuZnVuY3Rpb24gZGVjb2RlJGEoZW5jb2RlZCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKG9mZnNldCQyICsgZW5jb2RlZCAqIGR1cmF0aW9uU2Vjb25kKTtcclxufVxyXG5jb25zdCBzZWNvbmQgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZSRhLCBkZWNvZGUkYSk7XG5cbmNvbnN0IG9mZnNldCQxID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XHJcbmZ1bmN0aW9uIGVuY29kZSQ5KGRhdGUpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIG9mZnNldCQxKSAvIGR1cmF0aW9uTWludXRlKTtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGUkOShlbmNvZGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUob2Zmc2V0JDEgKyBlbmNvZGVkICogZHVyYXRpb25NaW51dGUpO1xyXG59XHJcbmNvbnN0IG1pbnV0ZSA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlJDksIGRlY29kZSQ5KTtcblxuY29uc3Qgb2Zmc2V0ID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XHJcbmZ1bmN0aW9uIGVuY29kZSQ4KGRhdGUpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIG9mZnNldCkgLyBkdXJhdGlvbkhvdXIpO1xyXG59XHJcbmZ1bmN0aW9uIGRlY29kZSQ4KGVuY29kZWQpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShvZmZzZXQgKyBlbmNvZGVkICogZHVyYXRpb25Ib3VyKTtcclxufVxyXG5jb25zdCBob3VyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUkOCwgZGVjb2RlJDgpO1xuXG5mdW5jdGlvbiBlbmNvZGUkNyhkYXRlKSB7XHJcbiAgICBjb25zdCB0ek9mZnNldE1zID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSB0ek9mZnNldE1zKSAvIGR1cmF0aW9uRGF5KTtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGUkNyhlbmNvZGVkKSB7XHJcbiAgICBjb25zdCBkID0gbmV3IERhdGUoMTk3MCwgMCwgMSk7XHJcbiAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkKTtcclxuICAgIHJldHVybiBkO1xyXG59XHJcbmNvbnN0IGRheSA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlJDcsIGRlY29kZSQ3KTtcblxuLy8gU2V0IGRhdGUgdG8gbi10aCBkYXkgb2YgdGhlIHdlZWsuXHJcbmZ1bmN0aW9uIHdlZWtkYXkobikge1xyXG4gICAgY29uc3QgYmFzZSA9IG5ldyBEYXRlKDIwMjMsIDAsIDEgKyBuKS5nZXRUaW1lKCk7XHJcbiAgICBmdW5jdGlvbiBlbmNvZGUoZGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGVNcyA9IGRhdGUuZ2V0VGltZSgpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlTXMgLSBiYXNlKSAvIGR1cmF0aW9uV2Vlayk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWNvZGUoZW5jb2RlZCkge1xyXG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShiYXNlKTtcclxuICAgICAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkICogNyk7XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUsIGRlY29kZSk7XHJcbn1cclxuY29uc3Qgc3VuZGF5ID0gd2Vla2RheSgwKTtcclxuY29uc3QgbW9uZGF5ID0gd2Vla2RheSgxKTtcclxuY29uc3QgdHVlc2RheSA9IHdlZWtkYXkoMik7XHJcbmNvbnN0IHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XHJcbmNvbnN0IHRodXJzZGF5ID0gd2Vla2RheSg0KTtcclxuY29uc3QgZnJpZGF5ID0gd2Vla2RheSg1KTtcclxuY29uc3Qgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG5mdW5jdGlvbiBlbmNvZGUkNihkYXRlKSB7XHJcbiAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpICogMTIgKyBkYXRlLmdldE1vbnRoKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVjb2RlJDYoZW5jb2RlZCkge1xyXG4gICAgY29uc3QgeWVhciA9IE1hdGguZmxvb3IoZW5jb2RlZCAvIDEyKTtcclxuICAgIGNvbnN0IG1vbnRoID0gZW5jb2RlZCAtIHllYXIgKiAxMjtcclxuICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XHJcbn1cclxuY29uc3QgbW9udGggPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZSQ2LCBkZWNvZGUkNik7XG5cbmZ1bmN0aW9uIGVuY29kZSQ1KGRhdGUpIHtcclxuICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVjb2RlJDUoZW5jb2RlZCkge1xyXG4gICAgLy8gTm90ZTogYXNzaWduaW5nIHllYXJzIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yXHJcbiAgICAvLyB3aWxsIGJyZWFrIGZvciB5ZWFycyAwIC0gOTkgQUQgKHdpbGwgdHVybiAxOTAwJ3MpLlxyXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XHJcbiAgICBkLnNldEZ1bGxZZWFyKGVuY29kZWQpO1xyXG4gICAgZC5zZXRNb250aCgwLCAxKTtcclxuICAgIGQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgICByZXR1cm4gZDtcclxufVxyXG5jb25zdCB5ZWFyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUkNSwgZGVjb2RlJDUpO1xuXG5mdW5jdGlvbiBlbmNvZGUkNChkYXRlKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIGR1cmF0aW9uTWludXRlKTtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGUkNChlbmNvZGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCAqIGR1cmF0aW9uTWludXRlKTtcclxufVxyXG5jb25zdCB1dGNNaW51dGUgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZSQ0LCBkZWNvZGUkNCk7XG5cbmZ1bmN0aW9uIGVuY29kZSQzKGRhdGUpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VGltZSgpIC8gZHVyYXRpb25Ib3VyKTtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGUkMyhlbmNvZGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCAqIGR1cmF0aW9uSG91cik7XHJcbn1cclxuY29uc3QgdXRjSG91ciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlJDMsIGRlY29kZSQzKTtcblxuZnVuY3Rpb24gZW5jb2RlJDIoZGF0ZSkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyBkdXJhdGlvbkRheSk7XHJcbn1cclxuZnVuY3Rpb24gZGVjb2RlJDIoZW5jb2RlZCkge1xyXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKDApO1xyXG4gICAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpICsgZW5jb2RlZCk7XHJcbiAgICBkLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xyXG4gICAgcmV0dXJuIGQ7XHJcbn1cclxuY29uc3QgdXRjRGF5ID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUkMiwgZGVjb2RlJDIpO1xuXG5mdW5jdGlvbiBlbmNvZGUkMShkYXRlKSB7XHJcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpICogMTIgKyBkYXRlLmdldFVUQ01vbnRoKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVjb2RlJDEoZW5jb2RlZCkge1xyXG4gICAgY29uc3QgeWVhciA9IE1hdGguZmxvb3IoZW5jb2RlZCAvIDEyKTtcclxuICAgIGNvbnN0IG1vbnRoID0gZW5jb2RlZCAtIHllYXIgKiAxMjtcclxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgMSkpO1xyXG59XHJcbmNvbnN0IHV0Y01vbnRoID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUkMSwgZGVjb2RlJDEpO1xuXG5mdW5jdGlvbiBlbmNvZGUoZGF0ZSkge1xyXG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGUoZW5jb2RlZCkge1xyXG4gICAgLy8gTm90ZTogYXNzaWduaW5nIHllYXJzIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yXHJcbiAgICAvLyB3aWxsIGJyZWFrIGZvciB5ZWFycyAwIC0gOTkgQUQgKHdpbGwgdHVybiAxOTAwJ3MpLlxyXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XHJcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGVuY29kZWQpO1xyXG4gICAgZC5zZXRVVENNb250aCgwLCAxKTtcclxuICAgIGQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgICByZXR1cm4gZDtcclxufVxyXG5jb25zdCB1dGNZZWFyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUsIGRlY29kZSk7XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kLFxuICAgIHNlY29uZDogc2Vjb25kLFxuICAgIG1pbnV0ZTogbWludXRlLFxuICAgIGhvdXI6IGhvdXIsXG4gICAgZGF5OiBkYXksXG4gICAgc3VuZGF5OiBzdW5kYXksXG4gICAgbW9uZGF5OiBtb25kYXksXG4gICAgdHVlc2RheTogdHVlc2RheSxcbiAgICB3ZWRuZXNkYXk6IHdlZG5lc2RheSxcbiAgICB0aHVyc2RheTogdGh1cnNkYXksXG4gICAgZnJpZGF5OiBmcmlkYXksXG4gICAgc2F0dXJkYXk6IHNhdHVyZGF5LFxuICAgIG1vbnRoOiBtb250aCxcbiAgICB5ZWFyOiB5ZWFyLFxuICAgIHV0Y01pbnV0ZTogdXRjTWludXRlLFxuICAgIHV0Y0hvdXI6IHV0Y0hvdXIsXG4gICAgdXRjRGF5OiB1dGNEYXksXG4gICAgdXRjTW9udGg6IHV0Y01vbnRoLFxuICAgIHV0Y1llYXI6IHV0Y1llYXJcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbmNvbnN0IGVudGVycHJpc2VNb2R1bGUgPSB7XHJcbiAgICBpc0VudGVycHJpc2U6IGZhbHNlLFxyXG59O1xuXG5jbGFzcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95Rm5zID0gW107XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZGVzdHJveUZuIG9mIHRoaXMuZGVzdHJveUZucykge1xyXG4gICAgICAgICAgICBkZXN0cm95Rm4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgUkVHSVNURVJFRF9NT0RVTEVTID0gW107XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlKG1vZHVsZSkge1xyXG4gICAgY29uc3Qgb3RoZXJNb2R1bGUgPSBSRUdJU1RFUkVEX01PRFVMRVMuZmluZCgob3RoZXIpID0+IHtcclxuICAgICAgICByZXR1cm4gKG1vZHVsZS50eXBlID09PSBvdGhlci50eXBlICYmXHJcbiAgICAgICAgICAgIG1vZHVsZS5vcHRpb25zS2V5ID09PSBvdGhlci5vcHRpb25zS2V5ICYmXHJcbiAgICAgICAgICAgIG1vZHVsZS5pZGVudGlmaWVyID09PSBvdGhlci5pZGVudGlmaWVyKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKG90aGVyTW9kdWxlKSB7XHJcbiAgICAgICAgaWYgKG1vZHVsZS5wYWNrYWdlVHlwZSA9PT0gJ2VudGVycHJpc2UnICYmIG90aGVyTW9kdWxlLnBhY2thZ2VUeXBlID09PSAnY29tbXVuaXR5Jykge1xyXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBjb21tdW5pdHkgbW9kdWxlIHdpdGggYW4gZW50ZXJwcmlzZSB2ZXJzaW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gUkVHSVNURVJFRF9NT0RVTEVTLmluZGV4T2Yob3RoZXJNb2R1bGUpO1xyXG4gICAgICAgICAgICBSRUdJU1RFUkVEX01PRFVMRVMuc3BsaWNlKGluZGV4LCAxLCBtb2R1bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNpbXBseSByZWdpc3RlciB0aGUgbW9kdWxlXHJcbiAgICAgICAgUkVHSVNURVJFRF9NT0RVTEVTLnB1c2gobW9kdWxlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXNSZWdpc3RlcmVkRW50ZXJwcmlzZU1vZHVsZXMoKSB7XHJcbiAgICByZXR1cm4gUkVHSVNURVJFRF9NT0RVTEVTLnNvbWUoKG0pID0+IG0ucGFja2FnZVR5cGUgPT09ICdlbnRlcnByaXNlJyk7XHJcbn1cclxuY29uc3QgTU9EVUxFX0NPTkZMSUNUUyA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGVDb25mbGljdHMoc291cmNlLCB0YXJnZXRzKSB7XHJcbiAgICBNT0RVTEVfQ09ORkxJQ1RTLnNldChzb3VyY2UsIHRhcmdldHMpO1xyXG59XG5cbmZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMpIHtcclxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB2YWx1ZXM7XHJcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGxldCBtaW4gPSBJbmZpbml0eTtcclxuICAgIGxldCBtYXggPSAtSW5maW5pdHk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHYgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHYgPSB2LmdldFRpbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPCBtaW4pIHtcclxuICAgICAgICAgICAgbWluID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPiBtYXgpIHtcclxuICAgICAgICAgICAgbWF4ID0gdjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBleHRlbnQgPSBbbWluLCBtYXhdO1xyXG4gICAgaWYgKGV4dGVudC5zb21lKCh2KSA9PiAhaXNGaW5pdGUodikpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBleHRlbnQ7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXNlZEV4dGVudChkLCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpLmV4dGVudDtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgY2xpcHBlZCA9IGZhbHNlO1xyXG4gICAgaWYgKGQubGVuZ3RoID4gMikge1xyXG4gICAgICAgIGQgPSAoX2EgPSBleHRlbnQoZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtOYU4sIE5hTl07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTmFOKG1pbikpIHtcclxuICAgICAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWluID4gZFswXSk7XHJcbiAgICAgICAgZCA9IFttaW4sIGRbMV1dO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc05hTihtYXgpKSB7XHJcbiAgICAgICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1heCA8IGRbMV0pO1xyXG4gICAgICAgIGQgPSBbZFswXSwgbWF4XTtcclxuICAgIH1cclxuICAgIGlmIChkWzBdID4gZFsxXSkge1xyXG4gICAgICAgIGQgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGV4dGVudDogZCwgY2xpcHBlZCB9O1xyXG59XHJcbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFbaV0pICYmIEFycmF5LmlzQXJyYXkoYltpXSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcnJheXNFcXVhbChhW2ldLCBiW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFbaV0gIT09IGJbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xyXG59XG5cbmNvbnN0IGRvT25jZUZsYWdzID0ge307XHJcbi8qKlxyXG4gKiBJZiB0aGUga2V5IHdhcyBwYXNzZWQgYmVmb3JlLCB0aGVuIGRvZXNuJ3QgZXhlY3V0ZSB0aGUgZnVuY1xyXG4gKi9cclxuZnVuY3Rpb24gZG9PbmNlKGZ1bmMsIGtleSkge1xyXG4gICAgaWYgKGRvT25jZUZsYWdzW2tleV0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmdW5jKCk7XHJcbiAgICBkb09uY2VGbGFnc1trZXldID0gdHJ1ZTtcclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbmNvbnN0IExvZ2dlciA9IHtcclxuICAgIGxvZyguLi5sb2dDb250ZW50KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coLi4ubG9nQ29udGVudCk7XHJcbiAgICB9LFxyXG4gICAgd2FybihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBBRyBDaGFydHMgLSAke21lc3NhZ2V9YCwgLi4ubG9nQ29udGVudCk7XHJcbiAgICB9LFxyXG4gICAgZXJyb3IobWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQUcgQ2hhcnRzIGVycm9yYCwgbWVzc2FnZSwgLi4ubG9nQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBRyBDaGFydHMgLSAke21lc3NhZ2V9YCwgLi4ubG9nQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRhYmxlKC4uLmxvZ0NvbnRlbnQpIHtcclxuICAgICAgICBjb25zb2xlLnRhYmxlKC4uLmxvZ0NvbnRlbnQpO1xyXG4gICAgfSxcclxuICAgIHdhcm5PbmNlKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcclxuICAgICAgICBkb09uY2UoKCkgPT4gTG9nZ2VyLndhcm4obWVzc2FnZSwgLi4ubG9nQ29udGVudCksIGBMb2dnZXIud2FybjogJHttZXNzYWdlfWApO1xyXG4gICAgfSxcclxuICAgIGVycm9yT25jZShtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XHJcbiAgICAgICAgZG9PbmNlKCgpID0+IExvZ2dlci5lcnJvcihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSwgYExvZ2dlci53YXJuOiAke21lc3NhZ2V9YCk7XHJcbiAgICB9LFxyXG59O1xuXG5mdW5jdGlvbiB3aW5kb3dWYWx1ZShuYW1lKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJlZGVjbGFyYXRpb24gb2Ygd2luZG93IHRoYXQgaXMgc2FmZSBmb3IgdXNlIHdpdGggR2F0c2J5IHNlcnZlci1zaWRlICh3ZWJwYWNrKSBjb21waWxhdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3QgV0lORE9XID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgIDogLy8gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyAoZ2xvYmFsIGFzIGFueSkgOlxyXG4gICAgICAgICAgICB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gV0lORE9XID09PSBudWxsIHx8IFdJTkRPVyA9PT0gdm9pZCAwID8gdm9pZCAwIDogV0lORE9XW25hbWVdO1xyXG59XG5cbmNvbnN0IExPTkdfVElNRV9QRVJJT0RfVEhSRVNIT0xEID0gMjAwMDtcclxubGV0IHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xyXG5jb25zdCBsb2dUaW1lR2FwID0gKCkgPT4ge1xyXG4gICAgY29uc3QgdGltZVNpbmNlTGFzdExvZyA9IERhdGUubm93KCkgLSB0aW1lT2ZMYXN0TG9nO1xyXG4gICAgaWYgKHRpbWVTaW5jZUxhc3RMb2cgPiBMT05HX1RJTUVfUEVSSU9EX1RIUkVTSE9MRCkge1xyXG4gICAgICAgIGNvbnN0IHByZXR0eUR1cmF0aW9uID0gKE1hdGguZmxvb3IodGltZVNpbmNlTGFzdExvZyAvIDEwMCkgLyAxMCkudG9GaXhlZCgxKTtcclxuICAgICAgICBMb2dnZXIubG9nKGAqKioqICR7cHJldHR5RHVyYXRpb259cyBzaW5jZSBsYXN0IGxvZyBtZXNzYWdlICoqKipgKTtcclxuICAgIH1cclxuICAgIHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xyXG59O1xyXG5jb25zdCBEZWJ1ZyA9IHtcclxuICAgIGNyZWF0ZSguLi5kZWJ1Z1NlbGVjdG9ycykge1xyXG4gICAgICAgIHJldHVybiAoLi4ubG9nQ29udGVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoRGVidWcuY2hlY2soLi4uZGVidWdTZWxlY3RvcnMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvZ0NvbnRlbnRbMF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dDb250ZW50ID0gdG9BcnJheShsb2dDb250ZW50WzBdKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9nVGltZUdhcCgpO1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyguLi5sb2dDb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY2hlY2soLi4uZGVidWdTZWxlY3RvcnMpIHtcclxuICAgICAgICBpZiAoZGVidWdTZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRlYnVnU2VsZWN0b3JzLnB1c2godHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoYXJ0RGVidWcgPSB0b0FycmF5KHdpbmRvd1ZhbHVlKCdhZ0NoYXJ0c0RlYnVnJykpO1xyXG4gICAgICAgIHJldHVybiBjaGFydERlYnVnLnNvbWUoKHNlbGVjdG9yKSA9PiBkZWJ1Z1NlbGVjdG9ycy5pbmNsdWRlcyhzZWxlY3RvcikpO1xyXG4gICAgfSxcclxufTtcblxuY29uc3QgQlJFQUtfVFJBTlNGT1JNX0NIQUlOID0gU3ltYm9sKCdCUkVBSycpO1xyXG5jb25zdCBDT05GSUdfS0VZID0gJ19fZGVjb3JhdG9yX2NvbmZpZyc7XHJcbmZ1bmN0aW9uIGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sLCBwcm9wZXJ0eUtleSwgdmFsdWVTdG9yZUtleSkge1xyXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBDT05GSUdfS0VZKSA9PSBudWxsKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgQ09ORklHX0tFWSwgeyB2YWx1ZToge30gfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb25maWcgPSB0YXJnZXRbQ09ORklHX0tFWV07XHJcbiAgICBpZiAoY29uZmlnW3Byb3BlcnR5S2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1twcm9wZXJ0eUtleV07XHJcbiAgICB9XHJcbiAgICBjb25maWdbcHJvcGVydHlLZXldID0geyBzZXR0ZXJzOiBbXSwgZ2V0dGVyczogW10gfTtcclxuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCk7XHJcbiAgICBjb25zdCBwcmV2U2V0ID0gZGVzY3JpcHRvciA9PT0gbnVsbCB8fCBkZXNjcmlwdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXNjcmlwdG9yLnNldDtcclxuICAgIGNvbnN0IHByZXZHZXQgPSBkZXNjcmlwdG9yID09PSBudWxsIHx8IGRlc2NyaXB0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlc2NyaXB0b3IuZ2V0O1xyXG4gICAgY29uc3QgZ2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gcHJldkdldCA/IHByZXZHZXQuY2FsbCh0aGlzKSA6IHRoaXNbdmFsdWVTdG9yZUtleV07XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2Zvcm1GbiBvZiAoX2IgPSAoX2EgPSBjb25maWdbcHJvcGVydHlLZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0dGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1Gbih0aGlzLCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gQlJFQUtfVFJBTlNGT1JNX0NIQUlOKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBzZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHNldHRlcnMgPSAoX2IgPSAoX2EgPSBjb25maWdbcHJvcGVydHlLZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0dGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XHJcbiAgICAgICAgbGV0IG9sZFZhbHVlO1xyXG4gICAgICAgIGlmIChzZXR0ZXJzLnNvbWUoKGYpID0+IGYubGVuZ3RoID4gMikpIHtcclxuICAgICAgICAgICAgLy8gTGF6aWx5IHJldHJpZXZlIG9sZCB2YWx1ZS5cclxuICAgICAgICAgICAgb2xkVmFsdWUgPSBwcmV2R2V0ID8gcHJldkdldC5jYWxsKHRoaXMpIDogdGhpc1t2YWx1ZVN0b3JlS2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2Zvcm1GbiBvZiBzZXR0ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdHJhbnNmb3JtRm4odGhpcywgcHJvcGVydHlLZXlPclN5bWJvbCwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlNldCkge1xyXG4gICAgICAgICAgICBwcmV2U2V0LmNhbGwodGhpcywgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpc1t2YWx1ZVN0b3JlS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB7XHJcbiAgICAgICAgc2V0OiBzZXR0ZXIsXHJcbiAgICAgICAgZ2V0OiBnZXR0ZXIsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29uZmlnW3Byb3BlcnR5S2V5XTtcclxufVxyXG5mdW5jdGlvbiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoc2V0VHJhbnNmb3JtLCBnZXRUcmFuc2Zvcm0pIHtcclxuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHlLZXkgPSBwcm9wZXJ0eUtleU9yU3ltYm9sLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVTdG9yZUtleSA9IGBfXyR7cHJvcGVydHlLZXl9YDtcclxuICAgICAgICBjb25zdCB7IGdldHRlcnMsIHNldHRlcnMgfSA9IGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sLCBwcm9wZXJ0eUtleSwgdmFsdWVTdG9yZUtleSk7XHJcbiAgICAgICAgc2V0dGVycy5wdXNoKHNldFRyYW5zZm9ybSk7XHJcbiAgICAgICAgaWYgKGdldFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBnZXR0ZXJzLnVuc2hpZnQoZ2V0VHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVjb3JhdGVkT2JqZWN0KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgIT09ICd1bmRlZmluZWQnICYmIENPTkZJR19LRVkgaW4gdGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRhcmdldCkge1xyXG4gICAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQoKTtcclxuICAgIHdoaWxlIChpc0RlY29yYXRlZE9iamVjdCh0YXJnZXQpKSB7XHJcbiAgICAgICAgdGFyZ2V0cy5hZGQodGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0W0NPTkZJR19LRVldKTtcclxuICAgICAgICB0YXJnZXQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRhcmdldHMpLmZsYXRNYXAoKGNvbmZpZ01hcCkgPT4gT2JqZWN0LmtleXMoY29uZmlnTWFwKSk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJlc3VsdFtrZXldID0gKF9hID0gdGFyZ2V0W2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIHt9KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKSB7XHJcbiAgICByZXR1cm4gKGtleSwgbWVzc2FnZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IFtgUHJvcGVydHkgWyR7a2V5fV0gaXMgZGVwcmVjYXRlZC5gLCBtZXNzYWdlXS5maWx0ZXIoKHYpID0+IHYgIT0gbnVsbCkuam9pbignICcpO1xyXG4gICAgICAgIExvZ2dlci53YXJuT25jZShtc2cpO1xyXG4gICAgfTtcclxufVxuXG5jb25zdCBDTEFTU19JTlNUQU5DRV9UWVBFID0gJ2NsYXNzLWluc3RhbmNlJztcclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgSlNPTi1kaWZmIGJldHdlZW4gYSBzb3VyY2UgYW5kIHRhcmdldCBKU09OIHN0cnVjdHVyZS5cclxuICpcclxuICogT24gYSBwZXIgcHJvcGVydHkgYmFzaXMsIHRha2VzIHRoZSB0YXJnZXQgcHJvcGVydHkgdmFsdWUgd2hlcmU6XHJcbiAqIC0gdHlwZXMgYXJlIGRpZmZlcmVudC5cclxuICogLSB0eXBlIGlzIHByaW1pdGl2ZS5cclxuICogLSB0eXBlIGlzIGFycmF5IGFuZCBsZW5ndGggb3IgY29udGVudCBoYXZlIGNoYW5nZWQuXHJcbiAqXHJcbiAqIFJlY3Vyc2VzIGZvciBvYmplY3QgdHlwZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBzb3VyY2Ugc3RhcnRpbmcgcG9pbnQgZm9yIGRpZmZcclxuICogQHBhcmFtIHRhcmdldCB0YXJnZXQgZm9yIGRpZmYgdnMuIHNvdXJjZVxyXG4gKlxyXG4gKiBAcmV0dXJucyBgbnVsbGAgaWYgbm8gZGlmZmVyZW5jZXMsIG9yIGFuIG9iamVjdCB3aXRoIHRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyB0aGF0IGhhdmUgY2hhbmdlZC5cclxuICovXHJcbmZ1bmN0aW9uIGpzb25EaWZmKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICBjb25zdCBzb3VyY2VUeXBlID0gY2xhc3NpZnkoc291cmNlKTtcclxuICAgIGNvbnN0IHRhcmdldFR5cGUgPSBjbGFzc2lmeSh0YXJnZXQpO1xyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09ICdhcnJheScpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldDtcclxuICAgICAgICBpZiAoc291cmNlVHlwZSAhPT0gJ2FycmF5JyB8fCBzb3VyY2UubGVuZ3RoICE9PSB0YXJnZXRBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsuLi50YXJnZXRBcnJheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXRBcnJheS5zb21lKCh0YXJnZXRFbGVtZW50LCBpKSA9PiBqc29uRGlmZihzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VbaV0sIHRhcmdldEVsZW1lbnQpICE9IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbLi4udGFyZ2V0QXJyYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAncHJpbWl0aXZlJykge1xyXG4gICAgICAgIGlmIChzb3VyY2VUeXBlICE9PSAncHJpbWl0aXZlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGhzID0gc291cmNlIHx8IHt9O1xyXG4gICAgY29uc3QgcmhzID0gdGFyZ2V0IHx8IHt9O1xyXG4gICAgY29uc3QgYWxsUHJvcHMgPSBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyhsaHMpLCAuLi5PYmplY3Qua2V5cyhyaHMpXSk7XHJcbiAgICBsZXQgcHJvcHNDaGFuZ2VkQ291bnQgPSAwO1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcclxuICAgICAgICAvLyBDaGVhcC1hbmQtZWFzeSBlcXVhbGl0eSBjaGVjay5cclxuICAgICAgICBpZiAobGhzW3Byb3BdID09PSByaHNbcHJvcF0pIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRha2UgPSAodikgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2O1xyXG4gICAgICAgICAgICBwcm9wc0NoYW5nZWRDb3VudCsrO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbGhzVHlwZSA9IGNsYXNzaWZ5KGxoc1twcm9wXSk7XHJcbiAgICAgICAgY29uc3QgcmhzVHlwZSA9IGNsYXNzaWZ5KHJoc1twcm9wXSk7XHJcbiAgICAgICAgaWYgKGxoc1R5cGUgIT09IHJoc1R5cGUpIHtcclxuICAgICAgICAgICAgLy8gVHlwZXMgY2hhbmdlZCwganVzdCB0YWtlIFJIUy5cclxuICAgICAgICAgICAgdGFrZShyaHNbcHJvcF0pO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJoc1R5cGUgPT09ICdwcmltaXRpdmUnIHx8IHJoc1R5cGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGFrZShyaHNbcHJvcF0pO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJoc1R5cGUgPT09ICdhcnJheScgJiYgbGhzW3Byb3BdLmxlbmd0aCAhPT0gcmhzW3Byb3BdLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBBcnJheXMgYXJlIGRpZmZlcmVudCBzaXplcywgc28ganVzdCB0YWtlIHRhcmdldCBhcnJheS5cclxuICAgICAgICAgICAgdGFrZShyaHNbcHJvcF0pO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJoc1R5cGUgPT09IENMQVNTX0lOU1RBTkNFX1RZUEUpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRvIGRvIGFueXRoaW5nIHRyaWNreSB3aXRoIGFycmF5IGRpZmZzIVxyXG4gICAgICAgICAgICB0YWtlKHJoc1twcm9wXSk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmhzVHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBsaHNbcHJvcF0gIT09IHJoc1twcm9wXSkge1xyXG4gICAgICAgICAgICB0YWtlKHJoc1twcm9wXSk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaWZmID0ganNvbkRpZmYobGhzW3Byb3BdLCByaHNbcHJvcF0pO1xyXG4gICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRha2UoZGlmZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzQ2hhbmdlZENvdW50ID09PSAwID8gbnVsbCA6IHJlc3VsdDtcclxufVxyXG4vKipcclxuICogU3BlY2lhbCB2YWx1ZSB1c2VkIGJ5IGBqc29uTWVyZ2VgIHRvIHNpZ25hbCB0aGF0IGEgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgbWVyZ2VkXHJcbiAqIG91dHB1dC5cclxuICovXHJcbmNvbnN0IERFTEVURSA9IFN5bWJvbCgnPGRlbGV0ZS1wcm9wZXJ0eT4nKTtcclxuY29uc3QgTk9UX1NQRUNJRklFRCA9IFN5bWJvbCgnPHVuc3BlY2lmaWVkLXByb3BlcnR5PicpO1xyXG4vKipcclxuICogTWVyZ2UgdG9nZXRoZXIgdGhlIHByb3ZpZGUgSlNPTiBvYmplY3Qgc3RydWN0dXJlcywgd2l0aCB0aGUgcHJlY2VkZW5jZSBvZiBhcHBsaWNhdGlvbiBydW5uaW5nXHJcbiAqIGZyb20gaGlnaGVyIGluZGV4ZXMgdG8gbG93ZXIgaW5kZXhlcy5cclxuICpcclxuICogRGVlcC1jbG9uZXMgYWxsIG9iamVjdHMgdG8gYXZvaWQgbXV0YXRpb24gb2YgdGhlIGlucHV0cyBjaGFuZ2luZyB0aGUgb3V0cHV0IG9iamVjdC4gRm9yIGFycmF5cyxcclxuICoganVzdCBwZXJmb3JtcyBhIGRlZXAtY2xvbmUgb2YgdGhlIGVudGlyZSBhcnJheSwgbm8gbWVyZ2luZyBvZiBlbGVtZW50cyBhdHRlbXB0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBqc29uIGFsbCBqc29uIG9iamVjdHMgdG8gbWVyZ2VcclxuICogQHBhcmFtIG9wdHMgbWVyZ2Ugb3B0aW9uc1xyXG4gKiBAcGFyYW0gb3B0cy5hdm9pZERlZXBDbG9uZSBjb250YWlucyBhIGxpc3Qgb2YgcHJvcGVydGllcyB3aGVyZSBkZWVwIGNsb25lcyBzaG91bGQgYmUgYXZvaWRlZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHRoZSBqc29uIGlucHV0c1xyXG4gKi9cclxuZnVuY3Rpb24ganNvbk1lcmdlKGpzb24sIG9wdHMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGF2b2lkRGVlcENsb25lID0gKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmF2b2lkRGVlcENsb25lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgIGNvbnN0IGpzb25UeXBlcyA9IGpzb24ubWFwKCh2KSA9PiBjbGFzc2lmeSh2KSk7XHJcbiAgICBpZiAoanNvblR5cGVzLnNvbWUoKHYpID0+IHYgPT09ICdhcnJheScpKSB7XHJcbiAgICAgICAgLy8gQ2xvbmUgZmluYWwgYXJyYXkuXHJcbiAgICAgICAgY29uc3QgZmluYWxWYWx1ZSA9IGpzb25banNvbi5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaW5hbFZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxWYWx1ZS5tYXAoKHYpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjbGFzc2lmeSh2KTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnYXJyYXknKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uTWVyZ2UoW1tdLCB2XSwgb3B0cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzb25NZXJnZShbe30sIHZdLCBvcHRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsVmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIGNvbnN0IHByb3BzID0gbmV3IFNldChqc29uLm1hcCgodikgPT4gKHYgIT0gbnVsbCA/IE9iamVjdC5rZXlzKHYpIDogW10pKS5yZWR1Y2UoKHIsIG4pID0+IHIuY29uY2F0KG4pLCBbXSkpO1xyXG4gICAgZm9yIChjb25zdCBuZXh0UHJvcCBvZiBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGpzb25cclxuICAgICAgICAgICAgLm1hcCgoaikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaiAhPSBudWxsICYmIHR5cGVvZiBqID09PSAnb2JqZWN0JyAmJiBuZXh0UHJvcCBpbiBqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galtuZXh0UHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE5PVF9TUEVDSUZJRUQ7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcigodikgPT4gdiAhPT0gTk9UX1NQRUNJRklFRCk7XHJcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGxhc3RWYWx1ZSA9PT0gREVMRVRFKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0eXBlcyA9IHZhbHVlcy5tYXAoKHYpID0+IGNsYXNzaWZ5KHYpKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbMF07XHJcbiAgICAgICAgaWYgKHR5cGVzLnNvbWUoKHQpID0+IHQgIT09IHR5cGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgbWlzbWF0Y2hpbmcgdHlwZXMuXHJcbiAgICAgICAgICAgIHJlc3VsdFtuZXh0UHJvcF0gPSBsYXN0VmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHR5cGUgPT09ICdhcnJheScgfHwgdHlwZSA9PT0gJ29iamVjdCcpICYmICFhdm9pZERlZXBDbG9uZS5pbmNsdWRlcyhuZXh0UHJvcCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0W25leHRQcm9wXSA9IGpzb25NZXJnZSh2YWx1ZXMsIG9wdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgIC8vIEFycmF5cyBuZWVkIHRvIGJlIHNoYWxsb3cgY29waWVkIHRvIGF2b2lkIGV4dGVybmFsIG11dGF0aW9uIGFuZCBhbGxvdyBqc29uRGlmZiB0b1xyXG4gICAgICAgICAgICAvLyBkZXRlY3QgY2hhbmdlcy5cclxuICAgICAgICAgICAgcmVzdWx0W25leHRQcm9wXSA9IFsuLi5sYXN0VmFsdWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSnVzdCBkaXJlY3RseSBhc3NpZ24vb3ZlcndyaXRlLlxyXG4gICAgICAgICAgICByZXN1bHRbbmV4dFByb3BdID0gbGFzdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IGFwcGx5IGEgSlNPTiBvYmplY3QgaW50byBhIGNsYXNzLWhpZXJhcmNoeSwgb3B0aW9uYWxseSBpbnN0YW50aWF0aW5nIGNlcnRhaW4gY2xhc3Nlc1xyXG4gKiBieSBwcm9wZXJ0eSBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGFyZ2V0IHRvIGFwcGx5IHNvdXJjZSBKU09OIHByb3BlcnRpZXMgaW50b1xyXG4gKiBAcGFyYW0gc291cmNlIHRvIGJlIGFwcGxpZWRcclxuICogQHBhcmFtIHBhcmFtc1xyXG4gKiBAcGFyYW0gcGFyYW1zLnBhdGggcGF0aCBmb3IgbG9nZ2luZy9lcnJvciBwdXJwb3NlcywgdG8gYWlkIHdpdGggcGlucG9pbnRpbmcgcHJvYmxlbXNcclxuICogQHBhcmFtIHBhcmFtcy5tYXRjaGVyUGF0aCBwYXRoIGZvciBwYXR0ZXJuIG1hdGNoaW5nLCB0byBsb29rdXAgYWxsb3dlZFR5cGVzIG92ZXJyaWRlLlxyXG4gKiBAcGFyYW0gcGFyYW1zLnNraXAgcHJvcGVydHkgbmFtZXMgdG8gc2tpcCBmcm9tIHRoZSBzb3VyY2VcclxuICogQHBhcmFtIHBhcmFtcy5jb25zdHJ1Y3RvcnMgZGljdGlvbmFyeSBvZiBwcm9wZXJ0eSBuYW1lIHRvIGNsYXNzIGNvbnN0cnVjdG9ycyBmb3IgcHJvcGVydGllcyB0aGF0XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgb2JqZWN0IGNvbnN0cnVjdGlvblxyXG4gKiBAcGFyYW0gcGFyYW1zLmNvbnN0cnVjdGVkQXJyYXlzIG1hcCBzdG9yZXMgYXJyYXlzIHdoaWNoIGl0ZW1zIHNob3VsZCBiZSBpbml0aWFsaXNlZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzaW5nIGEgY2xhc3MgY29uc3RydWN0b3JcclxuICogQHBhcmFtIHBhcmFtcy5hbGxvd2VkVHlwZXMgb3ZlcnJpZGVzIGJ5IHBhdGggZm9yIGFsbG93ZWQgcHJvcGVydHkgdHlwZXNcclxuICovXHJcbmZ1bmN0aW9uIGpzb25BcHBseSh0YXJnZXQsIHNvdXJjZSwgcGFyYW1zID0ge30pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgY29uc3QgeyBwYXRoID0gdW5kZWZpbmVkLCBtYXRjaGVyUGF0aCA9IHBhdGggPyBwYXRoLnJlcGxhY2UoLyhcXFtbMC05K10rXSkvaSwgJ1tdJykgOiB1bmRlZmluZWQsIHNraXAgPSBbXSwgY29uc3RydWN0b3JzID0ge30sIGNvbnN0cnVjdGVkQXJyYXlzID0gbmV3IFdlYWtNYXAoKSwgYWxsb3dlZFR5cGVzID0ge30sIGlkeCwgfSA9IHBhcmFtcztcclxuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdGFyZ2V0IGlzIHVuaW5pdGlhbGlzZWQ6ICR7cGF0aCAhPT0gbnVsbCAmJiBwYXRoICE9PSB2b2lkIDAgPyBwYXRoIDogJzxyb290Pid9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc291cmNlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0QW55ID0gdGFyZ2V0O1xyXG4gICAgaWYgKGlkeCAhPSBudWxsICYmICdfZGVjbGFyYXRpb25PcmRlcicgaW4gdGFyZ2V0QW55KSB7XHJcbiAgICAgICAgdGFyZ2V0QW55WydfZGVjbGFyYXRpb25PcmRlciddID0gaWR4O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGNsYXNzaWZ5KHRhcmdldCk7XHJcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHNvdXJjZSkge1xyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5TWF0Y2hlclBhdGggPSBgJHttYXRjaGVyUGF0aCA/IG1hdGNoZXJQYXRoICsgJy4nIDogJyd9JHtwcm9wZXJ0eX1gO1xyXG4gICAgICAgIGlmIChza2lwLmluZGV4T2YocHJvcGVydHlNYXRjaGVyUGF0aCkgPj0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5UGF0aCA9IGAke3BhdGggPyBwYXRoICsgJy4nIDogJyd9JHtwcm9wZXJ0eX1gO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENsYXNzID0gdGFyZ2V0QW55LmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldEFueVtwcm9wZXJ0eV07XHJcbiAgICAgICAgbGV0IGN0ciA9IChfYSA9IGNvbnN0cnVjdG9yc1twcm9wZXJ0eU1hdGNoZXJQYXRoXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RydWN0b3JzW3Byb3BlcnR5XTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWVUeXBlID0gY2xhc3NpZnkoY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWVUeXBlID0gY2xhc3NpZnkobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gQ0xBU1NfSU5TVEFOQ0VfVFlQRSAmJlxyXG4gICAgICAgICAgICAgICAgIShwcm9wZXJ0eSBpbiB0YXJnZXQgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldEFueSwgcHJvcGVydHkpKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gJHt0YXJnZXRDbGFzcyA9PT0gbnVsbCB8fCB0YXJnZXRDbGFzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0Q2xhc3MubmFtZX0gLSBwcm9wZXJ0eSBpcyB1bmtub3duYCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhbGxvd2FibGVUeXBlcyA9IChfYiA9IGFsbG93ZWRUeXBlc1twcm9wZXJ0eU1hdGNoZXJQYXRoXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW2N1cnJlbnRWYWx1ZVR5cGVdO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlVHlwZSA9PT0gQ0xBU1NfSU5TVEFOQ0VfVFlQRSAmJiBuZXdWYWx1ZVR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGxvd2VkLCB0aGlzIGlzIHRoZSBjb21tb24gY2FzZSEgLSBkbyBub3QgZXJyb3IuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFZhbHVlVHlwZSAhPSBudWxsICYmIG5ld1ZhbHVlVHlwZSAhPSBudWxsICYmICFhbGxvd2FibGVUeXBlcy5pbmNsdWRlcyhuZXdWYWx1ZVR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybihgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eVBhdGh9XSBpbiAke3RhcmdldENsYXNzID09PSBudWxsIHx8IHRhcmdldENsYXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRDbGFzcy5uYW1lfSAtIGNhbid0IGFwcGx5IHR5cGUgb2YgWyR7bmV3VmFsdWVUeXBlfV0sIGFsbG93ZWQgdHlwZXMgYXJlOiBbJHthbGxvd2FibGVUeXBlc31dYCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWVUeXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgICAgICBjdHIgPSAoX2MgPSBjdHIgIT09IG51bGwgJiYgY3RyICE9PSB2b2lkIDAgPyBjdHIgOiBjb25zdHJ1Y3RlZEFycmF5cy5nZXQoY3VycmVudFZhbHVlKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29uc3RydWN0b3JzW2Ake3Byb3BlcnR5TWF0Y2hlclBhdGh9W11gXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdHIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlQXJyYXkgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldID0gbmV3VmFsdWVBcnJheS5tYXAoKHYsIGlkeCkgPT4ganNvbkFwcGx5KG5ldyBjdHIoKSwgdiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHBhdGg6IHByb3BlcnR5UGF0aCwgbWF0Y2hlclBhdGg6IHByb3BlcnR5TWF0Y2hlclBhdGggKyAnW10nLCBpZHggfSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZVR5cGUgPT09IENMQVNTX0lOU1RBTkNFX1RZUEUpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldEFueVtwcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZVR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBqc29uQXBwbHkoY3VycmVudFZhbHVlLCBuZXdWYWx1ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHBhdGg6IHByb3BlcnR5UGF0aCwgbWF0Y2hlclBhdGg6IHByb3BlcnR5TWF0Y2hlclBhdGgsIGlkeDogdW5kZWZpbmVkIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0ciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QW55W3Byb3BlcnR5XSA9IGpzb25BcHBseShuZXcgY3RyKCksIG5ld1ZhbHVlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgcGF0aDogcHJvcGVydHlQYXRoLCBtYXRjaGVyUGF0aDogcHJvcGVydHlNYXRjaGVyUGF0aCwgaWR4OiB1bmRlZmluZWQgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QW55W3Byb3BlcnR5XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0QW55W3Byb3BlcnR5XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBMb2dnZXIud2FybihgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eVBhdGh9XSBpbiBbJHt0YXJnZXRDbGFzcyA9PT0gbnVsbCB8fCB0YXJnZXRDbGFzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0Q2xhc3MubmFtZX1dOyBuZXN0ZWQgZXJyb3IgaXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbi8qKlxyXG4gKiBXYWxrIHRoZSBnaXZlbiBKU09OIG9iamVjdCBncmFwaHMsIGludm9raW5nIHRoZSB2aXNpdCgpIGNhbGxiYWNrIGZvciBldmVyeSBvYmplY3QgZW5jb3VudGVyZWQuXHJcbiAqIEFycmF5cyBhcmUgZGVzY2VuZGVkIGludG8gd2l0aG91dCBhIGNhbGxiYWNrLCBob3dldmVyIHRoZWlyIGVsZW1lbnRzIHdpbGwgaGF2ZSB0aGUgdmlzaXQoKVxyXG4gKiBjYWxsYmFjayBpbnZva2VkIGlmIHRoZXkgYXJlIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBqc29uIHRvIHRyYXZlcnNlXHJcbiAqIEBwYXJhbSB2aXNpdCBjYWxsYmFjayBmb3IgZWFjaCBub24tcHJpbWl0aXZlIGFuZCBub24tYXJyYXkgb2JqZWN0IGZvdW5kXHJcbiAqIEBwYXJhbSBvcHRzXHJcbiAqIEBwYXJhbSBvcHRzLnNraXAgcHJvcGVydHkgbmFtZXMgdG8gc2tpcCB3aGVuIHdhbGtpbmdcclxuICogQHBhcmFtIGpzb25zIHRvIHRyYXZlcnNlIGluIHBhcmFsbGVsXHJcbiAqL1xyXG5mdW5jdGlvbiBqc29uV2Fsayhqc29uLCB2aXNpdCwgb3B0cywgLi4uanNvbnMpIHtcclxuICAgIGNvbnN0IGpzb25UeXBlID0gY2xhc3NpZnkoanNvbik7XHJcbiAgICBjb25zdCB7IHNraXAgPSBbXSB9ID0gb3B0cyAhPT0gbnVsbCAmJiBvcHRzICE9PSB2b2lkIDAgPyBvcHRzIDoge307XHJcbiAgICBpZiAoanNvblR5cGUgPT09ICdhcnJheScpIHtcclxuICAgICAgICB2aXNpdChqc29uVHlwZSwganNvbiwgLi4uanNvbnMpO1xyXG4gICAgICAgIGpzb24uZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAganNvbldhbGsoZWxlbWVudCwgdmlzaXQsIG9wdHMsIC4uLihqc29ucyAhPT0gbnVsbCAmJiBqc29ucyAhPT0gdm9pZCAwID8ganNvbnMgOiBbXSkubWFwKChvKSA9PiBvID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9baW5kZXhdKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGpzb25UeXBlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZpc2l0KGpzb25UeXBlLCBqc29uLCAuLi5qc29ucyk7XHJcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGpzb24pIHtcclxuICAgICAgICBpZiAoc2tpcC5pbmNsdWRlcyhwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlID0ganNvbltwcm9wZXJ0eV07XHJcbiAgICAgICAgY29uc3Qgb3RoZXJWYWx1ZXMgPSBqc29ucyA9PT0gbnVsbCB8fCBqc29ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDoganNvbnMubWFwKChvKSA9PiBvID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9bcHJvcGVydHldKTtcclxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBjbGFzc2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcgfHwgdmFsdWVUeXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgIGpzb25XYWxrKHZhbHVlLCB2aXNpdCwgb3B0cywgLi4ub3RoZXJWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcclxuLyoqXHJcbiAqIENsYXNzaWZ5IHRoZSB0eXBlIG9mIHZhbHVlIHRvIGFzc2lzdCB3aXRoIGhhbmRsaW5nIGZvciBtZXJnZSBwdXJwb3Nlcy5cclxuICovXHJcbmZ1bmN0aW9uIGNsYXNzaWZ5KHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQnJvd3NlciAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICdwcmltaXRpdmUnO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuICdwcmltaXRpdmUnO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgIHJldHVybiAnb2JqZWN0JztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gQ0xBU1NfSU5TVEFOQ0VfVFlQRTtcclxuICAgIH1cclxuICAgIHJldHVybiAncHJpbWl0aXZlJztcclxufVxuXG5jb25zdCB0d29QaSA9IE1hdGguUEkgKiAyO1xyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBhbmdsZSB0byBiZSBpbiB0aGUgWzAsIDLPgCkgaW50ZXJ2YWwuXHJcbiAqIEBwYXJhbSByYWRpYW5zIEFuZ2xlIGluIHJhZGlhbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTM2MChyYWRpYW5zKSB7XHJcbiAgICByYWRpYW5zICU9IHR3b1BpO1xyXG4gICAgcmFkaWFucyArPSB0d29QaTtcclxuICAgIHJhZGlhbnMgJT0gdHdvUGk7XHJcbiAgICByZXR1cm4gcmFkaWFucztcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZShyYWRpYW5zKSB7XHJcbiAgICByYWRpYW5zICU9IHR3b1BpO1xyXG4gICAgcmFkaWFucyArPSB0d29QaTtcclxuICAgIGlmIChyYWRpYW5zICE9PSB0d29QaSkge1xyXG4gICAgICAgIHJhZGlhbnMgJT0gdHdvUGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmFkaWFucztcclxufVxyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBhbmdsZSB0byBiZSBpbiB0aGUgWy3PgCwgz4ApIGludGVydmFsLlxyXG4gKiBAcGFyYW0gcmFkaWFucyBBbmdsZSBpbiByYWRpYW5zLlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUxODAocmFkaWFucykge1xyXG4gICAgcmFkaWFucyAlPSB0d29QaTtcclxuICAgIGlmIChyYWRpYW5zIDwgLU1hdGguUEkpIHtcclxuICAgICAgICByYWRpYW5zICs9IHR3b1BpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmFkaWFucyA+PSBNYXRoLlBJKSB7XHJcbiAgICAgICAgcmFkaWFucyAtPSB0d29QaTtcclxuICAgIH1cclxuICAgIHJldHVybiByYWRpYW5zO1xyXG59XHJcbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XHJcbiAgICByZXR1cm4gKGRlZ3JlZXMgLyAxODApICogTWF0aC5QSTtcclxufVxyXG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xyXG4gICAgcmV0dXJuIChyYWRpYW5zIC8gTWF0aC5QSSkgKiAxODA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByb3RhdGlvbiBhbmdsZSBiZXR3ZWVuIHR3byBvdGhlciBhbmdsZXMuXHJcbiAqIEBwYXJhbSBhbmdsZTAgQW5nbGUgaW4gcmFkaWFucy5cclxuICogQHBhcmFtIGFuZ2xlMSBBbmdsZSBpbiByYWRpYW5zLlxyXG4gKiBAcmV0dXJucyBBbmdsZSBpbiByYWRpYW5zLlxyXG4gKi9cclxuZnVuY3Rpb24gYW5nbGVCZXR3ZWVuKGFuZ2xlMCwgYW5nbGUxKSB7XHJcbiAgICBhbmdsZTAgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTApO1xyXG4gICAgYW5nbGUxID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUxKTtcclxuICAgIHJldHVybiBhbmdsZTEgLSBhbmdsZTAgKyAoYW5nbGUwID4gYW5nbGUxID8gMiAqIE1hdGguUEkgOiAwKTtcclxufVxuXG5mdW5jdGlvbiBjbGFtcCQxKHgsIG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHgpKTtcclxufVxyXG4vKipcclxuICogTWFwcyBhIGRpc2NyZXRlIGRvbWFpbiB0byBhIGNvbnRpbnVvdXMgbnVtZXJpYyByYW5nZS5cclxuICovXHJcbmNsYXNzIEJhbmRTY2FsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnYmFuZCc7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYWNoZVByb3BzID0gWydfZG9tYWluJywgJ3JhbmdlJywgJ19wYWRkaW5nSW5uZXInLCAnX3BhZGRpbmdPdXRlcicsICdyb3VuZCcsICdpbnRlcnZhbCddO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcHMgZGF0dW0gdG8gaXRzIGluZGV4IGluIHRoZSB7QGxpbmsgZG9tYWlufSBhcnJheS5cclxuICAgICAgICAgKiBVc2VkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGUgZGF0dW1zIChub3QgYWxsb3dlZCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3V0cHV0IHJhbmdlIHZhbHVlcyBmb3IgZGF0dW0gYXQgZWFjaCBpbmRleC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9yZGluYWxSYW5nZSA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRhaW5zIHVuaXF1ZSBkYXR1bXMgb25seS4gU2luY2UgYHt9YCBpcyB1c2VkIGluIHBsYWNlIG9mIGBNYXBgXHJcbiAgICAgICAgICogZm9yIElFMTEgY29tcGF0aWJpbGl0eSwgdGhlIGRhdHVtcyBhcmUgY29udmVydGVkIGB0b1N0cmluZ2AgYmVmb3JlXHJcbiAgICAgICAgICogdGhlIHVuaXF1ZW5lc3MgY2hlY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZG9tYWluID0gW107XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IFswLCAxXTtcclxuICAgICAgICB0aGlzLl9iYW5kd2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuX3Jhd0JhbmR3aWR0aCA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJhdGlvIG9mIHRoZSByYW5nZSB0aGF0IGlzIHJlc2VydmVkIGZvciBzcGFjZSBiZXR3ZWVuIGJhbmRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3BhZGRpbmdJbm5lciA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJhdGlvIG9mIHRoZSByYW5nZSB0aGF0IGlzIHJlc2VydmVkIGZvciBzcGFjZSBiZWZvcmUgdGhlIGZpcnN0XHJcbiAgICAgICAgICogYW5kIGFmdGVyIHRoZSBsYXN0IGJhbmQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcGFkZGluZ091dGVyID0gMDtcclxuICAgICAgICB0aGlzLnJvdW5kID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBkaWRDaGFuZ2UoKSB7XHJcbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBkaWRDaGFuZ2UgPSAhY2FjaGUgfHwgdGhpcy5jYWNoZVByb3BzLnNvbWUoKHApID0+IHRoaXNbcF0gIT09IGNhY2hlW3BdKTtcclxuICAgICAgICBpZiAoZGlkQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZVByb3BzLmZvckVhY2goKHApID0+ICh0aGlzLmNhY2hlW3BdID0gdGhpc1twXSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmVmcmVzaCgpIHtcclxuICAgICAgICBpZiAodGhpcy5kaWRDaGFuZ2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBkb21haW4odmFsdWVzKSB7XHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gW107XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgLy8gSW4gY2FzZSBvbmUgd2FudHMgdG8gaGF2ZSBkdXBsaWNhdGUgZG9tYWluIHZhbHVlcywgZm9yIGV4YW1wbGUsIHR3byAnSXRhbHknIGNhdGVnb3JpZXMsXHJcbiAgICAgICAgLy8gb25lIHNob3VsZCB1c2Ugb2JqZWN0cyByYXRoZXIgdGhhbiBzdHJpbmdzIGZvciBkb21haW4gdmFsdWVzIGxpa2Ugc286XHJcbiAgICAgICAgLy8geyB0b1N0cmluZzogKCkgPT4gJ0l0YWx5JyB9XHJcbiAgICAgICAgLy8geyB0b1N0cmluZzogKCkgPT4gJ0l0YWx5JyB9XHJcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleC5nZXQodmFsdWUpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4LnNldCh2YWx1ZSwgZG9tYWluLnB1c2godmFsdWUpIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9kb21haW4gPSBkb21haW47XHJcbiAgICB9XHJcbiAgICBnZXQgZG9tYWluKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb21haW47XHJcbiAgICB9XHJcbiAgICB0aWNrcygpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICBjb25zdCB7IGludGVydmFsID0gMSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBzdGVwID0gTWF0aC5hYnMoTWF0aC5yb3VuZChpbnRlcnZhbCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb21haW4uZmlsdGVyKChfLCBpKSA9PiBpICUgc3RlcCA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0KGQpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICBjb25zdCBpID0gdGhpcy5pbmRleC5nZXQoZCk7XHJcbiAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByID0gdGhpcy5vcmRpbmFsUmFuZ2VbaV07XHJcbiAgICAgICAgaWYgKHIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuICAgIGludmVydChwb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcmRpbmFsUmFuZ2UuZmluZEluZGV4KChwKSA9PiBwID09PSBwb3NpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tYWluW2luZGV4XTtcclxuICAgIH1cclxuICAgIGdldCBiYW5kd2lkdGgoKSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhbmR3aWR0aDtcclxuICAgIH1cclxuICAgIGdldCByYXdCYW5kd2lkdGgoKSB7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd0JhbmR3aWR0aDtcclxuICAgIH1cclxuICAgIHNldCBwYWRkaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBjbGFtcCQxKHZhbHVlLCAwLCAxKTtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBwYWRkaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nSW5uZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgcGFkZGluZ0lubmVyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcGFkZGluZ0lubmVyID0gY2xhbXAkMSh2YWx1ZSwgMCwgMSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFkZGluZ0lubmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nSW5uZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgcGFkZGluZ091dGVyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcGFkZGluZ091dGVyID0gY2xhbXAkMSh2YWx1ZSwgMCwgMSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFkZGluZ091dGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nT3V0ZXI7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9kb21haW4ubGVuZ3RoO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJvdW5kID0gdGhpcy5yb3VuZDtcclxuICAgICAgICBjb25zdCBwYWRkaW5nSW5uZXIgPSB0aGlzLl9wYWRkaW5nSW5uZXI7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZ091dGVyID0gdGhpcy5fcGFkZGluZ091dGVyO1xyXG4gICAgICAgIGNvbnN0IFtyMCwgcjFdID0gdGhpcy5yYW5nZTtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHIxIC0gcjA7XHJcbiAgICAgICAgY29uc3QgcmF3U3RlcCA9IHdpZHRoIC8gTWF0aC5tYXgoMSwgY291bnQgKyAyICogcGFkZGluZ091dGVyIC0gcGFkZGluZ0lubmVyKTtcclxuICAgICAgICBjb25zdCBzdGVwID0gcm91bmQgPyBNYXRoLmZsb29yKHJhd1N0ZXApIDogcmF3U3RlcDtcclxuICAgICAgICBjb25zdCBmdWxsQmFuZFdpZHRoID0gc3RlcCAqIChjb3VudCAtIHBhZGRpbmdJbm5lcik7XHJcbiAgICAgICAgY29uc3QgeDAgPSByMCArICh3aWR0aCAtIGZ1bGxCYW5kV2lkdGgpIC8gMjtcclxuICAgICAgICBjb25zdCBzdGFydCA9IHJvdW5kID8gTWF0aC5yb3VuZCh4MCkgOiB4MDtcclxuICAgICAgICBjb25zdCBidyA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XHJcbiAgICAgICAgY29uc3QgYmFuZHdpZHRoID0gcm91bmQgPyBNYXRoLnJvdW5kKGJ3KSA6IGJ3O1xyXG4gICAgICAgIGNvbnN0IHJhd0JhbmR3aWR0aCA9IHJhd1N0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHN0YXJ0ICsgc3RlcCAqIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9iYW5kd2lkdGggPSBiYW5kd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fcmF3QmFuZHdpZHRoID0gcmF3QmFuZHdpZHRoO1xyXG4gICAgICAgIHRoaXMub3JkaW5hbFJhbmdlID0gdmFsdWVzO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGNsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgZXBzaWxvbiA9IDFlLTEwKSB7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgZXBzaWxvbjtcclxufVxyXG5mdW5jdGlvbiBpc05lZ2F0aXZlKGEpIHtcclxuICAgIHJldHVybiBNYXRoLnNpZ24oYSkgPCAwIHx8IE9iamVjdC5pcyhhLCAtMCk7XHJcbn1cclxuZnVuY3Rpb24gcm91bmQkMSh2YWx1ZSwgZGVjaW1hbHMgPSAyKSB7XHJcbiAgICBjb25zdCBwb3cgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwb3cpIC8gcG93O1xyXG59XHJcbi8qKlxyXG4gKiBgTnVtYmVyLnRvRml4ZWQobilgIGFsd2F5cyBmb3JtYXRzIGEgbnVtYmVyIHNvIHRoYXQgaXQgaGFzIGBuYCBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuXHJcbiAqIEZvciBleGFtcGxlLCBgTnVtYmVyKDAuMDAwMDM0MjcpLnRvRml4ZWQoMilgIHJldHVybnMgYDAuMDBgLlxyXG4gKiBUaGF0J3Mgbm90IHZlcnkgaGVscGZ1bCwgYmVjYXVzZSBhbGwgdGhlIG1lYW5pbmdmdWwgaW5mb3JtYXRpb24gaXMgbG9zdC5cclxuICogSW4gdGhpcyBjYXNlIHdlIHdvdWxkIHdhbnQgdGhlIGZvcm1hdHRlZCB2YWx1ZSB0byBoYXZlIGF0IGxlYXN0IHR3byBzaWduaWZpY2FudCBkaWdpdHM6IGAwLjAwMDAzNGAsXHJcbiAqIG5vdCB0d28gZnJhY3Rpb24gZGlnaXRzLlxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICogQHBhcmFtIGZyYWN0aW9uT3JTaWduaWZpY2FudERpZ2l0c1xyXG4gKi9cclxuZnVuY3Rpb24gdG9GaXhlZCh2YWx1ZSwgZnJhY3Rpb25PclNpZ25pZmljYW50RGlnaXRzID0gMikge1xyXG4gICAgY29uc3QgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHZhbHVlKSkgLyBNYXRoLkxOMTApO1xyXG4gICAgaWYgKHBvd2VyID49IDAgfHwgIWlzRmluaXRlKHBvd2VyKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKGZyYWN0aW9uT3JTaWduaWZpY2FudERpZ2l0cyk7IC8vIGZyYWN0aW9uIGRpZ2l0c1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoTWF0aC5hYnMocG93ZXIpIC0gMSArIGZyYWN0aW9uT3JTaWduaWZpY2FudERpZ2l0cyk7IC8vIHNpZ25pZmljYW50IGRpZ2l0c1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXRoZW1hdGljYWxseSBjb3JyZWN0IG4gbW9kdWx1cyBvZiBtLiBGb3IgY29udGV4dCwgdGhlIEpTICUgb3BlcmF0b3IgaXMgcmVtYWluZGVyXHJcbiAqIE5PVCBtb2R1bHVzLCB3aGljaCBpcyB3aHkgdGhpcyBpcyBuZWVkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtb2QobiwgbSkge1xyXG4gICAgaWYgKG4gPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG4gJSBtKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLmZsb29yKChuICUgbSkgKyBtKTtcclxufVxuXG5jbGFzcyBDb2xvciB7XHJcbiAgICAvKipcclxuICAgICAqIEV2ZXJ5IGNvbG9yIGNvbXBvbmVudCBzaG91bGQgYmUgaW4gdGhlIFswLCAxXSByYW5nZS5cclxuICAgICAqIFNvbWUgZWFzaW5nIGZ1bmN0aW9ucyAoc3VjaCBhcyBlbGFzdGljIGVhc2luZykgY2FuIG92ZXJzaG9vdCB0aGUgdGFyZ2V0IHZhbHVlIGJ5IHNvbWUgYW1vdW50LlxyXG4gICAgICogU28sIHdoZW4gYW5pbWF0aW5nIGNvbG9ycywgaWYgdGhlIHNvdXJjZSBvciB0YXJnZXQgY29sb3IgY29tcG9uZW50cyBhcmUgYWxyZWFkeSBuZWFyXHJcbiAgICAgKiBvciBhdCB0aGUgZWRnZSBvZiB0aGUgYWxsb3dlZCBbMCwgMV0gcmFuZ2UsIGl0IGlzIHBvc3NpYmxlIGZvciB0aGUgaW50ZXJtZWRpYXRlIGNvbG9yXHJcbiAgICAgKiBjb21wb25lbnQgdmFsdWUgdG8gZW5kIHVwIG91dHNpZGUgb2YgdGhhdCByYW5nZSBtaWQtYW5pbWF0aW9uLiBGb3IgdGhpcyByZWFzb24gdGhlIGNvbnN0cnVjdG9yXHJcbiAgICAgKiBwZXJmb3JtcyByYW5nZSBjaGVja2luZy9jb25zdHJhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gciBSZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGcgR3JlZW4gY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIGIgQmx1ZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gYSBBbHBoYSAob3BhY2l0eSkgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyLCBnLCBiLCBhID0gMSkge1xyXG4gICAgICAgIC8vIE5hTiBpcyB0cmVhdGVkIGFzIDBcclxuICAgICAgICB0aGlzLnIgPSBjbGFtcCgwLCByIHx8IDAsIDEpO1xyXG4gICAgICAgIHRoaXMuZyA9IGNsYW1wKDAsIGcgfHwgMCwgMSk7XHJcbiAgICAgICAgdGhpcy5iID0gY2xhbXAoMCwgYiB8fCAwLCAxKTtcclxuICAgICAgICB0aGlzLmEgPSBjbGFtcCgwLCBhIHx8IDAsIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbG9yIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyB0byBiZSB2YWxpZDpcclxuICAgICAqIC0gI3JnYlxyXG4gICAgICogLSAjcnJnZ2JiXHJcbiAgICAgKiAtIHJnYihyLCBnLCBiKVxyXG4gICAgICogLSByZ2JhKHIsIGcsIGIsIGEpXHJcbiAgICAgKiAtIENTUyBjb2xvciBuYW1lIHN1Y2ggYXMgJ3doaXRlJywgJ29yYW5nZScsICdjeWFuJywgZXRjLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdmFsaWRDb2xvclN0cmluZyhzdHIpIHtcclxuICAgICAgICBpZiAoc3RyLmluZGV4T2YoJyMnKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIUNvbG9yLnBhcnNlSGV4KHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHIuaW5kZXhPZigncmdiJykgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISFDb2xvci5zdHJpbmdUb1JnYmEoc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICEhQ29sb3IubmFtZVRvSGV4W3N0ci50b0xvd2VyQ2FzZSgpXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdpdmVuIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcclxuICAgICAqIC0gI3JnYlxyXG4gICAgICogLSAjcnJnZ2JiXHJcbiAgICAgKiAtIHJnYihyLCBnLCBiKVxyXG4gICAgICogLSByZ2JhKHIsIGcsIGIsIGEpXHJcbiAgICAgKiAtIENTUyBjb2xvciBuYW1lIHN1Y2ggYXMgJ3doaXRlJywgJ29yYW5nZScsICdjeWFuJywgZXRjLlxyXG4gICAgICogQHBhcmFtIHN0clxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcclxuICAgICAgICAvLyBoZXhhZGVjaW1hbCBub3RhdGlvblxyXG4gICAgICAgIGlmIChzdHIuaW5kZXhPZignIycpID49IDApIHtcclxuICAgICAgICAgICAgLy8gdGhlcmUgY2FuIGJlIHNvbWUgbGVhZGluZyB3aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4U3RyaW5nKHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbG9yIG5hbWVcclxuICAgICAgICBjb25zdCBoZXggPSBDb2xvci5uYW1lVG9IZXhbc3RyLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgICAgIGlmIChoZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXhTdHJpbmcoaGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmdiKGEpIG5vdGF0aW9uXHJcbiAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2InKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xvci5mcm9tUmdiYVN0cmluZyhzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29sb3Igc3RyaW5nOiAnJHtzdHJ9J2ApO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRyeVBhcnNlRnJvbVN0cmluZyhzdHIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sb3IuZnJvbVN0cmluZyhzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoYGludmFsaWQgY29sb3Igc3RyaW5nOiAnJHtzdHJ9Jy5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21BcnJheShbMCwgMCwgMF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLyNoZXgtbm90YXRpb25cclxuICAgIHN0YXRpYyBwYXJzZUhleChpbnB1dCkge1xyXG4gICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvIC9nLCAnJykuc2xpY2UoMSk7XHJcbiAgICAgICAgbGV0IHBhcnRzO1xyXG4gICAgICAgIHN3aXRjaCAoaW5wdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgcGFydHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnNlSW50KGAke2lucHV0W2ldfSR7aW5wdXRbaSArIDFdfWAsIDE2KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCcnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHApID0+IHBhcnNlSW50KHAsIDE2KSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKChwKSA9PiBwICsgcCAqIDE2KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHBhcnRzID09PSBudWxsIHx8IHBhcnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0cy5sZW5ndGgpID49IDMgJiYgcGFydHMuZXZlcnkoKHApID0+IHAgPj0gMCkpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCgyNTUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJ0cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUhleFN0cmluZyhzdHIpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBDb2xvci5wYXJzZUhleChzdHIpO1xyXG4gICAgICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdmFsdWVzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUsIGEgLyAyNTUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBoZXhhZGVjaW1hbCBjb2xvciBzdHJpbmc6ICcke3N0cn0nYCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc3RyaW5nVG9SZ2JhKHN0cikge1xyXG4gICAgICAgIC8vIEZpbmQgcG9zaXRpb25zIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgcGFyZW50aGVzZXMuXHJcbiAgICAgICAgbGV0IFtwbywgcGNdID0gW05hTiwgTmFOXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjID0gc3RyW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXBvICYmIGMgPT09ICcoJykge1xyXG4gICAgICAgICAgICAgICAgcG8gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcpJykge1xyXG4gICAgICAgICAgICAgICAgcGMgPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBwbyAmJiBwYyAmJiBzdHIuc3Vic3RyaW5nKHBvICsgMSwgcGMpO1xyXG4gICAgICAgIGlmICghY29udGVudHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGNvbnRlbnRzLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgY29uc3QgcmdiYSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KHBhcnQpO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcnQuaW5kZXhPZignJScpID49IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHBlcmNlbnRhZ2UgciwgZywgb3IgYiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFscGhhIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFic29sdXRlIHIsIGcsIG9yIGIgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmdiYS5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJnYmE7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVJnYmFTdHJpbmcoc3RyKSB7XHJcbiAgICAgICAgY29uc3QgcmdiYSA9IENvbG9yLnN0cmluZ1RvUmdiYShzdHIpO1xyXG4gICAgICAgIGlmIChyZ2JhKSB7XHJcbiAgICAgICAgICAgIGlmIChyZ2JhLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZ2JhLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdLCByZ2JhWzNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCByZ2IvcmdiYSBjb2xvciBzdHJpbmc6ICcke3N0cn0nYCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycikge1xyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSwgYXJyWzNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihhcnJbMF0sIGFyclsxXSwgYXJyWzJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ2l2ZW4gYXJyYXkgc2hvdWxkIGNvbnRhaW4gMyBvciA0IGNvbG9yIGNvbXBvbmVudHMgKG51bWJlcnMpLicpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21IU0IoaCwgcywgYiwgYWxwaGEgPSAxKSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gQ29sb3IuSFNCdG9SR0IoaCwgcywgYik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUhTTChoLCBzLCBsLCBhbHBoYSA9IDEpIHtcclxuICAgICAgICBjb25zdCByZ2IgPSBDb2xvci5IU0x0b1JHQihoLCBzLCBsKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBwYWRIZXgoc3RyKSB7XHJcbiAgICAgICAgLy8gQ2FuJ3QgdXNlIGBwYWRTdGFydCgyLCAnMCcpYCBoZXJlIGJlY2F1c2Ugb2YgSUUuXHJcbiAgICAgICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDEgPyAnMCcgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcbiAgICB0b0hleFN0cmluZygpIHtcclxuICAgICAgICBsZXQgaGV4ID0gJyMnICtcclxuICAgICAgICAgICAgQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5yICogMjU1KS50b1N0cmluZygxNikpICtcclxuICAgICAgICAgICAgQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5nICogMjU1KS50b1N0cmluZygxNikpICtcclxuICAgICAgICAgICAgQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5iICogMjU1KS50b1N0cmluZygxNikpO1xyXG4gICAgICAgIGlmICh0aGlzLmEgPCAxKSB7XHJcbiAgICAgICAgICAgIGhleCArPSBDb2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLmEgKiAyNTUpLnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZXg7XHJcbiAgICB9XHJcbiAgICB0b1JnYmFTdHJpbmcoZnJhY3Rpb25EaWdpdHMgPSAzKSB7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IFtNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSksIE1hdGgucm91bmQodGhpcy5nICogMjU1KSwgTWF0aC5yb3VuZCh0aGlzLmIgKiAyNTUpXTtcclxuICAgICAgICBjb25zdCBrID0gTWF0aC5wb3coMTAsIGZyYWN0aW9uRGlnaXRzKTtcclxuICAgICAgICBpZiAodGhpcy5hICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChNYXRoLnJvdW5kKHRoaXMuYSAqIGspIC8gayk7XHJcbiAgICAgICAgICAgIHJldHVybiBgcmdiYSgke2NvbXBvbmVudHMuam9pbignLCAnKX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGByZ2IoJHtjb21wb25lbnRzLmpvaW4oJywgJyl9KWA7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBpZiAodGhpcy5hID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvUmdiYVN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgdG9IU0IoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLlJHQnRvSFNCKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFJHQnRvSFNMKHIsIGcsIGIpIHtcclxuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcclxuICAgICAgICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgICAgIGxldCBoO1xyXG4gICAgICAgIGxldCBzO1xyXG4gICAgICAgIGlmIChtYXggPT09IG1pbikge1xyXG4gICAgICAgICAgICAvLyBBY2hyb21hdGljXHJcbiAgICAgICAgICAgIGggPSBOYU47XHJcbiAgICAgICAgICAgIHMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBtYXggLSBtaW47XHJcbiAgICAgICAgICAgIHMgPSBsID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YSAvIChtYXggKyBtaW4pO1xyXG4gICAgICAgICAgICBpZiAobWF4ID09PSByKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1heCA9PT0gZykge1xyXG4gICAgICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkZWx0YSArIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoID0gKHIgLSBnKSAvIGRlbHRhICsgNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoICo9IDM2MCAvIDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbaCwgcywgbF07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgSFNMdG9SR0IoaCwgcywgbCkge1xyXG4gICAgICAgIGlmIChzID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIEFjaHJvbWF0aWNcclxuICAgICAgICAgICAgcmV0dXJuIFtsLCBsLCBsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XHJcbiAgICAgICAgY29uc3QgcCA9IDIgKiBsIC0gcTtcclxuICAgICAgICBmdW5jdGlvbiBodWVUb1JnYih0KSB7XHJcbiAgICAgICAgICAgIGlmICh0IDwgMClcclxuICAgICAgICAgICAgICAgIHQgKz0gMTtcclxuICAgICAgICAgICAgaWYgKHQgPiAxKVxyXG4gICAgICAgICAgICAgICAgdCAtPSAxO1xyXG4gICAgICAgICAgICBpZiAodCA8IDEgLyA2KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgICAgICAgIGlmICh0IDwgMSAvIDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgaWYgKHQgPCAyIC8gMylcclxuICAgICAgICAgICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHIgPSBodWVUb1JnYihoIC8gMzYwICsgMSAvIDMpO1xyXG4gICAgICAgIGNvbnN0IGcgPSBodWVUb1JnYihoIC8gMzYwKTtcclxuICAgICAgICBjb25zdCBiID0gaHVlVG9SZ2IoaCAvIDM2MCAtIDEgLyAzKTtcclxuICAgICAgICByZXR1cm4gW3IsIGcsIGJdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gUkdCIHRyaXBsZSB0byBhbiBhcnJheSBvZiBIU0IgKEhTVikgY29tcG9uZW50cy5cclxuICAgICAqIFRoZSBodWUgY29tcG9uZW50IHdpbGwgYmUgYE5hTmAgZm9yIGFjaHJvbWF0aWMgY29sb3JzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgUkdCdG9IU0IociwgZywgYikge1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xyXG4gICAgICAgIGNvbnN0IFMgPSBtYXggIT09IDAgPyAobWF4IC0gbWluKSAvIG1heCA6IDA7XHJcbiAgICAgICAgbGV0IEggPSBOYU47XHJcbiAgICAgICAgLy8gbWluID09IG1heCwgbWVhbnMgYWxsIGNvbXBvbmVudHMgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgLy8gYW5kIHRoZSBjb2xvciBpcyBhIHNoYWRlIG9mIGdyYXkgd2l0aCBubyBodWUgKEggaXMgTmFOKVxyXG4gICAgICAgIGlmIChtaW4gIT09IG1heCkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgY29uc3QgcmMgPSAobWF4IC0gcikgLyBkZWx0YTtcclxuICAgICAgICAgICAgY29uc3QgZ2MgPSAobWF4IC0gZykgLyBkZWx0YTtcclxuICAgICAgICAgICAgY29uc3QgYmMgPSAobWF4IC0gYikgLyBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHIgPT09IG1heCkge1xyXG4gICAgICAgICAgICAgICAgSCA9IGJjIC0gZ2M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZyA9PT0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBIID0gMi4wICsgcmMgLSBiYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIEggPSA0LjAgKyBnYyAtIHJjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEggLz0gNi4wO1xyXG4gICAgICAgICAgICBpZiAoSCA8IDApIHtcclxuICAgICAgICAgICAgICAgIEggPSBIICsgMS4wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbSCAqIDM2MCwgUywgbWF4XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIEhTQiAoSFNWKSB0cmlwbGUgdG8gYW4gYXJyYXkgb2YgUkdCIGNvbXBvbmVudHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBIU0J0b1JHQihILCBTLCBCKSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKEgpKSB7XHJcbiAgICAgICAgICAgIEggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBIID0gKCgoSCAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgLy8gbm9ybWFsaXplIGh1ZSB0byBbMCwgMzYwXSBpbnRlcnZhbCwgdGhlbiBzY2FsZSB0byBbMCwgMV1cclxuICAgICAgICBsZXQgciA9IDA7XHJcbiAgICAgICAgbGV0IGcgPSAwO1xyXG4gICAgICAgIGxldCBiID0gMDtcclxuICAgICAgICBpZiAoUyA9PT0gMCkge1xyXG4gICAgICAgICAgICByID0gZyA9IGIgPSBCO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaCA9IChIIC0gTWF0aC5mbG9vcihIKSkgKiA2O1xyXG4gICAgICAgICAgICBjb25zdCBmID0gaCAtIE1hdGguZmxvb3IoaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBCICogKDEgLSBTKTtcclxuICAgICAgICAgICAgY29uc3QgcSA9IEIgKiAoMSAtIFMgKiBmKTtcclxuICAgICAgICAgICAgY29uc3QgdCA9IEIgKiAoMSAtIFMgKiAoMSAtIGYpKTtcclxuICAgICAgICAgICAgc3dpdGNoIChoID4+IDAgLy8gZGlzY2FyZCB0aGUgZmxvYXRpbmcgcG9pbnQgcGFydCBvZiB0aGUgbnVtYmVyXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBxO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBxO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBCO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbciwgZywgYl07XHJcbiAgICB9XHJcbiAgICBkZXJpdmUoaHVlU2hpZnQsIHNhdHVyYXRpb25GYWN0b3IsIGJyaWdodG5lc3NGYWN0b3IsIG9wYWNpdHlGYWN0b3IpIHtcclxuICAgICAgICBjb25zdCBoc2IgPSBDb2xvci5SR0J0b0hTQih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcclxuICAgICAgICBsZXQgYiA9IGhzYlsyXTtcclxuICAgICAgICBpZiAoYiA9PSAwICYmIGJyaWdodG5lc3NGYWN0b3IgPiAxLjApIHtcclxuICAgICAgICAgICAgYiA9IDAuMDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGggPSAoKChoc2JbMF0gKyBodWVTaGlmdCkgJSAzNjApICsgMzYwKSAlIDM2MDtcclxuICAgICAgICBjb25zdCBzID0gTWF0aC5tYXgoTWF0aC5taW4oaHNiWzFdICogc2F0dXJhdGlvbkZhY3RvciwgMS4wKSwgMC4wKTtcclxuICAgICAgICBiID0gTWF0aC5tYXgoTWF0aC5taW4oYiAqIGJyaWdodG5lc3NGYWN0b3IsIDEuMCksIDAuMCk7XHJcbiAgICAgICAgY29uc3QgYSA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuYSAqIG9wYWNpdHlGYWN0b3IsIDEuMCksIDAuMCk7XHJcbiAgICAgICAgY29uc3QgcmdiYSA9IENvbG9yLkhTQnRvUkdCKGgsIHMsIGIpO1xyXG4gICAgICAgIHJnYmEucHVzaChhKTtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUFycmF5KHJnYmEpO1xyXG4gICAgfVxyXG4gICAgYnJpZ2h0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKDAsIDEuMCwgMS4wIC8gMC43LCAxLjApO1xyXG4gICAgfVxyXG4gICAgZGFya2VyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlcml2ZSgwLCAxLjAsIDAuNywgMS4wKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpbnRlcnBvbGF0ZShjb2xvciwgb3RoZXIpIHtcclxuICAgICAgICBjb25zdCBjMCA9IENvbG9yLnRyeVBhcnNlRnJvbVN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgY29uc3QgYzEgPSBDb2xvci50cnlQYXJzZUZyb21TdHJpbmcob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiAodCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gKHgsIHkpID0+IHggKiAoMSAtIHQpICsgeSAqIHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBuZXcgQ29sb3IoaShjMC5yLCBjMS5yKSwgaShjMC5nLCBjMS5nKSwgaShjMC5iLCBjMS5iKSwgaShjMC5hLCBjMS5hKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCA0OlxyXG4gKiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLyNuYW1lZC1jb2xvcnNcclxuICovXHJcbkNvbG9yLm5hbWVUb0hleCA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgYWxpY2VibHVlOiAnI0YwRjhGRicsXHJcbiAgICBhbnRpcXVld2hpdGU6ICcjRkFFQkQ3JyxcclxuICAgIGFxdWE6ICcjMDBGRkZGJyxcclxuICAgIGFxdWFtYXJpbmU6ICcjN0ZGRkQ0JyxcclxuICAgIGF6dXJlOiAnI0YwRkZGRicsXHJcbiAgICBiZWlnZTogJyNGNUY1REMnLFxyXG4gICAgYmlzcXVlOiAnI0ZGRTRDNCcsXHJcbiAgICBibGFjazogJyMwMDAwMDAnLFxyXG4gICAgYmxhbmNoZWRhbG1vbmQ6ICcjRkZFQkNEJyxcclxuICAgIGJsdWU6ICcjMDAwMEZGJyxcclxuICAgIGJsdWV2aW9sZXQ6ICcjOEEyQkUyJyxcclxuICAgIGJyb3duOiAnI0E1MkEyQScsXHJcbiAgICBidXJseXdvb2Q6ICcjREVCODg3JyxcclxuICAgIGNhZGV0Ymx1ZTogJyM1RjlFQTAnLFxyXG4gICAgY2hhcnRyZXVzZTogJyM3RkZGMDAnLFxyXG4gICAgY2hvY29sYXRlOiAnI0QyNjkxRScsXHJcbiAgICBjb3JhbDogJyNGRjdGNTAnLFxyXG4gICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NUVEJyxcclxuICAgIGNvcm5zaWxrOiAnI0ZGRjhEQycsXHJcbiAgICBjcmltc29uOiAnI0RDMTQzQycsXHJcbiAgICBjeWFuOiAnIzAwRkZGRicsXHJcbiAgICBkYXJrYmx1ZTogJyMwMDAwOEInLFxyXG4gICAgZGFya2N5YW46ICcjMDA4QjhCJyxcclxuICAgIGRhcmtnb2xkZW5yb2Q6ICcjQjg4NjBCJyxcclxuICAgIGRhcmtncmF5OiAnI0E5QTlBOScsXHJcbiAgICBkYXJrZ3JlZW46ICcjMDA2NDAwJyxcclxuICAgIGRhcmtncmV5OiAnI0E5QTlBOScsXHJcbiAgICBkYXJra2hha2k6ICcjQkRCNzZCJyxcclxuICAgIGRhcmttYWdlbnRhOiAnIzhCMDA4QicsXHJcbiAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZCMkYnLFxyXG4gICAgZGFya29yYW5nZTogJyNGRjhDMDAnLFxyXG4gICAgZGFya29yY2hpZDogJyM5OTMyQ0MnLFxyXG4gICAgZGFya3JlZDogJyM4QjAwMDAnLFxyXG4gICAgZGFya3NhbG1vbjogJyNFOTk2N0EnLFxyXG4gICAgZGFya3NlYWdyZWVuOiAnIzhGQkM4RicsXHJcbiAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M0Q4QicsXHJcbiAgICBkYXJrc2xhdGVncmF5OiAnIzJGNEY0RicsXHJcbiAgICBkYXJrc2xhdGVncmV5OiAnIzJGNEY0RicsXHJcbiAgICBkYXJrdHVycXVvaXNlOiAnIzAwQ0VEMScsXHJcbiAgICBkYXJrdmlvbGV0OiAnIzk0MDBEMycsXHJcbiAgICBkZWVwcGluazogJyNGRjE0OTMnLFxyXG4gICAgZGVlcHNreWJsdWU6ICcjMDBCRkZGJyxcclxuICAgIGRpbWdyYXk6ICcjNjk2OTY5JyxcclxuICAgIGRpbWdyZXk6ICcjNjk2OTY5JyxcclxuICAgIGRvZGdlcmJsdWU6ICcjMUU5MEZGJyxcclxuICAgIGZpcmVicmljazogJyNCMjIyMjInLFxyXG4gICAgZmxvcmFsd2hpdGU6ICcjRkZGQUYwJyxcclxuICAgIGZvcmVzdGdyZWVuOiAnIzIyOEIyMicsXHJcbiAgICBmdWNoc2lhOiAnI0ZGMDBGRicsXHJcbiAgICBnYWluc2Jvcm86ICcjRENEQ0RDJyxcclxuICAgIGdob3N0d2hpdGU6ICcjRjhGOEZGJyxcclxuICAgIGdvbGQ6ICcjRkZENzAwJyxcclxuICAgIGdvbGRlbnJvZDogJyNEQUE1MjAnLFxyXG4gICAgZ3JheTogJyM4MDgwODAnLFxyXG4gICAgZ3JlZW46ICcjMDA4MDAwJyxcclxuICAgIGdyZWVueWVsbG93OiAnI0FERkYyRicsXHJcbiAgICBncmV5OiAnIzgwODA4MCcsXHJcbiAgICBob25leWRldzogJyNGMEZGRjAnLFxyXG4gICAgaG90cGluazogJyNGRjY5QjQnLFxyXG4gICAgaW5kaWFucmVkOiAnI0NENUM1QycsXHJcbiAgICBpbmRpZ286ICcjNEIwMDgyJyxcclxuICAgIGl2b3J5OiAnI0ZGRkZGMCcsXHJcbiAgICBraGFraTogJyNGMEU2OEMnLFxyXG4gICAgbGF2ZW5kZXI6ICcjRTZFNkZBJyxcclxuICAgIGxhdmVuZGVyYmx1c2g6ICcjRkZGMEY1JyxcclxuICAgIGxhd25ncmVlbjogJyM3Q0ZDMDAnLFxyXG4gICAgbGVtb25jaGlmZm9uOiAnI0ZGRkFDRCcsXHJcbiAgICBsaWdodGJsdWU6ICcjQUREOEU2JyxcclxuICAgIGxpZ2h0Y29yYWw6ICcjRjA4MDgwJyxcclxuICAgIGxpZ2h0Y3lhbjogJyNFMEZGRkYnLFxyXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxcclxuICAgIGxpZ2h0Z3JheTogJyNEM0QzRDMnLFxyXG4gICAgbGlnaHRncmVlbjogJyM5MEVFOTAnLFxyXG4gICAgbGlnaHRncmV5OiAnI0QzRDNEMycsXHJcbiAgICBsaWdodHBpbms6ICcjRkZCNkMxJyxcclxuICAgIGxpZ2h0c2FsbW9uOiAnI0ZGQTA3QScsXHJcbiAgICBsaWdodHNlYWdyZWVuOiAnIzIwQjJBQScsXHJcbiAgICBsaWdodHNreWJsdWU6ICcjODdDRUZBJyxcclxuICAgIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsXHJcbiAgICBsaWdodHNsYXRlZ3JleTogJyM3Nzg4OTknLFxyXG4gICAgbGlnaHRzdGVlbGJsdWU6ICcjQjBDNERFJyxcclxuICAgIGxpZ2h0eWVsbG93OiAnI0ZGRkZFMCcsXHJcbiAgICBsaW1lOiAnIzAwRkYwMCcsXHJcbiAgICBsaW1lZ3JlZW46ICcjMzJDRDMyJyxcclxuICAgIGxpbmVuOiAnI0ZBRjBFNicsXHJcbiAgICBtYWdlbnRhOiAnI0ZGMDBGRicsXHJcbiAgICBtYXJvb246ICcjODAwMDAwJyxcclxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZDREFBJyxcclxuICAgIG1lZGl1bWJsdWU6ICcjMDAwMENEJyxcclxuICAgIG1lZGl1bW9yY2hpZDogJyNCQTU1RDMnLFxyXG4gICAgbWVkaXVtcHVycGxlOiAnIzkzNzBEQicsXHJcbiAgICBtZWRpdW1zZWFncmVlbjogJyMzQ0IzNzEnLFxyXG4gICAgbWVkaXVtc2xhdGVibHVlOiAnIzdCNjhFRScsXHJcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMEZBOUEnLFxyXG4gICAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4RDFDQycsXHJcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICcjQzcxNTg1JyxcclxuICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLFxyXG4gICAgbWludGNyZWFtOiAnI0Y1RkZGQScsXHJcbiAgICBtaXN0eXJvc2U6ICcjRkZFNEUxJyxcclxuICAgIG1vY2Nhc2luOiAnI0ZGRTRCNScsXHJcbiAgICBuYXZham93aGl0ZTogJyNGRkRFQUQnLFxyXG4gICAgbmF2eTogJyMwMDAwODAnLFxyXG4gICAgb2xkbGFjZTogJyNGREY1RTYnLFxyXG4gICAgb2xpdmU6ICcjODA4MDAwJyxcclxuICAgIG9saXZlZHJhYjogJyM2QjhFMjMnLFxyXG4gICAgb3JhbmdlOiAnI0ZGQTUwMCcsXHJcbiAgICBvcmFuZ2VyZWQ6ICcjRkY0NTAwJyxcclxuICAgIG9yY2hpZDogJyNEQTcwRDYnLFxyXG4gICAgcGFsZWdvbGRlbnJvZDogJyNFRUU4QUEnLFxyXG4gICAgcGFsZWdyZWVuOiAnIzk4RkI5OCcsXHJcbiAgICBwYWxldHVycXVvaXNlOiAnI0FGRUVFRScsXHJcbiAgICBwYWxldmlvbGV0cmVkOiAnI0RCNzA5MycsXHJcbiAgICBwYXBheWF3aGlwOiAnI0ZGRUZENScsXHJcbiAgICBwZWFjaHB1ZmY6ICcjRkZEQUI5JyxcclxuICAgIHBlcnU6ICcjQ0Q4NTNGJyxcclxuICAgIHBpbms6ICcjRkZDMENCJyxcclxuICAgIHBsdW06ICcjRERBMEREJyxcclxuICAgIHBvd2RlcmJsdWU6ICcjQjBFMEU2JyxcclxuICAgIHB1cnBsZTogJyM4MDAwODAnLFxyXG4gICAgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLFxyXG4gICAgcmVkOiAnI0ZGMDAwMCcsXHJcbiAgICByb3N5YnJvd246ICcjQkM4RjhGJyxcclxuICAgIHJveWFsYmx1ZTogJyM0MTY5RTEnLFxyXG4gICAgc2FkZGxlYnJvd246ICcjOEI0NTEzJyxcclxuICAgIHNhbG1vbjogJyNGQTgwNzInLFxyXG4gICAgc2FuZHlicm93bjogJyNGNEE0NjAnLFxyXG4gICAgc2VhZ3JlZW46ICcjMkU4QjU3JyxcclxuICAgIHNlYXNoZWxsOiAnI0ZGRjVFRScsXHJcbiAgICBzaWVubmE6ICcjQTA1MjJEJyxcclxuICAgIHNpbHZlcjogJyNDMEMwQzAnLFxyXG4gICAgc2t5Ymx1ZTogJyM4N0NFRUInLFxyXG4gICAgc2xhdGVibHVlOiAnIzZBNUFDRCcsXHJcbiAgICBzbGF0ZWdyYXk6ICcjNzA4MDkwJyxcclxuICAgIHNsYXRlZ3JleTogJyM3MDgwOTAnLFxyXG4gICAgc25vdzogJyNGRkZBRkEnLFxyXG4gICAgc3ByaW5nZ3JlZW46ICcjMDBGRjdGJyxcclxuICAgIHN0ZWVsYmx1ZTogJyM0NjgyQjQnLFxyXG4gICAgdGFuOiAnI0QyQjQ4QycsXHJcbiAgICB0ZWFsOiAnIzAwODA4MCcsXHJcbiAgICB0aGlzdGxlOiAnI0Q4QkZEOCcsXHJcbiAgICB0b21hdG86ICcjRkY2MzQ3JyxcclxuICAgIHRyYW5zcGFyZW50OiAnIzAwMDAwMDAwJyxcclxuICAgIHR1cnF1b2lzZTogJyM0MEUwRDAnLFxyXG4gICAgdmlvbGV0OiAnI0VFODJFRScsXHJcbiAgICB3aGVhdDogJyNGNURFQjMnLFxyXG4gICAgd2hpdGU6ICcjRkZGRkZGJyxcclxuICAgIHdoaXRlc21va2U6ICcjRjVGNUY1JyxcclxuICAgIHllbGxvdzogJyNGRkZGMDAnLFxyXG4gICAgeWVsbG93Z3JlZW46ICcjOUFDRDMyJyxcclxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIHNvbmFyanMvbm8tZHVwbGljYXRlLXN0cmluZyAqL1xyXG5mdW5jdGlvbiBWYWxpZGF0ZShwcmVkaWNhdGUpIHtcclxuICAgIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwgcHJvcCwgdikgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUodiwgeyB0YXJnZXQgfSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNsZWFuS2V5ID0gcHJvcC50b1N0cmluZygpLnJlcGxhY2UoL15fKi8sICcnKTtcclxuICAgICAgICBsZXQgdGFyZ2V0Q2xhc3MgPSAoX2IgPSAoX2EgPSB0YXJnZXQuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc05hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHRhcmdldC5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm5hbWU7XHJcbiAgICAgICAgaWYgKCh0YXJnZXRDbGFzcyA9PT0gbnVsbCB8fCB0YXJnZXRDbGFzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0Q2xhc3MubGVuZ3RoKSA8IDMpIHtcclxuICAgICAgICAgICAgdGFyZ2V0Q2xhc3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRDbGFzc05hbWUgPSB0YXJnZXRDbGFzcyA/IGBvZiBbJHt0YXJnZXRDbGFzc31dIGAgOiAnJztcclxuICAgICAgICBpZiAocHJlZGljYXRlLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLndhcm4oYFByb3BlcnR5IFske2NsZWFuS2V5fV0gJHt0YXJnZXRDbGFzc05hbWV9Y2Fubm90IGJlIHNldCB0byBbJHtzdHJpbmdpZnkodil9XTsgJHtwcmVkaWNhdGUubWVzc2FnZX0sIGlnbm9yaW5nLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgTG9nZ2VyLndhcm4oYFByb3BlcnR5IFske2NsZWFuS2V5fV0gJHt0YXJnZXRDbGFzc05hbWV9Y2Fubm90IGJlIHNldCB0byBbJHtzdHJpbmdpZnkodil9XSwgaWdub3JpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBCUkVBS19UUkFOU0ZPUk1fQ0hBSU47XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gJ05hTic7XHJcbiAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KVxyXG4gICAgICAgIHJldHVybiAnSW5maW5pdHknO1xyXG4gICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpXHJcbiAgICAgICAgcmV0dXJuICctSW5maW5pdHknO1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBwcmVkaWNhdGVXaXRoTWVzc2FnZShwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcclxuICAgIHByZWRpY2F0ZS5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgIHJldHVybiBwcmVkaWNhdGU7XHJcbn1cclxuY29uc3QgT1BUSU9OQUwgPSAodiwgY3R4LCBwcmVkaWNhdGUpID0+IHYgPT09IHVuZGVmaW5lZCB8fCBwcmVkaWNhdGUodiwgY3R4KTtcclxuY29uc3QgQVJSQVkgPSAobGVuZ3RoLCBwcmVkaWNhdGUpID0+IHtcclxuICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBBcnJheS5pc0FycmF5KHYpICYmXHJcbiAgICAgICAgKGxlbmd0aCA/IHYubGVuZ3RoID09PSBsZW5ndGggOiB0cnVlKSAmJlxyXG4gICAgICAgIChwcmVkaWNhdGUgPyB2LmV2ZXJ5KChlKSA9PiBwcmVkaWNhdGUoZSwgY3R4KSkgOiB0cnVlKSwgYGV4cGVjdGluZyBhbiBBcnJheWApO1xyXG59O1xyXG5jb25zdCBPUFRfQVJSQVkgPSAobGVuZ3RoKSA9PiB7XHJcbiAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCBBUlJBWShsZW5ndGgpKSwgJ2V4cGVjdGluZyBhbiBvcHRpb25hbCBBcnJheScpO1xyXG59O1xyXG5jb25zdCBOT05fRU1QVFlfQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA+IDAsIGBleHBlY3RpbmcgYSBub24tZW1wdHkgQXJyYXlgKTtcclxuY29uc3QgT1BUX05PTl9FTVBUWV9BUlJBWSA9ICgpID0+IHtcclxuICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsIE5PTl9FTVBUWV9BUlJBWSksICdleHBlY3RpbmcgYW4gb3B0aW9uYWwgbm9uLWVtcHR5IEFycmF5Jyk7XHJcbn07XHJcbmNvbnN0IEFORCA9ICguLi5wcmVkaWNhdGVzKSA9PiB7XHJcbiAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gcHJlZGljYXRlcy5ldmVyeSgocCkgPT4gcCh2LCBjdHgpKSwgcHJlZGljYXRlc1xyXG4gICAgICAgIC5tYXAoKHApID0+IHAubWVzc2FnZSlcclxuICAgICAgICAuZmlsdGVyKChtKSA9PiBtICE9IG51bGwpXHJcbiAgICAgICAgLmpvaW4oJyBBTkQgJykpO1xyXG59O1xyXG5jb25zdCBPUiA9ICguLi5wcmVkaWNhdGVzKSA9PiB7XHJcbiAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gcHJlZGljYXRlcy5zb21lKChwKSA9PiBwKHYsIGN0eCkpLCBwcmVkaWNhdGVzXHJcbiAgICAgICAgLm1hcCgocCkgPT4gcC5tZXNzYWdlKVxyXG4gICAgICAgIC5maWx0ZXIoKG0pID0+IG0gIT0gbnVsbClcclxuICAgICAgICAuam9pbignIE9SICcpKTtcclxufTtcclxuY29uc3QgaXNDb21wYXJhYmxlID0gKHYpID0+IHtcclxuICAgIHJldHVybiB2ICE9IG51bGwgJiYgIWlzTmFOKHYpO1xyXG59O1xyXG5jb25zdCBMRVNTX1RIQU4gPSAob3RoZXJGaWVsZCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gIWlzQ29tcGFyYWJsZSh2KSB8fCAhaXNDb21wYXJhYmxlKGN0eC50YXJnZXRbb3RoZXJGaWVsZF0pIHx8IHYgPCBjdHgudGFyZ2V0W290aGVyRmllbGRdLCBgZXhwZWN0ZWQgdG8gYmUgbGVzcyB0aGFuICR7b3RoZXJGaWVsZH1gKTtcclxuY29uc3QgR1JFQVRFUl9USEFOID0gKG90aGVyRmllbGQpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+ICFpc0NvbXBhcmFibGUodikgfHwgIWlzQ29tcGFyYWJsZShjdHgudGFyZ2V0W290aGVyRmllbGRdKSB8fCB2ID4gY3R4LnRhcmdldFtvdGhlckZpZWxkXSwgYGV4cGVjdGVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAke290aGVyRmllbGR9YCk7XHJcbmNvbnN0IEZVTkNUSU9OID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYpID0+IHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nLCAnZXhwZWN0aW5nIGEgRnVuY3Rpb24nKTtcclxuY29uc3QgT1BUX0ZVTkNUSU9OID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCBGVU5DVElPTiksIGBleHBlY3RpbmcgYW4gb3B0aW9uYWwgRnVuY3Rpb25gKTtcclxuY29uc3QgQk9PTEVBTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiB2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlLCAnZXhwZWN0aW5nIGEgQm9vbGVhbicpO1xyXG5jb25zdCBPUFRfQk9PTEVBTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+IE9QVElPTkFMKHYsIGN0eCwgQk9PTEVBTiksICdleHBlY3RpbmcgYW4gb3B0aW9uYWwgQm9vbGVhbicpO1xyXG5jb25zdCBTVFJJTkcgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnLCAnZXhwZWN0aW5nIGEgU3RyaW5nJyk7XHJcbmNvbnN0IE9QVF9TVFJJTkcgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsIFNUUklORyksICdleHBlY3RpbmcgYW4gb3B0aW9uYWwgU3RyaW5nJyk7XHJcbmNvbnN0IERBVEUgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gdiBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKCt2KSwgJ2V4cGVjdGluZyBhIERhdGUgb2JqZWN0Jyk7XHJcbmNvbnN0IE9QVF9EQVRFID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCBEQVRFKSwgJ2V4cGVjdGluZyBhbiBvcHRpb25hbCBEYXRlJyk7XHJcbmNvbnN0IERBVEVfQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShBUlJBWSh1bmRlZmluZWQsIERBVEUpLCAnZXhwZWN0aW5nIGFuIEFycmF5IG9mIERhdGUgb2JqZWN0cycpO1xyXG5jb25zdCBEQVRFVElNRV9NUyA9IE5VTUJFUiQxKDApO1xyXG5jb25zdCBPUFRfREFURVRJTUVfTVMgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsIERBVEVUSU1FX01TKSwgJ2V4cGVjdGluZyBhbiBvcHRpb25hbCBudW1iZXInKTtcclxuY29uc3QgT1BUX0RBVEVfT1JfREFURVRJTUVfTVMgPSBPUihPUFRfREFURSwgT1BUX0RBVEVUSU1FX01TKTtcclxuY29uc3QgY29sb3JNZXNzYWdlID0gYEEgY29sb3Igc3RyaW5nIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzIHRvIGJlIHZhbGlkOiAjcmdiLCAjcnJnZ2JiLCByZ2IociwgZywgYiksIHJnYmEociwgZywgYiwgYSkgb3IgYSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Y2A7XHJcbmNvbnN0IENPTE9SX1NUUklORyA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENvbG9yLnZhbGlkQ29sb3JTdHJpbmcodik7XHJcbn0sIGBleHBlY3RpbmcgYSBjb2xvciBTdHJpbmcuICR7Y29sb3JNZXNzYWdlfWApO1xyXG5jb25zdCBPUFRfQ09MT1JfU1RSSU5HID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCBDT0xPUl9TVFJJTkcpLCBgZXhwZWN0aW5nIGFuIG9wdGlvbmFsIGNvbG9yIFN0cmluZy4gJHtjb2xvck1lc3NhZ2V9YCk7XHJcbmNvbnN0IENPTE9SX1NUUklOR19BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZKHVuZGVmaW5lZCwgQ09MT1JfU1RSSU5HKSwgYGV4cGVjdGluZyBhbiBBcnJheSBvZiBjb2xvciBzdHJpbmdzLiAke2NvbG9yTWVzc2FnZX1gKTtcclxuY29uc3QgT1BUX0NPTE9SX1NUUklOR19BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+IE9QVElPTkFMKHYsIGN0eCwgQ09MT1JfU1RSSU5HX0FSUkFZKSwgYGV4cGVjdGluZyBhbiBvcHRpb25hbCBBcnJheSBvZiBjb2xvciBzdHJpbmdzLiAke2NvbG9yTWVzc2FnZX1gKTtcclxuZnVuY3Rpb24gbnVtYmVyTWVzc2FnZShwcmVmaXggPSBgZXhwZWN0aW5nIGEgZmluaXRlIE51bWJlcmAsIG1pbiwgbWF4KSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IHByZWZpeDtcclxuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBtYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gYCBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9IGluY2x1c2l2ZWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gYCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59YDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbn1cclxuZnVuY3Rpb24gTlVNQkVSJDEobWluLCBtYXgpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBudW1iZXJNZXNzYWdlKHVuZGVmaW5lZCwgbWluLCBtYXgpO1xyXG4gICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUodikgJiZcclxuICAgICAgICAobWluICE9PSB1bmRlZmluZWQgPyB2ID49IG1pbiA6IHRydWUpICYmXHJcbiAgICAgICAgKG1heCAhPT0gdW5kZWZpbmVkID8gdiA8PSBtYXggOiB0cnVlKSwgbWVzc2FnZSk7XHJcbn1cclxuZnVuY3Rpb24gT1BUX05VTUJFUihtaW4sIG1heCkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IG51bWJlck1lc3NhZ2UoJ2V4cGVjdGluZyBhbiBvcHRpb25hbCBmaW5pdGUgTnVtYmVyJywgbWluLCBtYXgpO1xyXG4gICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+IE9QVElPTkFMKHYsIGN0eCwgTlVNQkVSJDEobWluLCBtYXgpKSwgbWVzc2FnZSk7XHJcbn1cclxuZnVuY3Rpb24gTlVNQkVSX09SX05BTihtaW4sIG1heCkge1xyXG4gICAgLy8gQ2FuIGJlIE5hTiBvciBmaW5pdGUgbnVtYmVyXHJcbiAgICBjb25zdCBtZXNzYWdlID0gbnVtYmVyTWVzc2FnZSh1bmRlZmluZWQsIG1pbiwgbWF4KTtcclxuICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgKGlzTmFOKHYpIHx8XHJcbiAgICAgICAgICAgIChOdW1iZXIuaXNGaW5pdGUodikgJiYgKG1pbiAhPT0gdW5kZWZpbmVkID8gdiA+PSBtaW4gOiB0cnVlKSAmJiAobWF4ICE9PSB1bmRlZmluZWQgPyB2IDw9IG1heCA6IHRydWUpKSksIG1lc3NhZ2UpO1xyXG59XHJcbmNvbnN0IE5VTUJFUl9BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZKHVuZGVmaW5lZCwgTlVNQkVSJDEoKSksICdleHBlY3RpbmcgYW4gQXJyYXkgb2YgbnVtYmVycycpO1xyXG5jb25zdCBPUFRfTlVNQkVSX0FSUkFZID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCBOVU1CRVJfQVJSQVkpLCAnZXhwZWN0aW5nIGFuIG9wdGlvbmFsIEFycmF5IG9mIG51bWJlcnMnKTtcclxuY29uc3QgU1RSSU5HX0FSUkFZID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoQVJSQVkodW5kZWZpbmVkLCBTVFJJTkcpLCAnZXhwZWN0aW5nIGFuIEFycmF5IG9mIHN0cmluZ3MnKTtcclxuY29uc3QgT1BUX1NUUklOR19BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+IE9QVElPTkFMKHYsIGN0eCwgU1RSSU5HX0FSUkFZKSwgJ2V4cGVjdGluZyBhbiBvcHRpb25hbCBBcnJheSBvZiBzdHJpbmdzJyk7XHJcbmZ1bmN0aW9uIFNUUklOR19VTklPTiguLi52YWx1ZXMpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgZXhwZWN0aW5nIG9uZSBvZjogJHt2YWx1ZXMuam9pbignLCAnKX1gO1xyXG4gICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgdmFsdWVzLmluZGV4T2YodikgPj0gMCwgbWVzc2FnZSk7XHJcbn1cclxuY29uc3QgQk9PTEVBTl9BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZKHVuZGVmaW5lZCwgQk9PTEVBTiksICdleHBlY3RpbmcgYW4gQXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMnKTtcclxuY29uc3QgT1BUX0JPT0xFQU5fQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsIEJPT0xFQU5fQVJSQVkpLCAnZXhwZWN0aW5nIGFuIG9wdGlvbmFsIEFycmF5IG9mIGJvb2xlYW4gdmFsdWVzJyk7XHJcbmNvbnN0IEZPTlRfV0VJR0hUUyA9IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInXTtcclxuY29uc3QgRk9OVF9TVFlMRSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiB2ID09PSAnbm9ybWFsJyB8fCB2ID09PSAnaXRhbGljJyB8fCB2ID09PSAnb2JsaXF1ZScsIGBleHBlY3RpbmcgYSBmb250IHN0eWxlIGtleXdvcmQgc3VjaCBhcyAnbm9ybWFsJywgJ2l0YWxpYycgb3IgJ29ibGlxdWUnYCk7XHJcbmNvbnN0IE9QVF9GT05UX1NUWUxFID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCBGT05UX1NUWUxFKSwgYGV4cGVjdGluZyBhbiBvcHRpb25hbCBmb250IHN0eWxlIGtleXdvcmQgc3VjaCBhcyAnbm9ybWFsJywgJ2l0YWxpYycgb3IgJ29ibGlxdWUnYCk7XHJcbmNvbnN0IEZPTlRfV0VJR0hUID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYpID0+IEZPTlRfV0VJR0hUUy5pbmNsdWRlcyh2KSB8fCAodHlwZW9mIHYgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHYpKSwgYGV4cGVjdGluZyBhIGZvbnQgd2VpZ2h0IGtleXdvcmQgc3VjaCBhcyAnbm9ybWFsJywgJ2JvbGQnIG9yICdib2xkZXInIG9yIGEgbnVtZXJpYyB2YWx1ZSBzdWNoIGFzIDEwMCwgMzAwIG9yIDYwMGApO1xyXG5jb25zdCBPUFRfRk9OVF9XRUlHSFQgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsIEZPTlRfV0VJR0hUKSwgYGV4cGVjdGluZyBhbiBvcHRpb25hbCBmb250IHdlaWdodCBrZXl3b3JkIHN1Y2ggYXMgJ25vcm1hbCcsICdib2xkJyBvciAnYm9sZGVyJyBvciBhIG51bWVyaWMgdmFsdWUgc3VjaCBhcyAxMDAsIDMwMCBvciA2MDBgKTtcclxuY29uc3QgTElORV9EQVNIID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoQVJSQVkodW5kZWZpbmVkLCBOVU1CRVIkMSgwKSksICdleHBlY3RpbmcgYW4gQXJyYXkgb2YgbnVtYmVycyBzcGVjaWZ5aW5nIHRoZSBsZW5ndGggaW4gcGl4ZWxzIG9mIGFsdGVybmF0aW5nIGRhc2hlcyBhbmQgZ2FwcywgZm9yIGV4YW1wbGUsIFs2LCAzXSBtZWFucyBkYXNoZXMgd2l0aCBhIGxlbmd0aCBvZiA2IHBpeGVscyB3aXRoIGdhcHMgYmV0d2VlbiBvZiAzIHBpeGVscy4nKTtcclxuY29uc3QgT1BUX0xJTkVfREFTSCA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+IE9QVElPTkFMKHYsIGN0eCwgTElORV9EQVNIKSwgJ2V4cGVjdGluZyBhbiBvcHRpb25hbCBBcnJheSBvZiBudW1iZXJzIHNwZWNpZnlpbmcgdGhlIGxlbmd0aCBpbiBwaXhlbHMgb2YgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzLCBmb3IgZXhhbXBsZSwgWzYsIDNdIG1lYW5zIGRhc2hlcyB3aXRoIGEgbGVuZ3RoIG9mIDYgcGl4ZWxzIHdpdGggZ2FwcyBiZXR3ZWVuIG9mIDMgcGl4ZWxzLicpO1xyXG5jb25zdCBMSU5FX0NBUFMgPSBbJ2J1dHQnLCAncm91bmQnLCAnc3F1YXJlJ107XHJcbmNvbnN0IExJTkVfQ0FQID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYpID0+IExJTkVfQ0FQUy5pbmNsdWRlcyh2KSwgYGV4cGVjdGluZyBhIGxpbmUgY2FwIGtleXdvcmQgc3VjaCBhcyAnYnV0dCcsICdyb3VuZCcgb3IgJ3NxdWFyZSdgKTtcclxuY29uc3QgT1BUX0xJTkVfQ0FQID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCBMSU5FX0NBUCksIGBleHBlY3RpbmcgYW4gb3B0aW9uYWwgbGluZSBjYXAga2V5d29yZCBzdWNoIGFzICdidXR0JywgJ3JvdW5kJyBvciAnc3F1YXJlJ2ApO1xyXG5jb25zdCBMSU5FX0pPSU5TID0gWydyb3VuZCcsICdiZXZlbCcsICdtaXRlciddO1xyXG5jb25zdCBMSU5FX0pPSU4gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gTElORV9KT0lOUy5pbmNsdWRlcyh2KSwgYGV4cGVjdGluZyBhIGxpbmUgam9pbiBrZXl3b3JkIHN1Y2ggYXMgJ3JvdW5kJywgJ2JldmVsJyBvciAnbWl0ZXInYCk7XHJcbmNvbnN0IE9QVF9MSU5FX0pPSU4gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsIExJTkVfSk9JTiksIGBleHBlY3RpbmcgYW4gb3B0aW9uYWwgbGluZSBqb2luIGtleXdvcmQgc3VjaCBhcyAncm91bmQnLCAnYmV2ZWwnIG9yICdtaXRlcidgKTtcclxuY29uc3QgUE9TSVRJT05TID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuY29uc3QgUE9TSVRJT04gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gUE9TSVRJT05TLmluY2x1ZGVzKHYpLCBgZXhwZWN0aW5nIGEgcG9zaXRpb24ga2V5d29yZCBzdWNoIGFzICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJyBvciAnbGVmdGApO1xyXG5jb25zdCBJTlRFUkFDVElPTl9SQU5HRVMgPSBbJ2V4YWN0JywgJ25lYXJlc3QnXTtcclxuY29uc3QgSU5URVJBQ1RJT05fUkFOR0UgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gKHR5cGVvZiB2ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUodikpIHx8IElOVEVSQUNUSU9OX1JBTkdFUy5pbmNsdWRlcyh2KSwgYGV4cGVjdGluZyBhbiBpbnRlcmFjdGlvbiByYW5nZSBvZiAnZXhhY3QnLCAnbmVhcmVzdCcgb3IgYSBudW1iZXJgKTtcclxuY29uc3QgVEVYVF9XUkFQUyA9IFsnbmV2ZXInLCAnYWx3YXlzJywgJ2h5cGhlbmF0ZScsICdvbi1zcGFjZSddO1xyXG5jb25zdCBURVhUX1dSQVAgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gVEVYVF9XUkFQUy5pbmNsdWRlcyh2KSwgYGV4cGVjdGluZyBhIHRleHQgd3JhcCBzdHJhdGVneSBrZXl3b3JkIHN1Y2ggYXMgJ25ldmVyJywgJ2Fsd2F5cycsICdoeXBoZW5hdGUnLCBvciAnb24tc3BhY2UnYCk7XHJcbmNvbnN0IE9WRVJGTE9XX1NUUkFHRUdJRVMgPSBbJ2VsbGlwc2lzJywgJ2hpZGUnXTtcclxuY29uc3QgT1ZFUkZMT1dfU1RSQVRFR1kgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gT1ZFUkZMT1dfU1RSQUdFR0lFUy5pbmNsdWRlcyh2KSwgYGV4cGVjdGluZyBhbiBvdmVyZmxvdyBzdHJhdGVneSBrZXl3b3JkIHN1Y2ggYXMgJ2VsbGlwc2lzJywgb3IgJ2hpZGUnYCk7XHJcbmNvbnN0IFRFWFRfQUxJR05TID0gWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddO1xyXG5jb25zdCBURVhUX0FMSUdOID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYpID0+IFRFWFRfQUxJR05TLmluY2x1ZGVzKHYpLCBgZXhwZWN0aW5nIGEgdGV4dCBhbGlnbiBrZXl3b3JkIHN1Y2ggYXMgJ2xlZnQnLCAnY2VudGVyJywgb3IgJ3JpZ2h0J2ApO1xyXG5jb25zdCBWRVJUSUNBTF9BTElHTlMgPSBbJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ107XHJcbmNvbnN0IFZFUlRJQ0FMX0FMSUdOID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYpID0+IFZFUlRJQ0FMX0FMSUdOUy5pbmNsdWRlcyh2KSwgYGV4cGVjdGluZyBhIHRleHQgYWxpZ24ga2V5d29yZCBzdWNoIGFzICd0b3AnLCAnbWlkZGxlJywgb3IgJ2JvdHRvbSdgKTtcclxuY29uc3QgRElSRUNUSU9OUyA9IFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddO1xyXG5jb25zdCBESVJFQ1RJT04gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gRElSRUNUSU9OUy5pbmNsdWRlcyh2KSwgYGV4cGVjdGluZyBhIGRpcmVjdGlvbiBrZXl3b3JkIHN1Y2ggYXMgJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdgKTtcclxuY29uc3QgT1BUX0RJUkVDVElPTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+IE9QVElPTkFMKHYsIGN0eCwgRElSRUNUSU9OKSwgYGV4cGVjdGluZyBhbiBvcHRpb25hbCBkaXJlY3Rpb24ga2V5d29yZCBzdWNoIGFzICdob3Jpem9udGFsJyBvciAndmVydGljYWwnYCk7XG5cbnZhciBDaGFydEF4aXNEaXJlY3Rpb247XHJcbihmdW5jdGlvbiAoQ2hhcnRBeGlzRGlyZWN0aW9uKSB7XHJcbiAgICBDaGFydEF4aXNEaXJlY3Rpb25bXCJYXCJdID0gXCJ4XCI7XHJcbiAgICBDaGFydEF4aXNEaXJlY3Rpb25bXCJZXCJdID0gXCJ5XCI7XHJcbn0pKENoYXJ0QXhpc0RpcmVjdGlvbiB8fCAoQ2hhcnRBeGlzRGlyZWN0aW9uID0ge30pKTtcblxudmFyIFJlZHJhd1R5cGU7XHJcbihmdW5jdGlvbiAoUmVkcmF3VHlwZSkge1xyXG4gICAgUmVkcmF3VHlwZVtSZWRyYXdUeXBlW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XHJcbiAgICAvLyBDYW52YXMgZG9lc24ndCBuZWVkIGNsZWFyaW5nLCBhbiBpbmNyZW1lbnRhbCByZS1yZXJlbmRlciBpcyBzdWZmaWNpZW50LlxyXG4gICAgUmVkcmF3VHlwZVtSZWRyYXdUeXBlW1wiVFJJVklBTFwiXSA9IDFdID0gXCJUUklWSUFMXCI7XHJcbiAgICAvLyBHcm91cCBuZWVkcyBjbGVhcmluZywgYSBzZW1pLWluY3JlbWVudGFsIHJlLXJlbmRlciBpcyBzdWZmaWNpZW50LlxyXG4gICAgUmVkcmF3VHlwZVtSZWRyYXdUeXBlW1wiTUlOT1JcIl0gPSAyXSA9IFwiTUlOT1JcIjtcclxuICAgIC8vIENhbnZhcyBuZWVkcyB0byBiZSBjbGVhcmVkIGZvciB0aGVzZSByZWRyYXcgdHlwZXMuXHJcbiAgICBSZWRyYXdUeXBlW1JlZHJhd1R5cGVbXCJNQUpPUlwiXSA9IDNdID0gXCJNQUpPUlwiO1xyXG59KShSZWRyYXdUeXBlIHx8IChSZWRyYXdUeXBlID0ge30pKTtcclxuLyoqIEByZXR1cm5zIHRydWUgaWYgbmV3IEZ1bmN0aW9uKCkgaXMgZGlzYWJsZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICovXHJcbmZ1bmN0aW9uIGZ1bmN0aW9uQ29uc3RydWN0b3JBdmFpbGFibGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIHRydWUnKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFNUUklOR19GVU5DVElPTl9VU0VBQkxFID0gZnVuY3Rpb25Db25zdHJ1Y3RvckF2YWlsYWJsZSgpO1xyXG5mdW5jdGlvbiBTY2VuZUNoYW5nZURldGVjdGlvbihvcHRzKSB7XHJcbiAgICBjb25zdCB7IGNoYW5nZUNiLCBjb252ZXJ0b3IgfSA9IG9wdHMgIT09IG51bGwgJiYgb3B0cyAhPT0gdm9pZCAwID8gb3B0cyA6IHt9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIC8vIGB0YXJnZXRgIGlzIGVpdGhlciBhIGNvbnN0cnVjdG9yIChzdGF0aWMgbWVtYmVyKSBvciBwcm90b3R5cGUgKGluc3RhbmNlIG1lbWJlcilcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gYF9fJHtrZXl9YDtcclxuICAgICAgICBpZiAodGFyZ2V0W2tleV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoU1RSSU5HX0ZVTkNUSU9OX1VTRUFCTEUgJiYgY2hhbmdlQ2IgPT0gbnVsbCAmJiBjb252ZXJ0b3IgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcmVwYXJlRmFzdEdldFNldCh0YXJnZXQsIGtleSwgcHJpdmF0ZUtleSwgb3B0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmVwYXJlU2xvd0dldFNldCh0YXJnZXQsIGtleSwgcHJpdmF0ZUtleSwgb3B0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlRmFzdEdldFNldCh0YXJnZXQsIGtleSwgcHJpdmF0ZUtleSwgb3B0cykge1xyXG4gICAgY29uc3QgeyByZWRyYXcgPSBSZWRyYXdUeXBlLlRSSVZJQUwsIHR5cGUgPSAnbm9ybWFsJywgY2hlY2tEaXJ0eU9uQXNzaWdubWVudCA9IGZhbHNlIH0gPSBvcHRzICE9PSBudWxsICYmIG9wdHMgIT09IHZvaWQgMCA/IG9wdHMgOiB7fTtcclxuICAgIC8vIE9wdGltaXNlZCBjb2RlLXBhdGguXHJcbiAgICAvLyBSZW1vdmUgYWxsIGNvbmRpdGlvbmFsIGxvZ2ljIGZyb20gcnVudGltZSAtIGdlbmVyYXRlIGEgc2V0dGVyIHdpdGggdGhlIGV4YWN0IG5lY2Vzc2FyeVxyXG4gICAgLy8gc3RlcHMsIGFzIHRoZXNlIHNldHRlcnMgYXJlIGNhbGxlZCBhIExPVCBkdXJpbmcgdXBkYXRlIGN5Y2xlcy5cclxuICAgIGNvbnN0IHNldHRlckpzID0gbmV3IEZ1bmN0aW9uKCd2YWx1ZScsIGBcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiR7cHJpdmF0ZUtleX07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJHtwcml2YXRlS2V5fSA9IHZhbHVlO1xuICAgICAgICAgICAgJHt0eXBlID09PSAnbm9ybWFsJyA/IGB0aGlzLm1hcmtEaXJ0eSh0aGlzLCAke3JlZHJhd30pO2AgOiAnJ31cbiAgICAgICAgICAgICR7dHlwZSA9PT0gJ3RyYW5zZm9ybScgPyBgdGhpcy5tYXJrRGlydHlUcmFuc2Zvcm0oJHtyZWRyYXd9KTtgIDogJyd9XG4gICAgICAgICAgICAke3R5cGUgPT09ICdwYXRoJ1xyXG4gICAgICAgID8gYGlmICghdGhpcy5fZGlydHlQYXRoKSB7IHRoaXMuX2RpcnR5UGF0aCA9IHRydWU7IHRoaXMubWFya0RpcnR5KHRoaXMsICR7cmVkcmF3fSk7IH1gXHJcbiAgICAgICAgOiAnJ31cbiAgICAgICAgICAgICR7dHlwZSA9PT0gJ2ZvbnQnXHJcbiAgICAgICAgPyBgaWYgKCF0aGlzLl9kaXJ0eUZvbnQpIHsgdGhpcy5fZGlydHlGb250ID0gdHJ1ZTsgdGhpcy5tYXJrRGlydHkodGhpcywgJHtyZWRyYXd9KTsgfWBcclxuICAgICAgICA6ICcnfVxuICAgICAgICB9XG4gICAgICAgICR7Y2hlY2tEaXJ0eU9uQXNzaWdubWVudFxyXG4gICAgICAgID8gYGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9kaXJ0eSA+ICR7UmVkcmF3VHlwZS5OT05FfSkgeyB0aGlzLm1hcmtEaXJ0eSh2YWx1ZSwgdmFsdWUuX2RpcnR5KTsgfWBcclxuICAgICAgICA6ICcnfVxuYCk7XHJcbiAgICBjb25zdCBnZXR0ZXJKcyA9IG5ldyBGdW5jdGlvbihgcmV0dXJuIHRoaXMuJHtwcml2YXRlS2V5fTtgKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgIHNldDogc2V0dGVySnMsXHJcbiAgICAgICAgZ2V0OiBnZXR0ZXJKcyxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVTbG93R2V0U2V0KHRhcmdldCwga2V5LCBwcml2YXRlS2V5LCBvcHRzKSB7XHJcbiAgICBjb25zdCB7IHJlZHJhdyA9IFJlZHJhd1R5cGUuVFJJVklBTCwgdHlwZSA9ICdub3JtYWwnLCBjaGFuZ2VDYiwgY29udmVydG9yLCBjaGVja0RpcnR5T25Bc3NpZ25tZW50ID0gZmFsc2UsIH0gPSBvcHRzICE9PSBudWxsICYmIG9wdHMgIT09IHZvaWQgMCA/IG9wdHMgOiB7fTtcclxuICAgIC8vIFVub3B0aW1pc2VkIGJ1dCAnc2FmZScgY29kZS1wYXRoLCBmb3IgZW52aXJvbm1lbnRzIHdpdGggQ1NQIGhlYWRlcnMgYW5kIG5vICd1bnNhZmUtZXZhbCcuXHJcbiAgICAvLyBXZSBkZWxpYmVyYXRlbHkgZG8gbm90IHN1cHBvcnQgZGVidWcgYnJhbmNoZXMgZm91bmQgaW4gdGhlIG9wdGltaXNlZCBwYXRoIGFib3ZlLCBzaW5jZVxyXG4gICAgLy8gZm9yIGxhcmdlIGRhdGEtc2V0IHNlcmllcyBwZXJmb3JtYW5jZSBkZXRlcmlvcmF0ZXMgd2l0aCBldmVyeSBleHRyYSBicmFuY2ggaGVyZS5cclxuICAgIGNvbnN0IHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcclxuICAgICAgICB2YWx1ZSA9IGNvbnZlcnRvciA/IGNvbnZlcnRvcih2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdub3JtYWwnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgcmVkcmF3KTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0cmFuc2Zvcm0nKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlUcmFuc2Zvcm0ocmVkcmF3KTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdwYXRoJyAmJiAhdGhpcy5fZGlydHlQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eVBhdGggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgcmVkcmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2ZvbnQnICYmICF0aGlzLl9kaXJ0eUZvbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5Rm9udCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0aGlzLCByZWRyYXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VDYilcclxuICAgICAgICAgICAgICAgIGNoYW5nZUNiKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hlY2tEaXJ0eU9uQXNzaWdubWVudCAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9kaXJ0eSA+IFJlZHJhd1R5cGUuTk9ORSlcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodmFsdWUsIHZhbHVlLl9kaXJ0eSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZ2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgIHNldDogc2V0dGVyLFxyXG4gICAgICAgIGdldDogZ2V0dGVyLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgfSk7XHJcbn1cclxuY2xhc3MgQ2hhbmdlRGV0ZWN0YWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IFJlZHJhd1R5cGUuTUFKT1I7XHJcbiAgICB9XHJcbiAgICBtYXJrRGlydHkoX3NvdXJjZSwgdHlwZSA9IFJlZHJhd1R5cGUuVFJJVklBTCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSA+IHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHR5cGU7XHJcbiAgICB9XHJcbiAgICBtYXJrQ2xlYW4oX29wdHMpIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IFJlZHJhd1R5cGUuTk9ORTtcclxuICAgIH1cclxuICAgIGlzRGlydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5ID4gUmVkcmF3VHlwZS5OT05FO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IElEX01BUCA9IHt9O1xyXG5mdW5jdGlvbiByZXNldElkcygpIHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIElEX01BUCkge1xyXG4gICAgICAgIGRlbGV0ZSBJRF9NQVBba2V5XTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJZChpbnN0YW5jZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBpbnN0YW5jZS5jb25zdHJ1Y3RvcjtcclxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25zdHJ1Y3RvciwgJ2NsYXNzTmFtZScpXHJcbiAgICAgICAgPyBjb25zdHJ1Y3Rvci5jbGFzc05hbWVcclxuICAgICAgICA6IGNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICBpZiAoIWNsYXNzTmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7Y29uc3RydWN0b3J9IGlzIG1pc3NpbmcgdGhlICdjbGFzc05hbWUnIHByb3BlcnR5LmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV4dElkID0gKChfYSA9IElEX01BUFtjbGFzc05hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArIDE7XHJcbiAgICBJRF9NQVBbY2xhc3NOYW1lXSA9IG5leHRJZDtcclxuICAgIHJldHVybiBjbGFzc05hbWUgKyAnLScgKyBuZXh0SWQ7XHJcbn1cblxuZnVuY3Rpb24gbmVhcmVzdFNxdWFyZWQocG9pbnQsIG9iamVjdHMsIG1heERpc3RhbmNlU3F1YXJlZCA9IEluZmluaXR5KSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7IG5lYXJlc3Q6IHVuZGVmaW5lZCwgZGlzdGFuY2VTcXVhcmVkOiBtYXhEaXN0YW5jZVNxdWFyZWQgfTtcclxuICAgIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdHMpIHtcclxuICAgICAgICBjb25zdCB0aGlzRGlzdGFuY2UgPSBvYmouZGlzdGFuY2VTcXVhcmVkKHBvaW50KTtcclxuICAgICAgICBpZiAodGhpc0Rpc3RhbmNlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG5lYXJlc3Q6IG9iaiwgZGlzdGFuY2VTcXVhcmVkOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXNEaXN0YW5jZSA8IHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lm5lYXJlc3QgPSBvYmo7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQgPSB0aGlzRGlzdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyKHBvaW50LCBjb250YWluZXIsIG1heERpc3RhbmNlU3F1YXJlZCA9IEluZmluaXR5KSB7XHJcbiAgICBjb25zdCB0cG9pbnQgPSBjb250YWluZXIudHJhbnNmb3JtUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7IG5lYXJlc3Q6IHVuZGVmaW5lZCwgZGlzdGFuY2VTcXVhcmVkOiBtYXhEaXN0YW5jZVNxdWFyZWQgfTtcclxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY29udGFpbmVyLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgY29uc3QgeyBuZWFyZXN0LCBkaXN0YW5jZVNxdWFyZWQgfSA9IGNoaWxkLm5lYXJlc3RTcXVhcmVkKHRwb2ludCwgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCk7XHJcbiAgICAgICAgaWYgKGRpc3RhbmNlU3F1YXJlZCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBuZWFyZXN0LCBkaXN0YW5jZVNxdWFyZWQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2VTcXVhcmVkIDwgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCkge1xyXG4gICAgICAgICAgICByZXN1bHQubmVhcmVzdCA9IG5lYXJlc3Q7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVNxdWFyZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG5jbGFzcyBCQm94IHtcclxuICAgIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55ICYmIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBjb250YWluc1BvaW50KHgsIHkpIHtcclxuICAgICAgICByZXR1cm4geCA+PSB0aGlzLnggJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmIHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBjb2xsaWRlc0JCb3gob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJlxyXG4gICAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoID4gb3RoZXIueCAmJlxyXG4gICAgICAgICAgICB0aGlzLnkgPCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0ICYmXHJcbiAgICAgICAgICAgIHRoaXMueSArIHRoaXMuaGVpZ2h0ID4gb3RoZXIueSk7XHJcbiAgICB9XHJcbiAgICBpc0luZmluaXRlKCkge1xyXG4gICAgICAgIHJldHVybiAoTWF0aC5hYnModGhpcy54KSA9PT0gSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy55KSA9PT0gSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy53aWR0aCkgPT09IEluZmluaXR5IHx8XHJcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuaGVpZ2h0KSA9PT0gSW5maW5pdHkpO1xyXG4gICAgfVxyXG4gICAgZGlzdGFuY2VTcXVhcmVkKHBvaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZHggPSBwb2ludC54IC0gTWF0aC5tYXgodGhpcy54LCBNYXRoLm1pbihwb2ludC54LCB0aGlzLnggKyB0aGlzLndpZHRoKSk7XHJcbiAgICAgICAgY29uc3QgZHkgPSBwb2ludC55IC0gTWF0aC5tYXgodGhpcy55LCBNYXRoLm1pbihwb2ludC55LCB0aGlzLnkgKyB0aGlzLmhlaWdodCkpO1xyXG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZWFyZXN0Qm94KHBvaW50LCBib3hlcykge1xyXG4gICAgICAgIHJldHVybiBuZWFyZXN0U3F1YXJlZChwb2ludCwgYm94ZXMpO1xyXG4gICAgfVxyXG4gICAgc2hyaW5rKGFtb3VudCwgcG9zaXRpb24pIHtcclxuICAgICAgICBjb25zdCBhcHBseSA9IChwb3MsIGFtdCkgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHBvcykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgKz0gYW10O1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArPSBhbXQ7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpZHRoIC09IGFtdDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgKz0gYW10O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IGFtdCAqIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKz0gYW10O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2lkdGggLT0gYW10ICogMjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArPSBhbXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCAtPSBhbXQgKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSArPSBhbXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgLT0gYW10ICogMjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIC8vIFVua25vd24gcG9zaXRpb24gLSBkbyBub3RoaW5nLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgYXBwbHkocG9zaXRpb24sIGFtb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhhbW91bnQpLmZvckVhY2goKFtwb3MsIGFtdF0pID0+IGFwcGx5KHBvcywgYW10KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ3JvdyhhbW91bnQsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hyaW5rKC1hbW91bnQsIHBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgYW1vdW50KTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFkZGluZ0NvcHkpIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdDb3B5W2tleV0gKj0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaHJpbmsocGFkZGluZ0NvcHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBtZXJnZShib3hlcykge1xyXG4gICAgICAgIGxldCBsZWZ0ID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IHRvcCA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCByaWdodCA9IC1JbmZpbml0eTtcclxuICAgICAgICBsZXQgYm90dG9tID0gLUluZmluaXR5O1xyXG4gICAgICAgIGJveGVzLmZvckVhY2goKGJveCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYm94LnggPCBsZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYm94Lng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJveC55IDwgdG9wKSB7XHJcbiAgICAgICAgICAgICAgICB0b3AgPSBib3gueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm94LnggKyBib3gud2lkdGggPiByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBib3gueCArIGJveC53aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm94LnkgKyBib3guaGVpZ2h0ID4gYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICBib3R0b20gPSBib3gueSArIGJveC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEJCb3gobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XHJcbiAgICB9XHJcbn1cclxuQkJveC56ZXJvID0gbmV3IEJCb3goMCwgMCwgMCwgMCk7XG5cbi8qKlxyXG4gKiBBcyBvZiBKYW4gOCwgMjAxOSwgRmlyZWZveCBzdGlsbCBkb2Vzbid0IGltcGxlbWVudFxyXG4gKiBgZ2V0VHJhbnNmb3JtKCk6IERPTU1hdHJpeDtgXHJcbiAqIGBzZXRUcmFuc2Zvcm0odHJhbnNmb3JtPzogRE9NTWF0cml4MkRJbml0KWBcclxuICogaW4gdGhlIGBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgLlxyXG4gKiBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyODE1MFxyXG4gKiBJRTExIGFuZCBFZGdlIDQ0IGFsc28gZG9uJ3QgaGF2ZSB0aGUgc3VwcG9ydC5cclxuICogVGh1cyB0aGlzIGNsYXNzLCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybSBhbmRcclxuICogY29tYmluZSB0cmFuc2Zvcm1hdGlvbnMuXHJcbiAqIFN0YW5kYXJkczpcclxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9kZXYvY2FudmFzLmh0bWxcclxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL2dlb21ldHJ5LTEvXHJcbiAqL1xyXG5jbGFzcyBNYXRyaXgge1xyXG4gICAgZ2V0IGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLmVsZW1lbnRzXTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzID0gWzEsIDAsIDAsIDEsIDAsIDBdKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG4gICAgfVxyXG4gICAgc2V0RWxlbWVudHMoZWxlbWVudHMpIHtcclxuICAgICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAvLyBgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzLnNsaWNlKClgIGlzIDQtNSB0aW1lcyBzbG93ZXJcclxuICAgICAgICAvLyAoaW4gQ2hyb21lIDcxIGFuZCBGRiA2NCkgdGhhbiBtYW51YWxseSBjb3B5aW5nIGVsZW1lbnRzLFxyXG4gICAgICAgIC8vIHNpbmNlIHNsaWNpbmcgYWxsb2NhdGVzIG5ldyBtZW1vcnkuXHJcbiAgICAgICAgLy8gVGhlIHBlcmZvcm1hbmNlIG9mIHBhc3NpbmcgcGFyYW1ldGVycyBpbmRpdmlkdWFsbHlcclxuICAgICAgICAvLyB2cyBhcyBhbiBhcnJheSBpcyBhYm91dCB0aGUgc2FtZSBpbiBib3RoIGJyb3dzZXJzLCBzbyB3ZVxyXG4gICAgICAgIC8vIGdvIHdpdGggYSBzaW5nbGUgKGFycmF5IG9mIGVsZW1lbnRzKSBwYXJhbWV0ZXIsIGJlY2F1c2VcclxuICAgICAgICAvLyBgc2V0RWxlbWVudHMoZWxlbWVudHMpYCBhbmQgYHNldEVsZW1lbnRzKFthLCBiLCBjLCBkLCBlLCBmXSlgXHJcbiAgICAgICAgLy8gY2FsbHMgZ2l2ZSB1cyByb3VnaGx5IHRoZSBzYW1lIHBlcmZvcm1hbmNlLCB2ZXJzdXNcclxuICAgICAgICAvLyBgc2V0RWxlbWVudHMoLi4uZWxlbWVudHMpYCBhbmQgYHNldEVsZW1lbnRzKGEsIGIsIGMsIGQsIGUsIGYpYCxcclxuICAgICAgICAvLyB3aGVyZSB0aGUgc3ByZWFkIG9wZXJhdG9yIGNhdXNlcyBhIDIwLTMweCBwZXJmb3JtYW5jZSBkcm9wXHJcbiAgICAgICAgLy8gKDMweCB3aGVuIGNvbXBpbGVkIHRvIEVTNSdzIGAuYXBwbHkodGhpcywgZWxlbWVudHMpYFxyXG4gICAgICAgIC8vICAyMHggd2hlbiB1c2VkIG5hdGl2ZWx5KS5cclxuICAgICAgICBlWzBdID0gZWxlbWVudHNbMF07XHJcbiAgICAgICAgZVsxXSA9IGVsZW1lbnRzWzFdO1xyXG4gICAgICAgIGVbMl0gPSBlbGVtZW50c1syXTtcclxuICAgICAgICBlWzNdID0gZWxlbWVudHNbM107XHJcbiAgICAgICAgZVs0XSA9IGVsZW1lbnRzWzRdO1xyXG4gICAgICAgIGVbNV0gPSBlbGVtZW50c1s1XTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldCBpZGVudGl0eSgpIHtcclxuICAgICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICByZXR1cm4gZVswXSA9PT0gMSAmJiBlWzFdID09PSAwICYmIGVbMl0gPT09IDAgJiYgZVszXSA9PT0gMSAmJiBlWzRdID09PSAwICYmIGVbNV0gPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIHRoZSBBeEIgbWF0cml4IG11bHRpcGxpY2F0aW9uIGFuZCBzYXZlcyB0aGUgcmVzdWx0XHJcbiAgICAgKiB0byBgQ2AsIGlmIGdpdmVuLCBvciB0byBgQWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBBeEIoQSwgQiwgQykge1xyXG4gICAgICAgIGNvbnN0IGEgPSBBWzBdICogQlswXSArIEFbMl0gKiBCWzFdLCBiID0gQVsxXSAqIEJbMF0gKyBBWzNdICogQlsxXSwgYyA9IEFbMF0gKiBCWzJdICsgQVsyXSAqIEJbM10sIGQgPSBBWzFdICogQlsyXSArIEFbM10gKiBCWzNdLCBlID0gQVswXSAqIEJbNF0gKyBBWzJdICogQls1XSArIEFbNF0sIGYgPSBBWzFdICogQls0XSArIEFbM10gKiBCWzVdICsgQVs1XTtcclxuICAgICAgICBDID0gQyAhPT0gbnVsbCAmJiBDICE9PSB2b2lkIDAgPyBDIDogQTtcclxuICAgICAgICBDWzBdID0gYTtcclxuICAgICAgICBDWzFdID0gYjtcclxuICAgICAgICBDWzJdID0gYztcclxuICAgICAgICBDWzNdID0gZDtcclxuICAgICAgICBDWzRdID0gZTtcclxuICAgICAgICBDWzVdID0gZjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBvdGhlcmAgbWF0cml4IGdldHMgcG9zdC1tdWx0aXBsaWVkIHRvIHRoZSBjdXJyZW50IG1hdHJpeC5cclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIG90aGVyXHJcbiAgICAgKi9cclxuICAgIG11bHRpcGx5U2VsZihvdGhlcikge1xyXG4gICAgICAgIHRoaXMuQXhCKHRoaXMuZWxlbWVudHMsIG90aGVyLmVsZW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBvdGhlcmAgbWF0cml4IGdldHMgcG9zdC1tdWx0aXBsaWVkIHRvIHRoZSBjdXJyZW50IG1hdHJpeC5cclxuICAgICAqIFJldHVybnMgYSBuZXcgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIG90aGVyXHJcbiAgICAgKi9cclxuICAgIG11bHRpcGx5KG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBuZXcgQXJyYXkoNik7XHJcbiAgICAgICAgdGhpcy5BeEIodGhpcy5lbGVtZW50cywgb3RoZXIuZWxlbWVudHMsIGVsZW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChlbGVtZW50cyk7XHJcbiAgICB9XHJcbiAgICBwcmVNdWx0aXBseVNlbGYob3RoZXIpIHtcclxuICAgICAgICB0aGlzLkF4QihvdGhlci5lbGVtZW50cywgdGhpcy5lbGVtZW50cywgdGhpcy5lbGVtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggYXMgYSBuZXcgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBpbnZlcnNlKCkge1xyXG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBsZXQgYSA9IGVsWzBdLCBiID0gZWxbMV0sIGMgPSBlbFsyXSwgZCA9IGVsWzNdO1xyXG4gICAgICAgIGNvbnN0IGUgPSBlbFs0XSwgZiA9IGVsWzVdO1xyXG4gICAgICAgIGNvbnN0IHJEID0gMSAvIChhICogZCAtIGIgKiBjKTsgLy8gcmVjaXByb2NhbCBvZiBkZXRlcm1pbmFudFxyXG4gICAgICAgIGEgKj0gckQ7XHJcbiAgICAgICAgYiAqPSByRDtcclxuICAgICAgICBjICo9IHJEO1xyXG4gICAgICAgIGQgKj0gckQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoW2QsIC1iLCAtYywgYSwgYyAqIGYgLSBkICogZSwgYiAqIGUgLSBhICogZl0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYXZlIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIGludmVyc2VUbyhvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBsZXQgYSA9IGVsWzBdLCBiID0gZWxbMV0sIGMgPSBlbFsyXSwgZCA9IGVsWzNdO1xyXG4gICAgICAgIGNvbnN0IGUgPSBlbFs0XSwgZiA9IGVsWzVdO1xyXG4gICAgICAgIGNvbnN0IHJEID0gMSAvIChhICogZCAtIGIgKiBjKTsgLy8gcmVjaXByb2NhbCBvZiBkZXRlcm1pbmFudFxyXG4gICAgICAgIGEgKj0gckQ7XHJcbiAgICAgICAgYiAqPSByRDtcclxuICAgICAgICBjICo9IHJEO1xyXG4gICAgICAgIGQgKj0gckQ7XHJcbiAgICAgICAgb3RoZXIuc2V0RWxlbWVudHMoW2QsIC1iLCAtYywgYSwgYyAqIGYgLSBkICogZSwgYiAqIGUgLSBhICogZl0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaW52ZXJ0U2VsZigpIHtcclxuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcclxuICAgICAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcclxuICAgICAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7IC8vIHJlY2lwcm9jYWwgb2YgZGV0ZXJtaW5hbnRcclxuICAgICAgICBhICo9IHJEO1xyXG4gICAgICAgIGIgKj0gckQ7XHJcbiAgICAgICAgYyAqPSByRDtcclxuICAgICAgICBkICo9IHJEO1xyXG4gICAgICAgIGVsWzBdID0gZDtcclxuICAgICAgICBlbFsxXSA9IC1iO1xyXG4gICAgICAgIGVsWzJdID0gLWM7XHJcbiAgICAgICAgZWxbM10gPSBhO1xyXG4gICAgICAgIGVsWzRdID0gYyAqIGYgLSBkICogZTtcclxuICAgICAgICBlbFs1XSA9IGIgKiBlIC0gYSAqIGY7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm1Qb2ludCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCAqIGVbMF0gKyB5ICogZVsyXSArIGVbNF0sXHJcbiAgICAgICAgICAgIHk6IHggKiBlWzFdICsgeSAqIGVbM10gKyBlWzVdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm1CQm94KGJib3gsIHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICBjb25zdCB4eCA9IGVsZW1lbnRzWzBdO1xyXG4gICAgICAgIGNvbnN0IHh5ID0gZWxlbWVudHNbMV07XHJcbiAgICAgICAgY29uc3QgeXggPSBlbGVtZW50c1syXTtcclxuICAgICAgICBjb25zdCB5eSA9IGVsZW1lbnRzWzNdO1xyXG4gICAgICAgIGNvbnN0IGhfdyA9IGJib3gud2lkdGggKiAwLjU7XHJcbiAgICAgICAgY29uc3QgaF9oID0gYmJveC5oZWlnaHQgKiAwLjU7XHJcbiAgICAgICAgY29uc3QgY3ggPSBiYm94LnggKyBoX3c7XHJcbiAgICAgICAgY29uc3QgY3kgPSBiYm94LnkgKyBoX2g7XHJcbiAgICAgICAgY29uc3QgdyA9IE1hdGguYWJzKGhfdyAqIHh4KSArIE1hdGguYWJzKGhfaCAqIHl4KTtcclxuICAgICAgICBjb25zdCBoID0gTWF0aC5hYnMoaF93ICogeHkpICsgTWF0aC5hYnMoaF9oICogeXkpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IG5ldyBCQm94KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXQueCA9IGN4ICogeHggKyBjeSAqIHl4ICsgZWxlbWVudHNbNF0gLSB3O1xyXG4gICAgICAgIHRhcmdldC55ID0gY3ggKiB4eSArIGN5ICogeXkgKyBlbGVtZW50c1s1XSAtIGg7XHJcbiAgICAgICAgdGFyZ2V0LndpZHRoID0gdyArIHc7XHJcbiAgICAgICAgdGFyZ2V0LmhlaWdodCA9IGggKyBoO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICB0b0NvbnRleHQoY3R4KSB7XHJcbiAgICAgICAgLy8gSXQncyBmYWlyIHRvIHNheSB0aGF0IG1hdHJpeCBtdWx0aXBsaWNhdGlvbnMgYXJlIG5vdCBjaGVhcC5cclxuICAgICAgICAvLyBIb3dldmVyLCB1cGRhdGluZyBwYXRoIGRlZmluaXRpb25zIG9uIGV2ZXJ5IGZyYW1lIGlzbid0IGVpdGhlciwgc29cclxuICAgICAgICAvLyBpdCBtYXkgYmUgY2hlYXBlciB0byBqdXN0IHRyYW5zbGF0ZSBwYXRocy4gSXQncyBhbHNvIGZhaXIgdG9cclxuICAgICAgICAvLyBzYXksIHRoYXQgbW9zdCBwYXRocyB3aWxsIGhhdmUgdG8gYmUgcmUtcmVuZGVyZWQgYW55d2F5LCBzYXlcclxuICAgICAgICAvLyByZWN0YW5nbGUgcGF0aHMgaW4gYSBiYXIgY2hhcnQsIHdoZXJlIGFuIGFuaW1hdGlvbiB3b3VsZCBoYXBwZW4gd2hlblxyXG4gICAgICAgIC8vIHRoZSBkYXRhIHNldCBjaGFuZ2VzIGFuZCBleGlzdGluZyBiYXJzIGFyZSBtb3JwaGVkIGludG8gbmV3IG9uZXMuXHJcbiAgICAgICAgLy8gT3IgYSBwaWUgY2hhcnQsIHdoZXJlIG9sZCBzZWN0b3JzIGFyZSBhbHNvIG1vcnBoZWQgaW50byBuZXcgb25lcy5cclxuICAgICAgICAvLyBTYW1lIGZvciB0aGUgbGluZSBjaGFydC4gVGhlIG9ubHkgcGxhdXNpYmxlIGNhc2Ugd2hlcmUgdHJhbnNsYXRpbmdcclxuICAgICAgICAvLyBleGlzdGluZyBwYXRocyB3b3VsZCBiZSBlbm91Z2gsIGlzIHRoZSBzY2F0dGVyIGNoYXJ0LCB3aGVyZSBtYXJrZXJcclxuICAgICAgICAvLyBpY29ucywgdHlwaWNhbGx5IGNpcmNsZXMsIHN0YXkgdGhlIHNhbWUgc2l6ZS4gQnV0IGlmIGNpcmNsZSByYWRpaVxyXG4gICAgICAgIC8vIGFyZSBib3VuZCB0byBzb21lIGRhdGEgcG9pbnRzLCBldmVuIGNpcmNsZSBwYXRocyB3b3VsZCBoYXZlIHRvIGJlXHJcbiAgICAgICAgLy8gdXBkYXRlZC4gQW5kIHRodXMgaXQgbWFrZXMgc2Vuc2UgdG8gb3B0aW1pemUgZm9yIGZld2VyIG1hdHJpeFxyXG4gICAgICAgIC8vIHRyYW5zZm9ybXMsIHdoZXJlIHRyYW5zZm9ybSBtYXRyaWNlcyBvZiBwYXRocyBhcmUgbW9zdGx5IGlkZW50aXR5XHJcbiAgICAgICAgLy8gbWF0cmljZXMgYW5kIGB4YC9geWAsIGBjZW50ZXJYYC9gY2VudGVyWWAgYW5kIHNpbWlsYXIgcHJvcGVydGllc1xyXG4gICAgICAgIC8vIGFyZSB1c2VkIHRvIGRlZmluZSBhIHBhdGggYXQgc3BlY2lmaWMgY29vcmRpbmF0ZXMuIEFuZCBvbmx5IGdyb3Vwc1xyXG4gICAgICAgIC8vIGFyZSB1c2VkIHRvIGNvbGxlY3RpdmVseSBhcHBseSBhIHRyYW5zZm9ybSB0byBhIHNldCBvZiBub2Rlcy5cclxuICAgICAgICAvLyBJZiB0aGUgbWF0cml4IGlzIG1vc3RseSBpZGVudGl0eSAoOTUlIG9mIHRoZSB0aW1lKSxcclxuICAgICAgICAvLyB0aGUgYGlmICh0aGlzLmlzSWRlbnRpdHkpYCBjaGVjayBjYW4gbWFrZSB0aGlzIGNhbGwgMy00IHRpbWVzXHJcbiAgICAgICAgLy8gZmFzdGVyIG9uIGF2ZXJhZ2U6IGh0dHBzOi8vanNwZXJmLmNvbS9tYXRyaXgtY2hlY2stZmlyc3QtdnMtYWx3YXlzLXNldFxyXG4gICAgICAgIGlmICh0aGlzLmlkZW50aXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgY3R4LnRyYW5zZm9ybShlWzBdLCBlWzFdLCBlWzJdLCBlWzNdLCBlWzRdLCBlWzVdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmbHl3ZWlnaHQoc291cmNlTWF0cml4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdHJpeC5pbnN0YW5jZS5zZXRFbGVtZW50cyhzb3VyY2VNYXRyaXguZWxlbWVudHMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVwZGF0ZVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIHNjYWxpbmdYLCBzY2FsaW5nWSwgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZLCBvcHRzKSB7XHJcbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgY2VudGVycyBvZiBzY2FsaW5nIGFuZCByb3RhdGlvbiBhcmUgYXQgdGhlIG9yaWdpbi5cclxuICAgICAgICBjb25zdCBbYmJjeCwgYmJjeV0gPSBbMCwgMF07XHJcbiAgICAgICAgY29uc3Qgc3ggPSBzY2FsaW5nWDtcclxuICAgICAgICBjb25zdCBzeSA9IHNjYWxpbmdZO1xyXG4gICAgICAgIGxldCBzY3g7XHJcbiAgICAgICAgbGV0IHNjeTtcclxuICAgICAgICBpZiAoc3ggPT09IDEgJiYgc3kgPT09IDEpIHtcclxuICAgICAgICAgICAgc2N4ID0gMDtcclxuICAgICAgICAgICAgc2N5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjeCA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc2NhbGluZ0NlbnRlclgpID09IG51bGwgPyBiYmN4IDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNjYWxpbmdDZW50ZXJYO1xyXG4gICAgICAgICAgICBzY3kgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNjYWxpbmdDZW50ZXJZKSA9PSBudWxsID8gYmJjeSA6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zY2FsaW5nQ2VudGVyWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgciA9IHJvdGF0aW9uO1xyXG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHIpO1xyXG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHIpO1xyXG4gICAgICAgIGxldCByY3g7XHJcbiAgICAgICAgbGV0IHJjeTtcclxuICAgICAgICBpZiAociA9PT0gMCkge1xyXG4gICAgICAgICAgICByY3ggPSAwO1xyXG4gICAgICAgICAgICByY3kgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmN4ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5yb3RhdGlvbkNlbnRlclgpID09IG51bGwgPyBiYmN4IDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnJvdGF0aW9uQ2VudGVyWDtcclxuICAgICAgICAgICAgcmN5ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5yb3RhdGlvbkNlbnRlclkpID09IG51bGwgPyBiYmN5IDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnJvdGF0aW9uQ2VudGVyWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHggPSB0cmFuc2xhdGlvblg7XHJcbiAgICAgICAgY29uc3QgdHkgPSB0cmFuc2xhdGlvblk7XHJcbiAgICAgICAgLy8gVGhlIHRyYW5zZm9ybSBtYXRyaXggYE1gIGlzIGEgcmVzdWx0IG9mIHRoZSBmb2xsb3dpbmcgdHJhbnNmb3JtYXRpb25zOlxyXG4gICAgICAgIC8vIDEpIHRyYW5zbGF0ZSB0aGUgY2VudGVyIG9mIHNjYWxpbmcgdG8gdGhlIG9yaWdpblxyXG4gICAgICAgIC8vIDIpIHNjYWxlXHJcbiAgICAgICAgLy8gMykgdHJhbnNsYXRlIGJhY2tcclxuICAgICAgICAvLyA0KSB0cmFuc2xhdGUgdGhlIGNlbnRlciBvZiByb3RhdGlvbiB0byB0aGUgb3JpZ2luXHJcbiAgICAgICAgLy8gNSkgcm90YXRlXHJcbiAgICAgICAgLy8gNikgdHJhbnNsYXRlIGJhY2tcclxuICAgICAgICAvLyA3KSB0cmFuc2xhdGVcclxuICAgICAgICAvLyAgICAgICAgICg3KSAgICAgICAgICAoNikgICAgICAgICAgICAgKDUpICAgICAgICAgICAgICg0KSAgICAgICAgICAgKDMpICAgICAgICAgICAoMikgICAgICAgICAgICgxKVxyXG4gICAgICAgIC8vICAgICB8IDEgMCB0eCB8ICAgfCAxIDAgcmN4IHwgICB8IGNvcyAtc2luIDAgfCAgIHwgMSAwIC1yY3ggfCAgIHwgMSAwIHNjeCB8ICAgfCBzeCAwIDAgfCAgIHwgMSAwIC1zY3ggfFxyXG4gICAgICAgIC8vIE0gPSB8IDAgMSB0eSB8ICogfCAwIDEgcmN5IHwgKiB8IHNpbiAgY29zIDAgfCAqIHwgMCAxIC1yY3kgfCAqIHwgMCAxIHNjeSB8ICogfCAwIHN5IDAgfCAqIHwgMCAxIC1zY3kgfFxyXG4gICAgICAgIC8vICAgICB8IDAgMCAgMSB8ICAgfCAwIDAgIDEgIHwgICB8ICAwICAgIDAgIDEgfCAgIHwgMCAwICAxICAgfCAgIHwgMCAwICAxICB8ICAgfCAwICAwIDAgfCAgIHwgMCAwICAxICAgfFxyXG4gICAgICAgIC8vIFRyYW5zbGF0aW9uIGFmdGVyIHN0ZXBzIDEtNCBhYm92ZTpcclxuICAgICAgICBjb25zdCB0eDQgPSBzY3ggKiAoMSAtIHN4KSAtIHJjeDtcclxuICAgICAgICBjb25zdCB0eTQgPSBzY3kgKiAoMSAtIHN5KSAtIHJjeTtcclxuICAgICAgICBtYXRyaXguc2V0RWxlbWVudHMoW1xyXG4gICAgICAgICAgICBjb3MgKiBzeCxcclxuICAgICAgICAgICAgc2luICogc3gsXHJcbiAgICAgICAgICAgIC1zaW4gKiBzeSxcclxuICAgICAgICAgICAgY29zICogc3ksXHJcbiAgICAgICAgICAgIGNvcyAqIHR4NCAtIHNpbiAqIHR5NCArIHJjeCArIHR4LFxyXG4gICAgICAgICAgICBzaW4gKiB0eDQgKyBjb3MgKiB0eTQgKyByY3kgKyB0eSxcclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21Db250ZXh0KGN0eCkge1xyXG4gICAgICAgIGNvbnN0IGRvbU1hdHJpeCA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChbZG9tTWF0cml4LmEsIGRvbU1hdHJpeC5iLCBkb21NYXRyaXguYywgZG9tTWF0cml4LmQsIGRvbU1hdHJpeC5lLCBkb21NYXRyaXguZl0pO1xyXG4gICAgfVxyXG59XHJcbk1hdHJpeC5pbnN0YW5jZSA9IG5ldyBNYXRyaXgoKTtcblxudmFyIFBvaW50ZXJFdmVudHM7XHJcbihmdW5jdGlvbiAoUG9pbnRlckV2ZW50cykge1xyXG4gICAgUG9pbnRlckV2ZW50c1tQb2ludGVyRXZlbnRzW1wiQWxsXCJdID0gMF0gPSBcIkFsbFwiO1xyXG4gICAgUG9pbnRlckV2ZW50c1tQb2ludGVyRXZlbnRzW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XHJcbn0pKFBvaW50ZXJFdmVudHMgfHwgKFBvaW50ZXJFdmVudHMgPSB7fSkpO1xyXG5jb25zdCB6SW5kZXhDaGFuZ2VkQ2FsbGJhY2sgPSAobykgPT4ge1xyXG4gICAgaWYgKG8ucGFyZW50KSB7XHJcbiAgICAgICAgby5wYXJlbnQuZGlydHlaSW5kZXggPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgby56SW5kZXhDaGFuZ2VkKCk7XHJcbn07XHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBzY2VuZSBncmFwaCBub2RlLlxyXG4gKiBFYWNoIG5vZGUgY2FuIGhhdmUgemVybyBvciBvbmUgcGFyZW50IGFuZCBiZWxvbmcgdG8gemVybyBvciBvbmUgc2NlbmUuXHJcbiAqL1xyXG5jbGFzcyBOb2RlIGV4dGVuZHMgQ2hhbmdlRGV0ZWN0YWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIFNvbWUgYXJiaXRyYXJ5IGRhdGEgYm91bmQgdG8gdGhlIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGdldCBkYXR1bSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9kYXR1bSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdGhpcy5fcGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0dW07XHJcbiAgICB9XHJcbiAgICBnZXQgcHJldmlvdXNEYXR1bSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNEYXR1bTtcclxuICAgIH1cclxuICAgIHNldCBkYXR1bShkYXR1bSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kYXR1bSAhPT0gZGF0dW0pXHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0dW0gPSB0aGlzLl9kYXR1bTtcclxuICAgICAgICB0aGlzLl9kYXR1bSA9IGRhdHVtO1xyXG4gICAgfVxyXG4gICAgX3NldExheWVyTWFuYWdlcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2xheWVyTWFuYWdlciA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2RlYnVnID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmRlYnVnO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY2hpbGQuX3NldExheWVyTWFuYWdlcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fdmlydHVhbENoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLl9zZXRMYXllck1hbmFnZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBsYXllck1hbmFnZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyTWFuYWdlcjtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgIH1cclxuICAgIGdldCBjaGlsZHJlbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fdmlydHVhbENoaWxkcmVuLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi50aGlzLl9jaGlsZHJlbl07XHJcbiAgICAgICAgZm9yIChjb25zdCBuZXh0IG9mIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCguLi5uZXh0LmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldCB2aXJ0dWFsQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGhhc1ZpcnR1YWxDaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlydHVhbENoaWxkcmVuLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBzZXRQcm9wZXJ0aWVzKHN0eWxlcywgcGlja0tleXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gcGlja0tleXMgIT09IG51bGwgJiYgcGlja0tleXMgIT09IHZvaWQgMCA/IHBpY2tLZXlzIDogT2JqZWN0LmtleXMoc3R5bGVzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHN0eWxlc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBvbmUgb3IgbW9yZSBuZXcgbm9kZSBpbnN0YW5jZXMgdG8gdGhpcyBwYXJlbnQuXHJcbiAgICAgKiBJZiBvbmUgbmVlZHMgdG86XHJcbiAgICAgKiAtIG1vdmUgYSBjaGlsZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKiAtIG1vdmUgYSBjaGlsZCBmcm9tIG9uZSBwYXJlbnQgdG8gYW5vdGhlciAoaW5jbHVkaW5nIHBhcmVudHMgaW4gb3RoZXIgc2NlbmVzKVxyXG4gICAgICogb25lIHNob3VsZCB1c2UgdGhlIHtAbGluayBpbnNlcnRCZWZvcmV9IG1ldGhvZCBpbnN0ZWFkLlxyXG4gICAgICogQHBhcmFtIG5vZGVzIEEgbm9kZSBvciBub2RlcyB0byBhcHBlbmQuXHJcbiAgICAgKi9cclxuICAgIGFwcGVuZChub2Rlcykge1xyXG4gICAgICAgIC8vIFBhc3NpbmcgYSBzaW5nbGUgcGFyYW1ldGVyIHRvIGFuIG9wZW4tZW5kZWQgdmVyc2lvbiBvZiBgYXBwZW5kYFxyXG4gICAgICAgIC8vIHdvdWxkIGJlIDMwLTM1JSBzbG93ZXIgdGhhbiB0aGlzLlxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcclxuICAgICAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bm9kZX0gYWxyZWFkeSBiZWxvbmdzIHRvIGFub3RoZXIgcGFyZW50OiAke25vZGUucGFyZW50fS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5sYXllck1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtub2RlfSBhbHJlYWR5IGJlbG9uZ3MgdG8gYSBzY2VuZTogJHtub2RlLmxheWVyTWFuYWdlcn0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRTZXRbbm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIENhc3QgdG8gYGFueWAgdG8gYXZvaWQgYFByb3BlcnR5ICduYW1lJyBkb2VzIG5vdCBleGlzdCBvbiB0eXBlICdGdW5jdGlvbidgLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IG5vZGU6ICR7bm9kZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5pc1ZpcnR1YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNoaWxkU2V0W25vZGUuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgbm9kZS5fcGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgbm9kZS5fc2V0TGF5ZXJNYW5hZ2VyKHRoaXMubGF5ZXJNYW5hZ2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXJ0eVpJbmRleCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgUmVkcmF3VHlwZS5NQUpPUik7XHJcbiAgICB9XHJcbiAgICBhcHBlbmRDaGlsZChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmQobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDaGlsZChub2RlKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGUuYCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgZXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuaXNWaXJ0dWFsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4uaW5kZXhPZihub2RlKTtcclxuICAgICAgICAgICAgaWYgKGkgPCAwKVxyXG4gICAgICAgICAgICAgICAgZXJyb3IoKTtcclxuICAgICAgICAgICAgdGhpcy5fdmlydHVhbENoaWxkcmVuLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaSA8IDApXHJcbiAgICAgICAgICAgICAgICBlcnJvcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkU2V0W25vZGUuaWRdO1xyXG4gICAgICAgIG5vZGUuX3BhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBub2RlLl9zZXRMYXllck1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLmRpcnR5WkluZGV4ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eShub2RlLCBSZWRyYXdUeXBlLk1BSk9SKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZUN1bXVsYXRpdmVNYXRyaXgoKSB7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XHJcbiAgICAgICAgY29uc3QgbWF0cml4ID0gTWF0cml4LmZseXdlaWdodCh0aGlzLm1hdHJpeCk7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcclxuICAgICAgICAgICAgbWF0cml4LnByZU11bHRpcGx5U2VsZihwYXJlbnQubWF0cml4KTtcclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybVBvaW50KHgsIHkpIHtcclxuICAgICAgICBjb25zdCBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZUN1bXVsYXRpdmVNYXRyaXgoKTtcclxuICAgICAgICByZXR1cm4gbWF0cml4LmludmVydFNlbGYoKS50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcclxuICAgIH1cclxuICAgIGludmVyc2VUcmFuc2Zvcm1Qb2ludCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVDdW11bGF0aXZlTWF0cml4KCk7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeC50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybUJCb3goYmJveCkge1xyXG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlQ3VtdWxhdGl2ZU1hdHJpeCgpO1xyXG4gICAgICAgIHJldHVybiBtYXRyaXguaW52ZXJ0U2VsZigpLnRyYW5zZm9ybUJCb3goYmJveCk7XHJcbiAgICB9XHJcbiAgICBpbnZlcnNlVHJhbnNmb3JtQkJveChiYm94KSB7XHJcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVDdW11bGF0aXZlTWF0cml4KCk7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeC50cmFuc2Zvcm1CQm94KGJib3gpO1xyXG4gICAgfVxyXG4gICAgbWFya0RpcnR5VHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHRoaXMuZGlydHlUcmFuc2Zvcm0gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIFJlZHJhd1R5cGUuTUFKT1IpO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoeyBpc1ZpcnR1YWwsIHRhZyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKiBVbmlxdWUgbnVtYmVyIHRvIGFsbG93IGNyZWF0aW9uIG9yZGVyIHRvIGJlIGVhc2lseSBkZXRlcm1pbmVkLiAqL1xyXG4gICAgICAgIHRoaXMuc2VyaWFsTnVtYmVyID0gTm9kZS5fbmV4dFNlcmlhbE51bWJlcisrO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuaXF1ZSBub2RlIElEIGluIHRoZSBmb3JtIGBDbGFzc05hbWUtTmF0dXJhbE51bWJlcmAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvIHNpbXBsaWZ5IHRoZSB0eXBlIHN5c3RlbSAoZXNwZWNpYWxseSBpbiBTZWxlY3Rpb25zKSB3ZSBkb24ndCBoYXZlIHRoZSBgUGFyZW50YCBub2RlXHJcbiAgICAgICAgICogKG9uZSB0aGF0IGhhcyBjaGlsZHJlbikuIEluc3RlYWQsIHdlIG1pbWljIEhUTUwgRE9NLCB3aGVyZSBhbnkgbm9kZSBjYW4gaGF2ZSBjaGlsZHJlbi5cclxuICAgICAgICAgKiBCdXQgd2Ugc3RpbGwgbmVlZCB0byBkaXN0aW5ndWlzaCByZWd1bGFyIGxlYWYgbm9kZXMgZnJvbSBjb250YWluZXIgbGVhZnMgc29tZWhvdy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzQ29udGFpbmVyTm9kZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XHJcbiAgICAgICAgLy8gVXNlZCB0byBjaGVjayBmb3IgZHVwbGljYXRlIG5vZGVzLlxyXG4gICAgICAgIHRoaXMuY2hpbGRTZXQgPSB7fTsgLy8gbmV3IFNldDxOb2RlPigpXHJcbiAgICAgICAgLy8gVGhlc2UgbWF0cmljZXMgbWF5IG5lZWQgdG8gaGF2ZSBwYWNrYWdlIGxldmVsIHZpc2liaWxpdHlcclxuICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHB1cnBvc2VzLlxyXG4gICAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIHRoaXMuaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICB0aGlzLmRpcnR5VHJhbnNmb3JtID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2FsaW5nWCA9IDE7XHJcbiAgICAgICAgdGhpcy5zY2FsaW5nWSA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNlbnRlciBvZiBzY2FsaW5nLlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGBudWxsYCBtZWFucyB0aGUgc2NhbGluZyBjZW50ZXIgd2lsbCBiZVxyXG4gICAgICAgICAqIGRldGVybWluZWQgYXV0b21hdGljYWxseSwgYXMgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgICAgICogb2YgYSBub2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NhbGluZ0NlbnRlclggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2NhbGluZ0NlbnRlclkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucm90YXRpb25DZW50ZXJYID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uQ2VudGVyWSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cclxuICAgICAgICAgKiBUaGUgdmFsdWUgaXMgc2V0IGFzIGlzLiBObyBub3JtYWxpemF0aW9uIHRvIHRoZSBbLTE4MCwgMTgwKSBvciBbMCwgMzYwKVxyXG4gICAgICAgICAqIGludGVydmFsIGlzIHBlcmZvcm1lZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IDA7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvblkgPSAwO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXJ0eVpJbmRleCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuekluZGV4ID0gMDtcclxuICAgICAgICAvKiogRGlzY3JpbWluYXRvcnMgZm9yIHJlbmRlciBvcmRlciB3aXRoaW4gYSB6SW5kZXguICovXHJcbiAgICAgICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnBvaW50ZXJFdmVudHMgPSBQb2ludGVyRXZlbnRzLkFsbDtcclxuICAgICAgICB0aGlzLmlzVmlydHVhbCA9IGlzVmlydHVhbCAhPT0gbnVsbCAmJiBpc1ZpcnR1YWwgIT09IHZvaWQgMCA/IGlzVmlydHVhbCA6IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGFnID0gdGFnICE9PSBudWxsICYmIHRhZyAhPT0gdm9pZCAwID8gdGFnIDogTmFOO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnNQb2ludChfeCwgX3kpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhpdCB0ZXN0aW5nIG1ldGhvZC5cclxuICAgICAqIFJlY3Vyc2l2ZWx5IGNoZWNrcyBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoaXMgbm9kZSBvciBhbnkgb2YgaXRzIGNoaWxkcmVuLlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSBvciBgdW5kZWZpbmVkYC5cclxuICAgICAqIE5vZGVzIHRoYXQgcmVuZGVyIGxhdGVyIChzaG93IG9uIHRvcCkgYXJlIGhpdCB0ZXN0ZWQgZmlyc3QuXHJcbiAgICAgKi9cclxuICAgIHBpY2tOb2RlKHgsIHkpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy5wb2ludGVyRXZlbnRzID09PSBQb2ludGVyRXZlbnRzLk5vbmUgfHwgIXRoaXMuY29udGFpbnNQb2ludCh4LCB5KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMTAwMCkge1xyXG4gICAgICAgICAgICAvLyBUcnkgdG8gb3B0aW1pc2Ugd2hpY2ggY2hpbGRyZW4gdG8gaW50ZXJyb2dhdGU7IEJCb3ggY2FsY3VsYXRpb24gaXMgYW4gYXBwcm94aW1hdGlvblxyXG4gICAgICAgICAgICAvLyBmb3IgbW9yZSBjb21wbGV4IHNoYXBlcywgc28gZGlzY2FyZGluZyBpdGVtcyBiYXNlZCBvbiB0aGlzIHdpbGwgc2F2ZSBhIGxvdCBvZlxyXG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHdoZW4gdGhlIHBvaW50IGlzIG5vd2hlcmUgbmVhciB0aGUgY2hpbGQuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5zUG9pbnQgPSAoX2EgPSBjaGlsZC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWluc1BvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGl0ID0gY29udGFpbnNQb2ludCA/IGNoaWxkLnBpY2tOb2RlKHgsIHkpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGVzIGFkZGVkIGxhdGVyIHNob3VsZCBiZSBoaXQtdGVzdGVkIGZpcnN0LFxyXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGFyZSByZW5kZXJlZCBvbiB0b3Agb2YgdGhlIHByZXZpb3VzbHkgYWRkZWQgbm9kZXMuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGl0ID0gY2hpbGRyZW5baV0ucGlja05vZGUoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdGhpcy5pc0NvbnRhaW5lck5vZGUpIHtcclxuICAgICAgICAgICAgLy8gYSBsZWFmIG5vZGUsIGJ1dCBub3QgYSBjb250YWluZXIgbGVhZlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kTm9kZXMocHJlZGljYXRlKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJlZGljYXRlKHRoaXMpID8gW3RoaXNdIDogW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVzdWx0ID0gY2hpbGQuZmluZE5vZGVzKHByZWRpY2F0ZSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uY2hpbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb21wdXRlVHJhbnNmb3JtZWRCQm94KCkge1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgaWYgKCFiYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xyXG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IE1hdHJpeC5mbHl3ZWlnaHQodGhpcy5tYXRyaXgpO1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XHJcbiAgICAgICAgICAgIG1hdHJpeC5wcmVNdWx0aXBseVNlbGYocGFyZW50Lm1hdHJpeCk7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdHJpeC50cmFuc2Zvcm1CQm94KGJib3gsIGJib3gpO1xyXG4gICAgICAgIHJldHVybiBiYm94O1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGlydHlUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IG1hdHJpeCwgc2NhbGluZ1gsIHNjYWxpbmdZLCByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblksIHNjYWxpbmdDZW50ZXJYLCBzY2FsaW5nQ2VudGVyWSwgcm90YXRpb25DZW50ZXJYLCByb3RhdGlvbkNlbnRlclksIH0gPSB0aGlzO1xyXG4gICAgICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBzY2FsaW5nWCwgc2NhbGluZ1ksIHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwge1xyXG4gICAgICAgICAgICBzY2FsaW5nQ2VudGVyWCxcclxuICAgICAgICAgICAgc2NhbGluZ0NlbnRlclksXHJcbiAgICAgICAgICAgIHJvdGF0aW9uQ2VudGVyWCxcclxuICAgICAgICAgICAgcm90YXRpb25DZW50ZXJZLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1hdHJpeC5pbnZlcnNlVG8odGhpcy5pbnZlcnNlTWF0cml4KTtcclxuICAgICAgICB0aGlzLmRpcnR5VHJhbnNmb3JtID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZW5kZXIocmVuZGVyQ3R4KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gUmVkcmF3VHlwZS5OT05FO1xyXG4gICAgICAgIGlmIChzdGF0cylcclxuICAgICAgICAgICAgc3RhdHMubm9kZXNSZW5kZXJlZCsrO1xyXG4gICAgfVxyXG4gICAgY2xlYXJCQm94KGN0eCkge1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgaWYgKGJib3ggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gYmJveDtcclxuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcclxuICAgICAgICBjb25zdCBib3R0b21SaWdodCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICBjdHguY2xlYXJSZWN0KHRvcExlZnQueCwgdG9wTGVmdC55LCBib3R0b21SaWdodC54IC0gdG9wTGVmdC54LCBib3R0b21SaWdodC55IC0gdG9wTGVmdC55KTtcclxuICAgIH1cclxuICAgIG1hcmtEaXJ0eShfc291cmNlLCB0eXBlID0gUmVkcmF3VHlwZS5UUklWSUFMLCBwYXJlbnRUeXBlID0gdHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSA+IHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGlydHkgPT09IHR5cGUgJiYgdHlwZSA9PT0gcGFyZW50VHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHlwZTtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQubWFya0RpcnR5KHRoaXMsIHBhcmVudFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xyXG4gICAgICAgICAgICB0aGlzLmxheWVyTWFuYWdlci5tYXJrRGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZGlydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xyXG4gICAgfVxyXG4gICAgbWFya0NsZWFuKG9wdHMpIHtcclxuICAgICAgICBjb25zdCB7IGZvcmNlID0gZmFsc2UsIHJlY3Vyc2l2ZSA9IHRydWUgfSA9IG9wdHMgIT09IG51bGwgJiYgb3B0cyAhPT0gdm9pZCAwID8gb3B0cyA6IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSA9PT0gUmVkcmF3VHlwZS5OT05FICYmICFmb3JjZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gUmVkcmF3VHlwZS5OT05FO1xyXG4gICAgICAgIGlmIChyZWN1cnNpdmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fdmlydHVhbENoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oeyBmb3JjZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVjdXJzaXZlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLm1hcmtDbGVhbih7IGZvcmNlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmlzaWJpbGl0eUNoYW5nZWQoKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgcG9pbnQgZm9yIHN1Yi1jbGFzc2VzIHRvIHJlYWN0IHRvIHZpc2liaWxpdHkgY2hhbmdlcy5cclxuICAgIH1cclxuICAgIGdldCBub2RlQ291bnQoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcclxuICAgICAgICBsZXQgZGlydHlDb3VudCA9IHRoaXMuX2RpcnR5ID49IFJlZHJhd1R5cGUuTk9ORSB8fCB0aGlzLmRpcnR5VHJhbnNmb3JtID8gMSA6IDA7XHJcbiAgICAgICAgbGV0IHZpc2libGVDb3VudCA9IHRoaXMudmlzaWJsZSA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGNvdW50Q2hpbGQgPSAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBjb3VudDogY2hpbGRDb3VudCwgdmlzaWJsZUNvdW50OiBjaGlsZFZpc2libGVDb3VudCwgZGlydHlDb3VudDogY2hpbGREaXJ0eUNvdW50IH0gPSBjaGlsZC5ub2RlQ291bnQ7XHJcbiAgICAgICAgICAgIGNvdW50ICs9IGNoaWxkQ291bnQ7XHJcbiAgICAgICAgICAgIHZpc2libGVDb3VudCArPSBjaGlsZFZpc2libGVDb3VudDtcclxuICAgICAgICAgICAgZGlydHlDb3VudCArPSBjaGlsZERpcnR5Q291bnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX2NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNvdW50Q2hpbGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb3VudENoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgY291bnQsIHZpc2libGVDb3VudCwgZGlydHlDb3VudCB9O1xyXG4gICAgfVxyXG4gICAgekluZGV4Q2hhbmdlZCgpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCBmb3Igc3ViLWNsYXNzZXMuXHJcbiAgICB9XHJcbn1cclxuTm9kZS5fbmV4dFNlcmlhbE51bWJlciA9IDA7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiAndHJhbnNmb3JtJyB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIE5vZGUucHJvdG90eXBlLCBcInNjYWxpbmdYXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiAndHJhbnNmb3JtJyB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIE5vZGUucHJvdG90eXBlLCBcInNjYWxpbmdZXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiAndHJhbnNmb3JtJyB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIE5vZGUucHJvdG90eXBlLCBcInNjYWxpbmdDZW50ZXJYXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiAndHJhbnNmb3JtJyB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIE5vZGUucHJvdG90eXBlLCBcInNjYWxpbmdDZW50ZXJZXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiAndHJhbnNmb3JtJyB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIE5vZGUucHJvdG90eXBlLCBcInJvdGF0aW9uQ2VudGVyWFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogJ3RyYW5zZm9ybScgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBOb2RlLnByb3RvdHlwZSwgXCJyb3RhdGlvbkNlbnRlcllcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6ICd0cmFuc2Zvcm0nIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTm9kZS5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6ICd0cmFuc2Zvcm0nIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTm9kZS5wcm90b3R5cGUsIFwidHJhbnNsYXRpb25YXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiAndHJhbnNmb3JtJyB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIE5vZGUucHJvdG90eXBlLCBcInRyYW5zbGF0aW9uWVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SLCBjaGFuZ2VDYjogKG8pID0+IG8udmlzaWJpbGl0eUNoYW5nZWQoKSB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBOb2RlLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xyXG4gICAgICAgIHJlZHJhdzogUmVkcmF3VHlwZS5UUklWSUFMLFxyXG4gICAgICAgIGNoYW5nZUNiOiB6SW5kZXhDaGFuZ2VkQ2FsbGJhY2ssXHJcbiAgICB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIE5vZGUucHJvdG90eXBlLCBcInpJbmRleFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcclxuICAgICAgICByZWRyYXc6IFJlZHJhd1R5cGUuVFJJVklBTCxcclxuICAgICAgICBjaGFuZ2VDYjogekluZGV4Q2hhbmdlZENhbGxiYWNrLFxyXG4gICAgfSlcclxuICAgIC8qKiBEaXNjcmltaW5hdG9ycyBmb3IgcmVuZGVyIG9yZGVyIHdpdGhpbiBhIHpJbmRleC4gKi9cclxuICAgICxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgTm9kZS5wcm90b3R5cGUsIFwiekluZGV4U3ViT3JkZXJcIiwgdm9pZCAwKTtcblxuY2xhc3MgRHJvcFNoYWRvdyBleHRlbmRzIENoYW5nZURldGVjdGFibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjUpJztcclxuICAgICAgICB0aGlzLnhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMueU9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5ibHVyID0gNTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKSxcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKSxcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwieE9mZnNldFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKCkpLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJ5T2Zmc2V0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJibHVyXCIsIHZvaWQgMCk7XG5cbmNvbnN0IE1PQklMRSA9IFsvQW5kcm9pZC9pLCAvd2ViT1MvaSwgL2lQaG9uZS9pLCAvaVBhZC9pLCAvaVBvZC9pLCAvQmxhY2tCZXJyeS9pLCAvV2luZG93cyBQaG9uZS9pXTtcclxuZnVuY3Rpb24gaXNEZXNrdG9wKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgcmV0dXJuICFNT0JJTEUuc29tZSgocikgPT4gci50ZXN0KHVzZXJBZ2VudCkpO1xyXG59XG5cbi8qKlxyXG4gKiBXcmFwcyB0aGUgbmF0aXZlIENhbnZhcyBlbGVtZW50IGFuZCBvdmVycmlkZXMgaXRzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB0b1xyXG4gKiBwcm92aWRlIHJlc29sdXRpb24gaW5kZXBlbmRlbnQgcmVuZGVyaW5nIGJhc2VkIG9uIGB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb2AuXHJcbiAqL1xyXG5jbGFzcyBIZHBpQ2FudmFzIHtcclxuICAgIC8vIFRoZSB3aWR0aC9oZWlnaHQgYXR0cmlidXRlcyBvZiB0aGUgQ2FudmFzIGVsZW1lbnQgZGVmYXVsdCB0b1xyXG4gICAgLy8gMzAwLzE1MCBhY2NvcmRpbmcgdG8gdzMub3JnLlxyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIGBOYU5gIGlzIGRlbGliZXJhdGUgaGVyZSwgc28gdGhhdCBvdmVycmlkZXMgYXJlIGFsd2F5cyBhcHBsaWVkXHJcbiAgICAgICAgLy8gYW5kIHRoZSBgcmVzZXRUcmFuc2Zvcm1gIGluc2lkZSB0aGUgYHJlc2l6ZWAgbWV0aG9kIHdvcmtzIGluIElFMTEuXHJcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpbyA9IE5hTjtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gMDtcclxuICAgICAgICBjb25zdCB7IGRvY3VtZW50LCB3aW5kb3csIHdpZHRoID0gNjAwLCBoZWlnaHQgPSAzMDAsIGRvbUxheWVyID0gZmFsc2UsIHpJbmRleCA9IDAsIG5hbWUgPSB1bmRlZmluZWQsIG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZCwgfSA9IG9wdHM7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xyXG4gICAgICAgIEhkcGlDYW52YXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgICAgICAvLyBDcmVhdGUgY2FudmFzIGFuZCBpbW1lZGlhdGVseSBhcHBseSB3aWR0aCArIGhlaWdodCB0byBhdm9pZCBvdXQtb2YtbWVtb3J5XHJcbiAgICAgICAgLy8gZXJyb3JzIG9uIGlPUy9pUGFkT1MgU2FmYXJpLlxyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5yZWFsQ29udGV4dCA9IHRoaXMuZWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VTb3VyY2UgPSB0aGlzLnJlYWxDb250ZXh0LmNhbnZhcztcclxuICAgICAgICBjb25zdCB7IHN0eWxlIH0gPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcclxuICAgICAgICBzdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICBpZiAoZG9tTGF5ZXIpIHtcclxuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICBzdHlsZS56SW5kZXggPSBTdHJpbmcoekluZGV4KTtcclxuICAgICAgICAgICAgc3R5bGUudG9wID0gJzAnO1xyXG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0gJzAnO1xyXG4gICAgICAgICAgICBzdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBzdHlsZS5vcGFjaXR5ID0gYDFgO1xyXG4gICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmlkID0gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnNldFBpeGVsUmF0aW8ob3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvKTtcclxuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHNldCBjb250YWluZXIodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgc2V0IGVuYWJsZWQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gJ2Jsb2NrJyA6ICdub25lJztcclxuICAgICAgICB0aGlzLl9lbmFibGVkID0gISF2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBlbmFibGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlKCkge1xyXG4gICAgICAgIGNvbnN0IHsgcGFyZW50Tm9kZSB9ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnROb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIC8vIFdvcmthcm91bmQgbWVtb3J5IGFsbG9jYXRpb24gcXVpcmtzIGluIGlPUyBTYWZhcmkgYnkgcmVzaXppbmcgdG8gMHgwIGFuZCBjbGVhcmluZy5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTMyNS5cclxuICAgICAgICB0aGlzLmVsZW1lbnQud2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcclxuICAgIH1cclxuICAgIHNuYXBzaG90KCkge1xyXG4gICAgICAgIC8vIE5vLW9wIGZvciBjb21wYXRpYmlsaXR5IHdpdGggSGRwaU9mZnNjcmVlbkNhbnZhcy5cclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIHRvSW1hZ2UoKSB7XHJcbiAgICAgICAgY29uc3QgaW1nID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICAgICAgICBpbWcuc3JjID0gdGhpcy5nZXREYXRhVVJMKCk7XHJcbiAgICAgICAgcmV0dXJuIGltZztcclxuICAgIH1cclxuICAgIGdldERhdGFVUkwodHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQudG9EYXRhVVJMKHR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZmlsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGRvd25sb2FkZWQgZmlsZS5cclxuICAgICAqIEBwYXJhbSBmaWxlRm9ybWF0IFRoZSBmaWxlIGZvcm1hdCwgdGhlIGRlZmF1bHQgaXMgYGltYWdlL3BuZ2BcclxuICAgICAqL1xyXG4gICAgZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQgPSAnaW1hZ2UvcG5nJykge1xyXG4gICAgICAgIGZpbGVOYW1lID0gKGZpbGVOYW1lICE9PSBudWxsICYmIGZpbGVOYW1lICE9PSB2b2lkIDAgPyBmaWxlTmFtZSA6ICcnKS50cmltKCkgfHwgJ2ltYWdlJztcclxuICAgICAgICBjb25zdCBkYXRhVXJsID0gdGhpcy5nZXREYXRhVVJMKGZpbGVGb3JtYXQpO1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcclxuICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIGEuaHJlZiA9IGRhdGFVcmw7XHJcbiAgICAgICAgYS5kb3dubG9hZCA9IGZpbGVOYW1lO1xyXG4gICAgICAgIGEuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpOyAvLyByZXF1aXJlZCBmb3IgdGhlIGBjbGlja2AgdG8gd29yayBpbiBGaXJlZm94XHJcbiAgICAgICAgYS5jbGljaygpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGl4ZWxSYXRpbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgcGl4ZWwgcmF0aW8gb2YgdGhlIENhbnZhcyBlbGVtZW50IHRvIHRoZSBnaXZlbiB2YWx1ZSxcclxuICAgICAqIG9yIHVzZXMgdGhlIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIChkZWZhdWx0KSwgdGhlbiByZXNpemVzIHRoZSBDYW52YXNcclxuICAgICAqIGVsZW1lbnQgYWNjb3JkaW5nbHkgKGRlZmF1bHQpLlxyXG4gICAgICovXHJcbiAgICBzZXRQaXhlbFJhdGlvKHJhdGlvKSB7XHJcbiAgICAgICAgbGV0IHBpeGVsUmF0aW8gPSByYXRpbyAhPT0gbnVsbCAmJiByYXRpbyAhPT0gdm9pZCAwID8gcmF0aW8gOiB0aGlzLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgIGlmICghaXNEZXNrdG9wKCkpIHtcclxuICAgICAgICAgICAgLy8gTW9iaWxlIGJyb3dzZXJzIGhhdmUgc3RyaWN0ZXIgbWVtb3J5IGxpbWl0cywgd2UgcmVkdWNlIHJlbmRlcmluZyByZXNvbHV0aW9uIHRvXHJcbiAgICAgICAgICAgIC8vIGltcHJvdmUgc3RhYmlsaXR5IG9uIG1vYmlsZSBicm93c2Vycy4gaU9TIFNhZmFyaSAxMi0+MTYgYXJlIHBhaW4tcG9pbnRzIHNpbmNlIHRoZXlcclxuICAgICAgICAgICAgLy8gaGF2ZSBtZW1vcnkgYWxsb2NhdGlvbiBxdWlya3MgLSBzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTMyNS5cclxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xyXG4gICAgICAgIHJldHVybiBIZHBpQ2FudmFzLm92ZXJyaWRlU2NhbGUodGhpcy5yZWFsQ29udGV4dCwgcGl4ZWxSYXRpbyk7XHJcbiAgICB9XHJcbiAgICBzZXQgcGl4ZWxhdGVkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmltYWdlUmVuZGVyaW5nID0gdmFsdWUgPyAncGl4ZWxhdGVkJyA6ICdhdXRvJztcclxuICAgIH1cclxuICAgIGdldCBwaXhlbGF0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zdHlsZS5pbWFnZVJlbmRlcmluZyA9PT0gJ3BpeGVsYXRlZCc7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAoISh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGNvbnRleHQsIHBpeGVsUmF0aW8gfSA9IHRoaXM7XHJcbiAgICAgICAgZWxlbWVudC53aWR0aCA9IE1hdGgucm91bmQod2lkdGggKiBwaXhlbFJhdGlvKTtcclxuICAgICAgICBlbGVtZW50LmhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcbiAgICAgICAgY29udGV4dC5yZXNldFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCB0ZXh0TWVhc3VyaW5nQ29udGV4dCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dE1lYXN1cmluZ0NvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRNZWFzdXJpbmdDb250ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuX3RleHRNZWFzdXJpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRNZWFzdXJpbmdDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBzdmdUZXh0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdmdUZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdmdUZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAnc3ZnJyk7XHJcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJyk7XHJcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEwMCcpO1xyXG4gICAgICAgIC8vIEFkZCBhIGRlc2NyaXB0aXZlIGNsYXNzIG5hbWUgaW4gY2FzZSBzb21lb25lIHNlZXMgdGhpcyBTVkcgZWxlbWVudFxyXG4gICAgICAgIC8vIGluIGRldnRvb2xzIGFuZCB3b25kZXJzIGFib3V0IGl0cyBwdXJwb3NlOlxyXG4gICAgICAgIGlmIChzdmcuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIHN2Zy5jbGFzc0xpc3QuYWRkKCd0ZXh0LW1lYXN1cmluZy1zdmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3RleHQtbWVhc3VyaW5nLXN2ZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdmcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHN2Zy5zdHlsZS50b3AgPSAnLTEwMDBweCc7XHJcbiAgICAgICAgc3ZnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICAgICAgICBjb25zdCBzdmdUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHhtbG5zLCAndGV4dCcpO1xyXG4gICAgICAgIHN2Z1RleHQuc2V0QXR0cmlidXRlKCd4JywgJzAnKTtcclxuICAgICAgICBzdmdUZXh0LnNldEF0dHJpYnV0ZSgneScsICczMCcpO1xyXG4gICAgICAgIHN2Z1RleHQuc2V0QXR0cmlidXRlKCd0ZXh0JywgJ2JsYWNrJyk7XHJcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHN2Z1RleHQpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcclxuICAgICAgICB0aGlzLl9zdmdUZXh0ID0gc3ZnVGV4dDtcclxuICAgICAgICByZXR1cm4gc3ZnVGV4dDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgaGFzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oYXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNDaHJvbWUgPSB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTE7XHJcbiAgICAgICAgY29uc3QgaXNGaXJlZm94ID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMTtcclxuICAgICAgICBjb25zdCBpc1NhZmFyaSA9ICFpc0Nocm9tZSAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpID4gLTE7XHJcbiAgICAgICAgdGhpcy5faGFzID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgICAgIHRleHRNZXRyaWNzOiB0aGlzLnRleHRNZWFzdXJpbmdDb250ZXh0Lm1lYXN1cmVUZXh0KCd0ZXN0JykuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggaW1wbGVtZW50ZWQgYWR2YW5jZWQgVGV4dE1ldHJpY3Mgb2JqZWN0IGluIHY3NDpcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMDI1ODRcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCdzIGJ1Z2d5LCBzbyB3ZSdsbCBrZWVwIHVzaW5nIHRoZSBTVkcgZm9yIHRleHQgbWVhc3VyZW1lbnQgaW4gRmlyZWZveCBmb3Igbm93LlxyXG4gICAgICAgICAgICAgICAgIWlzRmlyZWZveCAmJlxyXG4gICAgICAgICAgICAgICAgIWlzU2FmYXJpLFxyXG4gICAgICAgICAgICBnZXRUcmFuc2Zvcm06IHRoaXMudGV4dE1lYXN1cmluZ0NvbnRleHQuZ2V0VHJhbnNmb3JtICE9PSB1bmRlZmluZWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0LCBmb250LCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbikge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMudGV4dE1lYXN1cmluZ0NvbnRleHQ7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBmb250O1xyXG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcclxuICAgICAgICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBtZWFzdXJlZCB0ZXh0LlxyXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHNpbmdsZS1saW5lIHRleHQgdG8gbWVhc3VyZS5cclxuICAgICAqIEBwYXJhbSBmb250IFRoZSBmb250IHNob3J0aGFuZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRUZXh0U2l6ZSh0ZXh0LCBmb250KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzLnRleHRNZXRyaWNzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMudGV4dE1lYXN1cmluZ0NvbnRleHQ7XHJcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udDtcclxuICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZWFzdXJlU3ZnVGV4dCh0ZXh0LCBmb250KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWVhc3VyZVN2Z1RleHQodGV4dCwgZm9udCkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy50ZXh0U2l6ZUNhY2hlO1xyXG4gICAgICAgIGNvbnN0IGZvbnRDYWNoZSA9IGNhY2hlW2ZvbnRdO1xyXG4gICAgICAgIC8vIE5vdGU6IGNvbnNpZGVyIG5vdCBjYWNoaW5nIHRoZSBzaXplIG9mIG51bWVyaWMgc3RyaW5ncy5cclxuICAgICAgICAvLyBGb3IgZXhhbXBsZTogaWYgKGlzTmFOKCt0ZXh0KSkgeyAvLyBza2lwXHJcbiAgICAgICAgaWYgKGZvbnRDYWNoZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gZm9udENhY2hlW3RleHRdO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhY2hlW2ZvbnRdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN2Z1RleHQgPSB0aGlzLnN2Z1RleHQ7XHJcbiAgICAgICAgc3ZnVGV4dC5zdHlsZS5mb250ID0gZm9udDtcclxuICAgICAgICBzdmdUZXh0LnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgICAgICAvLyBgZ2V0QkJveGAgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBgU1ZHUmVjdGAgd2l0aCB0aGUgc2FtZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YFxyXG4gICAgICAgIC8vIG1lYXN1cmVtZW50cyBhcyBgRE9NUmVjdGAgaW5zdGFuY2UgcmV0dXJuZWQgYnkgdGhlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgLlxyXG4gICAgICAgIC8vIEJ1dCB0aGUgYFNWR1JlY3RgIGluc3RhbmNlIGhhcyBoYWxmIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgRE9NUmVjdGAsXHJcbiAgICAgICAgLy8gc28gd2UgdXNlIHRoZSBgZ2V0QkJveGAgbWV0aG9kLlxyXG4gICAgICAgIGNvbnN0IGJib3ggPSBzdmdUZXh0LmdldEJCb3goKTtcclxuICAgICAgICBjb25zdCBzaXplID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogYmJveC53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBiYm94LmhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNhY2hlW2ZvbnRdW3RleHRdID0gc2l6ZTtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBvdmVycmlkZVNjYWxlKGN0eCwgc2NhbGUpIHtcclxuICAgICAgICBsZXQgZGVwdGggPSAwO1xyXG4gICAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IHtcclxuICAgICAgICAgICAgc2F2ZSgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNhdmUoKTtcclxuICAgICAgICAgICAgICAgIGRlcHRoKys7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RvcmUoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kcmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIFVuYWJsZSB0byByZXN0b3JlKCkgcGFzdCBkZXB0aCAwJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0VHJhbnNmb3JtKGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0VHJhbnNmb3JtKGEgKiBzY2FsZSwgYiAqIHNjYWxlLCBjICogc2NhbGUsIGQgKiBzY2FsZSwgZSAqIHNjYWxlLCBmICogc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXNldFRyYW5zZm9ybSgpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFzIG9mIEphbiA4LCAyMDE5LCBgcmVzZXRUcmFuc2Zvcm1gIGlzIHN0aWxsIGFuIFwiZXhwZXJpbWVudGFsIHRlY2hub2xvZ3lcIixcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBkb2Vzbid0IHdvcmsgaW4gSUUxMSBhbmQgRWRnZSA0NC5cclxuICAgICAgICAgICAgICAgIHRoaXMuJHNldFRyYW5zZm9ybShzY2FsZSwgMCwgMCwgc2NhbGUsIDAsIDApO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB2ZXJpZnlEZXB0aFplcm8oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIFNhdmUvcmVzdG9yZSBkZXB0aCBpcyBub24temVybzogJyArIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdmVycmlkZXMsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIG5hdGl2ZSBtZXRob2RzIHVuZGVyIHByZWZpeGVkIG5hbWVzLFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBoYXNuJ3QgYmVlbiBkb25lIGJ5IHRoZSBwcmV2aW91cyBvdmVycmlkZXMgYWxyZWFkeS5cclxuICAgICAgICAgICAgICAgIGlmICghY3R4WyckJyArIG5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4WyckJyArIG5hbWVdID0gY3R4W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBuYXRpdmUgbWV0aG9kcyB3aXRoIG92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIC8vIG9yIHByZXZpb3VzIG92ZXJyaWRlcyB3aXRoIHRoZSBuZXcgb25lcy5cclxuICAgICAgICAgICAgICAgIGN0eFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3R4O1xyXG4gICAgfVxyXG59XHJcbkhkcGlDYW52YXMuZG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50O1xyXG5IZHBpQ2FudmFzLnRleHRTaXplQ2FjaGUgPSB7fTtcblxuY2xhc3MgR3JhZGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wcyA9IFtdO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIExpbmVhckdyYWRpZW50IGV4dGVuZHMgR3JhZGllbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmFuZ2xlID0gMDtcclxuICAgIH1cclxuICAgIGNyZWF0ZUdyYWRpZW50KGN0eCwgYmJveCkge1xyXG4gICAgICAgIC8vIEdyYWRpZW50IDDCsCBhbmdsZSBzdGFydHMgYXQgdG9wIGFjY29yZGluZyB0byBDU1Mgc3BlY1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gOTA7XHJcbiAgICAgICAgY29uc3QgeyBzdG9wcywgYW5nbGUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgcmFkaWFucyA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucyhhbmdsZSArIGFuZ2xlT2Zmc2V0KSk7XHJcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XHJcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XHJcbiAgICAgICAgY29uc3QgdyA9IGJib3gud2lkdGg7XHJcbiAgICAgICAgY29uc3QgaCA9IGJib3guaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGN4ID0gYmJveC54ICsgdyAqIDAuNTtcclxuICAgICAgICBjb25zdCBjeSA9IGJib3gueSArIGggKiAwLjU7XHJcbiAgICAgICAgaWYgKHcgPiAwICYmIGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpYWdvbmFsID0gTWF0aC5zcXJ0KGggKiBoICsgdyAqIHcpIC8gMjtcclxuICAgICAgICAgICAgY29uc3QgZGlhZ29uYWxBbmdsZSA9IE1hdGguYXRhbjIoaCwgdyk7XHJcbiAgICAgICAgICAgIGxldCBxdWFydGVyZWRBbmdsZTtcclxuICAgICAgICAgICAgaWYgKHJhZGlhbnMgPCBNYXRoLlBJIC8gMikge1xyXG4gICAgICAgICAgICAgICAgcXVhcnRlcmVkQW5nbGUgPSByYWRpYW5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJhZGlhbnMgPCBNYXRoLlBJKSB7XHJcbiAgICAgICAgICAgICAgICBxdWFydGVyZWRBbmdsZSA9IE1hdGguUEkgLSByYWRpYW5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJhZGlhbnMgPCAoMyAqIE1hdGguUEkpIC8gMikge1xyXG4gICAgICAgICAgICAgICAgcXVhcnRlcmVkQW5nbGUgPSByYWRpYW5zIC0gTWF0aC5QSTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1YXJ0ZXJlZEFuZ2xlID0gMiAqIE1hdGguUEkgLSByYWRpYW5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGwgPSBkaWFnb25hbCAqIE1hdGguYWJzKE1hdGguY29zKHF1YXJ0ZXJlZEFuZ2xlIC0gZGlhZ29uYWxBbmdsZSkpO1xyXG4gICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChjeCArIGNvcyAqIGwsIGN5ICsgc2luICogbCwgY3ggLSBjb3MgKiBsLCBjeSAtIHNpbiAqIGwpO1xyXG4gICAgICAgICAgICBzdG9wcy5mb3JFYWNoKChzdG9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIHN0b3AuY29sb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ2JsYWNrJztcclxuICAgIH1cclxufVxuXG5jb25zdCBMSU5FQVJfR1JBRElFTlRfUkVHRVhQID0gL15saW5lYXItZ3JhZGllbnRcXCgoLio/KWRlZyxcXHMqKC4qPylcXHMqXFwpJC9pO1xyXG5jbGFzcyBTaGFwZSBleHRlbmRzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuZmlsbCA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuZmlsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlIHRoYXQgYHN0cm9rZVN0eWxlID0gbnVsbGAgbWVhbnMgaW52aXNpYmxlIHN0cm9rZSxcclxuICAgICAgICAgKiB3aGlsZSBgbGluZVdpZHRoID0gMGAgbWVhbnMgbm8gc3Ryb2tlLCBhbmQgc29tZXRpbWVzIHRoaXMgY2FuIG1lYW4gZGlmZmVyZW50IHRoaW5ncy5cclxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgYSByZWN0IHNoYXBlIHdpdGggYW4gaW52aXNpYmxlIHN0cm9rZSBtYXkgbm90IGFsaWduIHRvIHRoZSBwaXhlbCBncmlkXHJcbiAgICAgICAgICogcHJvcGVybHkgYmVjYXVzZSB0aGUgc3Ryb2tlIGFmZmVjdHMgdGhlIHJ1bGVzIG9mIGFsaWdubWVudCwgYW5kIGFyYyBzaGFwZXMgZm9ybWluZ1xyXG4gICAgICAgICAqIGEgcGllIGNoYXJ0IHdpbGwgaGF2ZSBhIGdhcCBiZXR3ZWVuIHRoZW0gaWYgdGhleSBoYXZlIGFuIGludmlzaWJsZSBzdHJva2UsIHdoZXJlYXNcclxuICAgICAgICAgKiB0aGVyZSB3b3VsZCBiZSBub3QgZ2FwIGlmIHRoZXJlIHdhcyBubyBzdHJva2UgYXQgYWxsLlxyXG4gICAgICAgICAqIFRoZSBwcmVmZXJyZWQgd2F5IG9mIG1ha2luZyB0aGUgc3Ryb2tlIGludmlzaWJsZSBpcyBzZXR0aW5nIHRoZSBgbGluZVdpZHRoYCB0byB6ZXJvLFxyXG4gICAgICAgICAqIHVubGVzcyBzcGVjaWZpYyBsb29rcyB0aGF0IGlzIGFjaGlldmVkIGJ5IGhhdmluZyBhbiBpbnZpc2libGUgc3Ryb2tlIGlzIGRlc2lyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdHJva2UgPSBTaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZTtcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcclxuICAgICAgICB0aGlzLmxpbmVEYXNoID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5saW5lRGFzaDtcclxuICAgICAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5saW5lRGFzaE9mZnNldDtcclxuICAgICAgICB0aGlzLmxpbmVDYXAgPSBTaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVDYXA7XHJcbiAgICAgICAgdGhpcy5saW5lSm9pbiA9IFNoYXBlLmRlZmF1bHRTdHlsZXMubGluZUpvaW47XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gU2hhcGUuZGVmYXVsdFN0eWxlcy5vcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuZmlsbFNoYWRvdyA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuZmlsbFNoYWRvdztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzdG9yZXMgdGhlIGRlZmF1bHQgc3R5bGVzIGludHJvZHVjZWQgYnkgdGhpcyBzdWJjbGFzcy5cclxuICAgICAqL1xyXG4gICAgcmVzdG9yZU93blN0eWxlcygpIHtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdHlsZXM7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0eWxlcyk7XHJcbiAgICAgICAgLy8gZ2V0T3duUHJvcGVydHlOYW1lcyBpcyBhYm91dCAyLjUgdGltZXMgZmFzdGVyIHRoYW5cclxuICAgICAgICAvLyBmb3IuLmluIHdpdGggdGhlIGhhc093blByb3BlcnR5IGNoZWNrIGFuZCBpbiB0aGlzXHJcbiAgICAgICAgLy8gY2FzZSwgd2hlcmUgbW9zdCBwcm9wZXJ0aWVzIGFyZSBpbmhlcml0ZWQsIGNhbiBiZVxyXG4gICAgICAgIC8vIG1vcmUgdGhhbiBhbiBvcmRlciBvZiBtYWduaXR1ZGUgZmFzdGVyLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgdGhpc1trZXldID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlR3JhZGllbnQoKSB7XHJcbiAgICAgICAgY29uc3QgeyBmaWxsIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCBsaW5lYXJHcmFkaWVudE1hdGNoO1xyXG4gICAgICAgIGlmICgoZmlsbCA9PT0gbnVsbCB8fCBmaWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsLnN0YXJ0c1dpdGgoJ2xpbmVhci1ncmFkaWVudCcpKSAmJiAobGluZWFyR3JhZGllbnRNYXRjaCA9IExJTkVBUl9HUkFESUVOVF9SRUdFWFAuZXhlYyhmaWxsKSkpIHtcclxuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBwYXJzZUZsb2F0KGxpbmVhckdyYWRpZW50TWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvcnMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JzUGFydCA9IGxpbmVhckdyYWRpZW50TWF0Y2hbMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yUmVnZXggPSAvKCNbMC05YS1mXSspfChyZ2JhP1xcKC4rP1xcKSl8KFthLXpdKykvZ2k7XHJcbiAgICAgICAgICAgIGxldCBjO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGMgPSBjb2xvclJlZ2V4LmV4ZWMoY29sb3JzUGFydCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChjWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50ID0gbmV3IExpbmVhckdyYWRpZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnQuYW5nbGUgPSBhbmdsZTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudC5zdG9wcyA9IGNvbG9ycy5tYXAoKGNvbG9yLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggLyAoY29sb3JzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2Zmc2V0LCBjb2xvciB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZGV2aWNlLXBpeGVsIGFsaWduZWQgY29vcmRpbmF0ZSAob3IgbGVuZ3RoIGlmIGxlbmd0aCBpcyBzdXBwbGllZCkuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogTm90IHN1aXRhYmxlIGZvciBzdHJva2VzLCBzaW5jZSB0aGUgc3Ryb2tlIG5lZWRzIHRvIGJlIG9mZnNldCB0byB0aGUgbWlkZGxlXHJcbiAgICAgKiBvZiBhIGRldmljZSBwaXhlbC5cclxuICAgICAqL1xyXG4gICAgYWxpZ24oc3RhcnQsIGxlbmd0aCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmxheWVyTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbnZhcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBpeGVsUmF0aW8pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDE7XHJcbiAgICAgICAgY29uc3QgYWxpZ25lZFN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICBpZiAobGVuZ3RoID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWxpZ25lZFN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAvLyBBdm9pZCBoaWRpbmcgY3Jpc3Agc2hhcGVzXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgcm91bmRpbmcgb2YgYWxpZ25lZFN0YXJ0IGJ5IGluY3JlYXNpbmcgbGVuZ3RoIHRvIGNvbXBlbnNhdGUgYmVmb3JlXHJcbiAgICAgICAgLy8gYWxpZ25tZW50LlxyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChsZW5ndGggKyBzdGFydCkgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW8gLSBhbGlnbmVkU3RhcnQ7XHJcbiAgICB9XHJcbiAgICBmaWxsU3Ryb2tlKGN0eCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRmlsbChjdHgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU3Ryb2tlKGN0eCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXJGaWxsKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGwpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBnbG9iYWxBbHBoYSB9ID0gY3R4O1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5RmlsbChjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5RmlsbEFscGhhKGN0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTaGFkb3coY3R4KTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDApJztcclxuICAgIH1cclxuICAgIGFwcGx5RmlsbChjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5ncmFkaWVudCkge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5ncmFkaWVudC5jcmVhdGVHcmFkaWVudChjdHgsIHRoaXMuY29tcHV0ZUJCb3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFwcGx5RmlsbEFscGhhKGN0eCkge1xyXG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYSAqIHRoaXMub3BhY2l0eSAqIHRoaXMuZmlsbE9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBhcHBseVNoYWRvdyhjdHgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIFRoZSBjYW52YXMgY29udGV4dCBzY2FsaW5nIChkZXBlbmRzIG9uIHRoZSBkZXZpY2UncyBwaXhlbCByYXRpbylcclxuICAgICAgICAvLyBoYXMgbm8gZWZmZWN0IG9uIHNoYWRvd3MsIHNvIHdlIGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlIHBpeGVsIHJhdGlvXHJcbiAgICAgICAgLy8gbWFudWFsbHkgaGVyZS5cclxuICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gKF9iID0gKF9hID0gdGhpcy5sYXllck1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW52YXMucGl4ZWxSYXRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICBjb25zdCBmaWxsU2hhZG93ID0gdGhpcy5maWxsU2hhZG93O1xyXG4gICAgICAgIGlmIChmaWxsU2hhZG93ID09PSBudWxsIHx8IGZpbGxTaGFkb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTaGFkb3cuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBmaWxsU2hhZG93LmNvbG9yO1xyXG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IGZpbGxTaGFkb3cueE9mZnNldCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gZmlsbFNoYWRvdy55T2Zmc2V0ICogcGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBmaWxsU2hhZG93LmJsdXIgKiBwaXhlbFJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbmRlclN0cm9rZShjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2VXaWR0aCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYSAqIHRoaXMub3BhY2l0eSAqIHRoaXMuc3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVEYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGluZURhc2hPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMubGluZURhc2hPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGluZUNhcCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLmxpbmVDYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubGluZUpvaW4pIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMubGluZUpvaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb250YWluc1BvaW50KHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1BvaW50SW5QYXRoKHgsIHkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZWZhdWx0cyBmb3Igc3R5bGUgcHJvcGVydGllcy4gTm90ZSB0aGF0IHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlIHBvc2l0aW9uXHJcbiAqIGFuZCBzaGFwZSBvZiB0aGUgbm9kZSBhcmUgbm90IGNvbnNpZGVyZWQgc3R5bGUgcHJvcGVydGllcywgZm9yIGV4YW1wbGU6XHJcbiAqIGB4YCwgYHlgLCBgd2lkdGhgLCBgaGVpZ2h0YCwgYHJhZGl1c2AsIGByb3RhdGlvbmAsIGV0Yy5cclxuICogQ2FuIGJlIHVzZWQgdG8gcmVzZXQgdG8gdGhlIG9yaWdpbmFsIHN0eWxpbmcgYWZ0ZXIgc29tZSBjdXN0b20gc3R5bGluZ1xyXG4gKiBoYXMgYmVlbiBhcHBsaWVkICh1c2luZyB0aGUgYHJlc3RvcmVPd25TdHlsZXNgIG1ldGhvZCkuXHJcbiAqIFRoZXNlIHN0YXRpYyBkZWZhdWx0cyBhcmUgbWVhbnQgdG8gYmUgaW5oZXJpdGVkIGJ5IHN1YmNsYXNzZXMuXHJcbiAqL1xyXG5TaGFwZS5kZWZhdWx0U3R5bGVzID0gT2JqZWN0LmFzc2lnbih7fSwge1xyXG4gICAgZmlsbDogJ2JsYWNrJyxcclxuICAgIHN0cm9rZTogdW5kZWZpbmVkLFxyXG4gICAgc3Ryb2tlV2lkdGg6IDAsXHJcbiAgICBsaW5lRGFzaDogdW5kZWZpbmVkLFxyXG4gICAgbGluZURhc2hPZmZzZXQ6IDAsXHJcbiAgICBsaW5lQ2FwOiB1bmRlZmluZWQsXHJcbiAgICBsaW5lSm9pbjogdW5kZWZpbmVkLFxyXG4gICAgb3BhY2l0eTogMSxcclxuICAgIGZpbGxTaGFkb3c6IHVuZGVmaW5lZCxcclxufSk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUlOT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTaGFwZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFNoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUlOT1IsIGNoYW5nZUNiOiAocykgPT4gcy51cGRhdGVHcmFkaWVudCgpIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgU2hhcGUucHJvdG90eXBlLCBcImZpbGxcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFNoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFNoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1JTk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgU2hhcGUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUlOT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTaGFwZS5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFNoYXBlLnByb3RvdHlwZSwgXCJsaW5lQ2FwXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUlOT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBTaGFwZS5wcm90b3R5cGUsIFwibGluZUpvaW5cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7XHJcbiAgICAgICAgcmVkcmF3OiBSZWRyYXdUeXBlLk1JTk9SLFxyXG4gICAgICAgIGNvbnZlcnRvcjogKHYpID0+IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHYpKSxcclxuICAgIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgU2hhcGUucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiwgY2hlY2tEaXJ0eU9uQXNzaWdubWVudDogdHJ1ZSB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFNoYXBlLnByb3RvdHlwZSwgXCJmaWxsU2hhZG93XCIsIHZvaWQgMCk7XG5cbmNvbnN0IGVsbGlwc2lzID0gJ1xcdTIwMjYnO1xyXG5mdW5jdGlvbiBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xyXG4gICAgY29uc3QgeyByZWRyYXcgPSBSZWRyYXdUeXBlLk1BSk9SLCBjaGFuZ2VDYiB9ID0gb3B0cyAhPT0gbnVsbCAmJiBvcHRzICE9PSB2b2lkIDAgPyBvcHRzIDoge307XHJcbiAgICByZXR1cm4gU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXcsIHR5cGU6ICdmb250JywgY2hhbmdlQ2IgfSk7XHJcbn1cclxuY2xhc3MgVGV4dCBleHRlbmRzIFNoYXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGlydHlGb250ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gMTA7XHJcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gJ3NhbnMtc2VyaWYnO1xyXG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRBbGlnbjtcclxuICAgICAgICB0aGlzLnRleHRCYXNlbGluZSA9IFRleHQuZGVmYXVsdFN0eWxlcy50ZXh0QmFzZWxpbmU7XHJcbiAgICAgICAgLy8gVGV4dE1ldHJpY3MgYXJlIHVzZWQgaWYgbGluZUhlaWdodCBpcyBub3QgZGVmaW5lZC5cclxuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBfc2V0TGluZXMoKSB7XHJcbiAgICAgICAgdGhpcy5saW5lcyA9IHNwbGl0VGV4dCh0aGlzLnRleHQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZvbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnQgPT0gbnVsbCB8fCB0aGlzLl9kaXJ0eUZvbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlGb250ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnQgPSBnZXRGb250KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcclxuICAgIH1cclxuICAgIGNvbXB1dGVCQm94KCkge1xyXG4gICAgICAgIHJldHVybiBIZHBpQ2FudmFzLmhhcy50ZXh0TWV0cmljc1xyXG4gICAgICAgICAgICA/IGdldFByZWNpc2VCQm94KHRoaXMubGluZXMsIHRoaXMueCwgdGhpcy55LCB0aGlzKVxyXG4gICAgICAgICAgICA6IGdldEFwcHJveGltYXRlQkJveCh0aGlzLmxpbmVzLCB0aGlzLngsIHRoaXMueSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXRMaW5lSGVpZ2h0KGxpbmUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmVIZWlnaHQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVIZWlnaHQ7XHJcbiAgICAgICAgaWYgKEhkcGlDYW52YXMuaGFzLnRleHRNZXRyaWNzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBIZHBpQ2FudmFzLm1lYXN1cmVUZXh0KGxpbmUsIHRoaXMuZm9udCwgdGhpcy50ZXh0QmFzZWxpbmUsIHRoaXMudGV4dEFsaWduKTtcclxuICAgICAgICAgICAgcmV0dXJuICgoKF9hID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG1ldHJpY3MuZW1IZWlnaHRBc2NlbnQpICtcclxuICAgICAgICAgICAgICAgICgoX2IgPSBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG1ldHJpY3MuZW1IZWlnaHREZXNjZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBIZHBpQ2FudmFzLmdldFRleHRTaXplKGxpbmUsIHRoaXMuZm9udCkuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgaXNQb2ludEluUGF0aCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgcmV0dXJuIGJib3ggPyBiYm94LmNvbnRhaW5zUG9pbnQocG9pbnQueCwgcG9pbnQueSkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJlbmRlcihyZW5kZXJDdHgpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT09IFJlZHJhd1R5cGUuTk9ORSAmJiAhZm9yY2VSZW5kZXIpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRzKVxyXG4gICAgICAgICAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHRoaXMubm9kZUNvdW50LmNvdW50O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggfHwgIXRoaXMubGF5ZXJNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0cylcclxuICAgICAgICAgICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeC50b0NvbnRleHQoY3R4KTtcclxuICAgICAgICBjb25zdCB7IGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XHJcbiAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xyXG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcclxuICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXIuY2FudmFzLnBpeGVsUmF0aW8gfHwgMTtcclxuICAgICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XHJcbiAgICAgICAgaWYgKGZpbGwpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhICogdGhpcy5vcGFjaXR5ICogdGhpcy5maWxsT3BhY2l0eTtcclxuICAgICAgICAgICAgY29uc3QgeyBmaWxsU2hhZG93IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoZmlsbFNoYWRvdyA9PT0gbnVsbCB8fCBmaWxsU2hhZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2hhZG93LmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGZpbGxTaGFkb3cuY29sb3I7XHJcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IGZpbGxTaGFkb3cueE9mZnNldCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IGZpbGxTaGFkb3cueU9mZnNldCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGZpbGxTaGFkb3cuYmx1ciAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJMaW5lcygobGluZSwgeCwgeSkgPT4gY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cm9rZSAmJiBzdHJva2VXaWR0aCkge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGEgKiB0aGlzLm9wYWNpdHkgKiB0aGlzLnN0cm9rZU9wYWNpdHk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBsaW5lQ2FwLCBsaW5lSm9pbiB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGxpbmVEYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmVDYXApIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGluZUpvaW4pIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTGluZXMoKGxpbmUsIHgsIHkpID0+IGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXJMaW5lcyhyZW5kZXJDYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IHsgbGluZXMsIHgsIHkgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgbGluZUhlaWdodHMgPSB0aGlzLmxpbmVzLm1hcCgobGluZSkgPT4gdGhpcy5nZXRMaW5lSGVpZ2h0KGxpbmUpKTtcclxuICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IGxpbmVIZWlnaHRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xyXG4gICAgICAgIGxldCBvZmZzZXRZID0gLSh0b3RhbEhlaWdodCAtIGxpbmVIZWlnaHRzWzBdKSAqIGdldFZlcnRpY2FsT2Zmc2V0KHRoaXMudGV4dEJhc2VsaW5lKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlbmRlckNhbGxiYWNrKGxpbmVzW2ldLCB4LCB5ICsgb2Zmc2V0WSk7XHJcbiAgICAgICAgICAgIG9mZnNldFkgKz0gbGluZUhlaWdodHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHdyYXAodGV4dCwgbWF4V2lkdGgsIG1heEhlaWdodCwgdGV4dFByb3BzLCB3cmFwcGluZywgb3ZlcmZsb3cgPSAnZWxsaXBzaXMnKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhbk92ZXJmbG93ID0gb3ZlcmZsb3cgIT09ICdoaWRlJztcclxuICAgICAgICBjb25zdCBmb250ID0gZ2V0Rm9udCh0ZXh0UHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IG1lYXN1cmVyID0gY3JlYXRlVGV4dE1lYXN1cmVyKGZvbnQpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyP1xcbi9nKTtcclxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdyYXBwaW5nID09PSAnbmV2ZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBUZXh0LnRydW5jYXRlTGluZShsaW5lc1swXSwgbWF4V2lkdGgsIG1lYXN1cmVyLCBjYW5PdmVyZmxvdyA/ICdhdXRvJyA6ICduZXZlcicpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IGN1bXVsYXRpdmVIZWlnaHQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkTGluZSA9IFRleHQud3JhcExpbmUobGluZSwgbWF4V2lkdGgsIG1heEhlaWdodCwgbWVhc3VyZXIsIHRleHRQcm9wcywgd3JhcHBpbmcsIGN1bXVsYXRpdmVIZWlnaHQsIGNhbk92ZXJmbG93KTtcclxuICAgICAgICAgICAgaWYgKHdyYXBwZWRMaW5lID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh3cmFwcGVkTGluZS5yZXN1bHQpO1xyXG4gICAgICAgICAgICBjdW11bGF0aXZlSGVpZ2h0ID0gd3JhcHBlZExpbmUuY3VtdWxhdGl2ZUhlaWdodDtcclxuICAgICAgICAgICAgaWYgKHdyYXBwZWRMaW5lLnRydW5jYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCdcXG4nKS50cmltKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgd3JhcExpbmUodGV4dCwgbWF4V2lkdGgsIG1heEhlaWdodCwgbWVhc3VyZXIsIHRleHRQcm9wcywgd3JhcHBpbmcsIGN1bXVsYXRpdmVIZWlnaHQsIGNhbk92ZXJmbG93KSB7XHJcbiAgICAgICAgdGV4dCA9IHRleHQudHJpbSgpO1xyXG4gICAgICAgIGlmICghdGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6ICcnLCB0cnVuY2F0ZWQ6IGZhbHNlLCBjdW11bGF0aXZlSGVpZ2h0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTaXplID0gbWVhc3VyZXIuc2l6ZSh0ZXh0KTtcclxuICAgICAgICBpZiAoaW5pdGlhbFNpemUud2lkdGggPD0gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgLy8gVGV4dCBmaXRzIGludG8gYSBzaW5nbGUgbGluZVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgdHJ1bmNhdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVIZWlnaHQ6IGN1bXVsYXRpdmVIZWlnaHQgKyBpbml0aWFsU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbml0aWFsU2l6ZS5oZWlnaHQgPiBtYXhIZWlnaHQgfHwgbWVhc3VyZXIud2lkdGgoJ1cnKSA+IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdCBlbm91Z2ggc3BhY2UgZm9yIGEgc2luZ2xlIGxpbmUgb3IgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHJldHVybiBjYW5PdmVyZmxvdyA/IHsgcmVzdWx0OiAnJywgdHJ1bmNhdGVkOiB0cnVlLCBjdW11bGF0aXZlSGVpZ2h0IH0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdvcmRzID0gdGV4dC5zcGxpdCgvXFxzKy9nKTtcclxuICAgICAgICBjb25zdCB3cmFwUmVzdWx0ID0gVGV4dC53cmFwTGluZVNlcXVlbnRpYWxseSh3b3JkcywgbWF4V2lkdGgsIG1heEhlaWdodCwgbWVhc3VyZXIsIHRleHRQcm9wcywgd3JhcHBpbmcsIGN1bXVsYXRpdmVIZWlnaHQsIGNhbk92ZXJmbG93KTtcclxuICAgICAgICBpZiAod3JhcFJlc3VsdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1bXVsYXRpdmVIZWlnaHQgPSB3cmFwUmVzdWx0LmN1bXVsYXRpdmVIZWlnaHQ7XHJcbiAgICAgICAgbGV0IHsgbGluZXMgfSA9IHdyYXBSZXN1bHQ7XHJcbiAgICAgICAgaWYgKCEod3JhcFJlc3VsdC53b3Jkc0Jyb2tlbk9yVHJ1bmNhdGVkIHx8IHdyYXBSZXN1bHQubGluZXNUcnVuY2F0ZWQpKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIHdvcmQgYnJlYWtzIG9yIHRydW5jYXRpb25zLCB0cnkgdGhlIGJhbGFuY2VkIHdyYXBwaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzQ291bnQgPSB3cmFwUmVzdWx0LmxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZWQgPSBUZXh0LndyYXBMaW5lQmFsYW5jZWQod29yZHMsIG1heFdpZHRoLCBtZWFzdXJlciwgbGluZXNDb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChiYWxhbmNlZC5sZW5ndGggPT09IGxpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZSBsaW5lcyBjYW4ndCBiZSBiYWxhbmNlZCBwcm9wZXJseSBiZWNhdXNlIG9mIHVudXN1YWxseSBsb25nIHdvcmRzXHJcbiAgICAgICAgICAgICAgICBsaW5lcyA9IGJhbGFuY2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRUZXh0ID0gbGluZXMubWFwKChsbikgPT4gbG4uam9pbignICcpKS5qb2luKCdcXG4nKTtcclxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHdyYXBwZWRUZXh0LCB0cnVuY2F0ZWQ6IHdyYXBSZXN1bHQubGluZXNUcnVuY2F0ZWQsIGN1bXVsYXRpdmVIZWlnaHQgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBicmVha1dvcmQod29yZCwgZmlyc3RMaW5lV2lkdGgsIG1heFdpZHRoLCBoeXBoZW5zLCBtZWFzdXJlcikge1xyXG4gICAgICAgIGNvbnN0IGlzUHVuY3R1YXRpb25BdCA9IChpbmRleCkgPT4gVGV4dC5wdW5jdHVhdGlvbk1hcmtzLmluY2x1ZGVzKHdvcmRbaW5kZXhdKTtcclxuICAgICAgICBjb25zdCBoID0gaHlwaGVucyA/IG1lYXN1cmVyLndpZHRoKCctJykgOiAwO1xyXG4gICAgICAgIGNvbnN0IGJyZWFrcyA9IFtdO1xyXG4gICAgICAgIGxldCBwYXJ0V2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBwID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYyA9IHdvcmRbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSBtZWFzdXJlci53aWR0aChjKTtcclxuICAgICAgICAgICAgY29uc3QgbGltaXQgPSBwID09PSAwID8gZmlyc3RMaW5lV2lkdGggOiBtYXhXaWR0aDtcclxuICAgICAgICAgICAgaWYgKHBhcnRXaWR0aCArIHcgKyBoID4gbGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgcGFydFdpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgIHArKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJ0V2lkdGggKz0gdztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcclxuICAgICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgYnJlYWtzKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gd29yZC5zdWJzdHJpbmcoc3RhcnQsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKGh5cGhlbnMgJiYgcGFydC5sZW5ndGggPiAwICYmICFpc1B1bmN0dWF0aW9uQXQoaW5kZXggLSAxKSAmJiAhaXNQdW5jdHVhdGlvbkF0KGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgcGFydCArPSAnLSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcclxuICAgICAgICAgICAgc3RhcnQgPSBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFydHMucHVzaCh3b3JkLnN1YnN0cmluZyhzdGFydCkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cztcclxuICAgIH1cclxuICAgIHN0YXRpYyB0cnVuY2F0ZUxpbmUodGV4dCwgbWF4V2lkdGgsIG1lYXN1cmVyLCBlbGxpcHNpc01vZGUpIHtcclxuICAgICAgICB0ZXh0ID0gdGV4dC50cmltRW5kKCk7XHJcbiAgICAgICAgY29uc3QgbGluZVdpZHRoID0gbWVhc3VyZXIud2lkdGgodGV4dCk7XHJcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+IG1heFdpZHRoICYmIGVsbGlwc2lzTW9kZSA9PT0gJ25ldmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsaW5lV2lkdGggPD0gbWF4V2lkdGggJiYgZWxsaXBzaXNNb2RlICE9PSAnZm9yY2UnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbGxpcHNpc1dpZHRoID0gbWVhc3VyZXIud2lkdGgoZWxsaXBzaXMpO1xyXG4gICAgICAgIGxldCB0cnVuYyA9IHRleHQ7XHJcbiAgICAgICAgbGV0IHRydW5jV2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgd2hpbGUgKHRydW5jLmxlbmd0aCA+IDAgJiYgdHJ1bmNXaWR0aCArIGVsbGlwc2lzV2lkdGggPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgbm8gc3BhY2UgYmV0d2VlbiB0aGUgZWxsaXBzaXMgYW5kIGxhc3QgbGV0dGVyXHJcbiAgICAgICAgICAgIHRydW5jID0gdHJ1bmMuc2xpY2UoMCwgLTEpLnRyaW1FbmQoKTtcclxuICAgICAgICAgICAgdHJ1bmNXaWR0aCA9IG1lYXN1cmVyLndpZHRoKHRydW5jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRydW5jV2lkdGggKyBlbGxpcHNpc1dpZHRoIDw9IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgJHt0cnVuY30ke2VsbGlwc2lzfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyB3cmFwTGluZVNlcXVlbnRpYWxseSh3b3JkcywgbWF4V2lkdGgsIG1heEhlaWdodCwgbWVhc3VyZXIsIHRleHRQcm9wcywgd3JhcHBpbmcsIGN1bXVsYXRpdmVIZWlnaHQsIGNhbk92ZXJmbG93KSB7XHJcbiAgICAgICAgY29uc3QgeyBmb250U2l6ZSA9IDAsIGxpbmVIZWlnaHQgPSBmb250U2l6ZSAqIFRleHQuZGVmYXVsdExpbmVIZWlnaHRSYXRpbyB9ID0gdGV4dFByb3BzO1xyXG4gICAgICAgIGNvbnN0IGJyZWFrV29yZCA9IHdyYXBwaW5nID09PSAnYWx3YXlzJyB8fCB3cmFwcGluZyA9PT0gJ2h5cGhlbmF0ZSc7XHJcbiAgICAgICAgY29uc3QgaHlwaGVuYXRlID0gd3JhcHBpbmcgPT09ICdoeXBoZW5hdGUnO1xyXG4gICAgICAgIGNvbnN0IHNwYWNlV2lkdGggPSBtZWFzdXJlci53aWR0aCgnICcpO1xyXG4gICAgICAgIGxldCB3b3Jkc0Jyb2tlbk9yVHJ1bmNhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGxpbmVzVHJ1bmNhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudExpbmUgPSBbXTtcclxuICAgICAgICBsZXQgbGluZVdpZHRoID0gMDtcclxuICAgICAgICBjb25zdCBnZXRSZXR1cm5WYWx1ZSA9ICgpID0+ICh7XHJcbiAgICAgICAgICAgIGxpbmVzLFxyXG4gICAgICAgICAgICBsaW5lc1RydW5jYXRlZCxcclxuICAgICAgICAgICAgd29yZHNCcm9rZW5PclRydW5jYXRlZCxcclxuICAgICAgICAgICAgY3VtdWxhdGl2ZUhlaWdodCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0cnVuY2F0ZUxhc3RMaW5lID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWNhbk92ZXJmbG93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMaW5lID0gY3VycmVudExpbmUuam9pbignICcpO1xyXG4gICAgICAgICAgICBjb25zdCB0cnVuYyA9IFRleHQudHJ1bmNhdGVMaW5lKGxhc3RMaW5lLCBtYXhXaWR0aCwgbWVhc3VyZXIsICdmb3JjZScpO1xyXG4gICAgICAgICAgICBpZiAodHJ1bmMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50TGluZS5zcGxpY2UoMCwgY3VycmVudExpbmUubGVuZ3RoLCB0cnVuYyk7XHJcbiAgICAgICAgICAgIGxpbmVzVHJ1bmNhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFJldHVyblZhbHVlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhZGROZXdMaW5lID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZEhlaWdodCA9IGN1bXVsYXRpdmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRIZWlnaHQgPj0gbWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIG5ldyBsaW5lXHJcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gW107XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIGN1bXVsYXRpdmVIZWlnaHQgPSBleHBlY3RlZEhlaWdodDtcclxuICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFhZGROZXdMaW5lKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydW5jYXRlTGFzdExpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB3b3JkID0gd29yZHNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmRXaWR0aCA9IG1lYXN1cmVyLndpZHRoKHdvcmQpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFNwYWNlV2lkdGggPSBjdXJyZW50TGluZS5sZW5ndGggPT09IDAgPyAwIDogc3BhY2VXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRMaW5lV2lkdGggPSBsaW5lV2lkdGggKyBleHBlY3RlZFNwYWNlV2lkdGggKyB3b3JkV2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChleHBlY3RlZExpbmVXaWR0aCA8PSBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHdvcmQgZml0cywgYWRkIGl0IHRvIHRoZSBjdXJyZW50IGxpbmVcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lLnB1c2god29yZCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBleHBlY3RlZExpbmVXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh3b3JkV2lkdGggPD0gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB3b3JkIGlzIG5vdCB0b28gbG9uZywgcHV0IGl0IG9udG8gbmV3IGxpbmVcclxuICAgICAgICAgICAgICAgIGlmICghYWRkTmV3TGluZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydW5jYXRlTGFzdExpbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lLnB1c2god29yZCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgYSBsb25nIHdvcmRcclxuICAgICAgICAgICAgd29yZHNCcm9rZW5PclRydW5jYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChicmVha1dvcmQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEJyZWFrIHRoZSB3b3JkIGludG8gcGFydHNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF2YWlsV2lkdGggPSBtYXhXaWR0aCAtIGxpbmVXaWR0aCAtIGV4cGVjdGVkU3BhY2VXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gVGV4dC5icmVha1dvcmQod29yZCwgYXZhaWxXaWR0aCwgbWF4V2lkdGgsIGh5cGhlbmF0ZSwgbWVhc3VyZXIpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXJ0cy5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1twXTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0ICYmIGN1cnJlbnRMaW5lLnB1c2gocGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gbWVhc3VyZXIud2lkdGgocGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhZGROZXdMaW5lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydW5jYXRlTGFzdExpbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2FuT3ZlcmZsb3cpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRoZSB3b3JkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFkZE5ld0xpbmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVuY2F0ZUxhc3RMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cnVuYyA9IFRleHQudHJ1bmNhdGVMaW5lKHdvcmQsIG1heFdpZHRoLCBtZWFzdXJlciwgJ2ZvcmNlJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJ1bmMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZS5wdXNoKHRydW5jKTtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgd29yZHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzVHJ1bmNhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2V0UmV0dXJuVmFsdWUoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB3cmFwTGluZUJhbGFuY2VkKHdvcmRzLCBtYXhXaWR0aCwgbWVhc3VyZXIsIGxpbmVzQ291bnQpIHtcclxuICAgICAgICBjb25zdCB0b3RhbFdvcmRzV2lkdGggPSB3b3Jkcy5yZWR1Y2UoKHN1bSwgdykgPT4gc3VtICsgbWVhc3VyZXIud2lkdGgodyksIDApO1xyXG4gICAgICAgIGNvbnN0IHNwYWNlV2lkdGggPSBtZWFzdXJlci53aWR0aCgnICcpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsU3BhY2VXaWR0aCA9IHNwYWNlV2lkdGggKiAod29yZHMubGVuZ3RoIC0gbGluZXNDb3VudCAtIDIpO1xyXG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VMaW5lV2lkdGggPSAodG90YWxXb3Jkc1dpZHRoICsgdG90YWxTcGFjZVdpZHRoKSAvIGxpbmVzQ291bnQ7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudExpbmUgPSBbXTtcclxuICAgICAgICBsZXQgbGluZVdpZHRoID0gbWVhc3VyZXIud2lkdGgod29yZHNbMF0pO1xyXG4gICAgICAgIGxldCBuZXdMaW5lID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHMpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtZWFzdXJlci53aWR0aCh3b3JkKTtcclxuICAgICAgICAgICAgaWYgKG5ld0xpbmUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5ldyBsaW5lXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmUucHVzaCh3b3JkKTtcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgbmV3TGluZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZExpbmVXaWR0aCA9IGxpbmVXaWR0aCArIHNwYWNlV2lkdGggKyB3aWR0aDtcclxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkTGluZVdpZHRoIDw9IGF2ZXJhZ2VMaW5lV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgYWRkaW5nIHdvcmRzIHRvIHRoZSBsaW5lXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZS5wdXNoKHdvcmQpO1xyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoID0gZXhwZWN0ZWRMaW5lV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwZWN0ZWRMaW5lV2lkdGggPD0gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbGFzdCB3b3JkIHRvIHRoZSBsaW5lXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZS5wdXNoKHdvcmQpO1xyXG4gICAgICAgICAgICAgICAgbmV3TGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQdXQgdGhlIHdvcmQgb250byB0aGUgbmV4dCBsaW5lXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IFt3b3JkXTtcclxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgfVxyXG4gICAgc2V0Rm9udChwcm9wcykge1xyXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9IHByb3BzLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IHByb3BzLmZvbnRTaXplO1xyXG4gICAgICAgIHRoaXMuZm9udFN0eWxlID0gcHJvcHMuZm9udFN0eWxlO1xyXG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9IHByb3BzLmZvbnRXZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBzZXRBbGlnbihwcm9wcykge1xyXG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gcHJvcHMudGV4dEFsaWduO1xyXG4gICAgICAgIHRoaXMudGV4dEJhc2VsaW5lID0gcHJvcHMudGV4dEJhc2VsaW5lO1xyXG4gICAgfVxyXG59XHJcblRleHQuY2xhc3NOYW1lID0gJ1RleHQnO1xyXG4vLyBUaGUgZGVmYXVsdCBsaW5lIHNwYWNpbmcgZm9yIGRvY3VtZW50IGVkaXRvcnMgaXMgdXN1YWxseSAxLjE1XHJcblRleHQuZGVmYXVsdExpbmVIZWlnaHRSYXRpbyA9IDEuMTU7XHJcblRleHQuZGVmYXVsdFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIFNoYXBlLmRlZmF1bHRTdHlsZXMsIHtcclxuICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcclxuICAgIGZvbnRTdHlsZTogdW5kZWZpbmVkLFxyXG4gICAgZm9udFdlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgZm9udFNpemU6IDEwLFxyXG4gICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxyXG4gICAgdGV4dEJhc2VsaW5lOiAnYWxwaGFiZXRpYycsXHJcbn0pO1xyXG5UZXh0LmVsbGlwc2lzID0gZWxsaXBzaXM7XHJcblRleHQucHVuY3R1YXRpb25NYXJrcyA9IFsnLicsICcsJywgJy0nLCAnOicsICc7JywgJyEnLCAnPycsIGAnYCwgJ1wiJywgJygnLCAnKSddO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgVGV4dC5wcm90b3R5cGUsIFwieFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgVGV4dC5wcm90b3R5cGUsIFwieVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SLCBjaGFuZ2VDYjogKG8pID0+IG8uX3NldExpbmVzKCkgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBUZXh0LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVGb250Q2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBUZXh0LnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFRleHQucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFRleHQucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVGb250Q2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBUZXh0LnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBUZXh0LnByb3RvdHlwZSwgXCJ0ZXh0QWxpZ25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NQUpPUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFRleHQucHJvdG90eXBlLCBcInRleHRCYXNlbGluZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgVGV4dC5wcm90b3R5cGUsIFwibGluZUhlaWdodFwiLCB2b2lkIDApO1xyXG5mdW5jdGlvbiBjcmVhdGVUZXh0TWVhc3VyZXIoZm9udCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBnZXRUZXh0U2l6ZSA9ICh0ZXh0KSA9PiBIZHBpQ2FudmFzLmdldFRleHRTaXplKHRleHQsIGZvbnQpO1xyXG4gICAgY29uc3QgZ2V0TGluZVdpZHRoID0gKHRleHQpID0+IHtcclxuICAgICAgICBpZiAoY2FjaGUuaGFzKHRleHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQodGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGdldFRleHRTaXplKHRleHQpO1xyXG4gICAgICAgIGNhY2hlLnNldCh0ZXh0LCB3aWR0aCk7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7IHNpemU6IGdldFRleHRTaXplLCB3aWR0aDogZ2V0TGluZVdpZHRoIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Rm9udChmb250UHJvcHMpIHtcclxuICAgIGNvbnN0IHsgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCB9ID0gZm9udFByb3BzO1xyXG4gICAgcmV0dXJuIFtmb250U3R5bGUgIT09IG51bGwgJiYgZm9udFN0eWxlICE9PSB2b2lkIDAgPyBmb250U3R5bGUgOiAnJywgZm9udFdlaWdodCAhPT0gbnVsbCAmJiBmb250V2VpZ2h0ICE9PSB2b2lkIDAgPyBmb250V2VpZ2h0IDogJycsIGZvbnRTaXplICsgJ3B4JywgZm9udEZhbWlseV0uam9pbignICcpLnRyaW0oKTtcclxufVxyXG5mdW5jdGlvbiBtZWFzdXJlVGV4dChsaW5lcywgeCwgeSwgdGV4dFByb3BzKSB7XHJcbiAgICByZXR1cm4gSGRwaUNhbnZhcy5oYXMudGV4dE1ldHJpY3NcclxuICAgICAgICA/IGdldFByZWNpc2VCQm94KGxpbmVzLCB4LCB5LCB0ZXh0UHJvcHMpXHJcbiAgICAgICAgOiBnZXRBcHByb3hpbWF0ZUJCb3gobGluZXMsIHgsIHksIHRleHRQcm9wcyk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UHJlY2lzZUJCb3gobGluZXMsIHgsIHksIHRleHRQcm9wcykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGxldCBsZWZ0ID0gMDtcclxuICAgIGxldCB0b3AgPSAwO1xyXG4gICAgbGV0IHdpZHRoID0gMDtcclxuICAgIGxldCBoZWlnaHQgPSAwO1xyXG4gICAgLy8gRGlzdGFuY2UgYmV0d2VlbiBmaXJzdCBhbmQgbGFzdCBiYXNlIGxpbmVzLlxyXG4gICAgbGV0IGJhc2VsaW5lRGlzdGFuY2UgPSAwO1xyXG4gICAgY29uc3QgZm9udCA9IGdldEZvbnQodGV4dFByb3BzKTtcclxuICAgIGNvbnN0IHsgbGluZUhlaWdodCwgdGV4dEJhc2VsaW5lID0gVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRCYXNlbGluZSwgdGV4dEFsaWduID0gVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRBbGlnbiwgfSA9IHRleHRQcm9wcztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBtZXRyaWNzID0gSGRwaUNhbnZhcy5tZWFzdXJlVGV4dChsaW5lc1tpXSwgZm9udCwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24pO1xyXG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCk7XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgbWV0cmljcy53aWR0aCk7XHJcbiAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB0b3AgKz0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcclxuICAgICAgICAgICAgaGVpZ2h0ICs9IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBiYXNlbGluZURpc3RhbmNlICs9IChfYSA9IG1ldHJpY3MuZm9udEJvdW5kaW5nQm94QXNjZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBtZXRyaWNzLmVtSGVpZ2h0QXNjZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA9PSBsaW5lcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCArPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJhc2VsaW5lRGlzdGFuY2UgKz0gKF9iID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBtZXRyaWNzLmVtSGVpZ2h0RGVzY2VudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGluZUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgYmFzZWxpbmVEaXN0YW5jZSA9IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBoZWlnaHQgKz0gYmFzZWxpbmVEaXN0YW5jZTtcclxuICAgIHRvcCArPSBiYXNlbGluZURpc3RhbmNlICogZ2V0VmVydGljYWxPZmZzZXQodGV4dEJhc2VsaW5lKTtcclxuICAgIHJldHVybiBuZXcgQkJveCh4IC0gbGVmdCwgeSAtIHRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QXBwcm94aW1hdGVCQm94KGxpbmVzLCB4LCB5LCB0ZXh0UHJvcHMpIHtcclxuICAgIGxldCB3aWR0aCA9IDA7XHJcbiAgICBsZXQgZmlyc3RMaW5lSGVpZ2h0ID0gMDtcclxuICAgIC8vIERpc3RhbmNlIGJldHdlZW4gZmlyc3QgYW5kIGxhc3QgYmFzZSBsaW5lcy5cclxuICAgIGxldCBiYXNlbGluZURpc3RhbmNlID0gMDtcclxuICAgIGNvbnN0IGZvbnQgPSBnZXRGb250KHRleHRQcm9wcyk7XHJcbiAgICBjb25zdCB7IGxpbmVIZWlnaHQsIHRleHRCYXNlbGluZSA9IFRleHQuZGVmYXVsdFN0eWxlcy50ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiA9IFRleHQuZGVmYXVsdFN0eWxlcy50ZXh0QWxpZ24sIH0gPSB0ZXh0UHJvcHM7XHJcbiAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGxpbmVTaXplID0gSGRwaUNhbnZhcy5nZXRUZXh0U2l6ZShsaW5lc1swXSwgZm9udCk7XHJcbiAgICAgICAgd2lkdGggPSBsaW5lU2l6ZS53aWR0aDtcclxuICAgICAgICBmaXJzdExpbmVIZWlnaHQgPSBsaW5lU2l6ZS5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluZVNpemUgPSBIZHBpQ2FudmFzLmdldFRleHRTaXplKGxpbmVzW2ldLCBmb250KTtcclxuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBsaW5lU2l6ZS53aWR0aCk7XHJcbiAgICAgICAgYmFzZWxpbmVEaXN0YW5jZSArPSBsaW5lSGVpZ2h0ICE9PSBudWxsICYmIGxpbmVIZWlnaHQgIT09IHZvaWQgMCA/IGxpbmVIZWlnaHQgOiBsaW5lU2l6ZS5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xyXG4gICAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICB4IC09IHdpZHRoO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICB4IC09IHdpZHRoIC8gMjtcclxuICAgIH1cclxuICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XHJcbiAgICAgICAgY2FzZSAnYWxwaGFiZXRpYyc6XHJcbiAgICAgICAgICAgIHkgLT0gZmlyc3RMaW5lSGVpZ2h0ICogMC43ICsgYmFzZWxpbmVEaXN0YW5jZSAqIDAuNTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgeSAtPSBmaXJzdExpbmVIZWlnaHQgKiAwLjQ1ICsgYmFzZWxpbmVEaXN0YW5jZSAqIDAuNTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaWRlb2dyYXBoaWMnOlxyXG4gICAgICAgICAgICB5IC09IGZpcnN0TGluZUhlaWdodCArIGJhc2VsaW5lRGlzdGFuY2U7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2hhbmdpbmcnOlxyXG4gICAgICAgICAgICB5IC09IGZpcnN0TGluZUhlaWdodCAqIDAuMiArIGJhc2VsaW5lRGlzdGFuY2UgKiAwLjU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgIHkgLT0gZmlyc3RMaW5lSGVpZ2h0ICsgYmFzZWxpbmVEaXN0YW5jZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJCb3goeCwgeSwgd2lkdGgsIGZpcnN0TGluZUhlaWdodCArIGJhc2VsaW5lRGlzdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFZlcnRpY2FsT2Zmc2V0KHRleHRCYXNlbGluZSkge1xyXG4gICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcclxuICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgIGNhc2UgJ2hhbmdpbmcnOlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxyXG4gICAgICAgIGNhc2UgJ2lkZW9ncmFwaGljJzpcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzcGxpdFRleHQodGV4dCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyA/IHRleHQuc3BsaXQoL1xccj9cXG4vZykgOiBbXTtcclxufVxuXG5mdW5jdGlvbiBQcm94eU9uV3JpdGUocHJveHlQcm9wZXJ0eSkge1xyXG4gICAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgodGFyZ2V0LCBfLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHRhcmdldFtwcm94eVByb3BlcnR5XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIFByb3h5UHJvcGVydHlPbldyaXRlKGNoaWxkTmFtZSwgY2hpbGRQcm9wZXJ0eSkge1xyXG4gICAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgdGFyZ2V0W2NoaWxkTmFtZV1bY2hpbGRQcm9wZXJ0eSAhPT0gbnVsbCAmJiBjaGlsZFByb3BlcnR5ICE9PSB2b2lkIDAgPyBjaGlsZFByb3BlcnR5IDoga2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBBbGxvd3Mgc2lkZS1lZmZlY3RzIHRvIGJlIHRyaWdnZXJlZCBvbiBwcm9wZXJ0eSB3cml0ZS5cclxuICpcclxuICogQHBhcmFtIG9wdHMubmV3VmFsdWUgY2FsbGVkIHdoZW4gYSBuZXcgdmFsdWUgaXMgc2V0IC0gbmV2ZXIgY2FsbGVkIGZvciB1bmRlZmluZWQgdmFsdWVzLlxyXG4gKiBAcGFyYW0gb3B0cy5vbGRWYWx1ZSBjYWxsZWQgd2l0aCB0aGUgb2xkIHZhbHVlIGJlZm9yZSBhIG5ldyB2YWx1ZSBpcyBzZXQgLSBuZXZlciBjYWxsZWQgZm9yXHJcbiAqICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCB2YWx1ZXMuXHJcbiAqIEBwYXJhbSBvcHRzLmNoYW5nZVZhbHVlIGNhbGxlZCBvbiBhbnkgY2hhbmdlIHRvIHRoZSB2YWx1ZSAtIGFsd2F5cyBjYWxsZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBBY3Rpb25PblNldChvcHRzKSB7XHJcbiAgICBjb25zdCB7IG5ld1ZhbHVlOiBuZXdWYWx1ZUZuLCBvbGRWYWx1ZTogb2xkVmFsdWVGbiwgY2hhbmdlVmFsdWU6IGNoYW5nZVZhbHVlRm4gfSA9IG9wdHM7XHJcbiAgICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIF8sIG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlRm4gPT09IG51bGwgfHwgb2xkVmFsdWVGbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkVmFsdWVGbi5jYWxsKHRhcmdldCwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZUZuID09PSBudWxsIHx8IG5ld1ZhbHVlRm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld1ZhbHVlRm4uY2FsbCh0YXJnZXQsIG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGFuZ2VWYWx1ZUZuID09PSBudWxsIHx8IGNoYW5nZVZhbHVlRm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5nZVZhbHVlRm4uY2FsbCh0YXJnZXQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcclxuICAgIH0pO1xyXG59XG5cbmNsYXNzIENhcHRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbmV3IFRleHQoKTtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IDEwO1xyXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9ICdzYW5zLXNlcmlmJztcclxuICAgICAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMud3JhcHBpbmcgPSAnYWx3YXlzJztcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2RlO1xyXG4gICAgICAgIG5vZGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgbm9kZS5wb2ludGVyRXZlbnRzID0gUG9pbnRlckV2ZW50cy5Ob25lO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZVRleHRXcmFwKGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHsgdGV4dCwgd3JhcHBpbmcgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBNYXRoLm1pbigoX2EgPSB0aGlzLm1heFdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eSwgY29udGFpbmVyV2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IChfYiA9IHRoaXMubWF4SGVpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb250YWluZXJIZWlnaHQ7XHJcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShtYXhXaWR0aCkgJiYgIWlzRmluaXRlKG1heEhlaWdodCkpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWQgPSBUZXh0LndyYXAodGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycsIG1heFdpZHRoLCBtYXhIZWlnaHQsIHRoaXMsIHdyYXBwaW5nKTtcclxuICAgICAgICB0aGlzLm5vZGUudGV4dCA9IHdyYXBwZWQ7XHJcbiAgICB9XHJcbn1cclxuQ2FwdGlvbi5TTUFMTF9QQURESU5HID0gMTA7XHJcbkNhcHRpb24uTEFSR0VfUEFERElORyA9IDIwO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoJ25vZGUnKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInRleHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRk9OVF9TVFlMRSksXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgnbm9kZScpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZPTlRfV0VJR0hUKSxcclxuICAgIFByb3h5UHJvcGVydHlPbldyaXRlKCdub2RlJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoJ25vZGUnKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoU1RSSU5HKSxcclxuICAgIFByb3h5UHJvcGVydHlPbldyaXRlKCdub2RlJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0NPTE9SX1NUUklORyksXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgnbm9kZScsICdmaWxsJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwibGluZUhlaWdodFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIm1heEhlaWdodFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFRFWFRfV1JBUCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCB2b2lkIDApO1xuXG5jbGFzcyBBeGlzVGl0bGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3BhY2luZyA9IENhcHRpb24uU01BTExfUEFERElORztcclxuICAgICAgICB0aGlzLmZvbnRTdHlsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IDEwO1xyXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9ICdzYW5zLXNlcmlmJztcclxuICAgICAgICB0aGlzLndyYXBwaW5nID0gJ2Fsd2F5cyc7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRk9OVF9TVFlMRSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9GT05UX1dFSUdIVCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFRFWFRfV1JBUCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcIndyYXBwaW5nXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZVTkNUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgdm9pZCAwKTtcblxuLyoqXHJcbiAqIFppcCB0d28gYXJyYXlzIGludG8gYW4gb2JqZWN0IG9mIGtleXMgYW5kIHZhbHVlcywgb3IgYW4gb2JqZWN0IG9mIGtleXMgd2l0aCBhIHNpbmdsZSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcclxuICAgIGNvbnN0IHppcHBlZCA9IHt9O1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB6aXBwZWRbYCR7a2V5c1tpXX1gXSA9IHZhbHVlc1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgemlwcGVkW2Ake2tleXNbaV19YF0gPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHppcHBlZDtcclxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XHJcbiAgICByZXR1cm4gKGQpID0+IE51bWJlcihhKSAqICgxIC0gZCkgKyBOdW1iZXIoYikgKiBkO1xyXG59XHJcbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoYSwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGEgPSBDb2xvci5mcm9tU3RyaW5nKGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBhID0gQ29sb3IuZnJvbUFycmF5KFswLCAwLCAwXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGIgPSBDb2xvci5mcm9tU3RyaW5nKGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBiID0gQ29sb3IuZnJvbUFycmF5KFswLCAwLCAwXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcmVkID0gaW50ZXJwb2xhdGVOdW1iZXIoYS5yLCBiLnIpO1xyXG4gICAgY29uc3QgZ3JlZW4gPSBpbnRlcnBvbGF0ZU51bWJlcihhLmcsIGIuZyk7XHJcbiAgICBjb25zdCBibHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoYS5iLCBiLmIpO1xyXG4gICAgY29uc3QgYWxwaGEgPSBpbnRlcnBvbGF0ZU51bWJlcihhLmEsIGIuYSk7XHJcbiAgICByZXR1cm4gKGQpID0+IENvbG9yLmZyb21BcnJheShbcmVkKGQpLCBncmVlbihkKSwgYmx1ZShkKSwgYWxwaGEoZCldKS50b1JnYmFTdHJpbmcoKTtcclxufVxuXG5jb25zdCBsaW5lYXIgPSAobikgPT4gbjtcclxuY29uc3QgZWFzZUluID0gKG4pID0+IDEgLSBNYXRoLmNvcygobiAqIE1hdGguUEkpIC8gMik7XHJcbmNvbnN0IGVhc2VPdXQgPSAobikgPT4gTWF0aC5zaW4oKG4gKiBNYXRoLlBJKSAvIDIpO1xyXG5jb25zdCBlYXNlSW5PdXQgPSAobikgPT4gLShNYXRoLmNvcyhuICogTWF0aC5QSSkgLSAxKSAvIDI7XHJcbmNvbnN0IGVhc2VJblF1YWQgPSAobikgPT4gbiAqIG47XHJcbmNvbnN0IGVhc2VPdXRRdWFkID0gKG4pID0+IDEgLSBNYXRoLnBvdygoMSAtIG4pLCAyKTtcclxuY29uc3QgZWFzZUluT3V0UXVhZCA9IChuKSA9PiAobiA8IDAuNSA/IDIgKiBuICogbiA6IDEgLSBNYXRoLnBvdygoLTIgKiBuICsgMiksIDIpIC8gMik7XG5cbnZhciBlYXNpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGxpbmVhcjogbGluZWFyLFxuICAgIGVhc2VJbjogZWFzZUluLFxuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXG4gICAgZWFzZUluT3V0OiBlYXNlSW5PdXQsXG4gICAgZWFzZUluUXVhZDogZWFzZUluUXVhZCxcbiAgICBlYXNlT3V0UXVhZDogZWFzZU91dFF1YWQsXG4gICAgZWFzZUluT3V0UXVhZDogZWFzZUluT3V0UXVhZFxufSk7XG5cbmNvbnN0IFFVSUNLX1RSQU5TSVRJT04gPSAwLjI7XHJcbmNvbnN0IElOSVRJQUxfTE9BRCA9IHtcclxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxLFxyXG4gICAgYW5pbWF0aW9uRGVsYXk6IDAsXHJcbn07XHJcbmNvbnN0IFJFTU9WRV9QSEFTRSA9IHtcclxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjI1LFxyXG4gICAgYW5pbWF0aW9uRGVsYXk6IDAsXHJcbn07XHJcbmNvbnN0IFVQREFURV9QSEFTRSA9IHtcclxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjUsXHJcbiAgICBhbmltYXRpb25EZWxheTogMC4yNSxcclxufTtcclxuY29uc3QgQUREX1BIQVNFID0ge1xyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAuMjUsXHJcbiAgICBhbmltYXRpb25EZWxheTogMC43NSxcclxufTtcclxuY29uc3QgTEFCRUxfUEhBU0UgPSB7XHJcbiAgICBhbmltYXRpb25EdXJhdGlvbjogUVVJQ0tfVFJBTlNJVElPTixcclxuICAgIGFuaW1hdGlvbkRlbGF5OiAxLFxyXG59O1xyXG52YXIgUmVwZWF0VHlwZTtcclxuKGZ1bmN0aW9uIChSZXBlYXRUeXBlKSB7XHJcbiAgICBSZXBlYXRUeXBlW1wiTG9vcFwiXSA9IFwibG9vcFwiO1xyXG4gICAgUmVwZWF0VHlwZVtcIlJldmVyc2VcIl0gPSBcInJldmVyc2VcIjtcclxufSkoUmVwZWF0VHlwZSB8fCAoUmVwZWF0VHlwZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIGlzTm9kZUFycmF5KGFycmF5KSB7XHJcbiAgICByZXR1cm4gYXJyYXkuZXZlcnkoKG4pID0+IG4gaW5zdGFuY2VvZiBOb2RlKTtcclxufVxyXG5jbGFzcyBBbmltYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcclxuICAgICAgICB0aGlzLmVsYXBzZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNSZXZlcnNlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICB0aGlzLmlkID0gb3B0cy5pZDtcclxuICAgICAgICB0aGlzLmdyb3VwSWQgPSBvcHRzLmdyb3VwSWQ7XHJcbiAgICAgICAgdGhpcy5hdXRvcGxheSA9IChfYSA9IG9wdHMuYXV0b3BsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XHJcbiAgICAgICAgdGhpcy5kZWxheSA9IChfYiA9IG9wdHMuZGVsYXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IChfYyA9IG9wdHMuZHVyYXRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDEwMDA7XHJcbiAgICAgICAgdGhpcy5lYXNlID0gKF9kID0gb3B0cy5lYXNlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBsaW5lYXI7XHJcbiAgICAgICAgdGhpcy5yZXBlYXQgPSAoX2UgPSBvcHRzLnJlcGVhdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcclxuICAgICAgICB0aGlzLnJlcGVhdFR5cGUgPSAoX2YgPSBvcHRzLnJlcGVhdFR5cGUpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IFJlcGVhdFR5cGUuTG9vcDtcclxuICAgICAgICAvLyB1c2VyIGRlZmluZWQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gb3B0cy5vbkNvbXBsZXRlO1xyXG4gICAgICAgIHRoaXMub25QbGF5ID0gb3B0cy5vblBsYXk7XHJcbiAgICAgICAgdGhpcy5vblN0b3AgPSBvcHRzLm9uU3RvcDtcclxuICAgICAgICB0aGlzLm9uUmVwZWF0ID0gb3B0cy5vblJlcGVhdDtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gb3B0cy5vblVwZGF0ZTtcclxuICAgICAgICAvLyBhbmltYXRpb24gaW50ZXJwb2xhdG9yIGJhc2VkIG9uIGBmcm9tYCAmIGB0b2AgdHlwZXNcclxuICAgICAgICB0aGlzLmludGVycG9sYXRlID0gdGhpcy5jcmVhdGVJbnRlcnBvbGF0b3Iob3B0cy5mcm9tLCBvcHRzLnRvKTtcclxuICAgICAgICBpZiAob3B0cy5za2lwID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIChfZyA9IHRoaXMub25VcGRhdGUpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jYWxsKHRoaXMsIG9wdHMudG8sIGZhbHNlLCB0aGlzKTtcclxuICAgICAgICAgICAgKF9oID0gdGhpcy5vblN0b3ApID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5jYWxsKHRoaXMsIHRoaXMpO1xyXG4gICAgICAgICAgICAoX2ogPSB0aGlzLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jYWxsKHRoaXMsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmF1dG9wbGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSBhbmltYXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gcHJldmVudCBmbGFzaGVzXHJcbiAgICAgICAgICAgIChfayA9IHRoaXMub25VcGRhdGUpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5jYWxsKHRoaXMsIG9wdHMuZnJvbSwgdHJ1ZSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGxheSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMub25QbGF5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5vblN0b3ApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJlc2V0KG9wdHMpIHtcclxuICAgICAgICBjb25zdCBkZWx0YVN0YXRlID0gdGhpcy5pbnRlcnBvbGF0ZSh0aGlzLmlzUmV2ZXJzZSA/IDEgLSB0aGlzLmRlbHRhIDogdGhpcy5kZWx0YSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZSA9IHRoaXMuY3JlYXRlSW50ZXJwb2xhdG9yKGRlbHRhU3RhdGUsIG9wdHMudG8pO1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5pdGVyYXRpb24gPSAwO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5kZWxheSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxheSA9IG9wdHMuZGVsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IG9wdHMuZHVyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5lYXNlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWFzZSA9IG9wdHMuZWFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodGltZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZCArPSB0aW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmVsYXBzZWQgPD0gdGhpcy5kZWxheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmludGVycG9sYXRlKHRoaXMuaXNSZXZlcnNlID8gMSAtIHRoaXMuZGVsdGEgOiB0aGlzLmRlbHRhKTtcclxuICAgICAgICAoX2EgPSB0aGlzLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB2YWx1ZSwgZmFsc2UsIHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmVsYXBzZWQgLSB0aGlzLmRlbGF5ID49IHRoaXMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlcmF0aW9uIDwgdGhpcy5yZXBlYXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlcmF0aW9uKys7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWQgPSAoKHRoaXMuZWxhcHNlZCAtIHRoaXMuZGVsYXkpICUgdGhpcy5kdXJhdGlvbikgKyB0aGlzLmRlbGF5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0VHlwZSA9PT0gUmVwZWF0VHlwZS5SZXZlcnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JldmVyc2UgPSAhdGhpcy5pc1JldmVyc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLm9uUmVwZWF0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgKF9jID0gdGhpcy5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldCBkZWx0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lYXNlKGNsYW1wKDAsICh0aGlzLmVsYXBzZWQgLSB0aGlzLmRlbGF5KSAvIHRoaXMuZHVyYXRpb24sIDEpKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUludGVycG9sYXRvcihmcm9tLCB0bykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJvbSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRlcnBvbGF0b3JFbnRyaWVzID0gT2JqZWN0LmtleXModG8pLm1hcCgoa2V5KSA9PiBbXHJcbiAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyb21ba2V5XSwgdG9ba2V5XSksXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmV0dXJuIChkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGludGVycG9sYXRvcl0gb2YgaW50ZXJwb2xhdG9yRW50cmllcykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbnRlcnBvbGF0b3IoZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaW50ZXJwb2xhdGVWYWx1ZShhLCBiKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgYSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVOdW1iZXIoYSwgYik7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUNvbG9yKGEsIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIEVycm9yLWNhc2UgaGFuZGxlZCBiZWxvdy5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaW50ZXJwb2xhdGUgdmFsdWVzOiAke2F9LCAke2J9YCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgTk9ERV9VUERBVEVfUEhBU0VTID0gWydyZW1vdmVkJywgJ3VwZGF0ZWQnLCAnYWRkZWQnXTtcclxuY29uc3QgRlJPTV9UT19NSVhJTlMgPSB7XHJcbiAgICBhZGRlZDogQUREX1BIQVNFLFxyXG4gICAgdXBkYXRlZDogVVBEQVRFX1BIQVNFLFxyXG4gICAgcmVtb3ZlZDogUkVNT1ZFX1BIQVNFLFxyXG4gICAgdW5rbm93bjogSU5JVElBTF9MT0FELFxyXG59O1xyXG4vKipcclxuICogSW1wbGVtZW50cyBhIHBlci1ub2RlIFwidG8vZnJvbVwiIGFuaW1hdGlvbiwgd2l0aCBzdXBwb3J0IGZvciBkZXRlY3Rpb24gb2YgYWRkZWQvbW92ZWQvcmVtb3ZlZFxyXG4gKiBub2Rlcy5cclxuICpcclxuICogQHBhcmFtIGlkIHByZWZpeCBmb3IgYWxsIGFuaW1hdGlvbiBpZHMgZ2VuZXJhdGVkIGJ5IHRoaXMgY2FsbFxyXG4gKiBAcGFyYW0gYW5pbWF0aW9uTWFuYWdlciB1c2VkIHRvIHNjaGVkdWxlIGdlbmVyYXRlZCBhbmltYXRpb25zXHJcbiAqIEBwYXJhbSBzZWxlY3Rpb25zIGNvbnRhaW5zIG5vZGVzIHRvIGJlIGFuaW1hdGVkXHJcbiAqIEBwYXJhbSBmcm9tRm4gY2FsbGJhY2sgdG8gZGV0ZXJtaW5lIHBlci1ub2RlIHN0YXJ0aW5nIHByb3BlcnRpZXNcclxuICogQHBhcmFtIHRvRm4gY2FsbGJhY2sgdG8gZGV0ZXJtaW5lIHBlci1ub2RlIGZpbmFsIHByb3BlcnRpZXNcclxuICogQHBhcmFtIGV4dHJhT3B0cyBvcHRpb25hbCBhZGRpdGlvbmFsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gQW5pbWF0aW9uTWFuYWdlciNhbmltYXRlLlxyXG4gKiBAcGFyYW0gZ2V0RGF0dW1JZCBvcHRpb25hbCBwZXItZGF0dW0gJ2lkJyBnZW5lcmF0aW9uIGZ1bmN0aW9uIGZvciBkaWZmIGNhbGN1bGF0aW9uIC0gbXVzdCBiZVxyXG4gKiAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWQgaWZmIGRpZmYgaXMgc3BlY2lmaWVkXHJcbiAqIEBwYXJhbSBkaWZmIG9wdGlvbmFsIGRpZmYgZnJvbSBhIERhdGFNb2RlbCB0byB1c2UgdG8gZGV0ZWN0IGFkZGVkL21vdmVkL3JlbW92ZWQgY2FzZXNcclxuICovXHJcbmZ1bmN0aW9uIGZyb21Ub01vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uc09yTm9kZXMsIGZucywgZ2V0RGF0dW1JZCwgZGlmZikge1xyXG4gICAgY29uc3QgeyBkZWZhdWx0RHVyYXRpb24gfSA9IGFuaW1hdGlvbk1hbmFnZXI7XHJcbiAgICBjb25zdCB7IGZyb21GbiwgdG9GbiwgaW50ZXJtZWRpYXRlRm4gfSA9IGZucztcclxuICAgIGNvbnN0IGlzTm9kZXMgPSBpc05vZGVBcnJheShzZWxlY3Rpb25zT3JOb2Rlcyk7XHJcbiAgICBjb25zdCBub2RlcyA9IGlzTm9kZXMgPyBzZWxlY3Rpb25zT3JOb2RlcyA6IFtdO1xyXG4gICAgY29uc3Qgc2VsZWN0aW9ucyA9ICFpc05vZGVzID8gc2VsZWN0aW9uc09yTm9kZXMgOiBbXTtcclxuICAgIC8vIER5bmFtaWMgY2FzZSB3aXRoIHZhcnlpbmcgYWRkL3VwZGF0ZS9yZW1vdmUgYmVoYXZpb3IuXHJcbiAgICBjb25zdCBpZHMgPSB7IGFkZGVkOiB7fSwgcmVtb3ZlZDoge30gfTtcclxuICAgIGlmIChnZXREYXR1bUlkICYmIGRpZmYpIHtcclxuICAgICAgICBpZHMuYWRkZWQgPSB6aXBPYmplY3QoZGlmZi5hZGRlZCwgdHJ1ZSk7XHJcbiAgICAgICAgaWRzLnJlbW92ZWQgPSB6aXBPYmplY3QoZGlmZi5yZW1vdmVkLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb2Nlc3NOb2RlcyA9IChsaXZlTm9kZXMsIG5vZGVzKSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBsZXQgcHJldkZyb21Qcm9wcztcclxuICAgICAgICBsZXQgbGl2ZU5vZGVJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IG5vZGVJbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzTGl2ZSA9IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4XSA9PT0gbm9kZTtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0ge1xyXG4gICAgICAgICAgICAgICAgbGFzdDogbm9kZUluZGV4ID49IG5vZGVzLmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgICAgICBsYXN0TGl2ZTogbGl2ZU5vZGVJbmRleCA+PSBsaXZlTm9kZXMubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgICAgIHByZXY6IG5vZGVzW25vZGVJbmRleCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgcHJldkZyb21Qcm9wcyxcclxuICAgICAgICAgICAgICAgIHByZXZMaXZlOiBsaXZlTm9kZXNbbGl2ZU5vZGVJbmRleCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgbmV4dDogbm9kZXNbbm9kZUluZGV4ICsgMV0sXHJcbiAgICAgICAgICAgICAgICBuZXh0TGl2ZTogbGl2ZU5vZGVzW2xpdmVOb2RlSW5kZXggKyAoaXNMaXZlID8gMSA6IDApXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uSWQgPSBgJHtncm91cElkfV8ke3N1YklkfV8ke25vZGUuaWR9YDtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25JZChhbmltYXRpb25JZCk7XHJcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSAndW5rbm93bic7XHJcbiAgICAgICAgICAgIGlmICghaXNMaXZlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAncmVtb3ZlZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZ2V0RGF0dW1JZCAmJiBkaWZmKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBjYWxjdWxhdGVTdGF0dXMobm9kZSwgbm9kZS5kYXR1bSwgZ2V0RGF0dW1JZCwgaWRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBfYyA9IGZyb21Gbihub2RlLCBub2RlLmRhdHVtLCBzdGF0dXMsIGN0eCksIHsgYW5pbWF0aW9uRGVsYXk6IGRlbGF5LCBhbmltYXRpb25EdXJhdGlvbjogZHVyYXRpb24sIHN0YXJ0ID0ge30sIGZpbmlzaCA9IHt9IH0gPSBfYywgZnJvbSA9IF9fcmVzdChfYywgW1wiYW5pbWF0aW9uRGVsYXlcIiwgXCJhbmltYXRpb25EdXJhdGlvblwiLCBcInN0YXJ0XCIsIFwiZmluaXNoXCJdKTtcclxuICAgICAgICAgICAgY29uc3QgX2QgPSB0b0ZuKG5vZGUsIG5vZGUuZGF0dW0sIHN0YXR1cywgY3R4KSwgeyBhbmltYXRpb25EZWxheTogdG9EZWxheSwgYW5pbWF0aW9uRHVyYXRpb246IHRvRHVyYXRpb24sIHN0YXJ0OiB0b1N0YXJ0ID0ge30sIGZpbmlzaDogdG9GaW5pc2ggPSB7fSB9ID0gX2QsIHRvID0gX19yZXN0KF9kLCBbXCJhbmltYXRpb25EZWxheVwiLCBcImFuaW1hdGlvbkR1cmF0aW9uXCIsIFwic3RhcnRcIiwgXCJmaW5pc2hcIl0pO1xyXG4gICAgICAgICAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGFuaW1hdGlvbklkLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBJZCxcclxuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXHJcbiAgICAgICAgICAgICAgICB0bzogdG8sXHJcbiAgICAgICAgICAgICAgICBlYXNlOiBlYXNlT3V0LFxyXG4gICAgICAgICAgICAgICAgb25QbGF5OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhcnQpLCB0b1N0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25VcGRhdGUocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVGbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoaW50ZXJtZWRpYXRlRm4obm9kZSwgbm9kZS5kYXR1bSwgc3RhdHVzLCBjdHgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25TdG9wOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0byksIGZpbmlzaCksIHRvRmluaXNoKSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246ICgoX2EgPSBkdXJhdGlvbiAhPT0gbnVsbCAmJiBkdXJhdGlvbiAhPT0gdm9pZCAwID8gZHVyYXRpb24gOiB0b0R1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSAqIGRlZmF1bHREdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGRlbGF5OiAoKF9iID0gZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgIT09IHZvaWQgMCA/IGRlbGF5IDogdG9EZWxheSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKiBkZWZhdWx0RHVyYXRpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaXNMaXZlKSB7XHJcbiAgICAgICAgICAgICAgICBsaXZlTm9kZUluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZUluZGV4Kys7XHJcbiAgICAgICAgICAgIHByZXZGcm9tUHJvcHMgPSBmcm9tO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBsZXQgc2VsZWN0aW9uSW5kZXggPSAwO1xyXG4gICAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLm5vZGVzKCk7XHJcbiAgICAgICAgY29uc3QgbGl2ZU5vZGVzID0gbm9kZXMuZmlsdGVyKChuKSA9PiAhc2VsZWN0aW9uLmlzR2FyYmFnZShuKSk7XHJcbiAgICAgICAgcHJvY2Vzc05vZGVzKGxpdmVOb2Rlcywgbm9kZXMpO1xyXG4gICAgICAgIC8vIE9ubHkgcGVyZm9ybSBzZWxlY3Rpb24gY2xlYW51cCBvbmNlLlxyXG4gICAgICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfV9zZWxlY3Rpb25fJHtzZWxlY3Rpb25JbmRleH1gLFxyXG4gICAgICAgICAgICBncm91cElkLFxyXG4gICAgICAgICAgICBmcm9tOiAwLFxyXG4gICAgICAgICAgICB0bzogMSxcclxuICAgICAgICAgICAgZWFzZTogZWFzZU91dCxcclxuICAgICAgICAgICAgb25TdG9wKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZWxlY3Rpb25JbmRleCsrO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc05vZGVzKG5vZGVzLCBub2Rlcyk7XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSBiYXRjaCBcInRvL2Zyb21cIiBhbmltYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBpZCBwcmVmaXggZm9yIGFsbCBhbmltYXRpb24gaWRzIGdlbmVyYXRlZCBieSB0aGlzIGNhbGxcclxuICogQHBhcmFtIGFuaW1hdGlvbk1hbmFnZXIgdXNlZCB0byBzY2hlZHVsZSBnZW5lcmF0ZWQgYW5pbWF0aW9uc1xyXG4gKiBAcGFyYW0gc2VsZWN0aW9uc09yTm9kZXMgY29udGFpbnMgbm9kZXMgdG8gYmUgYW5pbWF0ZWRcclxuICogQHBhcmFtIGZyb20gbm9kZSBzdGFydGluZyBwcm9wZXJ0aWVzXHJcbiAqIEBwYXJhbSB0byBub2RlIGZpbmFsIHByb3BlcnRpZXNcclxuICogQHBhcmFtIGV4dHJhT3B0cyBvcHRpb25hbCBhZGRpdGlvbmFsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gQW5pbWF0aW9uTWFuYWdlciNhbmltYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhdGljRnJvbVRvTW90aW9uKGdyb3VwSWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb25zT3JOb2RlcywgZnJvbSwgdG8sIGV4dHJhT3B0cyA9IHt9KSB7XHJcbiAgICBjb25zdCBpc05vZGVzID0gaXNOb2RlQXJyYXkoc2VsZWN0aW9uc09yTm9kZXMpO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBpc05vZGVzID8gc2VsZWN0aW9uc09yTm9kZXMgOiBbXTtcclxuICAgIGNvbnN0IHNlbGVjdGlvbnMgPSAhaXNOb2RlcyA/IHNlbGVjdGlvbnNPck5vZGVzIDogW107XHJcbiAgICBjb25zdCB7IGFuaW1hdGlvbkRlbGF5ID0gMCwgYW5pbWF0aW9uRHVyYXRpb24gPSAxLCBzdGFydCA9IHt9LCBmaW5pc2ggPSB7fSB9ID0gZXh0cmFPcHRzO1xyXG4gICAgY29uc3QgeyBkZWZhdWx0RHVyYXRpb24gfSA9IGFuaW1hdGlvbk1hbmFnZXI7XHJcbiAgICAvLyBTaW1wbGUgc3RhdGljIHRvL2Zyb20gY2FzZSwgd2UgY2FuIGJhdGNoIHVwZGF0ZXMuXHJcbiAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xyXG4gICAgICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfWAsXHJcbiAgICAgICAgZ3JvdXBJZCxcclxuICAgICAgICBmcm9tLFxyXG4gICAgICAgIHRvLFxyXG4gICAgICAgIGVhc2U6IGVhc2VPdXQsXHJcbiAgICAgICAgb25QbGF5OiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0aW9uLm5vZGVzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvblVwZGF0ZShwcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25TdG9wOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG8pLCBmaW5pc2gpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0aW9uLm5vZGVzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0byksIGZpbmlzaCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24gKiBkZWZhdWx0RHVyYXRpb24sXHJcbiAgICAgICAgZGVsYXk6IGFuaW1hdGlvbkRlbGF5ICogZGVmYXVsdER1cmF0aW9uLFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlU3RhdHVzKG5vZGUsIGRhdHVtLCBnZXREYXR1bUlkLCBpZHMpIHtcclxuICAgIGNvbnN0IGlkID0gZ2V0RGF0dW1JZChub2RlLCBkYXR1bSk7XHJcbiAgICBpZiAoaWRzLmFkZGVkW2lkXSkge1xyXG4gICAgICAgIHJldHVybiAnYWRkZWQnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaWRzLnJlbW92ZWRbaWRdKSB7XHJcbiAgICAgICAgcmV0dXJuICdyZW1vdmVkJztcclxuICAgIH1cclxuICAgIHJldHVybiAndXBkYXRlZCc7XHJcbn1cblxudmFyIGZyb21Ub01vdGlvbiQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBOT0RFX1VQREFURV9QSEFTRVM6IE5PREVfVVBEQVRFX1BIQVNFUyxcbiAgICBGUk9NX1RPX01JWElOUzogRlJPTV9UT19NSVhJTlMsXG4gICAgZnJvbVRvTW90aW9uOiBmcm9tVG9Nb3Rpb24sXG4gICAgc3RhdGljRnJvbVRvTW90aW9uOiBzdGF0aWNGcm9tVG9Nb3Rpb25cbn0pO1xuXG5jb25zdCBncm91cCA9IChjb250ZW50KSA9PiBgKCR7Y29udGVudH0pYDtcclxuY29uc3Qgb3B0aW9uYWxHcm91cCA9IChjb250ZW50KSA9PiBgJHtncm91cChjb250ZW50KX0/YDtcclxuY29uc3Qgbm9uQ2FwdHVyaW5nR3JvdXAgPSAoY29udGVudCkgPT4gb3B0aW9uYWxHcm91cChgPzoke2NvbnRlbnR9YCk7XHJcbmNvbnN0IGZvcm1hdFJlZ0V4ID0gKCgpID0+IHtcclxuICAgIGNvbnN0IGZpbGwgPSAnLic7XHJcbiAgICBjb25zdCBhbGlnbiA9ICdbPD49Xl0nO1xyXG4gICAgY29uc3Qgc2lnbiA9ICdbK1xcXFwtKCBdJztcclxuICAgIGNvbnN0IHN5bWJvbCA9ICdbJOKCrMKjwqXigqPigrkjXSc7XHJcbiAgICBjb25zdCB6ZXJvID0gJzAnO1xyXG4gICAgY29uc3Qgd2lkdGggPSAnXFxcXGQrJztcclxuICAgIGNvbnN0IGNvbW1hID0gJywnO1xyXG4gICAgY29uc3QgcHJlY2lzaW9uID0gJ1xcXFxkKyc7XHJcbiAgICBjb25zdCB0aWxkZSA9ICd+JztcclxuICAgIGNvbnN0IHR5cGUgPSAnWyVhLXpdJztcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKFtcclxuICAgICAgICAnXicsXHJcbiAgICAgICAgbm9uQ2FwdHVyaW5nR3JvdXAoYCR7b3B0aW9uYWxHcm91cChmaWxsKX0ke2dyb3VwKGFsaWduKX1gKSxcclxuICAgICAgICBvcHRpb25hbEdyb3VwKHNpZ24pLFxyXG4gICAgICAgIG9wdGlvbmFsR3JvdXAoc3ltYm9sKSxcclxuICAgICAgICBvcHRpb25hbEdyb3VwKHplcm8pLFxyXG4gICAgICAgIG9wdGlvbmFsR3JvdXAod2lkdGgpLFxyXG4gICAgICAgIG9wdGlvbmFsR3JvdXAoY29tbWEpLFxyXG4gICAgICAgIG5vbkNhcHR1cmluZ0dyb3VwKGBcXFxcLiR7Z3JvdXAocHJlY2lzaW9uKX1gKSxcclxuICAgICAgICBvcHRpb25hbEdyb3VwKHRpbGRlKSxcclxuICAgICAgICBvcHRpb25hbEdyb3VwKHR5cGUpLFxyXG4gICAgICAgICckJyxcclxuICAgIF0uam9pbignJyksICdpJyk7XHJcbn0pKCk7XHJcbmNvbnN0IHN1cnJvdW5kZWRSZWdFeCA9ICgoKSA9PiB7XHJcbiAgICBjb25zdCBwcmVmaXggPSAnLio/JztcclxuICAgIGNvbnN0IGNvbnRlbnQgPSAnLis/JztcclxuICAgIGNvbnN0IHN1ZmZpeCA9ICcuKj8nO1xyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoWydeJywgZ3JvdXAocHJlZml4KSwgYCNcXFxceyR7Z3JvdXAoY29udGVudCl9XFxcXH1gLCBncm91cChzdWZmaXgpLCAnJCddLmpvaW4oJycpKTtcclxufSkoKTtcclxuZnVuY3Rpb24gcGFyc2VGb3JtYXR0ZXIoZm9ybWF0dGVyKSB7XHJcbiAgICBsZXQgcHJlZml4O1xyXG4gICAgbGV0IHN1ZmZpeDtcclxuICAgIGNvbnN0IHN1cnJvdW5kZWQgPSBzdXJyb3VuZGVkUmVnRXguZXhlYyhmb3JtYXR0ZXIpO1xyXG4gICAgaWYgKHN1cnJvdW5kZWQpIHtcclxuICAgICAgICBbLCBwcmVmaXgsIGZvcm1hdHRlciwgc3VmZml4XSA9IHN1cnJvdW5kZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXRjaCA9IGZvcm1hdFJlZ0V4LmV4ZWMoZm9ybWF0dGVyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBudW1iZXIgZm9ybWF0dGVyIGlzIGludmFsaWQ6ICR7Zm9ybWF0dGVyfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgWywgZmlsbCwgYWxpZ24sIHNpZ24sIHN5bWJvbCwgemVybywgd2lkdGgsIGNvbW1hLCBwcmVjaXNpb24sIHRyaW0sIHR5cGVdID0gbWF0Y2g7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpbGwsXHJcbiAgICAgICAgYWxpZ24sXHJcbiAgICAgICAgc2lnbixcclxuICAgICAgICBzeW1ib2wsXHJcbiAgICAgICAgemVybyxcclxuICAgICAgICB3aWR0aDogcGFyc2VJbnQod2lkdGgpLFxyXG4gICAgICAgIGNvbW1hLFxyXG4gICAgICAgIHByZWNpc2lvbjogcGFyc2VJbnQocHJlY2lzaW9uKSxcclxuICAgICAgICB0cmltOiBCb29sZWFuKHRyaW0pLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgcHJlZml4LFxyXG4gICAgICAgIHN1ZmZpeCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnID8gcGFyc2VGb3JtYXR0ZXIoZm9ybWF0dGVyKSA6IGZvcm1hdHRlcjtcclxuICAgIGNvbnN0IHsgZmlsbCwgYWxpZ24sIHNpZ24gPSAnLScsIHN5bWJvbCwgemVybywgd2lkdGgsIGNvbW1hLCB0eXBlLCBwcmVmaXggPSAnJywgc3VmZml4ID0gJycsIHByZWNpc2lvbiB9ID0gb3B0aW9ucztcclxuICAgIGxldCB7IHRyaW0gfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBwcmVjaXNpb25Jc05hTiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKHByZWNpc2lvbik7XHJcbiAgICBsZXQgZm9ybWF0Qm9keTtcclxuICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgIGZvcm1hdEJvZHkgPSBkZWNpbWFsVHlwZXNbJ2cnXTtcclxuICAgICAgICB0cmltID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW4gZGVjaW1hbFR5cGVzICYmIHR5cGUgaW4gaW50ZWdlclR5cGVzKSB7XHJcbiAgICAgICAgZm9ybWF0Qm9keSA9IHByZWNpc2lvbklzTmFOID8gaW50ZWdlclR5cGVzW3R5cGVdIDogZGVjaW1hbFR5cGVzW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbiBkZWNpbWFsVHlwZXMpIHtcclxuICAgICAgICBmb3JtYXRCb2R5ID0gZGVjaW1hbFR5cGVzW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbiBpbnRlZ2VyVHlwZXMpIHtcclxuICAgICAgICBmb3JtYXRCb2R5ID0gaW50ZWdlclR5cGVzW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbnVtYmVyIGZvcm1hdHRlciB0eXBlIGlzIGludmFsaWQ6ICR7dHlwZX1gKTtcclxuICAgIH1cclxuICAgIGxldCBmb3JtYXR0ZXJQcmVjaXNpb247XHJcbiAgICBpZiAocHJlY2lzaW9uID09IG51bGwgfHwgcHJlY2lzaW9uSXNOYU4pIHtcclxuICAgICAgICBmb3JtYXR0ZXJQcmVjaXNpb24gPSB0eXBlID8gNiA6IDEyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9ybWF0dGVyUHJlY2lzaW9uID0gcHJlY2lzaW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChuKSA9PiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZvcm1hdEJvZHkobiwgZm9ybWF0dGVyUHJlY2lzaW9uKTtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZW1vdmVUcmFpbGluZ1plcm9zKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21tYSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBpbnNlcnRTZXBhcmF0b3IocmVzdWx0LCBjb21tYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCA9IGFkZFNpZ24obiwgcmVzdWx0LCBzaWduKTtcclxuICAgICAgICBpZiAoc3ltYm9sICYmIHN5bWJvbCAhPT0gJyMnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGAke3N5bWJvbH0ke3Jlc3VsdH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3ltYm9sID09PSAnIycgJiYgdHlwZSA9PT0gJ3gnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGAweCR7cmVzdWx0fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSAncycpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSR7Z2V0U0lQcmVmaXgobil9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICclJyB8fCB0eXBlID09PSAncCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSVgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2lkdGggIT0gbnVsbCAmJiAhaXNOYU4od2lkdGgpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZFBhZGRpbmcocmVzdWx0LCB3aWR0aCwgZmlsbCAhPT0gbnVsbCAmJiBmaWxsICE9PSB2b2lkIDAgPyBmaWxsIDogemVybywgYWxpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSBgJHtwcmVmaXh9JHtyZXN1bHR9JHtzdWZmaXh9YDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBhYnNGbG9vciA9IChuKSA9PiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcclxuY29uc3QgaW50ZWdlclR5cGVzID0ge1xyXG4gICAgYjogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDIpLFxyXG4gICAgYzogKG4pID0+IFN0cmluZy5mcm9tQ2hhckNvZGUobiksXHJcbiAgICBkOiAobikgPT4gTWF0aC5yb3VuZChNYXRoLmFicyhuKSkudG9GaXhlZCgwKSxcclxuICAgIG86IChuKSA9PiBhYnNGbG9vcihuKS50b1N0cmluZyg4KSxcclxuICAgIHg6IChuKSA9PiBhYnNGbG9vcihuKS50b1N0cmluZygxNiksXHJcbiAgICBYOiAobikgPT4gaW50ZWdlclR5cGVzLngobikudG9VcHBlckNhc2UoKSxcclxuICAgIG46IChuKSA9PiBpbnRlZ2VyVHlwZXMuZChuKSxcclxuICAgICclJzogKG4pID0+IGAke2Fic0Zsb29yKG4gKiAxMDApLnRvRml4ZWQoMCl9YCxcclxufTtcclxuY29uc3QgZGVjaW1hbFR5cGVzID0ge1xyXG4gICAgZTogKG4sIGYpID0+IE1hdGguYWJzKG4pLnRvRXhwb25lbnRpYWwoZiksXHJcbiAgICBFOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmUobiwgZikudG9VcHBlckNhc2UoKSxcclxuICAgIGY6IChuLCBmKSA9PiBNYXRoLmFicyhuKS50b0ZpeGVkKGYpLFxyXG4gICAgRjogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5mKG4sIGYpLnRvVXBwZXJDYXNlKCksXHJcbiAgICBnOiAobiwgZikgPT4ge1xyXG4gICAgICAgIGlmIChuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnMCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGEgPSBNYXRoLmFicyhuKTtcclxuICAgICAgICBjb25zdCBwID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGEpKTtcclxuICAgICAgICBpZiAocCA+PSAtNCAmJiBwIDwgZikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS50b0ZpeGVkKGYgLSAxIC0gcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhLnRvRXhwb25lbnRpYWwoZiAtIDEpO1xyXG4gICAgfSxcclxuICAgIEc6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZyhuLCBmKS50b1VwcGVyQ2FzZSgpLFxyXG4gICAgbjogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5nKG4sIGYpLFxyXG4gICAgcDogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5yKG4gKiAxMDAsIGYpLFxyXG4gICAgcjogKG4sIGYpID0+IHtcclxuICAgICAgICBpZiAobiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhID0gTWF0aC5hYnMobik7XHJcbiAgICAgICAgY29uc3QgcCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChhKSk7XHJcbiAgICAgICAgY29uc3QgcSA9IHAgLSAoZiAtIDEpO1xyXG4gICAgICAgIGlmIChxIDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEudG9GaXhlZCgtcSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLnBvdygxMCwgcSk7XHJcbiAgICAgICAgcmV0dXJuIChNYXRoLnJvdW5kKGEgLyB4KSAqIHgpLnRvRml4ZWQoKTtcclxuICAgIH0sXHJcbiAgICBzOiAobiwgZikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHAgPSBnZXRTSVByZWZpeFBvd2VyKG4pO1xyXG4gICAgICAgIHJldHVybiBkZWNpbWFsVHlwZXMucihuIC8gTWF0aC5wb3coMTAsIHApLCBmKTtcclxuICAgIH0sXHJcbiAgICAnJSc6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZihuICogMTAwLCBmKSxcclxufTtcclxuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdaZXJvcyhudW1TdHJpbmcpIHtcclxuICAgIHJldHVybiBudW1TdHJpbmcucmVwbGFjZSgvXFwuMCskLywgJycpLnJlcGxhY2UoLyhcXC5bMS05XSkwKyQvLCAnJDEnKTtcclxufVxyXG5mdW5jdGlvbiBpbnNlcnRTZXBhcmF0b3IobnVtU3RyaW5nLCBzZXBhcmF0b3IpIHtcclxuICAgIGxldCBkb3RJbmRleCA9IG51bVN0cmluZy5pbmRleE9mKCcuJyk7XHJcbiAgICBpZiAoZG90SW5kZXggPCAwKSB7XHJcbiAgICAgICAgZG90SW5kZXggPSBudW1TdHJpbmcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW50ZWdlckNoYXJzID0gbnVtU3RyaW5nLnN1YnN0cmluZygwLCBkb3RJbmRleCkuc3BsaXQoJycpO1xyXG4gICAgY29uc3QgZnJhY3Rpb25hbFBhcnQgPSBudW1TdHJpbmcuc3Vic3RyaW5nKGRvdEluZGV4KTtcclxuICAgIGZvciAobGV0IGkgPSBpbnRlZ2VyQ2hhcnMubGVuZ3RoIC0gMzsgaSA+IDA7IGkgLT0gMykge1xyXG4gICAgICAgIGludGVnZXJDaGFycy5zcGxpY2UoaSwgMCwgc2VwYXJhdG9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiBgJHtpbnRlZ2VyQ2hhcnMuam9pbignJyl9JHtmcmFjdGlvbmFsUGFydH1gO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNJUHJlZml4KG4pIHtcclxuICAgIHJldHVybiBzaVByZWZpeGVzW2dldFNJUHJlZml4UG93ZXIobildO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNJUHJlZml4UG93ZXIobikge1xyXG4gICAgY29uc3QgcG93ZXIgPSBNYXRoLmxvZzEwKE1hdGguYWJzKG4pKTtcclxuICAgIGNvbnN0IHAgPSBNYXRoLmZsb29yKHBvd2VyIC8gMykgKiAzO1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KG1pblNJUHJlZml4LCBNYXRoLm1pbihtYXhTSVByZWZpeCwgcCkpO1xyXG59XHJcbmNvbnN0IG1pblNJUHJlZml4ID0gLTI0O1xyXG5jb25zdCBtYXhTSVByZWZpeCA9IDI0O1xyXG5jb25zdCBzaVByZWZpeGVzID0ge1xyXG4gICAgW21pblNJUHJlZml4XTogJ3knLFxyXG4gICAgWy0yMV06ICd6JyxcclxuICAgIFstMThdOiAnYScsXHJcbiAgICBbLTE1XTogJ2YnLFxyXG4gICAgWy0xMl06ICdwJyxcclxuICAgIFstOV06ICduJyxcclxuICAgIFstNl06ICfCtScsXHJcbiAgICBbLTNdOiAnbScsXHJcbiAgICBbMF06ICcnLFxyXG4gICAgWzNdOiAnaycsXHJcbiAgICBbNl06ICdNJyxcclxuICAgIFs5XTogJ0cnLFxyXG4gICAgWzEyXTogJ1QnLFxyXG4gICAgWzE1XTogJ1AnLFxyXG4gICAgWzE4XTogJ0UnLFxyXG4gICAgWzIxXTogJ1onLFxyXG4gICAgW21heFNJUHJlZml4XTogJ1knLFxyXG59O1xyXG5jb25zdCBtaW51c1NpZ24gPSAnXFx1MjIxMic7XHJcbmZ1bmN0aW9uIGFkZFNpZ24obnVtLCBudW1TdHJpbmcsIHNpZ25UeXBlID0gJycpIHtcclxuICAgIGlmIChzaWduVHlwZSA9PT0gJygnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bSA+PSAwID8gbnVtU3RyaW5nIDogYCgke251bVN0cmluZ30pYDtcclxuICAgIH1cclxuICAgIGNvbnN0IHBsdXNTaWduID0gc2lnblR5cGUgPT09ICcrJyA/ICcrJyA6ICcnO1xyXG4gICAgcmV0dXJuIGAke251bSA+PSAwID8gcGx1c1NpZ24gOiBtaW51c1NpZ259JHtudW1TdHJpbmd9YDtcclxufVxyXG5mdW5jdGlvbiBhZGRQYWRkaW5nKG51bVN0cmluZywgd2lkdGgsIGZpbGwgPSAnICcsIGFsaWduID0gJz4nKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gbnVtU3RyaW5nO1xyXG4gICAgaWYgKGFsaWduID09PSAnPicgfHwgIWFsaWduKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBhZFN0YXJ0KHdpZHRoLCBmaWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnPCcpIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucGFkRW5kKHdpZHRoLCBmaWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnXicpIHtcclxuICAgICAgICBjb25zdCBwYWRXaWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gcmVzdWx0Lmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgcGFkTGVmdCA9IE1hdGguY2VpbChwYWRXaWR0aCAvIDIpO1xyXG4gICAgICAgIGNvbnN0IHBhZFJpZ2h0ID0gTWF0aC5mbG9vcihwYWRXaWR0aCAvIDIpO1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRTdGFydChwYWRMZWZ0ICsgcmVzdWx0Lmxlbmd0aCwgZmlsbCk7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBhZEVuZChwYWRSaWdodCArIHJlc3VsdC5sZW5ndGgsIGZpbGwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB0aWNrRm9ybWF0KHRpY2tzLCBmb3JtYXR0ZXIpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUZvcm1hdHRlcihmb3JtYXR0ZXIgIT09IG51bGwgJiYgZm9ybWF0dGVyICE9PSB2b2lkIDAgPyBmb3JtYXR0ZXIgOiAnLGYnKTtcclxuICAgIGNvbnN0IHsgcHJlY2lzaW9uIH0gPSBvcHRpb25zO1xyXG4gICAgaWYgKHByZWNpc2lvbiA9PSBudWxsIHx8IGlzTmFOKHByZWNpc2lvbikpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSAnZicgfHwgb3B0aW9ucy50eXBlID09PSAnJScpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wcmVjaXNpb24gPSBNYXRoLm1heCguLi50aWNrcy5tYXAoKHgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicgfHwgeCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChNYXRoLmFicyh4KSkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlnaXRzID0gb3B0aW9ucy50eXBlID8gNiA6IDEyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwID0geC50b0V4cG9uZW50aWFsKGRpZ2l0cyAtIDEpLnJlcGxhY2UoL1xcLj8wK2UvLCAnZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG90SW5kZXggPSBleHAuaW5kZXhPZignLicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvdEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsID49IDAgPyAwIDogLWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZXhwLmluZGV4T2YoJ2UnKSAtIGRvdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHMgLSBsIC0gMSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMudHlwZSB8fCBvcHRpb25zLnR5cGUgaW4gZGVjaW1hbFR5cGVzKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucHJlY2lzaW9uID0gTWF0aC5tYXgoLi4udGlja3MubWFwKCh4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHAgPSB4LnRvRXhwb25lbnRpYWwoKG9wdGlvbnMudHlwZSA/IDYgOiAxMikgLSAxKS5yZXBsYWNlKC9cXC4/MCtlLywgJ2UnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHAuc3Vic3RyaW5nKDAsIGV4cC5pbmRleE9mKCdlJykpLnJlcGxhY2UoJy4nLCAnJykubGVuZ3RoO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZiA9IGZvcm1hdChvcHRpb25zKTtcclxuICAgIHJldHVybiAobikgPT4gZihOdW1iZXIobikpO1xyXG59XG5cbmZ1bmN0aW9uIHRpY2tzIChzdGFydCwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCkge1xyXG4gICAgaWYgKGNvdW50IDwgMikge1xyXG4gICAgICAgIHJldHVybiByYW5nZSQxKHN0YXJ0LCBzdG9wLCBzdG9wIC0gc3RhcnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KTtcclxuICAgIGlmIChpc05hTihzdGVwKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTnVtZXJpY1RpY2tzKDApO1xyXG4gICAgfVxyXG4gICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XHJcbiAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wIC8gc3RlcCkgKiBzdGVwO1xyXG4gICAgcmV0dXJuIHJhbmdlJDEoc3RhcnQsIHN0b3AsIHN0ZXApO1xyXG59XHJcbmNvbnN0IHRpY2tNdWx0aXBsaWVycyA9IFsxLCAyLCA1LCAxMF07XHJcbmZ1bmN0aW9uIHRpY2tTdGVwKGEsIGIsIGNvdW50LCBtaW5Db3VudCA9IDAsIG1heENvdW50ID0gSW5maW5pdHkpIHtcclxuICAgIGNvbnN0IHJhd1N0ZXAgPSAoYiAtIGEpIC8gY291bnQ7XHJcbiAgICBjb25zdCBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChyYXdTdGVwKSk7XHJcbiAgICBjb25zdCBzdGVwID0gTWF0aC5wb3coMTAsIHBvd2VyKTtcclxuICAgIGNvbnN0IG0gPSB0aWNrTXVsdGlwbGllcnNcclxuICAgICAgICAubWFwKChtdWx0aXBsaWVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcyA9IG11bHRpcGxpZXIgKiBzdGVwO1xyXG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNlaWwoKGIgLSBhKSAvIHMpO1xyXG4gICAgICAgIGNvbnN0IGlzV2l0aGluQm91bmRzID0gYyA+PSBtaW5Db3VudCAmJiBjIDw9IG1heENvdW50O1xyXG4gICAgICAgIGNvbnN0IGRpZmZDb3VudCA9IE1hdGguYWJzKGMgLSBjb3VudCk7XHJcbiAgICAgICAgcmV0dXJuIHsgbXVsdGlwbGllciwgaXNXaXRoaW5Cb3VuZHMsIGRpZmZDb3VudCB9O1xyXG4gICAgfSlcclxuICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIGlmIChhLmlzV2l0aGluQm91bmRzICE9PSBiLmlzV2l0aGluQm91bmRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmlzV2l0aGluQm91bmRzID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYS5kaWZmQ291bnQgLSBiLmRpZmZDb3VudDtcclxuICAgIH0pWzBdLm11bHRpcGxpZXI7XHJcbiAgICBpZiAoIW0gfHwgaXNOYU4obSkpIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG0gKiBzdGVwO1xyXG59XHJcbmZ1bmN0aW9uIHNpbmdsZVRpY2tEb21haW4oYSwgYikge1xyXG4gICAgY29uc3QgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoYiAtIGEpKTtcclxuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLnBvdygxMCwgcG93ZXIpO1xyXG4gICAgcmV0dXJuIHRpY2tNdWx0aXBsaWVyc1xyXG4gICAgICAgIC5tYXAoKG11bHRpcGxpZXIpID0+IHtcclxuICAgICAgICBjb25zdCBzID0gbXVsdGlwbGllciAqIHN0ZXA7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKGEgLyBzKSAqIHM7XHJcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5jZWlsKGIgLyBzKSAqIHM7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSAxIC0gKGIgLSBhKSAvIChlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gW3N0YXJ0LCBlbmRdO1xyXG4gICAgICAgIHJldHVybiB7IGVycm9yLCBkb21haW4gfTtcclxuICAgIH0pXHJcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZXJyb3IgLSBiLmVycm9yKVswXS5kb21haW47XHJcbn1cclxuY2xhc3MgTnVtZXJpY1RpY2tzIGV4dGVuZHMgQXJyYXkge1xyXG4gICAgY29uc3RydWN0b3IoZnJhY3Rpb25EaWdpdHMsIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBpZiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyYWN0aW9uRGlnaXRzID0gZnJhY3Rpb25EaWdpdHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmFuZ2UkMShzdGFydCwgc3RvcCwgc3RlcCkge1xyXG4gICAgY29uc3QgY291bnREaWdpdHMgPSAoZXhwTm8pID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gZXhwTm8uc3BsaXQoJ2UnKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoKChfYiA9IChfYSA9IHBhcnRzWzBdLnNwbGl0KCcuJylbMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApIC0gTnVtYmVyKHBhcnRzWzFdKSwgMCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZnJhY3Rpb25hbERpZ2l0cyA9IGNvdW50RGlnaXRzKChzdGVwICUgMSkudG9FeHBvbmVudGlhbCgpKTtcclxuICAgIGNvbnN0IGYgPSBNYXRoLnBvdygxMCwgZnJhY3Rpb25hbERpZ2l0cyk7XHJcbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCk7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgTnVtZXJpY1RpY2tzKGZyYWN0aW9uYWxEaWdpdHMpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdGFydCArIHN0ZXAgKiBpO1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKE1hdGgucm91bmQodmFsdWUgKiBmKSAvIGYpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxufVxuXG5jbGFzcyBDb250aW51b3VzU2NhbGUge1xyXG4gICAgc3RhdGljIGlzKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ29udGludW91c1NjYWxlO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IoZG9tYWluLCByYW5nZSkge1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgICAgICB0aGlzLm5pY2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRpY2tDb3VudCA9IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xyXG4gICAgICAgIHRoaXMubWluVGlja0NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLm1heFRpY2tDb3VudCA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMubmljZURvbWFpbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdENsYW1wTW9kZSA9ICdyYXcnO1xyXG4gICAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcyA9IFsnZG9tYWluJywgJ3JhbmdlJywgJ25pY2UnLCAndGlja0NvdW50JywgJ21pblRpY2tDb3VudCcsICdtYXhUaWNrQ291bnQnXTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybSh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm1JbnZlcnQoeCkge1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG4gICAgY2FsY0JhbmR3aWR0aChzbWFsbGVzdEludGVydmFsID0gMSkge1xyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XHJcbiAgICAgICAgY29uc3QgbWF4UmFuZ2UgPSBNYXRoLm1heCguLi50aGlzLnJhbmdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcnZhbHMgPSAoZG9tYWluWzFdIC0gZG9tYWluWzBdKSAvIHNtYWxsZXN0SW50ZXJ2YWwgKyAxO1xyXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzL2JhbmRzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB3aWR0aCBvZiBpbmRpdmlkdWFsIGJhbmRzIGJ5IGRpdmlkaW5nIHRoZSBhdmFpbGFibGUgcmFuZ2UuXHJcbiAgICAgICAgLy8gQWxsb3cgYSBtYXhpbXVtIG51bWJlciBvZiBiYW5kcyB0byBlbnN1cmUgdGhlIHN0ZXAgZG9lcyBub3QgZmFsbCBiZWxvdyAxIHBpeGVsLlxyXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhlcmUgY291bGQgYmUgc29tZSBvdmVybGFwIG9mIHRoZSBiYW5kcyBpbiB0aGUgY2hhcnQuXHJcbiAgICAgICAgY29uc3QgbWF4QmFuZHMgPSBNYXRoLmZsb29yKG1heFJhbmdlKTsgLy8gQSBtaW5pbXVtIG9mIDFweCBwZXIgYmFyL2NvbHVtbiBtZWFucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgYmFuZHMgd2lsbCBlcXVhbCB0aGUgYXZhaWxhYmxlIHJhbmdlXHJcbiAgICAgICAgY29uc3QgYmFuZHMgPSBNYXRoLm1pbihpbnRlcnZhbHMsIG1heEJhbmRzKTtcclxuICAgICAgICByZXR1cm4gbWF4UmFuZ2UgLyBNYXRoLm1heCgxLCBiYW5kcyk7XHJcbiAgICB9XHJcbiAgICBmcm9tRG9tYWluKGQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5nZXRUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICBnZXREb21haW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubmljZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubmljZURvbWFpbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5pY2VEb21haW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tYWluO1xyXG4gICAgfVxyXG4gICAgY29udmVydCh4LCBvcHRzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNsYW1wTW9kZSA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5jbGFtcE1vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZGVmYXVsdENsYW1wTW9kZTtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gdGhpcy5nZXREb21haW4oKS5tYXAoKGQpID0+IHRoaXMudHJhbnNmb3JtKGQpKTtcclxuICAgICAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcclxuICAgICAgICBjb25zdCB7IHJhbmdlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IFtyMCwgcjFdID0gcmFuZ2U7XHJcbiAgICAgICAgeCA9IHRoaXMudHJhbnNmb3JtKHgpO1xyXG4gICAgICAgIGlmIChjbGFtcE1vZGUgPT09ICdjbGFtcGVkJykge1xyXG4gICAgICAgICAgICBpZiAoeCA8IGQwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoeCA+IGQxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcjE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGQwID09PSBkMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHIwICsgcjEpIC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoeCA9PT0gZDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHIwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh4ID09PSBkMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAocjAgKyAoKHRoaXMuZnJvbURvbWFpbih4KSAtIHRoaXMuZnJvbURvbWFpbihkMCkpIC8gKHRoaXMuZnJvbURvbWFpbihkMSkgLSB0aGlzLmZyb21Eb21haW4oZDApKSkgKiAocjEgLSByMCkpO1xyXG4gICAgfVxyXG4gICAgaW52ZXJ0KHgpIHtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICBjb25zdCBkb21haW4gPSB0aGlzLmdldERvbWFpbigpLm1hcCgoZCkgPT4gdGhpcy50cmFuc2Zvcm0oZCkpO1xyXG4gICAgICAgIGNvbnN0IFtkMCwgZDFdID0gZG9tYWluO1xyXG4gICAgICAgIGNvbnN0IHsgcmFuZ2UgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgW3IwLCByMV0gPSByYW5nZTtcclxuICAgICAgICBjb25zdCBpc1JldmVyc2VkID0gcjAgPiByMTtcclxuICAgICAgICBjb25zdCByTWluID0gaXNSZXZlcnNlZCA/IHIxIDogcjA7XHJcbiAgICAgICAgY29uc3Qgck1heCA9IGlzUmV2ZXJzZWQgPyByMCA6IHIxO1xyXG4gICAgICAgIGxldCBkO1xyXG4gICAgICAgIGlmICh4IDwgck1pbikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZXZlcnNlZCA/IGQxIDogZDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHggPiByTWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JldmVyc2VkID8gZDAgOiBkMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocjAgPT09IHIxKSB7XHJcbiAgICAgICAgICAgIGQgPSB0aGlzLnRvRG9tYWluKCh0aGlzLmZyb21Eb21haW4oZDApICsgdGhpcy5mcm9tRG9tYWluKGQxKSkgLyAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGQgPSB0aGlzLnRvRG9tYWluKHRoaXMuZnJvbURvbWFpbihkMCkgKyAoKHggLSByMCkgLyAocjEgLSByMCkpICogKHRoaXMuZnJvbURvbWFpbihkMSkgLSB0aGlzLmZyb21Eb21haW4oZDApKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUludmVydChkKTtcclxuICAgIH1cclxuICAgIGRpZENoYW5nZSgpIHtcclxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGRpZENoYW5nZSA9ICFjYWNoZSB8fCB0aGlzLmNhY2hlUHJvcHMuc29tZSgocCkgPT4gdGhpc1twXSAhPT0gY2FjaGVbcF0pO1xyXG4gICAgICAgIGlmIChkaWRDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlUHJvcHMuZm9yRWFjaCgocCkgPT4gKHRoaXMuY2FjaGVbcF0gPSB0aGlzW3BdKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZWZyZXNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpZENoYW5nZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0UGl4ZWxSYW5nZSgpIHtcclxuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMucmFuZ2Uuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlWzFdIC0gcmFuZ2VbMF07XHJcbiAgICB9XHJcbiAgICBpc0RlbnNlSW50ZXJ2YWwoeyBzdGFydCwgc3RvcCwgaW50ZXJ2YWwsIGNvdW50LCB9KSB7XHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gc3RvcCAtIHN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVJhbmdlID0gdGhpcy5nZXRQaXhlbFJhbmdlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RlcCA9IHR5cGVvZiBpbnRlcnZhbCA9PT0gJ251bWJlcicgPyBpbnRlcnZhbCA6IDE7XHJcbiAgICAgICAgY291bnQgIT09IG51bGwgJiYgY291bnQgIT09IHZvaWQgMCA/IGNvdW50IDogKGNvdW50ID0gZG9tYWluIC8gc3RlcCk7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IGF2YWlsYWJsZVJhbmdlKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci53YXJuKGB0aGUgY29uZmlndXJlZCB0aWNrIGludGVydmFsIHJlc3VsdHMgaW4gbW9yZSB0aGFuIDEgdGljayBwZXIgcGl4ZWwsIGlnbm9yaW5nLiBTdXBwbHkgYSBsYXJnZXIgdGljayBpbnRlcnZhbCBvciBvbWl0IHRoaXMgY29uZmlndXJhdGlvbi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5Db250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCA9IDU7XHJcbkNvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50ID0gNjtcblxuLyoqXHJcbiAqIE1hcHMgY29udGludW91cyBkb21haW4gdG8gYSBjb250aW51b3VzIHJhbmdlLlxyXG4gKi9cclxuY2xhc3MgTGluZWFyU2NhbGUgZXh0ZW5kcyBDb250aW51b3VzU2NhbGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoWzAsIDFdLCBbMCwgMV0pO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdsaW5lYXInO1xyXG4gICAgfVxyXG4gICAgdG9Eb21haW4oZCkge1xyXG4gICAgICAgIHJldHVybiBkO1xyXG4gICAgfVxyXG4gICAgdGlja3MoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gKF9hID0gdGhpcy50aWNrQ291bnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xyXG4gICAgICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMiB8fCBjb3VudCA8IDEgfHwgdGhpcy5kb21haW4uc29tZSgoZCkgPT4gIWlzRmluaXRlKGQpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5nZXREb21haW4oKTtcclxuICAgICAgICBjb25zdCB7IGludGVydmFsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmIChpbnRlcnZhbCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGVwID0gTWF0aC5hYnMoaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEZW5zZUludGVydmFsKHsgc3RhcnQ6IGQwLCBzdG9wOiBkMSwgaW50ZXJ2YWw6IHN0ZXAgfSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZSQxKGQwLCBkMSwgc3RlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpY2tzKGQwLCBkMSwgY291bnQsIHRoaXMubWluVGlja0NvdW50LCB0aGlzLm1heFRpY2tDb3VudCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubmljZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUaWNrU3RlcChzdGFydCwgc3RvcCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSAoX2EgPSB0aGlzLnRpY2tDb3VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQ7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IHRoaXMuaW50ZXJ2YWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCwgdGhpcy5taW5UaWNrQ291bnQsIHRoaXMubWF4VGlja0NvdW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kcyB0aGUgZG9tYWluIHNvIHRoYXQgaXQgc3RhcnRzIGFuZCBlbmRzIG9uIG5pY2Ugcm91bmQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVOaWNlRG9tYWluKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IChfYSA9IHRoaXMudGlja0NvdW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudDtcclxuICAgICAgICBsZXQgW3N0YXJ0LCBzdG9wXSA9IHRoaXMuZG9tYWluO1xyXG4gICAgICAgIGlmIChjb3VudCA8IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5uaWNlRG9tYWluID0gW3N0YXJ0LCBzdG9wXTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5uaWNlRG9tYWluID0gc2luZ2xlVGlja0RvbWFpbihzdGFydCwgc3RvcCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA0O1xyXG4gICAgICAgIGxldCBwcmV2MCA9IHN0YXJ0O1xyXG4gICAgICAgIGxldCBwcmV2MSA9IHN0b3A7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhBdHRlbXB0czsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFRpY2tTdGVwKHN0YXJ0LCBzdG9wKTtcclxuICAgICAgICAgICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmRvbWFpbjtcclxuICAgICAgICAgICAgaWYgKHN0ZXAgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKGQwIC8gc3RlcCkgKiBzdGVwO1xyXG4gICAgICAgICAgICAgICAgc3RvcCA9IE1hdGguY2VpbChkMSAvIHN0ZXApICogc3RlcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZmxvYXRpbmcgcG9pbnQgZXJyb3JcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSAxIC8gc3RlcDtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihkMCAqIHMpIC8gcztcclxuICAgICAgICAgICAgICAgIHN0b3AgPSBNYXRoLmNlaWwoZDEgKiBzKSAvIHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBwcmV2MCAmJiBzdG9wID09PSBwcmV2MSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldjAgPSBzdGFydDtcclxuICAgICAgICAgICAgcHJldjEgPSBzdG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5pY2VEb21haW4gPSBbc3RhcnQsIHN0b3BdO1xyXG4gICAgfVxyXG4gICAgdGlja0Zvcm1hdCh7IHRpY2tzLCBzcGVjaWZpZXIgfSkge1xyXG4gICAgICAgIHJldHVybiB0aWNrRm9ybWF0KHRpY2tzICE9PSBudWxsICYmIHRpY2tzICE9PSB2b2lkIDAgPyB0aWNrcyA6IHRoaXMudGlja3MoKSwgc3BlY2lmaWVyKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmdTdHJpbmdOdW1iZXJVbmRlZmluZWQoYSwgYikge1xyXG4gICAgbGV0IGRpZmYgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBkaWZmID0gYSAtIGI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgZGlmZiA9IGEubG9jYWxlQ29tcGFyZShiKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPT0gbnVsbCAmJiBiID09IG51bGwpIDtcclxuICAgIGVsc2UgaWYgKGEgPT0gbnVsbCkge1xyXG4gICAgICAgIGRpZmYgPSAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgIGRpZmYgPSAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGlmZiA9IFN0cmluZyhhKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlmZjtcclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZEFzY2VuZGluZyhhLCBiLCBjb21wYXJhdG9yKSB7XHJcbiAgICBjb25zdCB0b0xpdGVyYWwgPSAodikgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcbiAgICBmb3IgKGNvbnN0IGlkeCBpbiBhKSB7XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IGNvbXBhcmF0b3IodG9MaXRlcmFsKGFbaWR4XSksIHRvTGl0ZXJhbChiW2lkeF0pKTtcclxuICAgICAgICBpZiAoZGlmZiAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxuXG5jbGFzcyBHcm91cCBleHRlbmRzIE5vZGUge1xyXG4gICAgekluZGV4Q2hhbmdlZCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIpIHtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5fbGF5ZXJNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZUxheWVyKHRoaXMubGF5ZXIsIHRoaXMuekluZGV4LCB0aGlzLnpJbmRleFN1Yk9yZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0xheWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKHsgaXNWaXJ0dWFsOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuaXNWaXJ0dWFsIH0pO1xyXG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmxhc3RCQm94ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHsgekluZGV4LCB6SW5kZXhTdWJPcmRlciB9ID0gb3B0cyAhPT0gbnVsbCAmJiBvcHRzICE9PSB2b2lkIDAgPyBvcHRzIDoge307XHJcbiAgICAgICAgdGhpcy5pc0NvbnRhaW5lck5vZGUgPSB0cnVlO1xyXG4gICAgICAgIGlmICh6SW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnpJbmRleCA9IHpJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHpJbmRleFN1Yk9yZGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IHpJbmRleFN1Yk9yZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5hbWUgPSAoX2EgPSB0aGlzLm9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lO1xyXG4gICAgfVxyXG4gICAgX3NldExheWVyTWFuYWdlcihzY2VuZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyTWFuYWdlciAmJiB0aGlzLmxheWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyTWFuYWdlci5yZW1vdmVMYXllcih0aGlzLmxheWVyKTtcclxuICAgICAgICAgICAgdGhpcy5sYXllciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBRyBDaGFydHMgLSB1bmFibGUgdG8gZGVyZWdpc3RlciBzY2VuZSByZW5kZXJpbmcgbGF5ZXIhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLl9zZXRMYXllck1hbmFnZXIoc2NlbmUpO1xyXG4gICAgICAgIGlmIChzY2VuZSAmJiAoKF9hID0gdGhpcy5vcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5ZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgekluZGV4LCB6SW5kZXhTdWJPcmRlciwgbmFtZSB9ID0gKF9iID0gdGhpcy5vcHRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0Q29tcHV0ZWRPcGFjaXR5ID0gKCkgPT4gdGhpcy5nZXRDb21wdXRlZE9wYWNpdHkoKTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0VmlzaWJpbGl0eSA9ICgpID0+IHRoaXMuZ2V0VmlzaWJpbGl0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxheWVyID0gc2NlbmUuYWRkTGF5ZXIoe1xyXG4gICAgICAgICAgICAgICAgekluZGV4LFxyXG4gICAgICAgICAgICAgICAgekluZGV4U3ViT3JkZXIsXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgZ2V0Q29tcHV0ZWRPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgZ2V0VmlzaWJpbGl0eSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q29tcHV0ZWRPcGFjaXR5KCkge1xyXG4gICAgICAgIGxldCBvcGFjaXR5ID0gMTtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXM7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5ICo9IG5vZGUub3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnQpKTtcclxuICAgICAgICByZXR1cm4gb3BhY2l0eTtcclxuICAgIH1cclxuICAgIGdldFZpc2liaWxpdHkoKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzO1xyXG4gICAgICAgIGxldCB2aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG4gICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aXNpYmxlID0gbm9kZS52aXNpYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcclxuICAgIH1cclxuICAgIHZpc2liaWxpdHlDaGFuZ2VkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxheWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGF5ZXIuZW5hYmxlZCA9IHRoaXMudmlzaWJsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXJrRGlydHkoc291cmNlLCB0eXBlID0gUmVkcmF3VHlwZS5UUklWSUFMKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNWaXJ0dWFsKSB7XHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBwZXJjb2xhdGUgZGlyZWN0bHkgZm9yIHZpcnR1YWwgbm9kZXMgLSB0aGV5IGRvbid0IGV4aXN0IGZvciByZW5kZXJpbmcgcHVycG9zZXMuXHJcbiAgICAgICAgICAgIHN1cGVyLm1hcmtEaXJ0eShzb3VyY2UsIHR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvd25ncmFkZSBkaXJ0eS1uZXNzIHBlcmNvbGF0ZWQgdG8gcGFyZW50IGluIHNwZWNpYWwgY2FzZXMuXHJcbiAgICAgICAgbGV0IHBhcmVudFR5cGUgPSB0eXBlO1xyXG4gICAgICAgIGlmICh0eXBlIDwgUmVkcmF3VHlwZS5NSU5PUiB8fCB0aGlzLmxheWVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcGFyZW50VHlwZSA9IFJlZHJhd1R5cGUuVFJJVklBTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KHNvdXJjZSwgdHlwZSwgcGFyZW50VHlwZSk7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBjb25zaWRlciBhIGdyb3VwIHRvIGJlIGJvdW5kbGVzcywgdGh1cyBhbnkgcG9pbnQgYmVsb25ncyB0byBpdC5cclxuICAgIGNvbnRhaW5zUG9pbnQoX3gsIF95KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcclxuICAgICAgICByZXR1cm4gR3JvdXAuY29tcHV0ZUJCb3godGhpcy5jaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlVHJhbnNmb3JtZWRCQm94KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIocmVuZGVyQ3R4KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IG9wdHM6IHsgbmFtZSA9IHVuZGVmaW5lZCB9ID0ge30sIF9kZWJ1ZzogZGVidWcgPSAoKSA9PiB7IH0gfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBkaXJ0eSwgZGlydHlaSW5kZXgsIGxheWVyLCBjaGlsZHJlbiwgY2xpcFJlY3QsIGRpcnR5VHJhbnNmb3JtIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCB7IGN0eCwgZm9yY2VSZW5kZXIsIGNsaXBCQm94IH0gPSByZW5kZXJDdHg7XHJcbiAgICAgICAgY29uc3QgeyByZXNpemVkLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc0N0eFRyYW5zZm9ybSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICBjb25zdCBpc0RpcnR5ID0gZGlydHkgPj0gUmVkcmF3VHlwZS5NSU5PUiB8fCBkaXJ0eVpJbmRleCB8fCByZXNpemVkO1xyXG4gICAgICAgIGxldCBpc0NoaWxkRGlydHkgPSBpc0RpcnR5O1xyXG4gICAgICAgIGxldCBpc0NoaWxkTGF5ZXJEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaXNDaGlsZERpcnR5IHx8IChpc0NoaWxkRGlydHkgPSBjaGlsZC5sYXllck1hbmFnZXIgPT0gbnVsbCAmJiBjaGlsZC5kaXJ0eSA+PSBSZWRyYXdUeXBlLlRSSVZJQUwpO1xyXG4gICAgICAgICAgICBpc0NoaWxkTGF5ZXJEaXJ0eSB8fCAoaXNDaGlsZExheWVyRGlydHkgPSBjaGlsZC5sYXllck1hbmFnZXIgIT0gbnVsbCAmJiBjaGlsZC5kaXJ0eSA+PSBSZWRyYXdUeXBlLlRSSVZJQUwpO1xyXG4gICAgICAgICAgICBpZiAoaXNDaGlsZERpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICBkZWJ1Zyh7IG5hbWUsIGdyb3VwOiB0aGlzLCBpc0RpcnR5LCBpc0NoaWxkRGlydHksIGRpcnR5VHJhbnNmb3JtLCByZW5kZXJDdHgsIGZvcmNlUmVuZGVyIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlydHlUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgZm9yY2VSZW5kZXIgPSAnZGlydHlUcmFuc2Zvcm0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICAvLyBJZiBib3VuZGluZy1ib3ggb2YgYSBsYXllciBjaGFuZ2VzLCBmb3JjZSByZS1yZW5kZXIuXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCQm94ID0gdGhpcy5jb21wdXRlQkJveCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0QkJveCA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmxhc3RCQm94LmVxdWFscyhjdXJyZW50QkJveCkpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyID0gJ2RpcnR5VHJhbnNmb3JtJztcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEJCb3ggPSBjdXJyZW50QkJveDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzRGlydHkgJiYgIWlzQ2hpbGREaXJ0eSAmJiAhaXNDaGlsZExheWVyRGlydHkgJiYgIWZvcmNlUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lICYmIHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Zyh7IG5hbWUsIHJlc3VsdDogJ3NraXBwaW5nJywgcmVuZGVyQ3R4LCBjb3VudHM6IHRoaXMubm9kZUNvdW50LCBncm91cDogdGhpcyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGF5ZXIgJiYgc3RhdHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRzLmxheWVyc1NraXBwZWQrKztcclxuICAgICAgICAgICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1hcmtDbGVhbih7IHJlY3Vyc2l2ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZ3JvdXBWaXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG4gICAgICAgIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICAvLyBTd2l0Y2ggY29udGV4dCB0byB0aGUgY2FudmFzIGxheWVyIHdlIHVzZSBmb3IgdGhpcyBncm91cC5cclxuICAgICAgICAgICAgY3R4ID0gbGF5ZXIuY29udGV4dDtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZVJlbmRlciAhPT0gJ2RpcnR5VHJhbnNmb3JtJykge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIgPSBpc0NoaWxkRGlydHkgfHwgZGlydHlaSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvcmNlUmVuZGVyKVxyXG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcclxuICAgICAgICAgICAgaWYgKGNsaXBCQm94KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGlwQkJveCBpcyBpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UsIHdoZW4gd2UgaGl0IGEgbGF5ZXIgd2UgYXBwbHkgdGhlIG5ldyBjbGlwcGluZyBhdCB3aGljaCBwb2ludCB0aGVyZSBhcmUgbm8gdHJhbnNmb3JtcyBpbiBwbGF5XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfSA9IGNsaXBCQm94O1xyXG4gICAgICAgICAgICAgICAgZGVidWcoKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaXBCQm94LFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eFRyYW5zZm9ybTogY3R4LmdldFRyYW5zZm9ybSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckN0eCxcclxuICAgICAgICAgICAgICAgICAgICBncm91cDogdGhpcyxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcEN0eChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oY2FudmFzQ3R4VHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgb3BhY2l0eSBpZiB0aGlzIGlzbid0IGEgZGlzdGluY3QgbGF5ZXIgLSBvcGFjaXR5IHdpbGwgYmUgYXBwbGllZFxyXG4gICAgICAgICAgICAvLyBhdCBjb21wb3NpdGlvbiB0aW1lLlxyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBIGdyb3VwIGNhbiBoYXZlIGBzY2FsaW5nYCwgYHJvdGF0aW9uYCwgYHRyYW5zbGF0aW9uYCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgLy8gdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgY2FudmFzIGNvbnRleHQgYmVmb3JlIGNoaWxkcmVuIGFyZSByZW5kZXJlZCxcclxuICAgICAgICAvLyBzbyBhbGwgY2hpbGRyZW4gY2FuIGJlIHRyYW5zZm9ybWVkIGF0IG9uY2UuXHJcbiAgICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXgudG9Db250ZXh0KGN0eCk7XHJcbiAgICAgICAgaWYgKGNsaXBSZWN0KSB7XHJcbiAgICAgICAgICAgIC8vIGNsaXBSZWN0IGlzIGluIHRoZSBncm91cCdzIGNvb3JkaW5hdGUgc3BhY2VcclxuICAgICAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBjbGlwUmVjdDtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgZGVidWcoKCkgPT4gKHsgbmFtZSwgY2xpcFJlY3QsIGN0eFRyYW5zZm9ybTogY3R4LmdldFRyYW5zZm9ybSgpLCByZW5kZXJDdHgsIGdyb3VwOiB0aGlzIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5jbGlwQ3R4KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIGNsaXBCQm94IGlzIGluIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZSwgd2hlbiB3ZSBoaXQgYSBsYXllciB3ZSBhcHBseSB0aGUgbmV3IGNsaXBwaW5nIGF0IHdoaWNoIHBvaW50IHRoZXJlIGFyZSBubyB0cmFuc2Zvcm1zIGluIHBsYXlcclxuICAgICAgICAgICAgY2xpcEJCb3ggPSB0aGlzLm1hdHJpeC50cmFuc2Zvcm1CQm94KGNsaXBSZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFzVmlydHVhbENoaWxkcmVuID0gdGhpcy5oYXNWaXJ0dWFsQ2hpbGRyZW4oKTtcclxuICAgICAgICBpZiAoZGlydHlaSW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICBpZiAoZm9yY2VSZW5kZXIgIT09ICdkaXJ0eVRyYW5zZm9ybScpXHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc1ZpcnR1YWxDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB0aGlzLnNvcnRDaGlsZHJlbihjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlZHVjZSBjaHVybiBpZiByZW5kZXJDdHggaXMgaWRlbnRpY2FsLlxyXG4gICAgICAgIGNvbnN0IHJlbmRlckNvbnRleHRDaGFuZ2VkID0gZm9yY2VSZW5kZXIgIT09IHJlbmRlckN0eC5mb3JjZVJlbmRlciB8fCBjbGlwQkJveCAhPT0gcmVuZGVyQ3R4LmNsaXBCQm94IHx8IGN0eCAhPT0gcmVuZGVyQ3R4LmN0eDtcclxuICAgICAgICBjb25zdCBjaGlsZFJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0Q2hhbmdlZCA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVuZGVyQ3R4KSwgeyBjdHgsIGZvcmNlUmVuZGVyLCBjbGlwQkJveCB9KSA6IHJlbmRlckN0eDtcclxuICAgICAgICAvLyBSZW5kZXIgdmlzaWJsZSBjaGlsZHJlbi5cclxuICAgICAgICBsZXQgc2tpcHBlZCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWdyb3VwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpbnZpc2libGUgY2hpbGRyZW4sIGJ1dCBtYWtlIHN1cmUgdGhlaXIgZGlydHkgZmxhZyBpcyByZXNldC5cclxuICAgICAgICAgICAgICAgIGNoaWxkLm1hcmtDbGVhbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzKVxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgKz0gY2hpbGQubm9kZUNvdW50LmNvdW50O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFmb3JjZVJlbmRlciAmJiBjaGlsZC5kaXJ0eSA9PT0gUmVkcmF3VHlwZS5OT05FKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGNoaWxkcmVuIHRoYXQgZG9uJ3QgbmVlZCB0byBiZSByZWRyYXduLlxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzKVxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgKz0gY2hpbGQubm9kZUNvdW50LmNvdW50O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVuZGVyIG1hcmtzIHRoaXMgbm9kZSAoYW5kIGNoaWxkcmVuKSBhcyBjbGVhbiAtIG5vIG5lZWQgdG8gZXhwbGljaXRseSBtYXJrQ2xlYW4oKS5cclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkUmVuZGVyQ29udGV4dCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0cylcclxuICAgICAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHNraXBwZWQ7XHJcbiAgICAgICAgLy8gUmVuZGVyIG1hcmtzIHRoaXMgbm9kZSBhcyBjbGVhbiAtIG5vIG5lZWQgdG8gZXhwbGljaXRseSBtYXJrQ2xlYW4oKS5cclxuICAgICAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcclxuICAgICAgICBpZiAoY2xpcFJlY3QpIHtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc1ZpcnR1YWxDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAvLyBNYXJrIHZpcnR1YWwgbm9kZXMgYXMgY2xlYW4gYW5kIHRoZWlyIHZpcnR1YWwgY2hpbGRyZW4gLSBhbGwgb3RoZXIgbm9kZXMgaGF2ZSBhbHJlYWR5XHJcbiAgICAgICAgICAgIC8vIGJlZW4gdmlzaXRlZCBhbmQgbWFya2VkIGNsZWFuLlxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMudmlydHVhbENoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oeyByZWN1cnNpdmU6ICd2aXJ0dWFsJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRzKVxyXG4gICAgICAgICAgICAgICAgc3RhdHMubGF5ZXJzUmVuZGVyZWQrKztcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgaWYgKGZvcmNlUmVuZGVyKVxyXG4gICAgICAgICAgICAgICAgbGF5ZXIuc25hcHNob3QoKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHNhdmUvcmVzdG9yZSBkZXB0aCBvZiB6ZXJvIVxyXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBsYXllci5jb250ZXh0KS52ZXJpZnlEZXB0aFplcm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5hbWUgJiYgc3RhdHMpIHtcclxuICAgICAgICAgICAgZGVidWcoeyBuYW1lLCByZXN1bHQ6ICdyZW5kZXJlZCcsIHNraXBwZWQsIHJlbmRlckN0eCwgY291bnRzOiB0aGlzLm5vZGVDb3VudCwgZ3JvdXA6IHRoaXMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc29ydENoaWxkcmVuKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eVpJbmRleCA9IGZhbHNlO1xyXG4gICAgICAgIGNoaWxkcmVuLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kQXNjZW5kaW5nKFthLnpJbmRleCwgLi4uKChfYSA9IGEuekluZGV4U3ViT3JkZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF0pLCBhLnNlcmlhbE51bWJlcl0sIFtiLnpJbmRleCwgLi4uKChfYiA9IGIuekluZGV4U3ViT3JkZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF0pLCBiLnNlcmlhbE51bWJlcl0sIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbGlwQ3R4KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5KTtcclxuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LmNsaXAoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21wdXRlQkJveChub2Rlcykge1xyXG4gICAgICAgIGxldCBsZWZ0ID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IHJpZ2h0ID0gLUluZmluaXR5O1xyXG4gICAgICAgIGxldCB0b3AgPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgYm90dG9tID0gLUluZmluaXR5O1xyXG4gICAgICAgIG5vZGVzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgaWYgKCFuLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiYm94ID0gbi5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XHJcbiAgICAgICAgICAgIGlmICghYmJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBiYm94Lng7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBiYm94Lnk7XHJcbiAgICAgICAgICAgIGlmICh4IDwgbGVmdCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHkgPCB0b3ApIHtcclxuICAgICAgICAgICAgICAgIHRvcCA9IHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHggKyBiYm94LndpZHRoID4gcmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0geCArIGJib3gud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHkgKyBiYm94LmhlaWdodCA+IGJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgYm90dG9tID0geSArIGJib3guaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCQm94KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIGJib3ggZ2l2ZW4gaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlIHRvIGJib3ggaW4gdGhpcyBncm91cCdzIGNvb3JkaW5hdGUgc3BhY2UgYW5kXHJcbiAgICAgKiBzZXRzIHRoaXMgZ3JvdXAncyBjbGlwUmVjdCB0byB0aGUgdHJhbnNmb3JtZWQgYmJveC5cclxuICAgICAqIEBwYXJhbSBiYm94IGNsaXBSZWN0IGJib3ggaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxyXG4gICAgICovXHJcbiAgICBzZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoYmJveCkge1xyXG4gICAgICAgIHRoaXMuY2xpcFJlY3QgPSBiYm94ID8gdGhpcy50cmFuc2Zvcm1CQm94KGJib3gpIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbkdyb3VwLmNsYXNzTmFtZSA9ICdHcm91cCc7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xyXG4gICAgICAgIHJlZHJhdzogUmVkcmF3VHlwZS5NQUpPUixcclxuICAgICAgICBjb252ZXJ0b3I6ICh2KSA9PiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB2KSksXHJcbiAgICB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIEdyb3VwLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG5cbmNsYXNzIFNlbGVjdGlvbiB7XHJcbiAgICBzdGF0aWMgc2VsZWN0KHBhcmVudCwgY2xhc3NPckZhY3RvcnksIGdhcmJhZ2VDb2xsZWN0aW9uID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHBhcmVudCwgY2xhc3NPckZhY3RvcnksIGdhcmJhZ2VDb2xsZWN0aW9uKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzZWxlY3RBbGwocGFyZW50LCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgY29uc3QgdHJhdmVyc2UgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHRyYXZlcnNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyYXZlcnNlKHBhcmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2VsZWN0QnlDbGFzcyhub2RlLCBDbGFzcykge1xyXG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChub2RlKSA9PiBub2RlIGluc3RhbmNlb2YgQ2xhc3MpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNlbGVjdEJ5VGFnKG5vZGUsIHRhZykge1xyXG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChub2RlKSA9PiBub2RlLnRhZyA9PT0gdGFnKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudE5vZGUsIGNsYXNzT3JGYWN0b3J5LCBhdXRvQ2xlYW51cCA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xyXG4gICAgICAgIHRoaXMuYXV0b0NsZWFudXAgPSBhdXRvQ2xlYW51cDtcclxuICAgICAgICB0aGlzLmdhcmJhZ2VCaW4gPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fbm9kZXNNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsICdzY2VuZScsICdzY2VuZTpzZWxlY3Rpb25zJyk7XHJcbiAgICAgICAgdGhpcy5ub2RlRmFjdG9yeSA9IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKE5vZGUsIGNsYXNzT3JGYWN0b3J5KVxyXG4gICAgICAgICAgICA/ICgpID0+IG5ldyBjbGFzc09yRmFjdG9yeSgpXHJcbiAgICAgICAgICAgIDogY2xhc3NPckZhY3Rvcnk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZUZhY3RvcnkoZGF0dW0pO1xyXG4gICAgICAgIG5vZGUuZGF0dW0gPSBkYXR1bTtcclxuICAgICAgICBpbml0aWFsaXplciA9PT0gbnVsbCB8fCBpbml0aWFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbGl6ZXIobm9kZSk7XHJcbiAgICAgICAgaWYgKGlkeCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnNwbGljZShpZHgsIDAsIG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGRhdGEgaW4gYSBzZWxlY3Rpb24uIElmIGFuIGBnZXREYXR1bUlkKClgIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBtYWludGFpbiBhIGxpc3Qgb2YgaWRzIHJlbGF0ZWQgdG9cclxuICAgICAqIHRoZSBub2Rlcy4gT3RoZXJ3aXNlLCB0YWtlIHRoZSBtb3JlIGVmZmljaWVudCByb3V0ZSBvZiBzaW1wbHkgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgbm9kZXMgYXQgdGhlIGVuZFxyXG4gICAgICogb2YgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGF0YSwgaW5pdGlhbGl6ZXIsIGdldERhdHVtSWQpIHtcclxuICAgICAgICBpZiAodGhpcy5nYXJiYWdlQmluLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYFNlbGVjdGlvbiAtIHVwZGF0ZSgpIGNhbGxlZCB3aXRoIHBlbmRpbmcgZ2FyYmFnZTogJHtkYXRhfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2V0RGF0dW1JZCkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhTWFwID0gbmV3IE1hcChkYXRhLm1hcCgoZGF0dW0sIGlkeCkgPT4gW2dldERhdHVtSWQoZGF0dW0pLCBbZGF0dW0sIGlkeF1dKSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25vZGUsIGRhdHVtSWRdIG9mIHRoaXMuX25vZGVzTWFwLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFNYXAuaGFzKGRhdHVtSWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW25ld0RhdHVtXSA9IGRhdGFNYXAuZ2V0KGRhdHVtSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0dW0gPSBuZXdEYXR1bTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFNYXAuZGVsZXRlKGRhdHVtSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtkYXR1bUlkLCBbZGF0dW0sIGlkeF1dIG9mIGRhdGFNYXAuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc01hcC5zZXQodGhpcy5jcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSwgZGF0dW1JZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGRhdGEubGVuZ3RoLCB0aGlzLmRhdGEubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uYWRkKHRoaXMuX25vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPj0gdGhpcy5fbm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVOb2RlKGRhdGFbaV0sIGluaXRpYWxpemVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzW2ldLmRhdHVtID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKHRoaXMuX25vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhLnNsaWNlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NsZWFudXApIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgY2xlYW51cCgpIHtcclxuICAgICAgICBpZiAodGhpcy5nYXJiYWdlQmluLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX25vZGVzID0gdGhpcy5fbm9kZXMuZmlsdGVyKChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhcmJhZ2VCaW4uaGFzKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc01hcC5kZWxldGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uZGVsZXRlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoW10pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNHYXJiYWdlKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nYXJiYWdlQmluLmhhcyhub2RlKTtcclxuICAgIH1cclxuICAgIGhhc0dhcmJhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FyYmFnZUJpbi5zaXplID4gMDtcclxuICAgIH1cclxuICAgIGVhY2goaXRlcmF0ZSkge1xyXG4gICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IGl0ZXJhdGUobm9kZSwgbm9kZS5kYXR1bSwgaSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgZGF0dW0gPSB0aGlzLl9ub2Rlc1tpbmRleF0uZGF0dW07XHJcbiAgICAgICAgICAgIHlpZWxkIHsgbm9kZSwgZGF0dW0sIGluZGV4IH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VsZWN0KHByZWRpY2F0ZSkge1xyXG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24uc2VsZWN0QWxsKHRoaXMucGFyZW50Tm9kZSwgcHJlZGljYXRlKTtcclxuICAgIH1cclxuICAgIHNlbGVjdEJ5Q2xhc3MoQ2xhc3MpIHtcclxuICAgICAgICByZXR1cm4gU2VsZWN0aW9uLnNlbGVjdEJ5Q2xhc3ModGhpcy5wYXJlbnROb2RlLCBDbGFzcyk7XHJcbiAgICB9XHJcbiAgICBzZWxlY3RCeVRhZyh0YWcpIHtcclxuICAgICAgICByZXR1cm4gU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKHRoaXMucGFyZW50Tm9kZSwgdGFnKTtcclxuICAgIH1cclxuICAgIG5vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBMaW5lIGV4dGVuZHMgU2hhcGUge1xyXG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgdGhpcy54MSA9IDA7XHJcbiAgICAgICAgdGhpcy55MSA9IDA7XHJcbiAgICAgICAgdGhpcy54MiA9IDA7XHJcbiAgICAgICAgdGhpcy55MiA9IDA7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XHJcbiAgICB9XHJcbiAgICBzZXQgeCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMueDEgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLngyID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgeSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMueTEgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnkyID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJCb3goTWF0aC5taW4odGhpcy54MSwgdGhpcy54MiksIE1hdGgubWluKHRoaXMueTEsIHRoaXMueTIpLCBNYXRoLmFicyh0aGlzLngyIC0gdGhpcy54MSksIE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKSk7XHJcbiAgICB9XHJcbiAgICBpc1BvaW50SW5QYXRoKHB4LCBweSkge1xyXG4gICAgICAgIGlmICh0aGlzLngxID09PSB0aGlzLngyIHx8IHRoaXMueTEgPT09IHRoaXMueTIpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRyYW5zZm9ybVBvaW50KHB4LCBweSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVCQm94KClcclxuICAgICAgICAgICAgICAgIC5ncm93KHRoaXMuc3Ryb2tlV2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgLmNvbnRhaW5zUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJlbmRlcihyZW5kZXJDdHgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09PSBSZWRyYXdUeXBlLk5PTkUgJiYgIWZvcmNlUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0cylcclxuICAgICAgICAgICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeC50b0NvbnRleHQoY3R4KTtcclxuICAgICAgICBsZXQgeyB4MSwgeTEsIHgyLCB5MiB9ID0gdGhpcztcclxuICAgICAgICAvLyBBbGlnbiB0byB0aGUgcGl4ZWwgZ3JpZCBpZiB0aGUgbGluZSBpcyBzdHJpY3RseSB2ZXJ0aWNhbFxyXG4gICAgICAgIC8vIG9yIGhvcml6b250YWwgKGJ1dCBub3QgYm90aCwgaS5lLiBhIGRvdCkuXHJcbiAgICAgICAgaWYgKHgxID09PSB4Mikge1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZCh4MSkgKyAoTWF0aC5mbG9vcih0aGlzLnN0cm9rZVdpZHRoKSAlIDIpIC8gMjtcclxuICAgICAgICAgICAgeDEgPSB4O1xyXG4gICAgICAgICAgICB4MiA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHkxID09PSB5Mikge1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh5MSkgKyAoTWF0aC5mbG9vcih0aGlzLnN0cm9rZVdpZHRoKSAlIDIpIC8gMjtcclxuICAgICAgICAgICAgeTEgPSB5O1xyXG4gICAgICAgICAgICB5MiA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xyXG4gICAgICAgIHRoaXMuZmlsbFN0cm9rZShjdHgpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuZmlsbFNoYWRvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtDbGVhbigpO1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xyXG4gICAgfVxyXG59XHJcbkxpbmUuY2xhc3NOYW1lID0gJ0xpbmUnO1xyXG5MaW5lLmRlZmF1bHRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBTaGFwZS5kZWZhdWx0U3R5bGVzLCB7XHJcbiAgICBmaWxsOiB1bmRlZmluZWQsXHJcbiAgICBzdHJva2VXaWR0aDogMSxcclxufSk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ4MVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTGluZS5wcm90b3R5cGUsIFwieTFcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NQUpPUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExpbmUucHJvdG90eXBlLCBcIngyXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ5MlwiLCB2b2lkIDApO1xuXG4vKipcclxuICogRmluZHMgdGhlIHJvb3RzIG9mIGEgcGFyYW1ldHJpYyBsaW5lYXIgZXF1YXRpb24gaW4gYHRgLFxyXG4gKiB3aGVyZSBgdGAgbGllcyBpbiB0aGUgaW50ZXJ2YWwgb2YgYFswLDFdYC5cclxuICovXHJcbmZ1bmN0aW9uIGxpbmVhclJvb3QoYSwgYikge1xyXG4gICAgY29uc3QgdCA9IC1iIC8gYTtcclxuICAgIHJldHVybiBhICE9PSAwICYmIHQgPj0gMCAmJiB0IDw9IDEgPyBbdF0gOiBbXTtcclxufVxyXG4vKipcclxuICogRmluZHMgdGhlIHJvb3RzIG9mIGEgcGFyYW1ldHJpYyBxdWFkcmF0aWMgZXF1YXRpb24gaW4gYHRgLFxyXG4gKiB3aGVyZSBgdGAgbGllcyBpbiB0aGUgaW50ZXJ2YWwgb2YgYFswLDFdYC5cclxuICovXHJcbmZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RzKGEsIGIsIGMpIHtcclxuICAgIGlmIChhID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVhclJvb3QoYiwgYyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBEID0gYiAqIGIgLSA0ICogYSAqIGM7IC8vIFRoZSBwb2x5bm9taWFsJ3MgZGlzY3JpbWluYW50LlxyXG4gICAgY29uc3Qgcm9vdHMgPSBbXTtcclxuICAgIGlmIChEID09PSAwKSB7XHJcbiAgICAgICAgLy8gQSBzaW5nbGUgcmVhbCByb290LlxyXG4gICAgICAgIGNvbnN0IHQgPSAtYiAvICgyICogYSk7XHJcbiAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcclxuICAgICAgICAgICAgcm9vdHMucHVzaCh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChEID4gMCkge1xyXG4gICAgICAgIC8vIEEgcGFpciBvZiBkaXN0aW5jdCByZWFsIHJvb3RzLlxyXG4gICAgICAgIGNvbnN0IHJEID0gTWF0aC5zcXJ0KEQpO1xyXG4gICAgICAgIGNvbnN0IHQxID0gKC1iIC0gckQpIC8gKDIgKiBhKTtcclxuICAgICAgICBjb25zdCB0MiA9ICgtYiArIHJEKSAvICgyICogYSk7XHJcbiAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xyXG4gICAgICAgICAgICByb290cy5wdXNoKHQxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xyXG4gICAgICAgICAgICByb290cy5wdXNoKHQyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlbHNlIC0+IENvbXBsZXggcm9vdHMuXHJcbiAgICByZXR1cm4gcm9vdHM7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmRzIHRoZSByb290cyBvZiBhIHBhcmFtZXRyaWMgY3ViaWMgZXF1YXRpb24gaW4gYHRgLFxyXG4gKiB3aGVyZSBgdGAgbGllcyBpbiB0aGUgaW50ZXJ2YWwgb2YgYFswLDFdYC5cclxuICogUmV0dXJucyBhbiBhcnJheSBvZiBwYXJhbWV0cmljIGludGVyc2VjdGlvbiBsb2NhdGlvbnMgYWxvbmcgdGhlIGN1YmljLFxyXG4gKiBleGNsdWRpbmcgb3V0LW9mLWJvdW5kcyBpbnRlcnNlY3Rpb25zIChiZWZvcmUgb3IgYWZ0ZXIgdGhlIGVuZCBwb2ludFxyXG4gKiBvciBpbiB0aGUgaW1hZ2luYXJ5IHBsYW5lKS5cclxuICogQW4gYWRhcHRhdGlvbiBvZiBodHRwOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS9ibG9nLzIwMTMvY3ViaWMtbGluZS1pbnRlcnNlY3Rpb24vXHJcbiAqL1xyXG5mdW5jdGlvbiBjdWJpY1Jvb3RzKGEsIGIsIGMsIGQpIHtcclxuICAgIGlmIChhID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHF1YWRyYXRpY1Jvb3RzKGIsIGMsIGQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgQSA9IGIgLyBhO1xyXG4gICAgY29uc3QgQiA9IGMgLyBhO1xyXG4gICAgY29uc3QgQyA9IGQgLyBhO1xyXG4gICAgY29uc3QgUSA9ICgzICogQiAtIEEgKiBBKSAvIDk7XHJcbiAgICBjb25zdCBSID0gKDkgKiBBICogQiAtIDI3ICogQyAtIDIgKiBBICogQSAqIEEpIC8gNTQ7XHJcbiAgICBjb25zdCBEID0gUSAqIFEgKiBRICsgUiAqIFI7IC8vIFRoZSBwb2x5bm9taWFsJ3MgZGlzY3JpbWluYW50LlxyXG4gICAgY29uc3QgdGhpcmQgPSAxIC8gMztcclxuICAgIGNvbnN0IHJvb3RzID0gW107XHJcbiAgICBpZiAoRCA+PSAwKSB7XHJcbiAgICAgICAgLy8gQ29tcGxleCBvciBkdXBsaWNhdGUgcm9vdHMuXHJcbiAgICAgICAgY29uc3QgckQgPSBNYXRoLnNxcnQoRCk7XHJcbiAgICAgICAgY29uc3QgUyA9IE1hdGguc2lnbihSICsgckQpICogTWF0aC5wb3coTWF0aC5hYnMoUiArIHJEKSwgdGhpcmQpO1xyXG4gICAgICAgIGNvbnN0IFQgPSBNYXRoLnNpZ24oUiAtIHJEKSAqIE1hdGgucG93KE1hdGguYWJzKFIgLSByRCksIHRoaXJkKTtcclxuICAgICAgICBjb25zdCBJbSA9IE1hdGguYWJzKChNYXRoLnNxcnQoMykgKiAoUyAtIFQpKSAvIDIpOyAvLyBDb21wbGV4IHBhcnQgb2YgdGhlIHJvb3QgcGFpci5cclxuICAgICAgICBjb25zdCB0ID0gLXRoaXJkICogQSArIChTICsgVCk7IC8vIEEgcmVhbCByb290LlxyXG4gICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJvb3RzLnB1c2godCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJbSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gLXRoaXJkICogQSAtIChTICsgVCkgLyAyOyAvLyBUaGUgcmVhbCBwYXJ0IG9mIGEgY29tcGxleCByb290LlxyXG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcm9vdHMucHVzaCh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIERpc3RpbmN0IHJlYWwgcm9vdHMuXHJcbiAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLmFjb3MoUiAvIE1hdGguc3FydCgtUSAqIFEgKiBRKSk7XHJcbiAgICAgICAgY29uc3QgdGhpcmRBID0gdGhpcmQgKiBBO1xyXG4gICAgICAgIGNvbnN0IHR3b1NxcnRRID0gMiAqIE1hdGguc3FydCgtUSk7XHJcbiAgICAgICAgY29uc3QgdDEgPSB0d29TcXJ0USAqIE1hdGguY29zKHRoaXJkICogdGhldGEpIC0gdGhpcmRBO1xyXG4gICAgICAgIGNvbnN0IHQyID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqICh0aGV0YSArIDIgKiBNYXRoLlBJKSkgLSB0aGlyZEE7XHJcbiAgICAgICAgY29uc3QgdDMgPSB0d29TcXJ0USAqIE1hdGguY29zKHRoaXJkICogKHRoZXRhICsgNCAqIE1hdGguUEkpKSAtIHRoaXJkQTtcclxuICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJvb3RzLnB1c2godDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJvb3RzLnB1c2godDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJvb3RzLnB1c2godDMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByb290cztcclxufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGZvciB0aGUgZ2l2ZW4gcGFpciBvZiBsaW5lIHNlZ21lbnRzLCBvciBudWxsLFxyXG4gKiBpZiB0aGUgc2VnbWVudHMgYXJlIHBhcmFsbGVsIG9yIGRvbid0IGludGVyc2VjdC5cclxuICogQmFzZWQgb24gaHR0cDovL3BhdWxib3Vya2UubmV0L2dlb21ldHJ5L3BvaW50bGluZXBsYW5lL1xyXG4gKi9cclxuZnVuY3Rpb24gc2VnbWVudEludGVyc2VjdGlvbihheDEsIGF5MSwgYXgyLCBheTIsIGJ4MSwgYnkxLCBieDIsIGJ5Mikge1xyXG4gICAgY29uc3QgZCA9IChheDIgLSBheDEpICogKGJ5MiAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChieDIgLSBieDEpO1xyXG4gICAgaWYgKGQgPT09IDApIHtcclxuICAgICAgICAvLyBUaGUgbGluZXMgYXJlIHBhcmFsbGVsLlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdWEgPSAoKGJ4MiAtIGJ4MSkgKiAoYXkxIC0gYnkxKSAtIChheDEgLSBieDEpICogKGJ5MiAtIGJ5MSkpIC8gZDtcclxuICAgIGNvbnN0IHViID0gKChheDIgLSBheDEpICogKGF5MSAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChheDEgLSBieDEpKSAvIGQ7XHJcbiAgICBpZiAodWEgPj0gMCAmJiB1YSA8PSAxICYmIHViID49IDAgJiYgdWIgPD0gMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGF4MSArIHVhICogKGF4MiAtIGF4MSksXHJcbiAgICAgICAgICAgIHk6IGF5MSArIHVhICogKGF5MiAtIGF5MSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsOyAvLyBUaGUgaW50ZXJzZWN0aW9uIHBvaW50IGlzIG91dHNpZGUgZWl0aGVyIG9yIGJvdGggc2VnbWVudHMuXHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiB0aGUgZ2l2ZW4gY3ViaWMgY3VydmUgYW5kIHRoZSBsaW5lIHNlZ21lbnQuXHJcbiAqIFRha2VzIGluIHgveSBjb21wb25lbnRzIG9mIGN1YmljIGNvbnRyb2wgcG9pbnRzIGFuZCBsaW5lIHNlZ21lbnQgc3RhcnQvZW5kIHBvaW50c1xyXG4gKiBhcyBwYXJhbWV0ZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3ViaWNTZWdtZW50SW50ZXJzZWN0aW9ucyhweDEsIHB5MSwgcHgyLCBweTIsIHB4MywgcHkzLCBweDQsIHB5NCwgeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcclxuICAgIC8vIEZpbmQgbGluZSBlcXVhdGlvbiBjb2VmZmljaWVudHMuXHJcbiAgICBjb25zdCBBID0geTEgLSB5MjtcclxuICAgIGNvbnN0IEIgPSB4MiAtIHgxO1xyXG4gICAgY29uc3QgQyA9IHgxICogKHkyIC0geTEpIC0geTEgKiAoeDIgLSB4MSk7XHJcbiAgICAvLyBGaW5kIGN1YmljIEJlemllciBjdXJ2ZSBlcXVhdGlvbiBjb2VmZmljaWVudHMgZnJvbSBjb250cm9sIHBvaW50cy5cclxuICAgIGNvbnN0IGJ4ID0gYmV6aWVyQ29lZmZpY2llbnRzKHB4MSwgcHgyLCBweDMsIHB4NCk7XHJcbiAgICBjb25zdCBieSA9IGJlemllckNvZWZmaWNpZW50cyhweTEsIHB5MiwgcHkzLCBweTQpO1xyXG4gICAgY29uc3QgYSA9IEEgKiBieFswXSArIEIgKiBieVswXTsgLy8gdF4zXHJcbiAgICBjb25zdCBiID0gQSAqIGJ4WzFdICsgQiAqIGJ5WzFdOyAvLyB0XjJcclxuICAgIGNvbnN0IGMgPSBBICogYnhbMl0gKyBCICogYnlbMl07IC8vIHRcclxuICAgIGNvbnN0IGQgPSBBICogYnhbM10gKyBCICogYnlbM10gKyBDOyAvLyAxXHJcbiAgICBjb25zdCByb290cyA9IGN1YmljUm9vdHMoYSwgYiwgYywgZCk7XHJcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgcm9vdHMgYXJlIHdpdGhpbiBib3VuZHMgb2YgdGhlIGxpbmVhciBzZWdtZW50LlxyXG4gICAgZm9yIChjb25zdCB0IG9mIHJvb3RzKSB7XHJcbiAgICAgICAgY29uc3QgdHQgPSB0ICogdDtcclxuICAgICAgICBjb25zdCB0dHQgPSB0ICogdHQ7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgY2FydGVzaWFuIHBsYW5lIGNvb3JkaW5hdGVzIGZvciB0aGUgcGFyYW1ldHJpYyByb290IGB0YC5cclxuICAgICAgICBjb25zdCB4ID0gYnhbMF0gKiB0dHQgKyBieFsxXSAqIHR0ICsgYnhbMl0gKiB0ICsgYnhbM107XHJcbiAgICAgICAgY29uc3QgeSA9IGJ5WzBdICogdHR0ICsgYnlbMV0gKiB0dCArIGJ5WzJdICogdCArIGJ5WzNdO1xyXG4gICAgICAgIC8vIFRoZSBwYXJhbWV0cmljIGN1YmljIHJvb3RzIHdlIGZvdW5kIGFyZSBpbnRlcnNlY3Rpb24gcG9pbnRzXHJcbiAgICAgICAgLy8gd2l0aCBhbiBpbmZpbml0ZSBsaW5lLCBhbmQgc28gdGhlIHgveSBjb29yZGluYXRlcyBhYm92ZSBhcmUgYXMgd2VsbC5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHgveSBpcyBhbHNvIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBnaXZlbiBzZWdtZW50LlxyXG4gICAgICAgIGxldCBzO1xyXG4gICAgICAgIGlmICh4MSAhPT0geDIpIHtcclxuICAgICAgICAgICAgcyA9ICh4IC0geDEpIC8gKHgyIC0geDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhlIGxpbmUgaXMgdmVydGljYWxcclxuICAgICAgICAgICAgcyA9ICh5IC0geTEpIC8gKHkyIC0geTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocyA+PSAwICYmIHMgPD0gMSkge1xyXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goeyB4LCB5IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBjb29yZGluYXRlcyB2ZWN0b3IgbXVsdGlwbGllZCBieSB0aGUgY29lZmZpY2llbnQgbWF0cml4XHJcbiAqIG9mIHRoZSBwYXJhbWV0cmljIGN1YmljIELDqXppZXIgZXF1YXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBiZXppZXJDb2VmZmljaWVudHMoUDEsIFAyLCBQMywgUDQpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgLy8gQsOpemllciBleHByZXNzZWQgYXMgbWF0cml4IG9wZXJhdGlvbnM6XHJcbiAgICAgICAgLVAxICsgMyAqIFAyIC0gMyAqIFAzICsgUDQsXHJcbiAgICAgICAgMyAqIFAxIC0gNiAqIFAyICsgMyAqIFAzLFxyXG4gICAgICAgIC0zICogUDEgKyAzICogUDIsXHJcbiAgICAgICAgUDEsIC8vICAgICAgICAgICAgICAgICB8IDEgIDAgIDAgIDB8IHxQNHxcclxuICAgIF07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiB0aGUgYXJjIGFuZCB0aGUgbGluZSBzZWdtZW50LlxyXG4gKiBUYWtlcyBpbiBhcmMgcGFyYW1ldGVycyBhbmQgbGluZSBzZWdtZW50IHN0YXJ0L2VuZCBwb2ludHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmNJbnRlcnNlY3Rpb25zKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAvLyBTb2x2aW5nIHRoZSBxdWFkcmF0aWMgZXF1YXRpb246XHJcbiAgICAvLyAxLiB5ID0gayAqIHggKyB5MFxyXG4gICAgLy8gMi4gKHggLSBjeCleMiArICh5IC0gY3kpXjIgPSByXjJcclxuICAgIGNvbnN0IGsgPSAoeTIgLSB5MSkgLyAoeDIgLSB4MSk7XHJcbiAgICBjb25zdCB5MCA9IHkxIC0gayAqIHgxO1xyXG4gICAgY29uc3QgYSA9IE1hdGgucG93KGssIDIpICsgMTtcclxuICAgIGNvbnN0IGIgPSAyICogKGsgKiAoeTAgLSBjeSkgLSBjeCk7XHJcbiAgICBjb25zdCBjID0gTWF0aC5wb3coY3gsIDIpICsgTWF0aC5wb3coeTAgLSBjeSwgMikgLSBNYXRoLnBvdyhyLCAyKTtcclxuICAgIGNvbnN0IGQgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcclxuICAgIGlmIChkIDwgMCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGkxeCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAyIC8gYTtcclxuICAgIGNvbnN0IGkyeCA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAyIC8gYTtcclxuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcclxuICAgIFtpMXgsIGkyeF0uZm9yRWFjaCgoeCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzWEluc2lkZUxpbmUgPSB4ID49IE1hdGgubWluKHgxLCB4MikgJiYgeCA8PSBNYXRoLm1heCh4MSwgeDIpO1xyXG4gICAgICAgIGlmICghaXNYSW5zaWRlTGluZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHkgPSBrICogeCArIHkwO1xyXG4gICAgICAgIGNvbnN0IGExID0gbm9ybWFsaXplQW5nbGUzNjAoc3RhcnRBbmdsZSk7XHJcbiAgICAgICAgbGV0IGEyID0gbm9ybWFsaXplQW5nbGUzNjAoZW5kQW5nbGUpO1xyXG4gICAgICAgIGxldCBhID0gbm9ybWFsaXplQW5nbGUzNjAoTWF0aC5hdGFuMih5LCB4KSk7XHJcbiAgICAgICAgLy8gT3JkZXIgYW5nbGVzIGNsb2Nrd2lzZSBhZnRlciB0aGUgc3RhcnQgYW5nbGVcclxuICAgICAgICBpZiAoYTIgPD0gYTEpIHtcclxuICAgICAgICAgICAgYTIgKz0gMiAqIE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhIDwgYTEpIHtcclxuICAgICAgICAgICAgYSArPSAyICogTWF0aC5QSTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50ZXJDbG9ja3dpc2UgIT09IChhID49IGExICYmIGEgPD0gYTIpKSB7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnMucHVzaCh7IHgsIHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcclxufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5TZWN0b3IoeCwgeSwgc2VjdG9yKSB7XHJcbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSk7XHJcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gc2VjdG9yO1xyXG4gICAgaWYgKHNlY3Rvci5zdGFydEFuZ2xlID09PSBzZWN0b3IuZW5kQW5nbGUgfHxcclxuICAgICAgICByYWRpdXMgPCBNYXRoLm1pbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpIHx8XHJcbiAgICAgICAgcmFkaXVzID4gTWF0aC5tYXgoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBub3JtYWxpemVBbmdsZTE4MChzZWN0b3Iuc3RhcnRBbmdsZSk7XHJcbiAgICBjb25zdCBlbmRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMTgwKHNlY3Rvci5lbmRBbmdsZSk7XHJcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XHJcbiAgICAvLyBTZWN0b3IgY2FuIGNyb3NzIGF4aXMgc3RhcnRcclxuICAgIHJldHVybiBzdGFydEFuZ2xlIDwgZW5kQW5nbGVcclxuICAgICAgICA/IGFuZ2xlIDw9IGVuZEFuZ2xlICYmIGFuZ2xlID49IHN0YXJ0QW5nbGVcclxuICAgICAgICA6IChhbmdsZSA8PSBlbmRBbmdsZSAmJiBhbmdsZSA+PSAtTWF0aC5QSSkgfHwgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gTWF0aC5QSSk7XHJcbn1cclxuZnVuY3Rpb24gbGluZUNvbGxpZGVzU2VjdG9yKGxpbmUsIHNlY3Rvcikge1xyXG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0b3I7XHJcbiAgICBjb25zdCBvdXRlclN0YXJ0ID0geyB4OiBvdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCB5OiBvdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpIH07XHJcbiAgICBjb25zdCBvdXRlckVuZCA9IHsgeDogb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IG91dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpIH07XHJcbiAgICBjb25zdCBpbm5lclN0YXJ0ID0gaW5uZXJSYWRpdXMgPT09IDBcclxuICAgICAgICA/IHsgeDogMCwgeTogMCB9XHJcbiAgICAgICAgOiB7IHg6IGlubmVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IGlubmVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkgfTtcclxuICAgIGNvbnN0IGlubmVyRW5kID0gaW5uZXJSYWRpdXMgPT09IDBcclxuICAgICAgICA/IHsgeDogMCwgeTogMCB9XHJcbiAgICAgICAgOiB7IHg6IGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSB9O1xyXG4gICAgcmV0dXJuIChzZWdtZW50SW50ZXJzZWN0aW9uKGxpbmUuc3RhcnQueCwgbGluZS5zdGFydC55LCBsaW5lLmVuZC54LCBsaW5lLmVuZC55LCBvdXRlclN0YXJ0LngsIG91dGVyU3RhcnQueSwgaW5uZXJTdGFydC54LCBpbm5lclN0YXJ0LnkpICE9IG51bGwgfHxcclxuICAgICAgICBzZWdtZW50SW50ZXJzZWN0aW9uKGxpbmUuc3RhcnQueCwgbGluZS5zdGFydC55LCBsaW5lLmVuZC54LCBsaW5lLmVuZC55LCBvdXRlckVuZC54LCBvdXRlckVuZC55LCBpbm5lckVuZC54LCBpbm5lckVuZC55KSAhPSBudWxsIHx8XHJcbiAgICAgICAgYXJjSW50ZXJzZWN0aW9ucygwLCAwLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUsIGxpbmUuc3RhcnQueCwgbGluZS5zdGFydC55LCBsaW5lLmVuZC54LCBsaW5lLmVuZC55KS5sZW5ndGggPiAwKTtcclxufVxyXG5mdW5jdGlvbiBib3hDb2xsaWRlc1NlY3Rvcihib3gsIHNlY3Rvcikge1xyXG4gICAgY29uc3QgdG9wTGVmdCA9IHsgeDogYm94LngsIHk6IGJveC55IH07XHJcbiAgICBjb25zdCB0b3BSaWdodCA9IHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH07XHJcbiAgICBjb25zdCBib3R0b21MZWZ0ID0geyB4OiBib3gueCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH07XHJcbiAgICBjb25zdCBib3R0b21SaWdodCA9IHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55ICsgYm94LmhlaWdodCB9O1xyXG4gICAgcmV0dXJuIChsaW5lQ29sbGlkZXNTZWN0b3IoeyBzdGFydDogdG9wTGVmdCwgZW5kOiB0b3BSaWdodCB9LCBzZWN0b3IpIHx8XHJcbiAgICAgICAgbGluZUNvbGxpZGVzU2VjdG9yKHsgc3RhcnQ6IGJvdHRvbUxlZnQsIGVuZDogYm90dG9tUmlnaHQgfSwgc2VjdG9yKSk7XHJcbn1cblxudmFyIENvbW1hbmQ7XHJcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xyXG4gICAgQ29tbWFuZFtDb21tYW5kW1wiTW92ZVwiXSA9IDBdID0gXCJNb3ZlXCI7XHJcbiAgICBDb21tYW5kW0NvbW1hbmRbXCJMaW5lXCJdID0gMV0gPSBcIkxpbmVcIjtcclxuICAgIENvbW1hbmRbQ29tbWFuZFtcIkFyY1wiXSA9IDJdID0gXCJBcmNcIjtcclxuICAgIENvbW1hbmRbQ29tbWFuZFtcIkN1cnZlXCJdID0gM10gPSBcIkN1cnZlXCI7XHJcbiAgICBDb21tYW5kW0NvbW1hbmRbXCJDbG9zZVBhdGhcIl0gPSA0XSA9IFwiQ2xvc2VQYXRoXCI7XHJcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xyXG5jbGFzcyBQYXRoMkQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gVGhlIG1ldGhvZHMgb2YgdGhpcyBjbGFzcyB3aWxsIGxpa2VseSBiZSBjYWxsZWQgbWFueSB0aW1lcyBwZXIgYW5pbWF0aW9uIGZyYW1lLFxyXG4gICAgICAgIC8vIGFuZCBhbnkgYWxsb2NhdGlvbiBjYW4gdHJpZ2dlciBhIEdDIGN5Y2xlIGR1cmluZyBhbmltYXRpb24sIHNvIHdlIGF0dGVtcHRcclxuICAgICAgICAvLyB0byBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIGFsbG9jYXRpb25zLlxyXG4gICAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kcyA9IFtdO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNQYXJhbXMgPSBbXTtcclxuICAgICAgICB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2Nsb3NlZFBhdGggPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlzRGlydHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZFBhdGggIT09IHRoaXMucHJldmlvdXNDbG9zZWRQYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcmV2aW91c0NvbW1hbmRzLmxlbmd0aCAhPT0gdGhpcy5jb21tYW5kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzUGFyYW1zLmxlbmd0aCAhPT0gdGhpcy5wYXJhbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tbWFuZHNbaV0gIT09IHRoaXMucHJldmlvdXNDb21tYW5kc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbXNbaV0gIT09IHRoaXMucHJldmlvdXNQYXJhbXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgY29uc3QgY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gICAgICAgIGxldCBqID0gMDtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb21tYW5kIG9mIGNvbW1hbmRzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kLk1vdmU6XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwYXJhbXNbaisrXSwgcGFyYW1zW2orK10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kLkxpbmU6XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwYXJhbXNbaisrXSwgcGFyYW1zW2orK10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kLkN1cnZlOlxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBhcmFtc1tqKytdLCBwYXJhbXNbaisrXSwgcGFyYW1zW2orK10sIHBhcmFtc1tqKytdLCBwYXJhbXNbaisrXSwgcGFyYW1zW2orK10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kLkFyYzpcclxuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHBhcmFtc1tqKytdLCBwYXJhbXNbaisrXSwgcGFyYW1zW2orK10sIHBhcmFtc1tqKytdLCBwYXJhbXNbaisrXSwgcGFyYW1zW2orK10gPT09IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kLkNsb3NlUGF0aDpcclxuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbW1hbmRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbW92ZVRvKHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy54eSkge1xyXG4gICAgICAgICAgICB0aGlzLnh5WzBdID0geDtcclxuICAgICAgICAgICAgdGhpcy54eVsxXSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnh5ID0gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goQ29tbWFuZC5Nb3ZlKTtcclxuICAgICAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgbGluZVRvKHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy54eSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goQ29tbWFuZC5MaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5KTtcclxuICAgICAgICAgICAgdGhpcy54eVswXSA9IHg7XHJcbiAgICAgICAgICAgIHRoaXMueHlbMV0gPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgdGhpcy5saW5lVG8oeCArIHdpZHRoLCB5KTtcclxuICAgICAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMubGluZVRvKHgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XHJcbiAgICB9XHJcbiAgICBhcmMoeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGFudGlDbG9ja3dpc2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IGVuZFggPSB4ICsgciAqIE1hdGguY29zKGVBbmdsZSk7XHJcbiAgICAgICAgY29uc3QgZW5kWSA9IHkgKyByICogTWF0aC5zaW4oZUFuZ2xlKTtcclxuICAgICAgICBpZiAodGhpcy54eSkge1xyXG4gICAgICAgICAgICB0aGlzLnh5WzBdID0gZW5kWDtcclxuICAgICAgICAgICAgdGhpcy54eVsxXSA9IGVuZFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnh5ID0gW2VuZFgsIGVuZFldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goQ29tbWFuZC5BcmMpO1xyXG4gICAgICAgIHRoaXMucGFyYW1zLnB1c2goeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGFudGlDbG9ja3dpc2UgPyAxIDogMCk7XHJcbiAgICB9XHJcbiAgICBjdWJpY0N1cnZlVG8oY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnh5KSB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKGN4MSwgY3kxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKENvbW1hbmQuQ3VydmUpO1xyXG4gICAgICAgIHRoaXMucGFyYW1zLnB1c2goY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KTtcclxuICAgICAgICBpZiAodGhpcy54eSkge1xyXG4gICAgICAgICAgICB0aGlzLnh5WzBdID0geDtcclxuICAgICAgICAgICAgdGhpcy54eVsxXSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGNsb3NlZFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFBhdGg7XHJcbiAgICB9XHJcbiAgICBjbG9zZVBhdGgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMueHkpIHtcclxuICAgICAgICAgICAgdGhpcy54eSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKENvbW1hbmQuQ2xvc2VQYXRoKTtcclxuICAgICAgICAgICAgdGhpcy5fY2xvc2VkUGF0aCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXIoeyB0cmFja0NoYW5nZXMgfSA9IHsgdHJhY2tDaGFuZ2VzOiBmYWxzZSB9KSB7XHJcbiAgICAgICAgaWYgKHRyYWNrQ2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xyXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzUGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNDbG9zZWRQYXRoID0gdGhpcy5fY2xvc2VkUGF0aDtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnh5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2Nsb3NlZFBhdGggPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlzUG9pbnRJblBhdGgoeCwgeSkge1xyXG4gICAgICAgIGNvbnN0IGNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuICAgICAgICBjb25zdCBjbiA9IGNvbW1hbmRzLmxlbmd0aDtcclxuICAgICAgICAvLyBIaXQgdGVzdGluZyB1c2luZyByYXkgY2FzdGluZyBtZXRob2QsIHdoZXJlIHRoZSByYXkncyBvcmlnaW4gaXMgc29tZSBwb2ludFxyXG4gICAgICAgIC8vIG91dHNpZGUgdGhlIHBhdGguIEluIHRoaXMgY2FzZSwgYW4gb2Zmc2NyZWVuIHBvaW50IHRoYXQgaXMgcmVtb3RlIGVub3VnaCwgc28gdGhhdFxyXG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlIHBhdGggaXRzZWxmIGlzIGxhcmdlIGFuZCBpcyBwYXJ0aWFsbHkgb2Zmc2NyZWVuLCB0aGUgcmF5J3Mgb3JpZ2luXHJcbiAgICAgICAgLy8gd2lsbCBsaWtlbHkgYmUgb3V0c2lkZSB0aGUgcGF0aCBhbnl3YXkuIFRvIHRlc3QgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGVcclxuICAgICAgICAvLyBwYXRoIG9yIG5vdCwgd2UgY2FzdCBhIHJheSBmcm9tIHRoZSBvcmlnaW4gdG8gdGhlIGdpdmVuIHBvaW50IGFuZCBjaGVjayB0aGUgbnVtYmVyXHJcbiAgICAgICAgLy8gb2YgaW50ZXJzZWN0aW9ucyBvZiB0aGlzIHNlZ21lbnQgd2l0aCB0aGUgcGF0aC4gSWYgdGhlIG51bWJlciBvZiBpbnRlcnNlY3Rpb25zIGlzXHJcbiAgICAgICAgLy8gZXZlbiwgdGhlbiB0aGUgcmF5IGJvdGggZW50ZXJlZCBhbmQgZXhpdGVkIHRoZSBwYXRoIGFuIGVxdWFsIG51bWJlciBvZiB0aW1lcyxcclxuICAgICAgICAvLyB0aGVyZWZvcmUgdGhlIHBvaW50IGlzIG91dHNpZGUgdGhlIHBhdGgsIGFuZCBpbnNpZGUgdGhlIHBhdGgsIGlmIHRoZSBudW1iZXIgb2ZcclxuICAgICAgICAvLyBpbnRlcnNlY3Rpb25zIGlzIG9kZC4gU2luY2UgdGhlIHBhdGggaXMgY29tcG91bmQsIHdlIGNoZWNrIGlmIHRoZSByYXkgc2VnbWVudFxyXG4gICAgICAgIC8vIGludGVyc2VjdHMgd2l0aCBlYWNoIG9mIHRoZSBwYXRoJ3Mgc2VnbWVudHMsIHdoaWNoIGNhbiBiZSBlaXRoZXIgYSBsaW5lIHNlZ21lbnRcclxuICAgICAgICAvLyAob25lIG9yIG5vIGludGVyc2VjdGlvbiBwb2ludHMpIG9yIGEgQsOpemllciBjdXJ2ZSBzZWdtZW50ICh1cCB0byAzIGludGVyc2VjdGlvblxyXG4gICAgICAgIC8vIHBvaW50cykuXHJcbiAgICAgICAgY29uc3Qgb3ggPSAtMTAwMDA7XHJcbiAgICAgICAgY29uc3Qgb3kgPSAtMTAwMDA7XHJcbiAgICAgICAgLy8gdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSAgY3VycmVudCBwYXRoXHJcbiAgICAgICAgbGV0IHN4ID0gTmFOO1xyXG4gICAgICAgIGxldCBzeSA9IE5hTjtcclxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgcG9pbnQgb2YgdGhlIGN1cnJlbnQgcGF0aFxyXG4gICAgICAgIGxldCBweCA9IDA7XHJcbiAgICAgICAgbGV0IHB5ID0gMDtcclxuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGNpID0gMCwgcGkgPSAwOyBjaSA8IGNuOyBjaSsrKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbW1hbmQuTW92ZTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHN4KSAmJiBzZWdtZW50SW50ZXJzZWN0aW9uKHN4LCBzeSwgcHgsIHB5LCBveCwgb3ksIHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcGFyYW1zW3BpKytdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN4ID0gcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBwYXJhbXNbcGkrK107XHJcbiAgICAgICAgICAgICAgICAgICAgc3kgPSBweTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29tbWFuZC5MaW5lOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50SW50ZXJzZWN0aW9uKHB4LCBweSwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIG94LCBveSwgeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHggPSBwYXJhbXNbcGkgLSAyXTtcclxuICAgICAgICAgICAgICAgICAgICBweSA9IHBhcmFtc1twaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kLkN1cnZlOlxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IGN1YmljU2VnbWVudEludGVyc2VjdGlvbnMocHgsIHB5LCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBveCwgb3ksIHgsIHkpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBweCA9IHBhcmFtc1twaSAtIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHB5ID0gcGFyYW1zW3BpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbW1hbmQuQXJjOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN4ID0gcGFyYW1zW3BpKytdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN5ID0gcGFyYW1zW3BpKytdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBwYXJhbXNbcGkrK107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHBhcmFtc1twaSsrXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRBbmdsZSA9IHBhcmFtc1twaSsrXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudGVyQ2xvY2t3aXNlID0gQm9vbGVhbihwYXJhbXNbcGkrK10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IGFyY0ludGVyc2VjdGlvbnMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSwgb3gsIG95LCB4LCB5KS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgcHggPSBjeCArIE1hdGguY29zKGVuZEFuZ2xlKSAqIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBjeSArIE1hdGguc2luKGVuZEFuZ2xlKSAqIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbW1hbmQuQ2xvc2VQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oc3gpICYmIHNlZ21lbnRJbnRlcnNlY3Rpb24oc3gsIHN5LCBweCwgcHksIG94LCBveSwgeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbkNvdW50ICUgMiA9PT0gMTtcclxuICAgIH1cclxuICAgIGdldFBvaW50cygpIHtcclxuICAgICAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgY29vcmRzID0gW107XHJcbiAgICAgICAgbGV0IHBpID0gMDtcclxuICAgICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgY29tbWFuZHMubGVuZ3RoOyBjaSsrKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbW1hbmQuTW92ZTpcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29tbWFuZC5MaW5lOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKHsgeDogcGFyYW1zW3BpKytdLCB5OiBwYXJhbXNbcGkrK10gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbW1hbmQuQ3VydmU6XHJcbiAgICAgICAgICAgICAgICAgICAgcGkgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kLkFyYzpcclxuICAgICAgICAgICAgICAgICAgICBjb29yZHMucHVzaCh7IHg6IHBhcmFtc1twaSsrXSwgeTogcGFyYW1zW3BpKytdIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBpICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbW1hbmQuQ2xvc2VQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb29yZHM7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKG9wdHMpIHtcclxuICAgIGNvbnN0IHsgcmVkcmF3ID0gUmVkcmF3VHlwZS5NQUpPUiwgY2hhbmdlQ2IsIGNvbnZlcnRvciB9ID0gb3B0cyAhPT0gbnVsbCAmJiBvcHRzICE9PSB2b2lkIDAgPyBvcHRzIDoge307XHJcbiAgICByZXR1cm4gU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXcsIHR5cGU6ICdwYXRoJywgY29udmVydG9yLCBjaGFuZ2VDYiB9KTtcclxufVxyXG5jbGFzcyBQYXRoIGV4dGVuZHMgU2hhcGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNsYXJlIGEgcGF0aCB0byByZXRhaW4gZm9yIGxhdGVyIHJlbmRlcmluZyBhbmQgaGl0IHRlc3RpbmdcclxuICAgICAgICAgKiB1c2luZyBjdXN0b20gUGF0aDJEIGNsYXNzLiBUaGluayBvZiBpdCBhcyBhIFR5cGVTY3JpcHQgdmVyc2lvblxyXG4gICAgICAgICAqIG9mIHRoZSBuYXRpdmUgUGF0aDJEICh3aXRoIHNvbWUgZGlmZmVyZW5jZXMpIHRoYXQgd29ya3MgaW4gYWxsIGJyb3dzZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoMkQoKTtcclxuICAgICAgICB0aGlzLmNsaXBTY2FsaW5nWCA9IDE7XHJcbiAgICAgICAgdGhpcy5jbGlwU2NhbGluZ1kgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwYXRoIG9ubHkgaGFzIHRvIGJlIHVwZGF0ZWQgd2hlbiBjZXJ0YWluIGF0dHJpYnV0ZXMgY2hhbmdlLlxyXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBpZiB0cmFuc2Zvcm0gYXR0cmlidXRlcyAoc3VjaCBhcyBgdHJhbnNsYXRpb25YYClcclxuICAgICAgICAgKiBhcmUgY2hhbmdlZCwgd2UgZG9uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlIHBhdGguIFRoZSBgZGlydHlQYXRoYCBmbGFnXHJcbiAgICAgICAgICogaXMgaG93IHdlIGtlZXAgdHJhY2sgaWYgdGhlIHBhdGggaGFzIHRvIGJlIHVwZGF0ZWQgb3Igbm90LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2RpcnR5UGF0aCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzZXQgZGlydHlQYXRoKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5UGF0aCAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlQYXRoID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgUmVkcmF3VHlwZS5NQUpPUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZGlydHlQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eVBhdGg7XHJcbiAgICB9XHJcbiAgICBjaGVja1BhdGhEaXJ0eSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5UGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlydHlQYXRoID1cclxuICAgICAgICAgICAgdGhpcy5wYXRoLmlzRGlydHkoKSB8fCAoKF9iID0gKF9hID0gdGhpcy5maWxsU2hhZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEaXJ0eSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSkgfHwgKChfZCA9IChfYyA9IHRoaXMuY2xpcFBhdGgpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pc0RpcnR5KCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlKTtcclxuICAgIH1cclxuICAgIGlzUG9pbnRJblBhdGgoeCwgeSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLmNsb3NlZFBhdGggJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICB9XHJcbiAgICBpc0RpcnR5UGF0aCgpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCBmb3IgbW9yZSBleHBlbnNpdmUgZGlydHkgY2hlY2tzLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBhdGgoKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgcG9pbnQgZm9yIHN1YmNsYXNzZXMuXHJcbiAgICB9XHJcbiAgICBjbGlwKGN0eCwgb3ApIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgY29uc3QgY2xpcFNjYWxlID0gdGhpcy5jbGlwU2NhbGluZ1ggIT09IDEgfHwgdGhpcy5jbGlwU2NhbGluZ1kgIT09IDE7XHJcbiAgICAgICAgaWYgKGNsaXBTY2FsZSkge1xyXG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5jbGlwU2NhbGluZ1gsIHRoaXMuY2xpcFNjYWxpbmdZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3AoKTtcclxuICAgICAgICBpZiAoY2xpcFNjYWxlKSB7XHJcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW5kZXIocmVuZGVyQ3R4KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PT0gUmVkcmF3VHlwZS5OT05FICYmICFmb3JjZVJlbmRlcikge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHMpXHJcbiAgICAgICAgICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXgudG9Db250ZXh0KGN0eCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHlQYXRoIHx8IHRoaXMuaXNEaXJ0eVBhdGgoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhdGggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwTW9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBNb2RlID09PSAnbm9ybWFsJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwKGN0eCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCb3VuZCB0aGUgc2hhcGUgcmVuZGVyZWQgdG8gdGhlIGNsaXBwaW5nIHBhdGguXHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jbGlwUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFNjYWxpbmdYID4gMCAmJiB0aGlzLmNsaXBTY2FsaW5nWSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aC5kcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxTdHJva2UoY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwTW9kZSA9PT0gJ3B1bmNoLW91dCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcChjdHgsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdW5kIHRoZSBzaGFwZSByZW5kZXJlZCB0byB0aGUgY2xpcHBpbmcgcGF0aC5cclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNsaXBQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdmFsdWVzLCBidXQgcHJhY3RpY2FsbHkgdGhlc2Ugc2hvdWxkIG5ldmVyIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4ID0gLTEwMDAwLCB5ID0gLTEwMDAwLCB3aWR0aCA9IDIwMDAwLCBoZWlnaHQgPSAyMDAwMCB9ID0gKF9iID0gdGhpcy5jb21wdXRlQkJveCgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aC5kcmF3KGN0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFN0cm9rZShjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2EgPSB0aGlzLmZpbGxTaGFkb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrQ2xlYW4oKTtcclxuICAgICAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcclxuICAgIH1cclxufVxyXG5QYXRoLmNsYXNzTmFtZSA9ICdQYXRoJztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBQYXRoMkQpXHJcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBQYXRoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwTW9kZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGF0aC5wcm90b3R5cGUsIFwiY2xpcFNjYWxpbmdYXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwU2NhbGluZ1lcIiwgdm9pZCAwKTtcblxuY2xhc3MgU2VjdG9yIGV4dGVuZHMgUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuY2VudGVyWCA9IDA7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJZID0gMDtcclxuICAgICAgICB0aGlzLmlubmVyUmFkaXVzID0gMTA7XHJcbiAgICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IDIwO1xyXG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5lbmRBbmdsZSA9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIHRoaXMuYW5nbGVPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5zZXQgPSAwO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZUJCb3goKSB7XHJcbiAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cztcclxuICAgICAgICByZXR1cm4gbmV3IEJCb3godGhpcy5jZW50ZXJYIC0gcmFkaXVzLCB0aGlzLmNlbnRlclkgLSByYWRpdXMsIHJhZGl1cyAqIDIsIHJhZGl1cyAqIDIpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGF0aCgpIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIGNvbnN0IHsgYW5nbGVPZmZzZXQsIGluc2V0IH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLnN0YXJ0QW5nbGUgKyBhbmdsZU9mZnNldDtcclxuICAgICAgICBjb25zdCBlbmRBbmdsZSA9IHRoaXMuZW5kQW5nbGUgKyBhbmdsZU9mZnNldDtcclxuICAgICAgICBjb25zdCBmdWxsUGllID0gTWF0aC5hYnModGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgPj0gMiAqIE1hdGguUEk7XHJcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHRoaXMuY2VudGVyWDtcclxuICAgICAgICBjb25zdCBjZW50ZXJZID0gdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgIHBhdGguY2xlYXIoKTtcclxuICAgICAgICBpZiAoZnVsbFBpZSkge1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlSW5uZXJSYWRpdXMgPSB0aGlzLmlubmVyUmFkaXVzIDw9IDAgPyAwIDogdGhpcy5pbm5lclJhZGl1cyArIGluc2V0O1xyXG4gICAgICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWluKGJhc2VJbm5lclJhZGl1cywgdGhpcy5vdXRlclJhZGl1cyAtIGluc2V0KTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChiYXNlSW5uZXJSYWRpdXMsIHRoaXMub3V0ZXJSYWRpdXMgLSBpbnNldCk7XHJcbiAgICAgICAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XHJcbiAgICAgICAgICAgIGlmIChpbm5lclJhZGl1cyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBpbm5lclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgY2VudGVyWSArIGlubmVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpKTtcclxuICAgICAgICAgICAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5taW4odGhpcy5pbm5lclJhZGl1cyArIGluc2V0LCB0aGlzLm91dGVyUmFkaXVzIC0gaW5zZXQpO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KHRoaXMuaW5uZXJSYWRpdXMgKyBpbnNldCwgdGhpcy5vdXRlclJhZGl1cyAtIGluc2V0KTtcclxuICAgICAgICAgICAgY29uc3QgaW5uZXJBbmdsZU9mZnNldCA9IGlubmVyUmFkaXVzID4gMCA/IGluc2V0IC8gaW5uZXJSYWRpdXMgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRlckFuZ2xlT2Zmc2V0ID0gb3V0ZXJSYWRpdXMgPiAwID8gaW5zZXQgLyBvdXRlclJhZGl1cyA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHN3ZWVwID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0ZXJBbmdsZUV4Y2VlZGVkID0gc3dlZXAgPCAyICogb3V0ZXJBbmdsZU9mZnNldDtcclxuICAgICAgICAgICAgaWYgKG91dGVyQW5nbGVFeGNlZWRlZClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgaW5uZXJBbmdsZUV4Y2VlZGVkID0gaW5uZXJSYWRpdXMgPD0gaW5zZXQgfHwgc3dlZXAgPCAyICogaW5uZXJBbmdsZU9mZnNldDtcclxuICAgICAgICAgICAgaWYgKGlubmVyQW5nbGVFeGNlZWRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIHdlZGdlIG9uIGEgY2FydGVzaWFuIGNvLW9yZGluYXRlIHdpdGggcmFkaXVzIGBzd2VlcGBcclxuICAgICAgICAgICAgICAgIC8vIEluc2V0IGZyb20gYm90dG9tIC0gaS5lLiB5ID0gaW5uZXJSYWRpdXNcclxuICAgICAgICAgICAgICAgIC8vIEluc2V0IHRoZSB0b3AgLSBpLmUuIHkgPSAoeCAtIHgwKSAqIHRhbihzd2VlcClcclxuICAgICAgICAgICAgICAgIC8vIEZvcm0gYSByaWdodCBhbmdsZSBmcm9tIHRoZSB3ZWRnZSB3aXRoIGh5cG90ZW51c2UgeDAgYW5kIGFuIG9wcG9zaXRlIHNpZGUgb2YgaW5uZXJSYWRpdXNcclxuICAgICAgICAgICAgICAgIC8vIEdpdmVzIHgwID0gaW5zZXQgKiBzaW4oc3dlZXApXHJcbiAgICAgICAgICAgICAgICAvLyB5ID0gaW5zZXQgPSAoeCAtIGluc2V0ICogc2luKHN3ZWVwKSkgKiB0YW4oc3dlZXApIC0gc29sdmUgZm9yIHhcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZm9ybXVsYSBoYXMgbGltaXRzIChpLmUuIHN3ZWVwIGJlaW5nID49IGEgcXVhcnRlciB0dXJuKSxcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgYm91bmRzIGZvciB4IHNob3VsZCBiZSBbaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGguYWJzKHN3ZWVwKSA8IE1hdGguUEkgKiAwLjUgPyAoaW5zZXQgKiAoMSArIE1hdGguY29zKHN3ZWVwKSkpIC8gTWF0aC5zaW4oc3dlZXApIDogTmFOO1xyXG4gICAgICAgICAgICAgICAgLy8gciA9IHNxcnQoeCoqMiArIHkqKjIpXHJcbiAgICAgICAgICAgICAgICBsZXQgcjtcclxuICAgICAgICAgICAgICAgIGlmICh4ID4gMCAmJiB4IDwgb3V0ZXJSYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVuIHdpdGhpbiB0aGUgZm9ybXVsYSBsaW1pdHMsIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc24ndCBhbHdheXMgZW5vdWdoLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGVuc3VyZSB3ZSBuZXZlciBnbyBsZXNzIHRoYW4gdGhlIGlubmVyIHJhZGl1c1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBNYXRoLm1heChNYXRoLmh5cG90KGluc2V0LCB4KSwgaW5uZXJSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9ybXVsYSBsaW1pdHMgZXhjZWVkZWQgLSBqdXN0IHVzZSB0aGUgaW5uZXIgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IGlubmVyUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWlkQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAqIDAuNTtcclxuICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyByICogTWF0aC5jb3MobWlkQW5nbGUpLCBjZW50ZXJZICsgciAqIE1hdGguc2luKG1pZEFuZ2xlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlICsgaW5uZXJBbmdsZU9mZnNldCksIGNlbnRlclkgKyBpbm5lclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUgKyBpbm5lckFuZ2xlT2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgKyBvdXRlckFuZ2xlT2Zmc2V0LCBlbmRBbmdsZSAtIG91dGVyQW5nbGVPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoaW5uZXJBbmdsZUV4Y2VlZGVkKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlubmVyUmFkaXVzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gaW5uZXJBbmdsZU9mZnNldCwgc3RhcnRBbmdsZSArIGlubmVyQW5nbGVPZmZzZXQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8oY2VudGVyWCwgY2VudGVyWSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmRpcnR5UGF0aCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaXNQb2ludEluUGF0aCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgeyBhbmdsZU9mZnNldCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5zdGFydEFuZ2xlICsgYW5nbGVPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgZW5kQW5nbGUgPSB0aGlzLmVuZEFuZ2xlICsgYW5nbGVPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1pbih0aGlzLmlubmVyUmFkaXVzLCB0aGlzLm91dGVyUmFkaXVzKTtcclxuICAgICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KHRoaXMuaW5uZXJSYWRpdXMsIHRoaXMub3V0ZXJSYWRpdXMpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcclxuICAgICAgICByZXR1cm4gaXNQb2ludEluU2VjdG9yKHBvaW50LngsIHBvaW50LnksIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9KTtcclxuICAgIH1cclxufVxyXG5TZWN0b3IuY2xhc3NOYW1lID0gJ1NlY3Rvcic7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNlbnRlclhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY2VudGVyWVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImFuZ2xlT2Zmc2V0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImluc2V0XCIsIHZvaWQgMCk7XG5cbmZ1bmN0aW9uIGRlZXBNZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB8fCAoaXNPYmplY3RMaWtlKHRhcmdldCkgJiYgIWlzT2JqZWN0TGlrZShzb3VyY2UpKSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc291cmNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcclxuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHgpIHtcclxuICAgIHJldHVybiBpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyguLi5zb3VyY2VzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcclxuICAgICAgICBpZiAoIXNvdXJjZSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGlzRGVjb3JhdGVkT2JqZWN0KHNvdXJjZSkgPyBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyhzb3VyY2UpIDogT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRba2V5XSkgJiYgaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlRGVmYXVsdHModGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIChfYSA9IHRhcmdldFtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbi8vIFNpbWlsYXIgdG8gT2JqZWN0LmFzc2lnbiwgYnV0IG9ubHkgY29weSBhbiBleHBsaWNpdCBzZXQgb2Yga2V5cy5cclxuZnVuY3Rpb24gcGFydGlhbEFzc2lnbihrZXlzVG9Db3B5LCB0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb0NvcHkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxuXG5sZXQgZWxlbWVudCA9IG51bGw7XHJcbmZ1bmN0aW9uIHNhbml0aXplSHRtbCh0ZXh0KSB7XHJcbiAgICBpZiAodGV4dCA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRleHQgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50ICE9PSB2b2lkIDAgPyBlbGVtZW50IDogKGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XHJcbiAgICBlbGVtZW50LnRleHRDb250ZW50ID0gU3RyaW5nKHRleHQpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xyXG59XG5cbmNvbnN0IGlzU3RyaW5nID0gKHYpID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJztcclxuY29uc3QgaXNTdHJpbmdPYmplY3QgPSAodikgPT4gISF2ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCAndG9TdHJpbmcnKSAmJiBpc1N0cmluZyh2LnRvU3RyaW5nKCkpO1xyXG5jb25zdCBpc0RhdGUgPSAodikgPT4gdiBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKCt2KTtcclxuZnVuY3Rpb24gaXNEaXNjcmV0ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSB8fCBpc1N0cmluZ09iamVjdCh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gaXNDb250aW51b3VzKHZhbHVlKSB7XHJcbiAgICBjb25zdCBpc051bWJlck9iamVjdCA9ICh2KSA9PiAhIXYgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHYsICd2YWx1ZU9mJykgJiYgaXNOdW1iZXIodi52YWx1ZU9mKCkpO1xyXG4gICAgY29uc3QgaXNEYXRlID0gKHYpID0+IHYgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTigrdik7XHJcbiAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpIHx8IGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fCBpc0RhdGUodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrRGF0dW0odmFsdWUsIGlzQ29udGludW91c1NjYWxlKSB7XHJcbiAgICBpZiAoaXNDb250aW51b3VzU2NhbGUgJiYgaXNDb250aW51b3VzKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFpc0NvbnRpbnVvdXNTY2FsZSkge1xyXG4gICAgICAgIGlmICghaXNEaXNjcmV0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuY29uc3QgaXNOdW1iZXIgPSAodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZSh2KTtcblxuY29uc3QgbWVtb3JpemVkRm5zID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiBtZW1vKHBhcmFtcywgZm5HZW5lcmF0b3IpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgY29uc3Qgc2VyaWFsaXNlZFBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgMCk7XHJcbiAgICBpZiAoIW1lbW9yaXplZEZucy5oYXMoZm5HZW5lcmF0b3IpKSB7XHJcbiAgICAgICAgbWVtb3JpemVkRm5zLnNldChmbkdlbmVyYXRvciwgbmV3IE1hcCgpKTtcclxuICAgIH1cclxuICAgIGlmICghKChfYSA9IG1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKHNlcmlhbGlzZWRQYXJhbXMpKSkge1xyXG4gICAgICAgIChfYiA9IG1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0KHNlcmlhbGlzZWRQYXJhbXMsIGZuR2VuZXJhdG9yKHBhcmFtcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChfYyA9IG1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0KHNlcmlhbGlzZWRQYXJhbXMpO1xyXG59XG5cbmNvbnN0IFNNQUxMRVNUX0tFWV9JTlRFUlZBTCA9IHtcclxuICAgIHR5cGU6ICdyZWR1Y2VyJyxcclxuICAgIHByb3BlcnR5OiAnc21hbGxlc3RLZXlJbnRlcnZhbCcsXHJcbiAgICBpbml0aWFsVmFsdWU6IEluZmluaXR5LFxyXG4gICAgcmVkdWNlcjogKCkgPT4ge1xyXG4gICAgICAgIGxldCBwcmV2WCA9IE5hTjtcclxuICAgICAgICByZXR1cm4gKHNtYWxsZXN0U29GYXIgPSBJbmZpbml0eSwgbmV4dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0WCA9IG5leHQua2V5c1swXTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBNYXRoLmFicyhuZXh0WCAtIHByZXZYKTtcclxuICAgICAgICAgICAgcHJldlggPSBuZXh0WDtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWwgPiAwICYmIGludGVydmFsIDwgc21hbGxlc3RTb0Zhcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVydmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzbWFsbGVzdFNvRmFyO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG5jb25zdCBBR0dfVkFMVUVTX0VYVEVOVCA9IHtcclxuICAgIHR5cGU6ICdwcm9jZXNzb3InLFxyXG4gICAgcHJvcGVydHk6ICdhZ2dWYWx1ZXNFeHRlbnQnLFxyXG4gICAgY2FsY3VsYXRlOiAocHJvY2Vzc2VkRGF0YSkgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uKChfYiA9IChfYSA9IHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbMCwgMF0pXTtcclxuICAgICAgICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2YgKF9kID0gKF9jID0gcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2xpY2UoMSkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdKSB7XHJcbiAgICAgICAgICAgIGlmIChtaW4gPCByZXN1bHRbMF0pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IG1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4ID4gcmVzdWx0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBtYXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbn07XHJcbmNvbnN0IFNPUlRfRE9NQUlOX0dST1VQUyA9IHtcclxuICAgIHR5cGU6ICdwcm9jZXNzb3InLFxyXG4gICAgcHJvcGVydHk6ICdzb3J0ZWRHcm91cERvbWFpbicsXHJcbiAgICBjYWxjdWxhdGU6ICh7IGRvbWFpbjogeyBncm91cHMgfSB9KSA9PiB7XHJcbiAgICAgICAgaWYgKGdyb3VwcyA9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBbLi4uZ3JvdXBzXS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYVtpXSAtIGJbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbn07XHJcbmZ1bmN0aW9uIG5vcm1hbGlzZUZuQnVpbGRlcih7IG5vcm1hbGlzZVRvLCBtb2RlIH0pIHtcclxuICAgIGNvbnN0IG5vcm1hbGlzZSA9ICh2YWwsIGV4dGVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICh2YWwgKiBub3JtYWxpc2VUbykgLyBleHRlbnQ7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihub3JtYWxpc2VUbywgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KC1ub3JtYWxpc2VUbywgcmVzdWx0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gKCkgPT4gKCkgPT4gKHZhbHVlcywgdmFsdWVJbmRleGVzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzRXh0ZW50ID0gWzAsIDBdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4XTtcclxuICAgICAgICAgICAgY29uc3QgdmFsSWR4ID0gdmFsdWUgPCAwID8gMCA6IDE7XHJcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnc3VtJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzRXh0ZW50W3ZhbElkeF0gKz0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsSWR4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSA9IE1hdGgubWluKHZhbHVlc0V4dGVudFt2YWxJZHhdLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSA9IE1hdGgubWF4KHZhbHVlc0V4dGVudFt2YWxJZHhdLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gTWF0aC5tYXgoTWF0aC5hYnModmFsdWVzRXh0ZW50WzBdKSwgdmFsdWVzRXh0ZW50WzFdKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xyXG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gbm9ybWFsaXNlKHZhbHVlc1t2YWx1ZUlkeF0sIGV4dGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpc2VHcm91cFRvKHNjb3BlLCBtYXRjaEdyb3VwSWRzLCBub3JtYWxpc2VUbywgbW9kZSA9ICdzdW0nKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNjb3BlczogW3Njb3BlLmlkXSxcclxuICAgICAgICB0eXBlOiAnZ3JvdXAtdmFsdWUtcHJvY2Vzc29yJyxcclxuICAgICAgICBtYXRjaEdyb3VwSWRzLFxyXG4gICAgICAgIGFkanVzdDogbWVtbyh7IG5vcm1hbGlzZVRvLCBtb2RlIH0sIG5vcm1hbGlzZUZuQnVpbGRlciksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGlzZVByb3BlcnR5Rm5CdWlsZGVyKHsgbm9ybWFsaXNlVG8sIHplcm9Eb21haW4sIHJhbmdlTWluLCByYW5nZU1heCwgfSkge1xyXG4gICAgY29uc3Qgbm9ybWFsaXNlU3BhbiA9IG5vcm1hbGlzZVRvWzFdIC0gbm9ybWFsaXNlVG9bMF07XHJcbiAgICBjb25zdCBub3JtYWxpc2UgPSAodmFsLCBzdGFydCwgc3BhbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5vcm1hbGlzZVRvWzBdICsgKCh2YWwgLSBzdGFydCkgLyBzcGFuKSAqIG5vcm1hbGlzZVNwYW47XHJcbiAgICAgICAgaWYgKHNwYW4gPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRG9tYWluO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPj0gbm9ybWFsaXNlVG9bMV0pXHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpc2VUb1sxXTtcclxuICAgICAgICBpZiAocmVzdWx0IDwgbm9ybWFsaXNlVG9bMF0pXHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpc2VUb1swXTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiAoKSA9PiAocERhdGEsIHBJZHgpID0+IHtcclxuICAgICAgICBsZXQgW3N0YXJ0LCBlbmRdID0gcERhdGEuZG9tYWluLnZhbHVlc1twSWR4XTtcclxuICAgICAgICBpZiAocmFuZ2VNaW4gIT0gbnVsbClcclxuICAgICAgICAgICAgc3RhcnQgPSByYW5nZU1pbjtcclxuICAgICAgICBpZiAocmFuZ2VNYXggIT0gbnVsbClcclxuICAgICAgICAgICAgZW5kID0gcmFuZ2VNYXg7XHJcbiAgICAgICAgY29uc3Qgc3BhbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgIHBEYXRhLmRvbWFpbi52YWx1ZXNbcElkeF0gPSBbbm9ybWFsaXNlVG9bMF0sIG5vcm1hbGlzZVRvWzFdXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHBEYXRhLmRhdGEpIHtcclxuICAgICAgICAgICAgbGV0IGdyb3VwVmFsdWVzID0gZ3JvdXAudmFsdWVzO1xyXG4gICAgICAgICAgICBpZiAocERhdGEudHlwZSA9PT0gJ3VuZ3JvdXBlZCcpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwVmFsdWVzID0gW2dyb3VwVmFsdWVzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cFZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzW3BJZHhdID0gbm9ybWFsaXNlKHZhbHVlc1twSWR4XSwgc3RhcnQsIHNwYW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpc2VQcm9wZXJ0eVRvKHNjb3BlLCBwcm9wZXJ0eSwgbm9ybWFsaXNlVG8sIHplcm9Eb21haW4sIHJhbmdlTWluLCByYW5nZU1heCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY29wZXM6IFtzY29wZS5pZF0sXHJcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5LXZhbHVlLXByb2Nlc3NvcicsXHJcbiAgICAgICAgcHJvcGVydHksXHJcbiAgICAgICAgYWRqdXN0OiBtZW1vKHsgbm9ybWFsaXNlVG8sIHJhbmdlTWluLCByYW5nZU1heCwgemVyb0RvbWFpbiB9LCBub3JtYWxpc2VQcm9wZXJ0eUZuQnVpbGRlciksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGFuaW1hdGlvblZhbGlkYXRpb24oc2NvcGUsIHZhbHVlS2V5SWRzID0gW10pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ3Byb2Nlc3NvcicsXHJcbiAgICAgICAgc2NvcGVzOiBbc2NvcGUuaWRdLFxyXG4gICAgICAgIHByb3BlcnR5OiAnYW5pbWF0aW9uVmFsaWRhdGlvbicsXHJcbiAgICAgICAgY2FsY3VsYXRlKHJlc3VsdCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5cywgdmFsdWVzIH0gPSByZXN1bHQuZGVmcztcclxuICAgICAgICAgICAgY29uc3QgeyBpbnB1dCwgZGF0YSB9ID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBsZXQgdW5pcXVlS2V5cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGxldCBvcmRlcmVkS2V5cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHZhbHVlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gdmFsdWVzW2tdLnNjb3BlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKHMpID0+IHMgPT09IHNjb3BlLmlkKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlS2V5SWRzLnNvbWUoKHYpID0+IHZhbHVlc1trXS5pZCA9PT0gdikpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUtleXMucHVzaChbaywgdmFsdWVzW2tdXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc0tleSA9IChpZHgsIGRlZiwgdHlwZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZVR5cGUgPT09ICdjYXRlZ29yeScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlWYWx1ZXMgPSByZXN1bHQuZG9tYWluW3R5cGVdW2lkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlS2V5cyAmJiAodW5pcXVlS2V5cyA9IGtleVZhbHVlcy5sZW5ndGggPT09IGlucHV0LmNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFZhbHVlID0gKF9hID0gZGF0YVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3R5cGVdW2lkeF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gMTsgKHVuaXF1ZUtleXMgfHwgb3JkZXJlZEtleXMpICYmIGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5VmFsdWUgPSBkYXRhW2RdW3R5cGVdW2lkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZEtleXMgJiYgKG9yZGVyZWRLZXlzID0gbGFzdFZhbHVlIDw9IGtleVZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVLZXlzICYmICh1bmlxdWVLZXlzID0gbGFzdFZhbHVlICE9PSBrZXlWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0ga2V5VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyAodW5pcXVlS2V5cyB8fCBvcmRlcmVkS2V5cykgJiYgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NLZXkoaywga2V5c1trXSwgJ2tleXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgKHVuaXF1ZUtleXMgfHwgb3JkZXJlZEtleXMpICYmIGsgPCB2YWx1ZUtleXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtpZHgsIGtleV0gPSB2YWx1ZUtleXNba107XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzS2V5KGlkeCwga2V5LCAndmFsdWVzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgdW5pcXVlS2V5cywgb3JkZXJlZEtleXMgfTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBidWlsZEdyb3VwQWNjRm4oeyBtb2RlLCBzZXBhcmF0ZU5lZ2F0aXZlIH0pIHtcclxuICAgIHJldHVybiAoKSA9PiAoKSA9PiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcclxuICAgICAgICAvLyBEYXR1bSBzY29wZS5cclxuICAgICAgICBjb25zdCBhY2MgPSBbMCwgMF07XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbCA9IHZhbHVlc1t2YWx1ZUlkeF07XHJcbiAgICAgICAgICAgIGNvbnN0IGFjY0luZGV4ID0gaXNOZWdhdGl2ZShjdXJyZW50VmFsKSAmJiBzZXBhcmF0ZU5lZ2F0aXZlID8gMCA6IDE7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbCAhPT0gJ251bWJlcicgfHwgaXNOYU4oY3VycmVudFZhbCkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdub3JtYWwnKVxyXG4gICAgICAgICAgICAgICAgYWNjW2FjY0luZGV4XSArPSBjdXJyZW50VmFsO1xyXG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjW2FjY0luZGV4XTtcclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICd0cmFpbGluZycpXHJcbiAgICAgICAgICAgICAgICBhY2NbYWNjSW5kZXhdICs9IGN1cnJlbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBidWlsZEdyb3VwV2luZG93QWNjRm4oeyBtb2RlLCBzdW0gfSkge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAvLyBFbnRpcmUgZGF0YS1zZXQgc2NvcGUuXHJcbiAgICAgICAgY29uc3QgbGFzdFZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGxldCBmaXJzdFJvdyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgLy8gR3JvdXAgc2NvcGUuXHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWVzLCB2YWx1ZUluZGV4ZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIERhdHVtIHNjb3BlLlxyXG4gICAgICAgICAgICAgICAgbGV0IGFjYyA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWwgPSB2YWx1ZXNbdmFsdWVJZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGZpcnN0Um93ICYmIHN1bSA9PT0gJ2N1cnJlbnQnID8gMCA6IGxhc3RWYWx1ZXNbdmFsdWVJZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RWYWx1ZXNbdmFsdWVJZHhdID0gY3VycmVudFZhbDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW1WYWx1ZSA9IHN1bSA9PT0gJ2N1cnJlbnQnID8gY3VycmVudFZhbCA6IGxhc3RWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWwgIT09ICdudW1iZXInIHx8IGlzTmFOKGN1cnJlbnRWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RWYWx1ZSAhPT0gJ251bWJlcicgfHwgaXNOYU4obGFzdFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdub3JtYWwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2MgKz0gc3VtVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ3RyYWlsaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjICs9IHN1bVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlyc3RSb3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBhY2N1bXVsYXRlR3JvdXAoc2NvcGUsIG1hdGNoR3JvdXBJZCwgbW9kZSwgc3VtLCBzZXBhcmF0ZU5lZ2F0aXZlID0gZmFsc2UpIHtcclxuICAgIGxldCBhZGp1c3Q7XHJcbiAgICBpZiAobW9kZS5zdGFydHNXaXRoKCd3aW5kb3cnKSkge1xyXG4gICAgICAgIGNvbnN0IG1vZGVQYXJhbSA9IG1vZGUuZW5kc1dpdGgoJy10cmFpbGluZycpID8gJ3RyYWlsaW5nJyA6ICdub3JtYWwnO1xyXG4gICAgICAgIGFkanVzdCA9IG1lbW8oeyBtb2RlOiBtb2RlUGFyYW0sIHN1bSB9LCBidWlsZEdyb3VwV2luZG93QWNjRm4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWRqdXN0ID0gbWVtbyh7IG1vZGU6IG1vZGUsIHNlcGFyYXRlTmVnYXRpdmUgfSwgYnVpbGRHcm91cEFjY0ZuKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2NvcGVzOiBbc2NvcGUuaWRdLFxyXG4gICAgICAgIHR5cGU6ICdncm91cC12YWx1ZS1wcm9jZXNzb3InLFxyXG4gICAgICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxyXG4gICAgICAgIGFkanVzdCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGlmZihwcmV2aW91c0RhdGEsIHVwZGF0ZU1vdmVkRGF0dW1zID0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAncHJvY2Vzc29yJyxcclxuICAgICAgICBwcm9wZXJ0eTogJ2RpZmYnLFxyXG4gICAgICAgIGNhbGN1bGF0ZTogKHByb2Nlc3NlZERhdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbW92ZWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgYWRkZWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogW10sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkOiBbXSxcclxuICAgICAgICAgICAgICAgIGFkZGVkSW5kaWNlczogW10sXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkSW5kaWNlczogW10sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkSW5kaWNlczogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRlZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkZWRJbmRpY2VzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW5kaWNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZEluZGljZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgocHJldmlvdXNEYXRhLmRhdGEubGVuZ3RoLCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gcHJldmlvdXNEYXRhLmRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHByb2Nlc3NlZERhdGEuZGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZJZCA9IHByZXYgPyBjcmVhdGVEYXR1bUlkKHByZXYua2V5cykgOiAnJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtSWQgPSBkYXR1bSA/IGNyZWF0ZURhdHVtSWQoZGF0dW0ua2V5cykgOiAnJztcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2SWQgPT09IGRhdHVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFycmF5c0VxdWFsKHByZXYudmFsdWVzLCBkYXR1bS52YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEluZGljZXMuc2V0KGRhdHVtSWQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkLmhhcyhkYXR1bUlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVNb3ZlZERhdHVtcyB8fCAhYXJyYXlzRXF1YWwocmVtb3ZlZC5nZXQoZGF0dW1JZCkudmFsdWVzLCBkYXR1bS52YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEluZGljZXMuc2V0KGRhdHVtSWQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLmRlbGV0ZShkYXR1bUlkKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkSW5kaWNlcy5kZWxldGUoZGF0dW1JZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXR1bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkLnNldChkYXR1bUlkLCBkYXR1bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJbmRpY2VzLnNldChkYXR1bUlkLCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhZGRlZC5oYXMocHJldklkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVNb3ZlZERhdHVtcyB8fCAhYXJyYXlzRXF1YWwoYWRkZWQuZ2V0KHByZXZJZCkudmFsdWVzLCBwcmV2LnZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5zZXQocHJldklkLCBwcmV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEluZGljZXMuc2V0KHByZXZJZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkLnNldChwcmV2SWQsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhZGRlZC5kZWxldGUocHJldklkKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRlZEluZGljZXMuZGVsZXRlKHByZXZJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5kZWxldGUocHJldklkKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkSW5kaWNlcy5kZWxldGUocHJldklkKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnNldChwcmV2SWQsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRJbmRpY2VzLnNldChwcmV2SWQsIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpZmYuYWRkZWQgPSBBcnJheS5mcm9tKGFkZGVkLmtleXMoKSk7XHJcbiAgICAgICAgICAgIGRpZmYudXBkYXRlZCA9IEFycmF5LmZyb20odXBkYXRlZC5rZXlzKCkpO1xyXG4gICAgICAgICAgICBkaWZmLnJlbW92ZWQgPSBBcnJheS5mcm9tKHJlbW92ZWQua2V5cygpKTtcclxuICAgICAgICAgICAgZGlmZi5tb3ZlZCA9IEFycmF5LmZyb20obW92ZWQua2V5cygpKTtcclxuICAgICAgICAgICAgZGlmZi5hZGRlZEluZGljZXMgPSBBcnJheS5mcm9tKGFkZGVkSW5kaWNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgIGRpZmYudXBkYXRlZEluZGljZXMgPSBBcnJheS5mcm9tKHVwZGF0ZWRJbmRpY2VzLnZhbHVlcygpKTtcclxuICAgICAgICAgICAgZGlmZi5yZW1vdmVkSW5kaWNlcyA9IEFycmF5LmZyb20ocmVtb3ZlZEluZGljZXMudmFsdWVzKCkpO1xyXG4gICAgICAgICAgICBkaWZmLmNoYW5nZWQgPSBkaWZmLmFkZGVkLmxlbmd0aCA+IDAgfHwgZGlmZi51cGRhdGVkLmxlbmd0aCA+IDAgfHwgZGlmZi5yZW1vdmVkLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURhdHVtSWQoa2V5cykge1xyXG4gICAgcmV0dXJuIGtleXMuam9pbignX19fJyk7XHJcbn1cblxuY2xhc3MgTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gJyM0NjQ2NDYnO1xyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSAxMjtcclxuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSAnVmVyZGFuYSwgc2Fucy1zZXJpZic7XHJcbiAgICB9XHJcbiAgICBnZXRGb250KCkge1xyXG4gICAgICAgIHJldHVybiBnZXRGb250KHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQk9PTEVBTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKENPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRk9OVF9TVFlMRSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZPTlRfV0VJR0hUKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZVTkNUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCB2b2lkIDApO1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKG9wdHMpIHtcclxuICAgIGNvbnN0IHsgcGFyYWxsZWxGbGlwUm90YXRpb24gPSAwLCByZWd1bGFyRmxpcFJvdGF0aW9uID0gMCB9ID0gb3B0cztcclxuICAgIGNvbnN0IGNvbmZpZ3VyZWRSb3RhdGlvbiA9IG9wdHMucm90YXRpb24gPyBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnMob3B0cy5yb3RhdGlvbikpIDogMDtcclxuICAgIGNvbnN0IHBhcmFsbGVsRmxpcEZsYWcgPSAhY29uZmlndXJlZFJvdGF0aW9uICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID49IDAgJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPD0gTWF0aC5QSSA/IC0xIDogMTtcclxuICAgIC8vIEZsaXAgaWYgdGhlIGF4aXMgcm90YXRpb24gYW5nbGUgaXMgaW4gdGhlIHRvcCBoZW1pc3BoZXJlLlxyXG4gICAgY29uc3QgcmVndWxhckZsaXBGbGFnID0gIWNvbmZpZ3VyZWRSb3RhdGlvbiAmJiByZWd1bGFyRmxpcFJvdGF0aW9uID49IDAgJiYgcmVndWxhckZsaXBSb3RhdGlvbiA8PSBNYXRoLlBJID8gLTEgOiAxO1xyXG4gICAgbGV0IGRlZmF1bHRSb3RhdGlvbiA9IDA7XHJcbiAgICBpZiAob3B0cy5wYXJhbGxlbCkge1xyXG4gICAgICAgIGRlZmF1bHRSb3RhdGlvbiA9IChwYXJhbGxlbEZsaXBGbGFnICogTWF0aC5QSSkgLyAyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVndWxhckZsaXBGbGFnID09PSAtMSkge1xyXG4gICAgICAgIGRlZmF1bHRSb3RhdGlvbiA9IE1hdGguUEk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb25maWd1cmVkUm90YXRpb24sIGRlZmF1bHRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZywgcmVndWxhckZsaXBGbGFnIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0TGFiZWxTcGFjaW5nKG1pblNwYWNpbmcsIHJvdGF0ZWQpIHtcclxuICAgIGlmICghaXNOYU4obWluU3BhY2luZykpIHtcclxuICAgICAgICByZXR1cm4gbWluU3BhY2luZztcclxuICAgIH1cclxuICAgIHJldHVybiByb3RhdGVkID8gMCA6IDEwO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRleHRCYXNlbGluZShwYXJhbGxlbCwgbGFiZWxSb3RhdGlvbiwgc2lkZUZsYWcsIHBhcmFsbGVsRmxpcEZsYWcpIHtcclxuICAgIGlmIChwYXJhbGxlbCAmJiAhbGFiZWxSb3RhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBzaWRlRmxhZyAqIHBhcmFsbGVsRmxpcEZsYWcgPT09IC0xID8gJ2hhbmdpbmcnIDogJ2JvdHRvbSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ21pZGRsZSc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBsYWJlbFJvdGF0aW9uLCBsYWJlbEF1dG9Sb3RhdGlvbiwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZykge1xyXG4gICAgY29uc3QgbGFiZWxSb3RhdGVkID0gbGFiZWxSb3RhdGlvbiA+IDAgJiYgbGFiZWxSb3RhdGlvbiA8PSBNYXRoLlBJO1xyXG4gICAgY29uc3QgbGFiZWxBdXRvUm90YXRlZCA9IGxhYmVsQXV0b1JvdGF0aW9uID4gMCAmJiBsYWJlbEF1dG9Sb3RhdGlvbiA8PSBNYXRoLlBJO1xyXG4gICAgY29uc3QgYWxpZ25GbGFnID0gbGFiZWxSb3RhdGVkIHx8IGxhYmVsQXV0b1JvdGF0ZWQgPyAtMSA6IDE7XHJcbiAgICBpZiAocGFyYWxsZWwpIHtcclxuICAgICAgICBpZiAobGFiZWxSb3RhdGlvbiB8fCBsYWJlbEF1dG9Sb3RhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoc2lkZUZsYWcgKiBhbGlnbkZsYWcgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2VuZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnY2VudGVyJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzaWRlRmxhZyAqIHJlZ3VsYXJGbGlwRmxhZyA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gJ2VuZCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3N0YXJ0JztcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbEJCb3godGV4dCwgYmJveCwgbGFiZWxYLCBsYWJlbFksIGxhYmVsTWF0cml4KSB7XHJcbiAgICAvLyBUZXh0LmNvbXB1dGVCQm94KCkgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgYW55IG9mIHRoZSB0cmFuc2Zvcm1hdGlvbnMgdGhhdCBoYXZlIGJlZW4gYXBwbGllZCB0byB0aGUgbGFiZWwgbm9kZXMsIG9ubHkgdGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHVzZWZ1bC5cclxuICAgIC8vIFJhdGhlciB0aGFuIHRha2luZyBpbnRvIGFjY291bnQgYWxsIHRyYW5zZm9ybWF0aW9ucyBpbmNsdWRpbmcgdGhvc2Ugb2YgcGFyZW50IG5vZGVzIHdoaWNoIHdvdWxkIGJlIHRoZSByZXN1bHQgb2YgYGNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKWAsIGdpdmluZyB0aGUgeCBhbmQgeSBpbiB0aGUgZW50aXJlIGF4aXMgY29vcmRpbmF0ZSBzcGFjZSxcclxuICAgIC8vIHRha2UgaW50byBhY2NvdW50IG9ubHkgdGhlIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGlvbiBhcHBsaWVkIHRvIGluZGl2aWR1YWwgbGFiZWwgbm9kZXMgdG8gZ2V0IHRoZSB4IHkgY29vcmRpbmF0ZXMgb2YgdGhlIGxhYmVscyByZWxhdGl2ZSB0byBlYWNoIG90aGVyXHJcbiAgICAvLyB0aGlzIG1ha2VzIGxhYmVsIGNvbGxpc2lvbiBkZXRlY3Rpb24gYSBsb3Qgc2ltcGxlclxyXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBiYm94O1xyXG4gICAgY29uc3QgdHJhbnNsYXRlZEJCb3ggPSBuZXcgQkJveChsYWJlbFgsIGxhYmVsWSwgMCwgMCk7XHJcbiAgICBsYWJlbE1hdHJpeC50cmFuc2Zvcm1CQm94KHRyYW5zbGF0ZWRCQm94LCBiYm94KTtcclxuICAgIGNvbnN0IHsgeCA9IDAsIHkgPSAwIH0gPSBiYm94O1xyXG4gICAgYmJveC53aWR0aCA9IHdpZHRoO1xyXG4gICAgYmJveC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBvaW50OiB7IHgsIHksIHNpemU6IDAgfSxcclxuICAgICAgICBsYWJlbDogeyB3aWR0aCwgaGVpZ2h0LCB0ZXh0IH0sXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBDb25zdGFudHMgdG8gZGVjbGFyZSB0aGUgZXhwZWN0ZWQgbm9taW5hbCB6SW5kZXggZm9yIGFsbCB0eXBlcyBvZiBsYXllciBpbiBjaGFydCByZW5kZXJpbmcuXHJcbiAqL1xyXG52YXIgTGF5ZXJzO1xyXG4oZnVuY3Rpb24gKExheWVycykge1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIlNFUklFU19CQUNLR1JPVU5EX1pJTkRFWFwiXSA9IC0xMF0gPSBcIlNFUklFU19CQUNLR1JPVU5EX1pJTkRFWFwiO1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIkFYSVNfR1JJRF9aSU5ERVhcIl0gPSAwXSA9IFwiQVhJU19HUklEX1pJTkRFWFwiO1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIkFYSVNfWklOREVYXCJdID0gMjBdID0gXCJBWElTX1pJTkRFWFwiO1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIlNFUklFU19DUk9TU0xJTkVfUkFOR0VfWklOREVYXCJdID0gMzBdID0gXCJTRVJJRVNfQ1JPU1NMSU5FX1JBTkdFX1pJTkRFWFwiO1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIlNFUklFU19MQVlFUl9aSU5ERVhcIl0gPSA1MDBdID0gXCJTRVJJRVNfTEFZRVJfWklOREVYXCI7XHJcbiAgICBMYXllcnNbTGF5ZXJzW1wiQVhJU19GT1JFR1JPVU5EX1pJTkRFWFwiXSA9IDc1MF0gPSBcIkFYSVNfRk9SRUdST1VORF9aSU5ERVhcIjtcclxuICAgIExheWVyc1tMYXllcnNbXCJTRVJJRVNfQ1JPU1NIQUlSX1pJTkRFWFwiXSA9IDEwMDBdID0gXCJTRVJJRVNfQ1JPU1NIQUlSX1pJTkRFWFwiO1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIlNFUklFU19MQUJFTF9aSU5ERVhcIl0gPSAxNTAwXSA9IFwiU0VSSUVTX0xBQkVMX1pJTkRFWFwiO1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIlNFUklFU19DUk9TU0xJTkVfTElORV9aSU5ERVhcIl0gPSAyNTAwXSA9IFwiU0VSSUVTX0NST1NTTElORV9MSU5FX1pJTkRFWFwiO1xyXG4gICAgTGF5ZXJzW0xheWVyc1tcIkxFR0VORF9aSU5ERVhcIl0gPSAzMDAwXSA9IFwiTEVHRU5EX1pJTkRFWFwiO1xyXG59KShMYXllcnMgfHwgKExheWVycyA9IHt9KSk7XG5cbmNsYXNzIE1hcmtlciBleHRlbmRzIFBhdGgge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMTI7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICBjb25zdCB7IHgsIHksIHNpemUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgaGFsZiA9IHNpemUgLyAyO1xyXG4gICAgICAgIHJldHVybiBuZXcgQkJveCh4IC0gaGFsZiwgeSAtIGhhbGYsIHNpemUsIHNpemUpO1xyXG4gICAgfVxyXG4gICAgYXBwbHlQYXRoKHMsIG1vdmVzKSB7XHJcbiAgICAgICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCB7IHgsIHkgfSA9IHRoaXM7XHJcbiAgICAgICAgcGF0aC5jbGVhcigpO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyB4OiBteCwgeTogbXksIHQgfSBvZiBtb3Zlcykge1xyXG4gICAgICAgICAgICB4ICs9IG14ICogcztcclxuICAgICAgICAgICAgeSArPSBteSAqIHM7XHJcbiAgICAgICAgICAgIGlmICh0ID09PSAnbW92ZScpIHtcclxuICAgICAgICAgICAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGF0aC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTWFya2VyLnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBNYXJrZXIucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oeyBjb252ZXJ0b3I6IE1hdGguYWJzIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5cbmNsYXNzIENpcmNsZSBleHRlbmRzIE1hcmtlciB7XHJcbiAgICB1cGRhdGVQYXRoKCkge1xyXG4gICAgICAgIGNvbnN0IHsgeCwgeSwgcGF0aCwgc2l6ZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCByID0gc2l6ZSAvIDI7XHJcbiAgICAgICAgcGF0aC5jbGVhcigpO1xyXG4gICAgICAgIHBhdGguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG59XHJcbkNpcmNsZS5jbGFzc05hbWUgPSAnQ2lyY2xlJztcblxuY29uc3QgREVGQVVMVF9GSUxMUyA9IHtcclxuICAgIEJMVUU6ICcjNTA5MGRjJyxcclxuICAgIE9SQU5HRTogJyNmZmEwM2EnLFxyXG4gICAgR1JFRU46ICcjNDU5ZDU1JyxcclxuICAgIENZQU46ICcjMzRiZmUxJyxcclxuICAgIFlFTExPVzogJyNlMWNjMDAnLFxyXG4gICAgVklPTEVUOiAnIzk2NjljYicsXHJcbiAgICBHUkFZOiAnI2I1YjViNScsXHJcbiAgICBNQUdFTlRBOiAnI2JkNWFhNycsXHJcbiAgICBCUk9XTjogJyM4YTYyMjQnLFxyXG4gICAgUkVEOiAnI2VmNTQ1MicsXHJcbn07XHJcbmNvbnN0IERFRkFVTFRfU1RST0tFUyA9IHtcclxuICAgIEJMVUU6ICcjMmI1Yzk1JyxcclxuICAgIE9SQU5HRTogJyNjYzZmMTAnLFxyXG4gICAgR1JFRU46ICcjMWU2NTJlJyxcclxuICAgIENZQU46ICcjMTg4NTllJyxcclxuICAgIFlFTExPVzogJyNhNjk0MDAnLFxyXG4gICAgVklPTEVUOiAnIzYwM2M4OCcsXHJcbiAgICBHUkFZOiAnIzU3NTc1NycsXHJcbiAgICBNQUdFTlRBOiAnIzdkMmY2ZCcsXHJcbiAgICBCUk9XTjogJyM0ZjM1MDgnLFxyXG4gICAgUkVEOiAnI2E4MjUyOScsXHJcbn07XG5cbmNsYXNzIE1vZHVsZU1hcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLm1vZHVsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBtb2R1bGVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubW9kdWxlcykpIHtcclxuICAgICAgICAgICAgbW9kdWxlLmluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubW9kdWxlc1trZXldO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnRba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRNb2R1bGUobW9kdWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlc1ttb2R1bGUub3B0aW9uc0tleV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIG1vZHVsZSBhbHJlYWR5IGluaXRpYWxpc2VkOiAnICsgbW9kdWxlLm9wdGlvbnNLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9kdWxlLm9wdGlvbnNLZXkgaW4gdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBjbGFzcyBhbHJlYWR5IGhhcyBvcHRpb24ga2V5ICcke21vZHVsZS5vcHRpb25zS2V5fSdgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlQ29udGV4dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kdWxlQ29udGV4dCA9IHRoaXMucGFyZW50LmNyZWF0ZU1vZHVsZUNvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kdWxlSW5zdGFuY2UgPSBuZXcgbW9kdWxlLmluc3RhbmNlQ29uc3RydWN0b3IoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5tb2R1bGVDb250ZXh0KSk7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVzW21vZHVsZS5vcHRpb25zS2V5XSA9IHsgaW5zdGFuY2U6IG1vZHVsZUluc3RhbmNlIH07XHJcbiAgICAgICAgdGhpcy5wYXJlbnRbbW9kdWxlLm9wdGlvbnNLZXldID0gbW9kdWxlSW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNb2R1bGUobW9kdWxlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLm1vZHVsZXNbbW9kdWxlLm9wdGlvbnNLZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5zdGFuY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXN0cm95KCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubW9kdWxlc1ttb2R1bGUub3B0aW9uc0tleV07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50W21vZHVsZS5vcHRpb25zS2V5XTtcclxuICAgIH1cclxuICAgIGlzTW9kdWxlRW5hYmxlZChtb2R1bGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVzW21vZHVsZS5vcHRpb25zS2V5XSAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBpbnN0YW5jZSB9IG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2R1bGVzKSkge1xyXG4gICAgICAgICAgICB5aWVsZCBpbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgTGlzdGVuZXJzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGFkZExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgbWV0YSkge1xyXG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHsgc3ltYm9sOiBTeW1ib2woZXZlbnRUeXBlKSwgaGFuZGxlciwgbWV0YSB9O1xyXG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMuaGFzKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmdldChldmVudFR5cGUpLnB1c2gocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5zZXQoZXZlbnRUeXBlLCBbcmVjb3JkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUxpc3RlbmVyKHJlY29yZC5zeW1ib2wpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnRTeW1ib2wpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IFt0eXBlLCBsaXN0ZW5lcnNdIG9mIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGxpc3RlbmVyKSA9PiBsaXN0ZW5lci5zeW1ib2wgPT09IGV2ZW50U3ltYm9sKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShtYXRjaEluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmRlbGV0ZSh0eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcGF0Y2goZXZlbnRUeXBlLCAuLi5wYXJhbXMpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgdXRpbGl0eSBjbGFzcyB0byBzdG9yZSBhbGwgdGhlIHJlc3VsdHMgb2YgTGlzdGVuZXJzIChvciBkbyBub3RoaW5nXHJcbiAgICAgICAgLy8gaWYgUiA9IHZvaWQpLlxyXG4gICAgICAgIGNsYXNzIFJlc3VsdEFycmF5IHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHVzaChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlc3VsdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLnJlc3VsdHMgPSBbXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgUmVzdWx0QXJyYXkoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuZ2V0TGlzdGVuZXJzQnlUeXBlKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChsaXN0ZW5lci5oYW5kbGVyKC4uLnBhcmFtcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuZXJyb3JPbmNlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzLnJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaFdyYXBIYW5kbGVycyhldmVudFR5cGUsIHdyYXBGbiwgLi4ucGFyYW1zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB3cmFwRm4obGlzdGVuZXIuaGFuZGxlciwgbGlzdGVuZXIubWV0YSwgLi4ucGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmVycm9yT25jZShlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgT2JzZXJ2YWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIGxpc3RlbmVyIG11c3QgYmUgYSBGdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudFR5cGVMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudFR5cGUpO1xyXG4gICAgICAgIGlmIChldmVudFR5cGVMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgZXZlbnRUeXBlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldChldmVudFR5cGUsIG5ldyBTZXQoW2xpc3RlbmVyXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQodHlwZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWxldGUobGlzdGVuZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUodHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzKHR5cGUpO1xyXG4gICAgfVxyXG4gICAgY2xlYXJFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBmaXJlRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnQudHlwZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXZlbnQpKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBleHRlbmREb21haW4odmFsdWVzLCBkb21haW4gPSBbSW5maW5pdHksIC1JbmZpbml0eV0pIHtcclxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA8IGRvbWFpblswXSkge1xyXG4gICAgICAgICAgICBkb21haW5bMF0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID4gZG9tYWluWzFdKSB7XHJcbiAgICAgICAgICAgIGRvbWFpblsxXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkb21haW47XHJcbn1cblxuZnVuY3Rpb24gc3VtVmFsdWVzKHZhbHVlcywgYWNjdW11bGF0b3IgPSBbMCwgMF0pIHtcclxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgYWNjdW11bGF0b3JbMF0gKz0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgYWNjdW11bGF0b3JbMV0gKz0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG59XHJcbmZ1bmN0aW9uIHN1bShzY29wZSwgaWQsIG1hdGNoR3JvdXBJZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHNjb3BlczogW3Njb3BlLmlkXSxcclxuICAgICAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcclxuICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcclxuICAgICAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcyksXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBncm91cFN1bShzY29wZSwgaWQsIG1hdGNoR3JvdXBJZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZCxcclxuICAgICAgICBzY29wZXM6IFtzY29wZS5pZF0sXHJcbiAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXHJcbiAgICAgICAgbWF0Y2hHcm91cElkczogbWF0Y2hHcm91cElkID8gW21hdGNoR3JvdXBJZF0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IHN1bVZhbHVlcyh2YWx1ZXMpLFxyXG4gICAgICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMF0pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgYWNjWzBdICs9IChfYSA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICAgICAgYWNjWzFdICs9IChfYiA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFsxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByYW5nZShzY29wZSwgaWQsIG1hdGNoR3JvdXBJZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHNjb3BlczogW3Njb3BlLmlkXSxcclxuICAgICAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcclxuICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcclxuICAgICAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gZXh0ZW5kRG9tYWluKHZhbHVlcyksXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjb3VudChzY29wZSwgaWQpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBpZCxcclxuICAgICAgICBzY29wZXM6IFtzY29wZS5pZF0sXHJcbiAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXHJcbiAgICAgICAgYWdncmVnYXRlRnVuY3Rpb246ICgpID0+IFswLCAxXSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdyb3VwQ291bnQoc2NvcGUsIGlkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHNjb3BlczogW3Njb3BlLmlkXSxcclxuICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcclxuICAgICAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKCkgPT4gWzAsIDFdLFxyXG4gICAgICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMF0pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgYWNjWzBdICs9IChfYSA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICAgICAgYWNjWzFdICs9IChfYiA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFsxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBhdmVyYWdlKHNjb3BlLCBpZCwgbWF0Y2hHcm91cElkKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgc2NvcGVzOiBbc2NvcGUuaWRdLFxyXG4gICAgICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxyXG4gICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxyXG4gICAgICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBzdW1WYWx1ZXModmFsdWVzKS5tYXAoKHYpID0+IHYgLyB2YWx1ZXMubGVuZ3RoKSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdyb3VwQXZlcmFnZShzY29wZSwgaWQsIG1hdGNoR3JvdXBJZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHNjb3BlczogW3Njb3BlLmlkXSxcclxuICAgICAgICBtYXRjaEdyb3VwSWRzOiBtYXRjaEdyb3VwSWQgPyBbbWF0Y2hHcm91cElkXSA6IHVuZGVmaW5lZCxcclxuICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcclxuICAgICAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcyksXHJcbiAgICAgICAgZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbjogKG5leHQsIGFjYyA9IFswLCAwLCAtMV0pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgYWNjWzBdICs9IChfYSA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICAgICAgYWNjWzFdICs9IChfYiA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFsxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICAgICAgYWNjWzJdKys7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaW5hbEZ1bmN0aW9uOiAoYWNjID0gWzAsIDAsIDBdKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFjY1swXSArIGFjY1sxXTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIHJlc3VsdCAvIGFjY1syXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQgLyBhY2NbMl0sIDBdO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBhcmVhKHNjb3BlLCBpZCwgYWdnRm4sIG1hdGNoR3JvdXBJZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHNjb3BlczogW3Njb3BlLmlkXSxcclxuICAgICAgICBtYXRjaEdyb3VwSWRzOiBtYXRjaEdyb3VwSWQgPyBbbWF0Y2hHcm91cElkXSA6IHVuZGVmaW5lZCxcclxuICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcclxuICAgICAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcywga2V5UmFuZ2UgPSBbXSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlXaWR0aCA9IGtleVJhbmdlWzFdIC0ga2V5UmFuZ2VbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBhZ2dGbi5hZ2dyZWdhdGVGdW5jdGlvbih2YWx1ZXMpLm1hcCgodikgPT4gdiAvIGtleVdpZHRoKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIGlmIChhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0Lmdyb3VwQWdncmVnYXRlRnVuY3Rpb24gPSBhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBhY2N1bXVsYXRlZFZhbHVlKG9ubHlQb3NpdGl2ZSkge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBsZXQgdmFsdWUgPSAwO1xyXG4gICAgICAgIHJldHVybiAoZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXR1bSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW07XHJcbiAgICAgICAgICAgIGlmIChpc05hTihkYXR1bSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW07XHJcbiAgICAgICAgICAgIHZhbHVlICs9IG9ubHlQb3NpdGl2ZSA/IE1hdGgubWF4KDAsIGRhdHVtKSA6IGRhdHVtO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlKCkge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBsZXQgdmFsdWUgPSAwO1xyXG4gICAgICAgIHJldHVybiAoZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXR1bSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW07XHJcbiAgICAgICAgICAgIGlmIChpc05hTihkYXR1bSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW07XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsaW5nVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdmFsdWUgKz0gZGF0dW07XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFpbGluZ1ZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XG5cbi8qKiBNb2RlcyBvZiBtYXRjaGluZyB1c2VyIGludGVyYWN0aW9ucyB0byByZW5kZXJlZCBub2RlcyAoZS5nLiBob3ZlciBvciBjbGljaykgKi9cclxudmFyIFNlcmllc05vZGVQaWNrTW9kZTtcclxuKGZ1bmN0aW9uIChTZXJpZXNOb2RlUGlja01vZGUpIHtcclxuICAgIC8qKiBQaWNrIG1hdGNoZXMgYmFzZWQgdXBvbiBwaWNrIGNvb3JkaW5hdGVzIGJlaW5nIGluc2lkZSBhIG1hdGNoaW5nIHNoYXBlL21hcmtlci4gKi9cclxuICAgIFNlcmllc05vZGVQaWNrTW9kZVtTZXJpZXNOb2RlUGlja01vZGVbXCJFWEFDVF9TSEFQRV9NQVRDSFwiXSA9IDBdID0gXCJFWEFDVF9TSEFQRV9NQVRDSFwiO1xyXG4gICAgLyoqIFBpY2sgbWF0Y2hlcyBieSBuZWFyZXN0IGNhdGVnb3J5L1gtYXhpcyB2YWx1ZSwgdGhlbiBkaXN0YW5jZSB3aXRoaW4gdGhhdCBjYXRlZ29yeS9YLXZhbHVlLiAqL1xyXG4gICAgU2VyaWVzTm9kZVBpY2tNb2RlW1Nlcmllc05vZGVQaWNrTW9kZVtcIk5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUXCJdID0gMV0gPSBcIk5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUXCI7XHJcbiAgICAvKiogUGljayBtYXRjaGVzIGJ5IG5lYXJlc3QgY2F0ZWdvcnkgdmFsdWUsIHRoZW4gZGlzdGFuY2Ugd2l0aGluIHRoYXQgY2F0ZWdvcnkuICovXHJcbiAgICBTZXJpZXNOb2RlUGlja01vZGVbU2VyaWVzTm9kZVBpY2tNb2RlW1wiTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1RcIl0gPSAyXSA9IFwiTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1RcIjtcclxuICAgIC8qKiBQaWNrIG1hdGNoZXMgYmFzZWQgdXBvbiBkaXN0YW5jZSB0byBpZGVhbCBwb3NpdGlvbiAqL1xyXG4gICAgU2VyaWVzTm9kZVBpY2tNb2RlW1Nlcmllc05vZGVQaWNrTW9kZVtcIk5FQVJFU1RfTk9ERVwiXSA9IDNdID0gXCJORUFSRVNUX05PREVcIjtcclxufSkoU2VyaWVzTm9kZVBpY2tNb2RlIHx8IChTZXJpZXNOb2RlUGlja01vZGUgPSB7fSkpO1xyXG5mdW5jdGlvbiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbih2KSB7XHJcbiAgICByZXR1cm4gY2hlY2tEYXR1bSh2LCB0cnVlKSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGJhc2ljRGlzY3JldGVDaGVja0RhdHVtVmFsaWRhdGlvbih2KSB7XHJcbiAgICByZXR1cm4gY2hlY2tEYXR1bSh2LCBmYWxzZSkgIT0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBrZXlQcm9wZXJ0eShzY29wZSwgcHJvcE5hbWUsIGNvbnRpbnVvdXMsIG9wdHMgPSB7fSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7IHNjb3BlczogW3Njb3BlLmlkXSwgcHJvcGVydHk6IHByb3BOYW1lLCB0eXBlOiAna2V5JywgdmFsdWVUeXBlOiBjb250aW51b3VzID8gJ3JhbmdlJyA6ICdjYXRlZ29yeScsIHZhbGlkYXRpb246IGNvbnRpbnVvdXMgPyBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbiA6IGJhc2ljRGlzY3JldGVDaGVja0RhdHVtVmFsaWRhdGlvbiB9LCBvcHRzKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdmFsdWVQcm9wZXJ0eShzY29wZSwgcHJvcE5hbWUsIGNvbnRpbnVvdXMsIG9wdHMgPSB7fSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7IHNjb3BlczogW3Njb3BlLmlkXSwgcHJvcGVydHk6IHByb3BOYW1lLCB0eXBlOiAndmFsdWUnLCB2YWx1ZVR5cGU6IGNvbnRpbnVvdXMgPyAncmFuZ2UnIDogJ2NhdGVnb3J5JywgdmFsaWRhdGlvbjogY29udGludW91cyA/IGJhc2ljQ29udGludW91c0NoZWNrRGF0dW1WYWxpZGF0aW9uIDogYmFzaWNEaXNjcmV0ZUNoZWNrRGF0dW1WYWxpZGF0aW9uIH0sIG9wdHMpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiByYW5nZWRWYWx1ZVByb3BlcnR5KHNjb3BlLCBwcm9wTmFtZSwgb3B0cyA9IHt9KSB7XHJcbiAgICBjb25zdCB7IG1pbiA9IC1JbmZpbml0eSwgbWF4ID0gSW5maW5pdHkgfSA9IG9wdHMsIGRlZk9wdHMgPSBfX3Jlc3Qob3B0cywgW1wibWluXCIsIFwibWF4XCJdKTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgc2NvcGVzOiBbc2NvcGUuaWRdLCB0eXBlOiAndmFsdWUnLCBwcm9wZXJ0eTogcHJvcE5hbWUsIHZhbHVlVHlwZTogJ3JhbmdlJywgdmFsaWRhdGlvbjogYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb24sIHByb2Nlc3NvcjogKCkgPT4gKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0dW0gIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4oZGF0dW0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZGF0dW0sIG1pbiksIG1heCk7XHJcbiAgICAgICAgfSB9LCBkZWZPcHRzKTtcclxufVxyXG5mdW5jdGlvbiB0cmFpbGluZ1ZhbHVlUHJvcGVydHkoc2NvcGUsIHByb3BOYW1lLCBjb250aW51b3VzLCBvcHRzID0ge30pIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVQcm9wZXJ0eShzY29wZSwgcHJvcE5hbWUsIGNvbnRpbnVvdXMsIG9wdHMpKSwgeyBwcm9jZXNzb3I6IHRyYWlsaW5nVmFsdWUoKSB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdHJhaWxpbmdWYWx1ZSgpIHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gMDtcclxuICAgICAgICByZXR1cm4gKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsaW5nVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdmFsdWUgPSBkYXR1bTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nVmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShzY29wZSwgcHJvcE5hbWUsIGNvbnRpbnVvdXMsIG9wdHMgPSB7fSkge1xyXG4gICAgY29uc3QgeyBvbmx5UG9zaXRpdmUgfSA9IG9wdHMsIGRlZk9wdHMgPSBfX3Jlc3Qob3B0cywgW1wib25seVBvc2l0aXZlXCJdKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVQcm9wZXJ0eShzY29wZSwgcHJvcE5hbWUsIGNvbnRpbnVvdXMsIGRlZk9wdHMpKSwgeyBwcm9jZXNzb3I6IGFjY3VtdWxhdGVkVmFsdWUob25seVBvc2l0aXZlKSB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHkoc2NvcGUsIHByb3BOYW1lLCBjb250aW51b3VzLCBvcHRzID0ge30pIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVQcm9wZXJ0eShzY29wZSwgcHJvcE5hbWUsIGNvbnRpbnVvdXMsIG9wdHMpKSwgeyBwcm9jZXNzb3I6IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSgpIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoc2NvcGUsIHByb3BOYW1lLCBjb250aW51b3VzLCBtb2RlLCBzdW0gPSAnY3VycmVudCcsIG9wdHMpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShzY29wZSwgcHJvcE5hbWUsIGNvbnRpbnVvdXMsIG9wdHMpLFxyXG4gICAgICAgIGFjY3VtdWxhdGVHcm91cChzY29wZSwgb3B0cy5ncm91cElkLCBtb2RlLCBzdW0sIG9wdHMuc2VwYXJhdGVOZWdhdGl2ZSksXHJcbiAgICBdO1xyXG59XHJcbmNsYXNzIFNlcmllc05vZGVDbGlja0V2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGV2ZW50LCB7IGRhdHVtIH0sIHNlcmllcykge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgIHRoaXMuZGF0dW0gPSBkYXR1bTtcclxuICAgICAgICB0aGlzLnNlcmllc0lkID0gc2VyaWVzLmlkO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmZpbGwgPSAneWVsbG93JztcclxuICAgICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubGluZURhc2ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0NPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCwgMSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0xJTkVfREFTSCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgdm9pZCAwKTtcclxuY2xhc3MgU2VyaWVzSGlnaGxpZ2h0U3R5bGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRpbU9wYWNpdHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZXJpZXNIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDAsIDEpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJkaW1PcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0JPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHZvaWQgMCk7XHJcbmNsYXNzIFRleHRIaWdobGlnaHRTdHlsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvbG9yID0gJ2JsYWNrJztcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgVGV4dEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG5jbGFzcyBIaWdobGlnaHRTdHlsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLml0ZW0gPSBuZXcgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBuZXcgU2VyaWVzSGlnaGxpZ2h0U3R5bGUoKTtcclxuICAgICAgICB0aGlzLnRleHQgPSBuZXcgVGV4dEhpZ2hsaWdodFN0eWxlKCk7XHJcbiAgICB9XHJcbn1cclxudmFyIFNlcmllc0hpZ2hsaWdodDtcclxuKGZ1bmN0aW9uIChTZXJpZXNIaWdobGlnaHQpIHtcclxuICAgIFNlcmllc0hpZ2hsaWdodFtTZXJpZXNIaWdobGlnaHRbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIFNlcmllc0hpZ2hsaWdodFtTZXJpZXNIaWdobGlnaHRbXCJUaGlzXCJdID0gMV0gPSBcIlRoaXNcIjtcclxuICAgIFNlcmllc0hpZ2hsaWdodFtTZXJpZXNIaWdobGlnaHRbXCJPdGhlclwiXSA9IDJdID0gXCJPdGhlclwiO1xyXG59KShTZXJpZXNIaWdobGlnaHQgfHwgKFNlcmllc0hpZ2hsaWdodCA9IHt9KSk7XHJcbmNsYXNzIFNlcmllcyBleHRlbmRzIE9ic2VydmFibGUge1xyXG4gICAgZ2V0IHR5cGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNvbnN0cnVjdG9yLnR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xyXG4gICAgfVxyXG4gICAgc2V0IGRhdGEoaW5wdXQpIHtcclxuICAgICAgICB0aGlzLl9kYXRhID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5vbkRhdGFDaGFuZ2UoKTtcclxuICAgIH1cclxuICAgIGdldCBkYXRhKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fY2hhcnREYXRhO1xyXG4gICAgfVxyXG4gICAgb25EYXRhQ2hhbmdlKCkge1xyXG4gICAgICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldENoYXJ0RGF0YShpbnB1dCkge1xyXG4gICAgICAgIHRoaXMuX2NoYXJ0RGF0YSA9IGlucHV0O1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGlucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzRGF0YSgpIHtcclxuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IGRhdGEubGVuZ3RoID4gMCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2VkKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmlzaWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcclxuICAgIH1cclxuICAgIG9uU2VyaWVzR3JvdXBpbmdDaGFuZ2UocHJldiwgbmV4dCkge1xyXG4gICAgICAgIGNvbnN0IHsgaWQsIHR5cGUsIHZpc2libGUsIHJvb3RHcm91cCwgaGlnaGxpZ2h0R3JvdXAsIGFubm90YXRpb25Hcm91cCB9ID0gdGhpcztcclxuICAgICAgICBpZiAocHJldikge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIuZGVyZWdpc3RlclNlcmllcyh7IGlkLCB0eXBlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIucmVnaXN0ZXJTZXJpZXMoeyBpZCwgdHlwZSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IG5leHQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgc2VyaWVzIGlzbid0IGFscmVhZHkgYXR0YWNoZWQgdG8gdGhlIHNjZW5lLWdyYXBoIHlldC5cclxuICAgICAgICBpZiAodGhpcy5yb290R3JvdXAucGFyZW50ID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLmN0eC5zZXJpZXNMYXllck1hbmFnZXIuY2hhbmdlR3JvdXAoe1xyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgcm9vdEdyb3VwLFxyXG4gICAgICAgICAgICBoaWdobGlnaHRHcm91cCxcclxuICAgICAgICAgICAgYW5ub3RhdGlvbkdyb3VwLFxyXG4gICAgICAgICAgICBnZXRHcm91cFpJbmRleFN1Yk9yZGVyOiAodHlwZSkgPT4gdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUpLFxyXG4gICAgICAgICAgICBzZXJpZXNHcm91cGluZzogbmV4dCxcclxuICAgICAgICAgICAgb2xkR3JvdXBpbmc6IHByZXYsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB7IGlubmVyOiAxLCBvdXRlcjogMCB9O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Ioc2VyaWVzT3B0cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5Ob2RlQ2xpY2tFdmVudCA9IFNlcmllc05vZGVDbGlja0V2ZW50O1xyXG4gICAgICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcclxuICAgICAgICAvLyBUaGUgZ3JvdXAgbm9kZSB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgbm9kZXMgdXNlZCB0byByZW5kZXIgdGhpcyBzZXJpZXMuXHJcbiAgICAgICAgdGhpcy5yb290R3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiAnc2VyaWVzUm9vdCcsIGlzVmlydHVhbDogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLmF4ZXMgPSB7XHJcbiAgICAgICAgICAgIFtDaGFydEF4aXNEaXJlY3Rpb24uWF06IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgW0NoYXJ0QXhpc0RpcmVjdGlvbi5ZXTogdW5kZWZpbmVkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25zID0gW0NoYXJ0QXhpc0RpcmVjdGlvbi5YLCBDaGFydEF4aXNEaXJlY3Rpb24uWV07XHJcbiAgICAgICAgLy8gRmxhZyB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHJlY2FsY3VsYXRlIG5vZGUgZGF0YS5cclxuICAgICAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaG93SW5MZWdlbmQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY3Vyc29yID0gJ2RlZmF1bHQnO1xyXG4gICAgICAgIHRoaXMubm9kZUNsaWNrUmFuZ2UgPSAnZXhhY3QnO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzR3JvdXBpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGVjbGFyYXRpb25PcmRlciA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzTGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U3R5bGUgPSBuZXcgSGlnaGxpZ2h0U3R5bGUoKTtcclxuICAgICAgICB0aGlzLm1vZHVsZU1hcCA9IG5ldyBNb2R1bGVNYXAodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY3R4ID0gc2VyaWVzT3B0cy5tb2R1bGVDdHg7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbExheWVyID0gZmFsc2UsIHBpY2tNb2RlcyA9IFtTZXJpZXNOb2RlUGlja01vZGUuTkVBUkVTVF9CWV9NQUlOX0FYSVNfRklSU1RdLCBkaXJlY3Rpb25LZXlzID0ge30sIGRpcmVjdGlvbk5hbWVzID0ge30sIGNvbnRlbnRHcm91cFZpcnR1YWwgPSB0cnVlLCBjYW5IYXZlQXhlcyA9IGZhbHNlLCB9ID0gc2VyaWVzT3B0cztcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbktleXMgPSBkaXJlY3Rpb25LZXlzO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uTmFtZXMgPSBkaXJlY3Rpb25OYW1lcztcclxuICAgICAgICB0aGlzLmNhbkhhdmVBeGVzID0gY2FuSGF2ZUF4ZXM7XHJcbiAgICAgICAgdGhpcy5jb250ZW50R3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoe1xyXG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1jb250ZW50YCxcclxuICAgICAgICAgICAgbGF5ZXI6ICFjb250ZW50R3JvdXBWaXJ0dWFsLFxyXG4gICAgICAgICAgICBpc1ZpcnR1YWw6IGNvbnRlbnRHcm91cFZpcnR1YWwsXHJcbiAgICAgICAgICAgIHpJbmRleDogTGF5ZXJzLlNFUklFU19MQVlFUl9aSU5ERVgsXHJcbiAgICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoJ2RhdGEnKSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRHcm91cCA9IG5ldyBHcm91cCh7XHJcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWhpZ2hsaWdodGAsXHJcbiAgICAgICAgICAgIGxheWVyOiAhY29udGVudEdyb3VwVmlydHVhbCxcclxuICAgICAgICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxyXG4gICAgICAgICAgICB6SW5kZXg6IExheWVycy5TRVJJRVNfTEFZRVJfWklOREVYLFxyXG4gICAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKCdoaWdobGlnaHQnKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodE5vZGUgPSB0aGlzLmhpZ2hsaWdodEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6ICdoaWdobGlnaHROb2RlJywgekluZGV4OiAwIH0pKTtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodExhYmVsID0gdGhpcy5oaWdobGlnaHRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiAnaGlnaGxpZ2h0TGFiZWwnLCB6SW5kZXg6IDEwIH0pKTtcclxuICAgICAgICB0aGlzLnBpY2tNb2RlcyA9IHBpY2tNb2RlcztcclxuICAgICAgICB0aGlzLmxhYmVsR3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoe1xyXG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1zZXJpZXMtbGFiZWxzYCxcclxuICAgICAgICAgICAgbGF5ZXI6IHVzZUxhYmVsTGF5ZXIsXHJcbiAgICAgICAgICAgIHpJbmRleDogTGF5ZXJzLlNFUklFU19MQUJFTF9aSU5ERVgsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkdyb3VwID0gbmV3IEdyb3VwKHtcclxuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYW5ub3RhdGlvbmAsXHJcbiAgICAgICAgICAgIGxheWVyOiAhY29udGVudEdyb3VwVmlydHVhbCxcclxuICAgICAgICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxyXG4gICAgICAgICAgICB6SW5kZXg6IExheWVycy5TRVJJRVNfTEFZRVJfWklOREVYLFxyXG4gICAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKCdhbm5vdGF0aW9uJyksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUsIHN1YkluZGV4ID0gMCkge1xyXG4gICAgICAgIGxldCBtYWluQWRqdXN0ID0gMDtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnZGF0YSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3BhdGhzJzpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsYWJlbHMnOlxyXG4gICAgICAgICAgICAgICAgbWFpbkFkanVzdCArPSAyMDAwMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtYXJrZXInOlxyXG4gICAgICAgICAgICAgICAgbWFpbkFkanVzdCArPSAxMDAwMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvLyBGb2xsb3dpbmcgY2FzZXMgYXJlIGluIHRoZWlyIG93biBsYXllciwgc28gbmVlZCB0byBiZSBjYXJlZnVsIHRvIHJlc3BlY3QgZGVjbGFyYXRpb25PcmRlci5cclxuICAgICAgICAgICAgY2FzZSAnaGlnaGxpZ2h0JzpcclxuICAgICAgICAgICAgICAgIHN1YkluZGV4ICs9IDE1MDAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Fubm90YXRpb24nOlxyXG4gICAgICAgICAgICAgICAgbWFpbkFkanVzdCArPSAxNTAwMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtYWluID0gKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciArIG1haW5BZGp1c3Q7XHJcbiAgICAgICAgcmV0dXJuIFttYWluLCBzdWJJbmRleF07XHJcbiAgICB9XHJcbiAgICBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllc0xpc3RlbmVycy5hZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaCh0eXBlLCBldmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllc0xpc3RlbmVycy5kaXNwYXRjaCh0eXBlLCBldmVudCk7XHJcbiAgICB9XHJcbiAgICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmRlcmVnaXN0ZXJTZXJpZXModGhpcyk7XHJcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzTGF5ZXJNYW5hZ2VyLnJlbGVhc2VHcm91cCh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBjb25zdCByZXNvbHZlZERpcmVjdGlvbiA9IHRoaXMucmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBwcm9wZXJ0aWVzID09PSBudWxsIHx8IHByb3BlcnRpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BlcnRpZXNbcmVzb2x2ZWREaXJlY3Rpb25dO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGlmICgha2V5cylcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgICBjb25zdCBhZGRWYWx1ZXMgPSAoLi4uaXRlbXMpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVtcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzKC4uLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZXMoLi4uT2JqZWN0LnZhbHVlcyh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBhZGRWYWx1ZXMoLi4ua2V5cy5tYXAoKGtleSkgPT4gdGhpc1trZXldKSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH1cclxuICAgIGdldEtleXMoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aW9uVmFsdWVzKGRpcmVjdGlvbiwgdGhpcy5kaXJlY3Rpb25LZXlzKTtcclxuICAgIH1cclxuICAgIGdldE5hbWVzKGRpcmVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHRoaXMuZGlyZWN0aW9uTmFtZXMpO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHVuaW9uIG9mIHRoZSBzZXJpZXMgZG9tYWluICgnY29tbXVuaXR5JykgYW5kIHNlcmllcy1vcHRpb24gZG9tYWlucyAoJ2VudGVycHJpc2UnKS5cclxuICAgIGdldERvbWFpbihkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKTtcclxuICAgICAgICBjb25zdCBtb2R1bGVEb21haW5zID0gKF9hID0gdGhpcy5kaXNwYXRjaCgnZGF0YS1nZXREb21haW4nLCB7IGRpcmVjdGlvbiB9KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgMkQgbW9kdWxlRG9tYWlucyBpbnRvIGEgMUQgYXJyYXkgYW5kIGNvbmNhdGVuYXRlIGl0IHdpdGggc2VyaWVzRG9tYWluXHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZURvbWFpbnMucmVkdWNlKCh0b3RhbCwgY3VycmVudCkgPT4gdG90YWwuY29uY2F0KGN1cnJlbnQpLCBzZXJpZXNEb21haW4pO1xyXG4gICAgfVxyXG4gICAgLy8gSW5kaWNhdGUgdGhhdCBzb21ldGhpbmcgZXh0ZXJuYWwgY2hhbmdlZCBhbmQgd2Ugc2hvdWxkIHJlY2FsY3VsYXRlIG5vZGVEYXRhLlxyXG4gICAgbWFya05vZGVEYXRhRGlydHkoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmlzaWJsZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLnJlZ2lzdGVyU2VyaWVzKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3BhY2l0eSgpIHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0T3BhY2l0eSA9IDE7XHJcbiAgICAgICAgY29uc3QgeyBkaW1PcGFjaXR5ID0gMSwgZW5hYmxlZCA9IHRydWUgfSA9IHRoaXMuaGlnaGxpZ2h0U3R5bGUuc2VyaWVzO1xyXG4gICAgICAgIGlmICghZW5hYmxlZCB8fCBkaW1PcGFjaXR5ID09PSBkZWZhdWx0T3BhY2l0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wYWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5pc0l0ZW1JZEhpZ2hsaWdodGVkKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBTZXJpZXNIaWdobGlnaHQuTm9uZTpcclxuICAgICAgICAgICAgY2FzZSBTZXJpZXNIaWdobGlnaHQuVGhpczpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3BhY2l0eTtcclxuICAgICAgICAgICAgY2FzZSBTZXJpZXNIaWdobGlnaHQuT3RoZXI6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGltT3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRTdHJva2VXaWR0aChkZWZhdWx0U3Ryb2tlV2lkdGgpIHtcclxuICAgICAgICBjb25zdCB7IHN0cm9rZVdpZHRoLCBlbmFibGVkID0gdHJ1ZSB9ID0gdGhpcy5oaWdobGlnaHRTdHlsZS5zZXJpZXM7XHJcbiAgICAgICAgaWYgKCFlbmFibGVkIHx8IHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlIGluIHN0eWxpbmcgZm9yIGhpZ2hsaWdodCBjYXNlcy5cclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJva2VXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFNlcmllc0hpZ2hsaWdodC5UaGlzOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xyXG4gICAgICAgICAgICBjYXNlIFNlcmllc0hpZ2hsaWdodC5Ob25lOlxyXG4gICAgICAgICAgICBjYXNlIFNlcmllc0hpZ2hsaWdodC5PdGhlcjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNJdGVtSWRIaWdobGlnaHRlZCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHsgc2VyaWVzIH0gPSAoX2IgPSAoX2EgPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0QWN0aXZlSGlnaGxpZ2h0KCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xyXG4gICAgICAgIC8vIEhpZ2hsaWdodGluZyBub3QgYWN0aXZlLlxyXG4gICAgICAgIGlmIChzZXJpZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2VyaWVzSGlnaGxpZ2h0Lk5vbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhpZ2hsaWdodGluZyBhY3RpdmUsIHRoaXMgc2VyaWVzIG5vdCBoaWdobGlnaHRlZC5cclxuICAgICAgICBpZiAoc2VyaWVzICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTZXJpZXNIaWdobGlnaHQuT3RoZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTZXJpZXNIaWdobGlnaHQuVGhpcztcclxuICAgIH1cclxuICAgIGdldE1vZHVsZVRvb2x0aXBQYXJhbXMoZGF0dW0pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gKF9hID0gdGhpcy5kaXNwYXRjaCgndG9vbHRpcC1nZXRQYXJhbXMnLCB7IGRhdHVtIH0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLnJlZHVjZSgodG90YWwsIGN1cnJlbnQpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudCksIHRvdGFsKTtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICB9XHJcbiAgICBwaWNrTm9kZShwb2ludCwgbGltaXRQaWNrTW9kZXMpIHtcclxuICAgICAgICBjb25zdCB7IHBpY2tNb2RlcywgdmlzaWJsZSwgcm9vdEdyb3VwIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghdmlzaWJsZSB8fCAhcm9vdEdyb3VwLnZpc2libGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHBpY2tNb2RlIG9mIHBpY2tNb2Rlcykge1xyXG4gICAgICAgICAgICBpZiAobGltaXRQaWNrTW9kZXMgJiYgIWxpbWl0UGlja01vZGVzLmluY2x1ZGVzKHBpY2tNb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG1hdGNoO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHBpY2tNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNlcmllc05vZGVQaWNrTW9kZS5FWEFDVF9TSEFQRV9NQVRDSDpcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMucGlja05vZGVFeGFjdFNoYXBlKHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU2VyaWVzTm9kZVBpY2tNb2RlLk5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTZXJpZXNOb2RlUGlja01vZGUuTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlTWFpbkF4aXNGaXJzdChwb2ludCwgcGlja01vZGUgPT09IFNlcmllc05vZGVQaWNrTW9kZS5ORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNlcmllc05vZGVQaWNrTW9kZS5ORUFSRVNUX05PREU6XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHBpY2tNb2RlLCBtYXRjaDogbWF0Y2guZGF0dW0sIGRpc3RhbmNlOiBtYXRjaC5kaXN0YW5jZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGlja05vZGVFeGFjdFNoYXBlKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNvbnRlbnRHcm91cC5waWNrTm9kZShwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggJiYgeyBkYXR1bTogbWF0Y2guZGF0dW0sIGRpc3RhbmNlOiAwIH07XHJcbiAgICB9XHJcbiAgICBwaWNrTm9kZUNsb3Nlc3REYXR1bShfcG9pbnQpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCBmb3Igc3ViY2xhc3NlcyAtIGJ1dCBpZiB0aGlzIGlzIGludm9rZWQsIHRoZSBzdWJjbGFzcyBzcGVjaWZpZWQgaXQgd2FudHNcclxuICAgICAgICAvLyB0byB1c2UgdGhpcyBmZWF0dXJlLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQUcgQ2hhcnRzIC0gU2VyaWVzLnBpY2tOb2RlQ2xvc2VzdERhdHVtKCkgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9XHJcbiAgICBwaWNrTm9kZU1haW5BeGlzRmlyc3QoX3BvaW50LCBfcmVxdWlyZUNhdGVnb3J5QXhpcykge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IGZvciBzdWJjbGFzc2VzIC0gYnV0IGlmIHRoaXMgaXMgaW52b2tlZCwgdGhlIHN1YmNsYXNzIHNwZWNpZmllZCBpdCB3YW50c1xyXG4gICAgICAgIC8vIHRvIHVzZSB0aGlzIGZlYXR1cmUuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBRyBDaGFydHMgLSBTZXJpZXMucGlja05vZGVNYWluQXhpc0ZpcnN0KCkgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgICB9XHJcbiAgICBmaXJlTm9kZUNsaWNrRXZlbnQoZXZlbnQsIGRhdHVtKSB7XHJcbiAgICAgICAgdGhpcy5maXJlRXZlbnQobmV3IHRoaXMuTm9kZUNsaWNrRXZlbnQoJ25vZGVDbGljaycsIGV2ZW50LCBkYXR1bSwgdGhpcykpO1xyXG4gICAgfVxyXG4gICAgZmlyZU5vZGVEb3VibGVDbGlja0V2ZW50KGV2ZW50LCBkYXR1bSkge1xyXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KG5ldyB0aGlzLk5vZGVDbGlja0V2ZW50KCdub2RlRG91YmxlQ2xpY2snLCBldmVudCwgZGF0dW0sIHRoaXMpKTtcclxuICAgIH1cclxuICAgIHRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKSB7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZW5hYmxlZDtcclxuICAgICAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgndmlzaWJpbGl0eS1jaGFuZ2VkJywgeyBpdGVtSWQsIGVuYWJsZWQgfSk7XHJcbiAgICB9XHJcbiAgICBpc0VuYWJsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcclxuICAgIH1cclxuICAgIGdldE1vZHVsZU1hcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXA7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVNb2R1bGVDb250ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY3R4KSwgeyBzZXJpZXM6IHRoaXMgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRMYWJlbFRleHQobGFiZWwsIHBhcmFtcywgZGVmYXVsdEZvcm1hdHRlciA9IFN0cmluZykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAobGFiZWwuZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5jdHguY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsLmZvcm1hdHRlciwgT2JqZWN0LmFzc2lnbih7IHNlcmllc0lkOiB0aGlzLmlkIH0sIHBhcmFtcykpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0Rm9ybWF0dGVyKHBhcmFtcy52YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcihwYXJhbXMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSA9IG1hcmtlci5nZXRTdHlsZSgpKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBkZWZhdWx0U2l6ZSA9IHsgc2l6ZTogKF9iID0gKF9hID0gcGFyYW1zLmRhdHVtLnBvaW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCB9O1xyXG4gICAgICAgIGNvbnN0IG1hcmtlclN0eWxlID0gbWVyZ2VEZWZhdWx0cyhkZWZhdWx0U2l6ZSwgZGVmYXVsdFN0eWxlKTtcclxuICAgICAgICBpZiAobWFya2VyLmZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBzdHlsZSA9IHRoaXMuY3R4LmNhbGxiYWNrQ2FjaGUuY2FsbChtYXJrZXIuZm9ybWF0dGVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHNlcmllc0lkOiB0aGlzLmlkIH0sIG1hcmtlclN0eWxlKSwgcGFyYW1zKSwgeyBkYXR1bTogcGFyYW1zLmRhdHVtLmRhdHVtIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoc3R5bGUsIG1hcmtlclN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcmtlclN0eWxlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyU3R5bGUobWFya2VyTm9kZSwgbWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSA9IG1hcmtlci5nZXRTdHlsZSgpLCB7IGFwcGx5VHJhbnNsYXRpb24gPSB0cnVlIH0gPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IHsgcG9pbnQgfSA9IHBhcmFtcy5kYXR1bTtcclxuICAgICAgICBjb25zdCBhY3RpdmVTdHlsZSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSk7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiBhY3RpdmVTdHlsZS5zaXplID4gMCAmJiBwb2ludCAmJiAhaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpO1xyXG4gICAgICAgIGlmIChhcHBseVRyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIG1hcmtlck5vZGUuc2V0UHJvcGVydGllcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aXNpYmxlIH0sIGFjdGl2ZVN0eWxlKSwgeyB0cmFuc2xhdGlvblg6IHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludC54LCB0cmFuc2xhdGlvblk6IHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludC55IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcmtlck5vZGUuc2V0UHJvcGVydGllcyhPYmplY3QuYXNzaWduKHsgdmlzaWJsZSB9LCBhY3RpdmVTdHlsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPbmx5IGZvciBjdXN0b20gbWFya2VyIHNoYXBlc1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWFya2VyLnNoYXBlID09PSAnZnVuY3Rpb24nICYmICFtYXJrZXJOb2RlLmRpcnR5UGF0aCkge1xyXG4gICAgICAgICAgICBtYXJrZXJOb2RlLnBhdGguY2xlYXIoeyB0cmFja0NoYW5nZXM6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIG1hcmtlck5vZGUudXBkYXRlUGF0aCgpO1xyXG4gICAgICAgICAgICBtYXJrZXJOb2RlLmNoZWNrUGF0aERpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TWluUmVjdCgpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY2hlY2tSZXNpemUobmV3U2VyaWVzUmVjdCkge1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzID0ge1xyXG4gICAgICAgICAgICBzZXJpZXNSZWN0V2lkdGg6IG5ld1Nlcmllc1JlY3QgPT09IG51bGwgfHwgbmV3U2VyaWVzUmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3U2VyaWVzUmVjdC53aWR0aCxcclxuICAgICAgICAgICAgc2VyaWVzUmVjdEhlaWdodDogbmV3U2VyaWVzUmVjdCA9PT0gbnVsbCB8fCBuZXdTZXJpZXNSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdTZXJpZXNSZWN0LmhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xyXG4gICAgICAgIGlmIChyZXNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtOb2RlRGF0YURpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNpemU7XHJcbiAgICB9XHJcbn1cclxuU2VyaWVzLmhpZ2hsaWdodGVkWkluZGV4ID0gMTAwMDAwMDAwMDAwMDtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShTVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgU2VyaWVzLnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgU2VyaWVzLnByb3RvdHlwZSwgXCJfdmlzaWJsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgU2VyaWVzLnByb3RvdHlwZSwgXCJzaG93SW5MZWdlbmRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShTVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgU2VyaWVzLnByb3RvdHlwZSwgXCJjdXJzb3JcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBTZXJpZXMucHJvdG90eXBlLCBcIm5vZGVDbGlja1JhbmdlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgQWN0aW9uT25TZXQoe1xyXG4gICAgICAgIGNoYW5nZVZhbHVlOiBmdW5jdGlvbiAobmV3VmFsLCBvbGRWYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5vblNlcmllc0dyb3VwaW5nQ2hhbmdlKG9sZFZhbCwgbmV3VmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBTZXJpZXMucHJvdG90eXBlLCBcInNlcmllc0dyb3VwaW5nXCIsIHZvaWQgMCk7XG5cbmZ1bmN0aW9uIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9ucykge1xyXG4gICAgc3RhdGljRnJvbVRvTW90aW9uKGlkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zLCB7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0sIExBQkVMX1BIQVNFKTtcclxufVxyXG5mdW5jdGlvbiBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKSB7XHJcbiAgICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbnMsIHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSwgTEFCRUxfUEhBU0UpO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0TGFiZWxGbihfbm9kZSkge1xyXG4gICAgcmV0dXJuIHsgb3BhY2l0eTogMSB9O1xyXG59XG5cbmNvbnN0IENPTlNUQU5UUyA9IHtcclxuICAgIHBlcmlvZHM6IFsnQU0nLCAnUE0nXSxcclxuICAgIGRheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcclxuICAgIHNob3J0RGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcclxuICAgIG1vbnRoczogW1xyXG4gICAgICAgICdKYW51YXJ5JyxcclxuICAgICAgICAnRmVicnVhcnknLFxyXG4gICAgICAgICdNYXJjaCcsXHJcbiAgICAgICAgJ0FwcmlsJyxcclxuICAgICAgICAnTWF5JyxcclxuICAgICAgICAnSnVuZScsXHJcbiAgICAgICAgJ0p1bHknLFxyXG4gICAgICAgICdBdWd1c3QnLFxyXG4gICAgICAgICdTZXB0ZW1iZXInLFxyXG4gICAgICAgICdPY3RvYmVyJyxcclxuICAgICAgICAnTm92ZW1iZXInLFxyXG4gICAgICAgICdEZWNlbWJlcicsXHJcbiAgICBdLFxyXG4gICAgc2hvcnRNb250aHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcclxufTtcclxuZnVuY3Rpb24gZGF5T2ZZZWFyKGRhdGUsIHN0YXJ0T2ZZZWFyID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSkge1xyXG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydE9mWWVhci5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgY29uc3QgdGltZURpZmYgPSBkYXRlLmdldFRpbWUoKSAtIHN0YXJ0T2ZZZWFyLmdldFRpbWUoKSArIHN0YXJ0T2Zmc2V0ICogNjAwMDA7XHJcbiAgICBjb25zdCB0aW1lT25lRGF5ID0gMzYwMDAwMCAqIDI0O1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGltZURpZmYgLyB0aW1lT25lRGF5KTtcclxufVxyXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKGRhdGUsIHN0YXJ0RGF5KSB7XHJcbiAgICBjb25zdCBzdGFydE9mWWVhciA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XHJcbiAgICBjb25zdCBzdGFydE9mWWVhckRheSA9IHN0YXJ0T2ZZZWFyLmdldERheSgpO1xyXG4gICAgY29uc3QgZmlyc3RXZWVrU3RhcnRPZmZzZXQgPSAoc3RhcnREYXkgLSBzdGFydE9mWWVhckRheSArIDcpICUgNztcclxuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCBmaXJzdFdlZWtTdGFydE9mZnNldCArIDEpO1xyXG4gICAgaWYgKHN0YXJ0T2Zmc2V0IDw9IGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlPZlllYXIoZGF0ZSwgc3RhcnRPZmZzZXQpIC8gNykgKyAxO1xyXG4gICAgfVxyXG4gICAgLy8gRGF5cyBiZWZvcmUgd2VlayAxIGFyZSBpbiB3ZWVrIDAuXHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5jb25zdCBTVU5EQVkgPSAwO1xyXG5jb25zdCBNT05EQVkgPSAxO1xyXG5jb25zdCBUSFVSU0RBWSA9IDQ7XHJcbmZ1bmN0aW9uIGlzb1dlZWtPZlllYXIoZGF0ZSwgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSkge1xyXG4gICAgY29uc3QgZmlyc3RPZlllYXIgPSBuZXcgRGF0ZSh5ZWFyLCAwLCAxKTtcclxuICAgIGNvbnN0IGZpcnN0T2ZZZWFyRGF5ID0gZmlyc3RPZlllYXIuZ2V0RGF5KCk7XHJcbiAgICBjb25zdCBmaXJzdFRodXJzZGF5T2Zmc2V0ID0gKFRIVVJTREFZIC0gZmlyc3RPZlllYXJEYXkgKyA3KSAlIDc7XHJcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IG5ldyBEYXRlKHllYXIsIDAsIGZpcnN0VGh1cnNkYXlPZmZzZXQgLSAoVEhVUlNEQVkgLSBNT05EQVkpICsgMSk7XHJcbiAgICBpZiAoc3RhcnRPZmZzZXQgPD0gZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRheU9mWWVhcihkYXRlLCBzdGFydE9mZnNldCkgLyA3KSArIDE7XHJcbiAgICB9XHJcbiAgICAvLyBEYXlzIGJlZm9yZSB3ZWVrIDEgYXJlIGluIHdlZWsgNTIvNTMgb2YgcHJldmlvdXMgeWVhci5cclxuICAgIHJldHVybiBpc29XZWVrT2ZZZWFyKGRhdGUsIHllYXIgLSAxKTtcclxufVxyXG5mdW5jdGlvbiB0aW1lem9uZShkYXRlKSB7XHJcbiAgICBjb25zdCBvZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XHJcbiAgICBjb25zdCB1bnNpZ25lZE9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XHJcbiAgICBjb25zdCBzaWduID0gb2Zmc2V0ID4gMCA/ICctJyA6ICcrJztcclxuICAgIHJldHVybiBgJHtzaWdufSR7cGFkKE1hdGguZmxvb3IodW5zaWduZWRPZmZzZXQgLyA2MCksIDIsICcwJyl9JHtwYWQoTWF0aC5mbG9vcih1bnNpZ25lZE9mZnNldCAlIDYwKSwgMiwgJzAnKX1gO1xyXG59XHJcbmNvbnN0IEZPUk1BVFRFUlMgPSB7XHJcbiAgICBhOiAoZCkgPT4gQ09OU1RBTlRTLnNob3J0RGF5c1tkLmdldERheSgpXSxcclxuICAgIEE6IChkKSA9PiBDT05TVEFOVFMuZGF5c1tkLmdldERheSgpXSxcclxuICAgIGI6IChkKSA9PiBDT05TVEFOVFMuc2hvcnRNb250aHNbZC5nZXRNb250aCgpXSxcclxuICAgIEI6IChkKSA9PiBDT05TVEFOVFMubW9udGhzW2QuZ2V0TW9udGgoKV0sXHJcbiAgICBjOiAnJXgsICVYJyxcclxuICAgIGQ6IChkLCBwKSA9PiBwYWQoZC5nZXREYXRlKCksIDIsIHAgIT09IG51bGwgJiYgcCAhPT0gdm9pZCAwID8gcCA6ICcwJyksXHJcbiAgICBlOiAnJV9kJyxcclxuICAgIGY6IChkLCBwKSA9PiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSAqIDEwMDAsIDYsIHAgIT09IG51bGwgJiYgcCAhPT0gdm9pZCAwID8gcCA6ICcwJyksXHJcbiAgICBIOiAoZCwgcCkgPT4gcGFkKGQuZ2V0SG91cnMoKSwgMiwgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogJzAnKSxcclxuICAgIEk6IChkLCBwKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaG91cnMgPSBkLmdldEhvdXJzKCkgJSAxMjtcclxuICAgICAgICByZXR1cm4gaG91cnMgPT09IDAgPyAnMTInIDogcGFkKGhvdXJzLCAyLCBwICE9PSBudWxsICYmIHAgIT09IHZvaWQgMCA/IHAgOiAnMCcpO1xyXG4gICAgfSxcclxuICAgIGo6IChkLCBwKSA9PiBwYWQoZGF5T2ZZZWFyKGQpICsgMSwgMywgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogJzAnKSxcclxuICAgIG06IChkLCBwKSA9PiBwYWQoZC5nZXRNb250aCgpICsgMSwgMiwgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogJzAnKSxcclxuICAgIE06IChkLCBwKSA9PiBwYWQoZC5nZXRNaW51dGVzKCksIDIsIHAgIT09IG51bGwgJiYgcCAhPT0gdm9pZCAwID8gcCA6ICcwJyksXHJcbiAgICBMOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIDMsIHAgIT09IG51bGwgJiYgcCAhPT0gdm9pZCAwID8gcCA6ICcwJyksXHJcbiAgICBwOiAoZCkgPT4gKGQuZ2V0SG91cnMoKSA8IDEyID8gJ0FNJyA6ICdQTScpLFxyXG4gICAgUTogKGQpID0+IFN0cmluZyhkLmdldFRpbWUoKSksXHJcbiAgICBzOiAoZCkgPT4gU3RyaW5nKE1hdGguZmxvb3IoZC5nZXRUaW1lKCkgLyAxMDAwKSksXHJcbiAgICBTOiAoZCwgcCkgPT4gcGFkKGQuZ2V0U2Vjb25kcygpLCAyLCBwICE9PSBudWxsICYmIHAgIT09IHZvaWQgMCA/IHAgOiAnMCcpLFxyXG4gICAgdTogKGQpID0+IHtcclxuICAgICAgICBsZXQgZGF5ID0gZC5nZXREYXkoKTtcclxuICAgICAgICBpZiAoZGF5IDwgMSlcclxuICAgICAgICAgICAgZGF5ICs9IDc7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhkYXkgJSA3KTtcclxuICAgIH0sXHJcbiAgICBVOiAoZCwgcCkgPT4gcGFkKHdlZWtPZlllYXIoZCwgU1VOREFZKSwgMiwgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogJzAnKSxcclxuICAgIFY6IChkLCBwKSA9PiBwYWQoaXNvV2Vla09mWWVhcihkKSwgMiwgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogJzAnKSxcclxuICAgIHc6IChkLCBwKSA9PiBwYWQoZC5nZXREYXkoKSwgMiwgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogJzAnKSxcclxuICAgIFc6IChkLCBwKSA9PiBwYWQod2Vla09mWWVhcihkLCBNT05EQVkpLCAyLCBwICE9PSBudWxsICYmIHAgIT09IHZvaWQgMCA/IHAgOiAnMCcpLFxyXG4gICAgeDogJyUtbS8lLWQvJVknLFxyXG4gICAgWDogJyUtSTolTTolUyAlcCcsXHJcbiAgICB5OiAoZCwgcCkgPT4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgMiwgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogJzAnKSxcclxuICAgIFk6IChkLCBwKSA9PiBwYWQoZC5nZXRGdWxsWWVhcigpLCA0LCBwICE9PSBudWxsICYmIHAgIT09IHZvaWQgMCA/IHAgOiAnMCcpLFxyXG4gICAgWjogKGQpID0+IHRpbWV6b25lKGQpLFxyXG4gICAgJyUnOiAoKSA9PiAnJScsXHJcbn07XHJcbmNvbnN0IFBBRFMgPSB7XHJcbiAgICBfOiAnICcsXHJcbiAgICAnMCc6ICcwJyxcclxuICAgICctJzogJycsXHJcbn07XHJcbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgc2l6ZSwgcGFkQ2hhcikge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gU3RyaW5nKE1hdGguZmxvb3IodmFsdWUpKTtcclxuICAgIGlmIChvdXRwdXQubGVuZ3RoID49IHNpemUpIHtcclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGAke3BhZENoYXIucmVwZWF0KHNpemUgLSBvdXRwdXQubGVuZ3RoKX0ke291dHB1dH1gO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGVyKGZvcm1hdFN0cmluZykge1xyXG4gICAgY29uc3QgZm9ybWF0UGFydHMgPSBbXTtcclxuICAgIHdoaWxlIChmb3JtYXRTdHJpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCBuZXh0RXNjYXBlSWR4ID0gZm9ybWF0U3RyaW5nLmluZGV4T2YoJyUnKTtcclxuICAgICAgICBpZiAobmV4dEVzY2FwZUlkeCAhPT0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBsaXRlcmFsUGFydCA9IG5leHRFc2NhcGVJZHggPiAwID8gZm9ybWF0U3RyaW5nLnN1YnN0cmluZygwLCBuZXh0RXNjYXBlSWR4KSA6IGZvcm1hdFN0cmluZztcclxuICAgICAgICAgICAgZm9ybWF0UGFydHMucHVzaChsaXRlcmFsUGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0RXNjYXBlSWR4IDwgMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY29uc3QgbWF5YmVQYWRTcGVjaWZpZXIgPSBmb3JtYXRTdHJpbmdbbmV4dEVzY2FwZUlkeCArIDFdO1xyXG4gICAgICAgIGNvbnN0IG1heWJlUGFkID0gUEFEU1ttYXliZVBhZFNwZWNpZmllcl07XHJcbiAgICAgICAgaWYgKG1heWJlUGFkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbmV4dEVzY2FwZUlkeCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtYXliZUZvcm1hdHRlclNwZWNpZmllciA9IGZvcm1hdFN0cmluZ1tuZXh0RXNjYXBlSWR4ICsgMV07XHJcbiAgICAgICAgY29uc3QgbWF5YmVGb3JtYXR0ZXIgPSBGT1JNQVRURVJTW21heWJlRm9ybWF0dGVyU3BlY2lmaWVyXTtcclxuICAgICAgICBpZiAodHlwZW9mIG1heWJlRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdFBhcnRzLnB1c2goW21heWJlRm9ybWF0dGVyLCBtYXliZVBhZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWF5YmVGb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGJ1aWxkRm9ybWF0dGVyKG1heWJlRm9ybWF0dGVyKTtcclxuICAgICAgICAgICAgZm9ybWF0UGFydHMucHVzaChbZm9ybWF0dGVyLCBtYXliZVBhZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9ybWF0UGFydHMucHVzaChgJHttYXliZVBhZCAhPT0gbnVsbCAmJiBtYXliZVBhZCAhPT0gdm9pZCAwID8gbWF5YmVQYWQgOiAnJ30ke21heWJlRm9ybWF0dGVyU3BlY2lmaWVyfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcuc3Vic3RyaW5nKG5leHRFc2NhcGVJZHggKyAyKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoZGF0ZVRpbWUpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRlVGltZUFzRGF0ZSA9IHR5cGVvZiBkYXRlVGltZSA9PT0gJ251bWJlcicgPyBuZXcgRGF0ZShkYXRlVGltZSkgOiBkYXRlVGltZTtcclxuICAgICAgICByZXR1cm4gZm9ybWF0UGFydHMubWFwKChjKSA9PiAodHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6IGNbMF0oZGF0ZVRpbWVBc0RhdGUsIGNbMV0pKSkuam9pbignJyk7XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGludGVycG9sYXRlUGF0dGVybiA9IC8oI1xceyguKj8pXFx9KS9nO1xyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgdmFsdWVzLCBmb3JtYXRzKSB7XHJcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShpbnRlcnBvbGF0ZVBhdHRlcm4sIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IGFyZ3NbMl07XHJcbiAgICAgICAgY29uc3QgW3ZhbHVlTmFtZSwgZm9ybWF0TmFtZV0gPSBuYW1lLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbdmFsdWVOYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXROYW1lICYmIGZvcm1hdHMgJiYgZm9ybWF0c1tmb3JtYXROYW1lXTtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsb2NhbGVzLCBvcHRpb25zIH0gPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb2NhbGVTdHJpbmcobG9jYWxlcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0TmFtZSAmJiBmb3JtYXRzICYmIGZvcm1hdHNbZm9ybWF0TmFtZV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0RhdGVTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS50b1N0cmluZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGluamVjdFN0eWxlKGRvY3VtZW50LCBjc3NTdHlsZSkge1xyXG4gICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3NTdHlsZTtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGVzZSBzdHlsZXMgYXJlIGluamVjdGVkIGJlZm9yZSBvdGhlciBzdHlsZXMsIHNvIGl0IGNhbiBiZSBvdmVycmlkZGVuLlxyXG4gICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xyXG59XG5cbmNvbnN0IERFRkFVTFRfVE9PTFRJUF9DTEFTUyA9ICdhZy1jaGFydC10b29sdGlwJztcclxuY29uc3QgREVGQVVMVF9UT09MVElQX0RBUktfQ0xBU1MgPSAnYWctY2hhcnQtZGFyay10b29sdGlwJztcclxuY29uc3QgZGVmYXVsdFRvb2x0aXBDc3MgPSBgXG4uJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9IHtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xcyBlYXNlO1xuICAgIGRpc3BsYXk6IHRhYmxlO1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBsZWZ0OiAwcHg7XG4gICAgdG9wOiAwcHg7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB6LWluZGV4OiA5OTk5OTtcbiAgICBmb250OiAxMnB4IFZlcmRhbmEsIHNhbnMtc2VyaWY7XG4gICAgY29sb3I6IHJnYig3MCwgNzAsIDcwKTtcbiAgICBib3gtc2hhZG93OiAwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjA4KTtcbn1cblxuLiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS1uby1pbnRlcmFjdGlvbiB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG5cbi4ke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tbm8tYW5pbWF0aW9uIHtcbiAgICB0cmFuc2l0aW9uOiBub25lICFpbXBvcnRhbnQ7XG59XG5cbi4ke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30taGlkZGVuIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG59XG5cbi4ke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tdGl0bGUge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBwYWRkaW5nOiA4cHggMTRweDtcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAycHg7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDJweDtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg4ODg4ODtcbiAgICB6LWluZGV4OiAxO1xufVxuXG4uJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LXRpdGxlOm9ubHktY2hpbGQge1xuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xufVxuXG4uJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LWNvbnRlbnQge1xuICAgIHBhZGRpbmc6IDZweCAxNHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxLjdlbTtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMTUpO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi4ke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tYXJyb3c6OmJlZm9yZSB7XG4gICAgY29udGVudDogXCJcIjtcblxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDEwMCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcblxuICAgIGJvcmRlcjogNXB4IHNvbGlkICNkOWQ5ZDk7XG5cbiAgICBib3JkZXItbGVmdC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyLXJpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDtcblxuICAgIHdpZHRoOiAwO1xuICAgIGhlaWdodDogMDtcblxuICAgIG1hcmdpbjogMCBhdXRvO1xufVxuXG4uJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LWFycm93OjphZnRlciB7XG4gICAgY29udGVudDogXCJcIjtcblxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IGNhbGMoMTAwJSAtIDFweCk7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcblxuICAgIGJvcmRlcjogNXB4IHNvbGlkIHdoaXRlO1xuXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlci1yaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICB3aWR0aDogMDtcbiAgICBoZWlnaHQ6IDA7XG5cbiAgICBtYXJnaW46IDAgYXV0bztcbn1cblxuLiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS4ke0RFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTfSB7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIGJhY2tncm91bmQ6ICMxNTE4MWM7XG59XG5cbi4ke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30uJHtERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTU30gLiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS1jb250ZW50IHtcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNSk7XG59XG5cbi5hZy1jaGFydC13cmFwcGVyIHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5gO1xyXG5mdW5jdGlvbiB0b1Rvb2x0aXBIdG1sKGlucHV0LCBkZWZhdWx0cykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgY29udGVudCA9IChfYSA9IGRlZmF1bHRzID09PSBudWxsIHx8IGRlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0cy5jb250ZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJywgdGl0bGUgPSBkZWZhdWx0cyA9PT0gbnVsbCB8fCBkZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdHMudGl0bGUsIGNvbG9yID0gKF9iID0gZGVmYXVsdHMgPT09IG51bGwgfHwgZGVmYXVsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRzLmNvbG9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnd2hpdGUnLCBiYWNrZ3JvdW5kQ29sb3IgPSAoX2MgPSBkZWZhdWx0cyA9PT0gbnVsbCB8fCBkZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdHMuYmFja2dyb3VuZENvbG9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnIzg4OCcsIH0gPSBpbnB1dDtcclxuICAgIGNvbnN0IHRpdGxlSHRtbCA9IHRpdGxlXHJcbiAgICAgICAgPyBgPGRpdiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS10aXRsZVwiXG4gICAgICAgIHN0eWxlPVwiY29sb3I6ICR7Y29sb3J9OyBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tncm91bmRDb2xvcn1cIj4ke3RpdGxlfTwvZGl2PmBcclxuICAgICAgICA6ICcnO1xyXG4gICAgY29uc3QgY29udGVudEh0bWwgPSBjb250ZW50ID8gYDxkaXYgY2xhc3M9XCIke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tY29udGVudFwiPiR7Y29udGVudH08L2Rpdj5gIDogJyc7XHJcbiAgICByZXR1cm4gYCR7dGl0bGVIdG1sfSR7Y29udGVudEh0bWx9YDtcclxufVxyXG5jb25zdCBQT1NJVElPTl9UWVBFUyA9IFsncG9pbnRlcicsICdub2RlJ107XHJcbmNvbnN0IFBPU0lUSU9OX1RZUEUgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodikgPT4gUE9TSVRJT05fVFlQRVMuaW5jbHVkZXModiksIGBleHBlY3RpbmcgYSBwb3NpdGlvbiB0eXBlIGtleXdvcmQgc3VjaCBhcyAncG9pbnRlcicgb3IgJ25vZGUnYCk7XHJcbmNsYXNzIFRvb2x0aXBQb3NpdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgZm9yIHRoZSB0b29sdGlwLiBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBmb2xsb3dzIHRoZSBwb2ludGVyLiAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdwb2ludGVyJztcclxuICAgICAgICAvKiogVGhlIGhvcml6b250YWwgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwLiAqL1xyXG4gICAgICAgIHRoaXMueE9mZnNldCA9IDA7XHJcbiAgICAgICAgLyoqIFRoZSB2ZXJ0aWNhbCBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuICovXHJcbiAgICAgICAgdGhpcy55T2Zmc2V0ID0gMDtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFBPU0lUSU9OX1RZUEUpXHJcbiAgICAvKiogVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgZm9yIHRoZSB0b29sdGlwLiBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBmb2xsb3dzIHRoZSBwb2ludGVyLiAqL1xyXG4gICAgLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgVG9vbHRpcFBvc2l0aW9uLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoKSlcclxuICAgIC8qKiBUaGUgaG9yaXpvbnRhbCBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuICovXHJcbiAgICAsXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInhPZmZzZXRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKVxyXG4gICAgLyoqIFRoZSB2ZXJ0aWNhbCBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuICovXHJcbiAgICAsXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInlPZmZzZXRcIiwgdm9pZCAwKTtcclxuY2xhc3MgVG9vbHRpcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXNFbGVtZW50LCBkb2N1bWVudCwgd2luZG93LCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmVuYWJsZUludGVyYWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNob3dBcnJvdyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNsYXNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubGFzdENsYXNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSAnbmVhcmVzdCc7XHJcbiAgICAgICAgdGhpcy5sYXN0VmlzaWJpbGl0eUNoYW5nZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBUb29sdGlwUG9zaXRpb24oKTtcclxuICAgICAgICB0aGlzLnNob3dUaW1lb3V0ID0gMDtcclxuICAgICAgICB0aGlzLl9zaG93QXJyb3cgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFJvb3QgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMudG9vbHRpcFJvb3QuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoREVGQVVMVF9UT09MVElQX0NMQVNTKTtcclxuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBjYW52YXNFbGVtZW50O1xyXG4gICAgICAgIC8vIERldGVjdCB3aGVuIHRoZSBjaGFydCBiZWNvbWVzIGludmlzaWJsZSBhbmQgaGlkZSB0aGUgdG9vbHRpcCBhcyB3ZWxsLlxyXG4gICAgICAgIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSB0aGlzLmNhbnZhc0VsZW1lbnQgJiYgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeyByb290OiB0aGlzLnRvb2x0aXBSb290IH0pO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMuY2FudmFzRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFRvb2x0aXAudG9vbHRpcERvY3VtZW50cy5pbmRleE9mKGRvY3VtZW50KSA8IDApIHtcclxuICAgICAgICAgICAgaW5qZWN0U3R5bGUoZG9jdW1lbnQsIGRlZmF1bHRUb29sdGlwQ3NzKTtcclxuICAgICAgICAgICAgVG9vbHRpcC50b29sdGlwRG9jdW1lbnRzLnB1c2goZG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLmNhbnZhc0VsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzVmlzaWJsZSgpIHtcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhERUZBVUxUX1RPT0xUSVBfQ0xBU1MgKyAnLWhpZGRlbicpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2xhc3ModmlzaWJsZSwgc2hvd0Fycm93KSB7XHJcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBjbGFzczogbmV3Q2xhc3MsIGxhc3RDbGFzcywgZW5hYmxlSW50ZXJhY3Rpb24sIGxhc3RWaXNpYmlsaXR5Q2hhbmdlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHdhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZSgpO1xyXG4gICAgICAgIGNvbnN0IG5vd1Zpc2libGUgPSAhIXZpc2libGU7XHJcbiAgICAgICAgbGV0IHRpbWVTaW5jZUxhc3RWaXNpYmlsaXR5Q2hhbmdlTXMgPSBJbmZpbml0eTtcclxuICAgICAgICBpZiAod2FzVmlzaWJsZSAhPT0gbm93VmlzaWJsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID0gbm93IC0gbGFzdFZpc2liaWxpdHlDaGFuZ2U7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFZpc2liaWxpdHlDaGFuZ2UgPSBub3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRvZ2dsZUNsYXNzID0gKG5hbWUsIGluY2x1ZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gYCR7REVGQVVMVF9UT09MVElQX0NMQVNTfS0ke25hbWV9YDtcclxuICAgICAgICAgICAgaWYgKGluY2x1ZGUpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFRpbWUgYmVsb3cgd2hpY2ggYW4gYW5pbWF0ZWQgbW92ZSBzaG91bGQgYmUgdXNlZC5cclxuICAgICAgICBjb25zdCBhbmltYXRlZE1vdmVUaHJlc2hvbGRNcyA9IDEwMDtcclxuICAgICAgICAvLyBUaW1lIGJlbG93IHdoaWNoIHdlIHNob3VsZCB0cmVhdCB1cGRhdGVzIGFzIGluZGlzdGluZ3Vpc2hhYmxlIHRvIHVzZXJzLCBhbmQgd2Ugc2hvdWxkbid0XHJcbiAgICAgICAgLy8gYWRqdXN0IHRoZSBgbm8tYW5pbWF0aW9uYCBDU1MgY2xhc3MuXHJcbiAgICAgICAgY29uc3QgdGhyYXNoaW5nVGhyZXNob2xkTXMgPSA1O1xyXG4gICAgICAgIC8vIE5vIGFuaW1hdGlvbiBvbiBmaXJzdCBzaG93IG9yIGlmIHRvb2x0aXAgaXMgZGlzYWJsZWQgZm9yIGEgbm9uLXRyaXZpYWwgYW1vdW50IG9mIHRpbWUuXHJcbiAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBgbm8tYW5pbWF0aW9uYCBjbGFzcyBvbiBmYXN0IHVwZGF0ZS5cclxuICAgICAgICBjb25zdCBub0FuaW1hdGlvbiA9ICF3YXNWaXNpYmxlICYmIG5vd1Zpc2libGUgJiYgdGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA+IGFuaW1hdGVkTW92ZVRocmVzaG9sZE1zO1xyXG4gICAgICAgIGlmICh0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID4gdGhyYXNoaW5nVGhyZXNob2xkTXMpIHtcclxuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoJ25vLWFuaW1hdGlvbicsIG5vQW5pbWF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9nZ2xlQ2xhc3MoJ25vLWludGVyYWN0aW9uJywgIWVuYWJsZUludGVyYWN0aW9uKTsgLy8gUHJldmVudCBpbnRlcmFjdGlvbi5cclxuICAgICAgICB0b2dnbGVDbGFzcygnaGlkZGVuJywgIXZpc2libGUpOyAvLyBIaWRlIGlmIG5vdCB2aXNpYmxlLlxyXG4gICAgICAgIHRvZ2dsZUNsYXNzKCdhcnJvdycsICEhc2hvd0Fycm93KTsgLy8gQWRkIGFycm93IGlmIHRvb2x0aXAgaXMgY29uc3RyYWluZWQuXHJcbiAgICAgICAgaWYgKG5ld0NsYXNzICE9PSBsYXN0Q2xhc3MpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGxhc3RDbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ld0NsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmV3Q2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENsYXNzID0gbmV3Q2xhc3M7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0b29sdGlwIGF0IHRoZSBnaXZlbiBldmVudCdzIGNvb3JkaW5hdGVzLlxyXG4gICAgICogSWYgdGhlIGBodG1sYCBwYXJhbWV0ZXIgaXMgbWlzc2luZywgbW92ZXMgdGhlIGV4aXN0aW5nIHRvb2x0aXAgdG8gdGhlIG5ldyBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgc2hvdyhtZXRhLCBodG1sLCBpbnN0YW50bHkgPSBmYWxzZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcclxuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIGNhbnZhc0VsZW1lbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGh0bWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFlbGVtZW50LmlubmVySFRNTCkge1xyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGltaXQgPSAobG93LCBhY3R1YWwsIGhpZ2gpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGFjdHVhbCwgaGlnaCksIGxvdyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gKF9iID0gKF9hID0gbWV0YS5wb3NpdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnhPZmZzZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IChfZCA9IChfYyA9IG1ldGEucG9zaXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy55T2Zmc2V0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXNFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IG5haXZlTGVmdCA9IGNhbnZhc1JlY3QubGVmdCArIG1ldGEub2Zmc2V0WCAtIGVsZW1lbnQuY2xpZW50V2lkdGggLyAyICsgeE9mZnNldDtcclxuICAgICAgICBjb25zdCBuYWl2ZVRvcCA9IGNhbnZhc1JlY3QudG9wICsgbWV0YS5vZmZzZXRZIC0gZWxlbWVudC5jbGllbnRIZWlnaHQgLSA4ICsgeU9mZnNldDtcclxuICAgICAgICBjb25zdCB3aW5kb3dCb3VuZHMgPSB0aGlzLmdldFdpbmRvd0JvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgY29uc3QgbWF4TGVmdCA9IHdpbmRvd0JvdW5kcy54ICsgd2luZG93Qm91bmRzLndpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCAtIDE7XHJcbiAgICAgICAgY29uc3QgbWF4VG9wID0gd2luZG93Qm91bmRzLnkgKyB3aW5kb3dCb3VuZHMuaGVpZ2h0IC0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IGxpbWl0KHdpbmRvd0JvdW5kcy54LCBuYWl2ZUxlZnQsIG1heExlZnQpO1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IGxpbWl0KHdpbmRvd0JvdW5kcy55LCBuYWl2ZVRvcCwgbWF4VG9wKTtcclxuICAgICAgICBjb25zdCBjb25zdHJhaW5lZCA9IGxlZnQgIT09IG5haXZlTGVmdCB8fCB0b3AgIT09IG5haXZlVG9wO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTaG93QXJyb3cgPSAhY29uc3RyYWluZWQgJiYgIXhPZmZzZXQgJiYgIXlPZmZzZXQ7XHJcbiAgICAgICAgY29uc3Qgc2hvd0Fycm93ID0gKF9mID0gKF9lID0gbWV0YS5zaG93QXJyb3cpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMuc2hvd0Fycm93KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBkZWZhdWx0U2hvd0Fycm93O1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2hvd0Fycm93KHNob3dBcnJvdyk7XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7TWF0aC5yb3VuZChsZWZ0KX1weCwgJHtNYXRoLnJvdW5kKHRvcCl9cHgpYDtcclxuICAgICAgICB0aGlzLmVuYWJsZUludGVyYWN0aW9uID0gKF9nID0gbWV0YS5lbmFibGVJbnRlcmFjdGlvbikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXkgPiAwICYmICFpbnN0YW50bHkpIHtcclxuICAgICAgICAgICAgdGhpcy50b2dnbGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLnNob3dUaW1lb3V0ID0gdGhpcy53aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZSh0cnVlKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50b2dnbGUodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXRXaW5kb3dCb3VuZGluZ0JveCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJCb3goMCwgMCwgdGhpcy53aW5kb3cuaW5uZXJXaWR0aCwgdGhpcy53aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgdG9nZ2xlKHZpc2libGUpIHtcclxuICAgICAgICBpZiAoIXZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZUNsYXNzKHZpc2libGUsIHRoaXMuX3Nob3dBcnJvdyk7XHJcbiAgICB9XHJcbiAgICBwb2ludGVyTGVmdE9udG9Ub29sdGlwKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVJbnRlcmFjdGlvbilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IChfYSA9IGV2ZW50LnNvdXJjZUV2ZW50LnJlbGF0ZWRUYXJnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3Q7XHJcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IFsnJywgJy10aXRsZScsICctY29udGVudCddO1xyXG4gICAgICAgIGNvbnN0IGNsYXNzTGlzdENvbnRhaW5zID0gQm9vbGVhbihjbGFzc2VzLmZpbHRlcigoYykgPT4gY2xhc3NMaXN0ID09PSBudWxsIHx8IGNsYXNzTGlzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NMaXN0LmNvbnRhaW5zKGAke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30ke2N9YCkpKTtcclxuICAgICAgICByZXR1cm4gY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQgJiYgY2xhc3NMaXN0Q29udGFpbnM7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTaG93QXJyb3coc2hvdykge1xyXG4gICAgICAgIHRoaXMuX3Nob3dBcnJvdyA9IHNob3c7XHJcbiAgICB9XHJcbn1cclxuVG9vbHRpcC50b29sdGlwRG9jdW1lbnRzID0gW107XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQk9PTEVBTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9CT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJzaG93QXJyb3dcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImNsYXNzXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZGVsYXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJyYW5nZVwiLCB2b2lkIDApO1xuXG5jbGFzcyBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB2b2lkIDApO1xyXG5jbGFzcyBTZXJpZXNUb29sdGlwIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaG93QXJyb3cgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mb3JtYXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uID0gbmV3IFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVG9vbHRpcFBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbiAgICB0b1Rvb2x0aXBIdG1sKGRlZmF1bHRzLCBwYXJhbXMsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0Rm4gPSAoX2EgPSBvdmVycmlkZXMgPT09IG51bGwgfHwgb3ZlcnJpZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZXMuZm9ybWF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmZvcm1hdDtcclxuICAgICAgICBjb25zdCByZW5kZXJlckZuID0gKF9iID0gb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLnJlbmRlcmVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIGlmIChmb3JtYXRGbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9Ub29sdGlwSHRtbCh7IGNvbnRlbnQ6IGludGVycG9sYXRlKGZvcm1hdEZuLCBwYXJhbXMpIH0sIGRlZmF1bHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbmRlcmVyRm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvVG9vbHRpcEh0bWwocmVuZGVyZXJGbihwYXJhbXMpLCBkZWZhdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b1Rvb2x0aXBIdG1sKGRlZmF1bHRzKTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9CT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJzaG93QXJyb3dcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9GVU5DVElPTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHZvaWQgMCk7XG5cbmZ1bmN0aW9uIHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoaW5pdGlhbExvYWQsIHJvdGF0aW9uRGVncmVlcywgc2NhbGVGbiwgb2xkU2NhbGVGbikge1xyXG4gICAgY29uc3Qgc2NhbGUgPSBbc2NhbGVGbi5jb252ZXJ0KDApLCBzY2FsZUZuLmNvbnZlcnQoMSldO1xyXG4gICAgY29uc3Qgb2xkU2NhbGUgPSBbb2xkU2NhbGVGbi5jb252ZXJ0KDApLCBvbGRTY2FsZUZuLmNvbnZlcnQoMSldO1xyXG4gICAgY29uc3Qgcm90YXRpb24gPSBNYXRoLlBJIC8gLTIgKyB0b1JhZGlhbnMocm90YXRpb25EZWdyZWVzKTtcclxuICAgIGNvbnN0IHNjYWxlVG9OZXdSYWRpdXMgPSAoeyByYWRpdXMgfSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7IGlubmVyUmFkaXVzOiBzY2FsZVswXSwgb3V0ZXJSYWRpdXM6IHNjYWxlWzBdICsgKHNjYWxlWzFdIC0gc2NhbGVbMF0pICogcmFkaXVzIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2NhbGVUb09sZFJhZGl1cyA9ICh7IHJhZGl1cyB9KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHsgaW5uZXJSYWRpdXM6IG9sZFNjYWxlWzBdLCBvdXRlclJhZGl1czogb2xkU2NhbGVbMF0gKyAob2xkU2NhbGVbMV0gLSBvbGRTY2FsZVswXSkgKiByYWRpdXMgfTtcclxuICAgIH07XHJcbiAgICBjb25zdCBmcm9tRm4gPSAoc2VjdCwgZGF0dW0sIHN0YXR1cywgeyBwcmV2RnJvbVByb3BzIH0pID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgICAgICAvLyBEZWZhdWx0IHRvIHN0YXJ0aW5nIGZyb20gY3VycmVudCBzdGF0ZS5cclxuICAgICAgICBsZXQgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0O1xyXG4gICAgICAgIGxldCB7IGZpbGwsIHN0cm9rZSB9ID0gZGF0dW0uc2VjdG9yRm9ybWF0O1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICd1bmtub3duJyB8fCAoc3RhdHVzID09PSAnYWRkZWQnICYmICFwcmV2RnJvbVByb3BzKSkge1xyXG4gICAgICAgICAgICAvLyBTdGFydCBvZiBhbmltYXRpb24gKGZ1bGwgbmV3IGRhdGEpIC0gc3dlZXAgaW4uXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgZW5kQW5nbGUgPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgaW5uZXJSYWRpdXMgPSBkYXR1bS5pbm5lclJhZGl1cztcclxuICAgICAgICAgICAgb3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAnYWRkZWQnICYmIHByZXZGcm9tUHJvcHMpIHtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IChfYSA9IHByZXZGcm9tUHJvcHMuZW5kQW5nbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJvdGF0aW9uO1xyXG4gICAgICAgICAgICBlbmRBbmdsZSA9IChfYiA9IHByZXZGcm9tUHJvcHMuZW5kQW5nbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHJvdGF0aW9uO1xyXG4gICAgICAgICAgICBpbm5lclJhZGl1cyA9IChfYyA9IHByZXZGcm9tUHJvcHMuaW5uZXJSYWRpdXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRhdHVtLmlubmVyUmFkaXVzO1xyXG4gICAgICAgICAgICBvdXRlclJhZGl1cyA9IChfZCA9IHByZXZGcm9tUHJvcHMub3V0ZXJSYWRpdXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRhdHVtLm91dGVyUmFkaXVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnYWRkZWQnICYmICFpbml0aWFsTG9hZCkge1xyXG4gICAgICAgICAgICBjb25zdCByYWRpaSA9IHNjYWxlVG9PbGRSYWRpdXMoZGF0dW0pO1xyXG4gICAgICAgICAgICBpbm5lclJhZGl1cyA9IHJhZGlpLmlubmVyUmFkaXVzO1xyXG4gICAgICAgICAgICBvdXRlclJhZGl1cyA9IHJhZGlpLm91dGVyUmFkaXVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdHVzID09PSAndXBkYXRlZCcpIHtcclxuICAgICAgICAgICAgZmlsbCA9IChfZSA9IHNlY3QuZmlsbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmlsbDtcclxuICAgICAgICAgICAgc3Ryb2tlID0gKF9mID0gc2VjdC5zdHJva2UpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHN0cm9rZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZmlsbCwgc3Ryb2tlIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdG9GbiA9IChfc2VjdCwgZGF0dW0sIHN0YXR1cywgeyBwcmV2TGl2ZSB9KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAvLyBEZWZhdWx0IHRvIG1vdmluZyB0byB0YXJnZXQgc3RhdGUuXHJcbiAgICAgICAgbGV0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XHJcbiAgICAgICAgY29uc3QgeyBzdHJva2UsIGZpbGwgfSA9IGRhdHVtLnNlY3RvckZvcm1hdDtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAncmVtb3ZlZCcgJiYgcHJldkxpdmUpIHtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IChfYSA9IHByZXZMaXZlLmRhdHVtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kQW5nbGU7XHJcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gKF9iID0gcHJldkxpdmUuZGF0dW0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lbmRBbmdsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAncmVtb3ZlZCcgJiYgIXByZXZMaXZlKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgZW5kQW5nbGUgPSByb3RhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlbW92ZWQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGlpID0gc2NhbGVUb05ld1JhZGl1cyhkYXR1bSk7XHJcbiAgICAgICAgICAgIGlubmVyUmFkaXVzID0gcmFkaWkuaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgICAgIG91dGVyUmFkaXVzID0gcmFkaWkub3V0ZXJSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIHN0cm9rZSwgZmlsbCB9O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGlubmVyQ2lyY2xlID0ge1xyXG4gICAgICAgIGZyb21GbjogKG5vZGUsIF9kYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgcmV0dXJuIHsgc2l6ZTogKF9jID0gKF9iID0gKF9hID0gbm9kZS5wcmV2aW91c0RhdHVtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmFkaXVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBub2RlLnNpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvRm46IChfbm9kZSwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4geyBzaXplOiAoX2EgPSBkYXR1bS5yYWRpdXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAgfTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiB7IG5vZGVzOiB7IHRvRm4sIGZyb21GbiB9LCBpbm5lckNpcmNsZSB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0UGllU2VsZWN0aW9uc0ZuKF9ub2RlLCBkYXR1bSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdGFydEFuZ2xlOiBkYXR1bS5zdGFydEFuZ2xlLFxyXG4gICAgICAgIGVuZEFuZ2xlOiBkYXR1bS5lbmRBbmdsZSxcclxuICAgICAgICBpbm5lclJhZGl1czogZGF0dW0uaW5uZXJSYWRpdXMsXHJcbiAgICAgICAgb3V0ZXJSYWRpdXM6IGRhdHVtLm91dGVyUmFkaXVzLFxyXG4gICAgICAgIGZpbGw6IGRhdHVtLnNlY3RvckZvcm1hdC5maWxsLFxyXG4gICAgICAgIHN0cm9rZTogZGF0dW0uc2VjdG9yRm9ybWF0LnN0cm9rZSxcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSBwZXItbm9kZSByZXNldC5cclxuICpcclxuICogQHBhcmFtIHNlbGVjdGlvbnMgY29udGFpbnMgbm9kZXMgdG8gYmUgcmVzZXRcclxuICogQHBhcmFtIHByb3BzRm4gY2FsbGJhY2sgdG8gZGV0ZXJtaW5lIHBlci1ub2RlIHByb3BlcnRpZXNcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0TW90aW9uKHNlbGVjdGlvbnNPck5vZGVzLCBwcm9wc0ZuKSB7XHJcbiAgICBjb25zdCBpc05vZGVzID0gaXNOb2RlQXJyYXkoc2VsZWN0aW9uc09yTm9kZXMpO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBpc05vZGVzID8gc2VsZWN0aW9uc09yTm9kZXMgOiBbXTtcclxuICAgIGNvbnN0IHNlbGVjdGlvbnMgPSAhaXNOb2RlcyA/IHNlbGVjdGlvbnNPck5vZGVzIDogW107XHJcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwcm9wc0ZuKG5vZGUsIG5vZGUuZGF0dW0pO1xyXG4gICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoZnJvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICBjb25zdCBmcm9tID0gcHJvcHNGbihub2RlLCBub2RlLmRhdHVtKTtcclxuICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoZnJvbSk7XHJcbiAgICB9XHJcbn1cblxudmFyIHJlc2V0TW90aW9uJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHJlc2V0TW90aW9uOiByZXNldE1vdGlvblxufSk7XG5cbmNsYXNzIFN0YXRlTWFjaGluZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsU3RhdGUsIHN0YXRlcywgcHJlVHJhbnNpdGlvbkNiKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XHJcbiAgICAgICAgdGhpcy5wcmVUcmFuc2l0aW9uQ2IgPSBwcmVUcmFuc2l0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCAnYW5pbWF0aW9uJyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcclxuICAgICAgICB0aGlzLmRlYnVnKGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8IGluaXQgLT4gJHtpbml0aWFsU3RhdGV9YCwgJ2NvbG9yOiBncmVlbicpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNpdGlvbihldmVudCwgZGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlQ29uZmlnID0gdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZV07XHJcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25UcmFuc2l0aW9uID0gY3VycmVudFN0YXRlQ29uZmlnID09PSBudWxsIHx8IGN1cnJlbnRTdGF0ZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFN0YXRlQ29uZmlnW2V2ZW50XTtcclxuICAgICAgICBpZiAoIWRlc3RpbmF0aW9uVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8ICR7dGhpcy5zdGF0ZX0gLT4gJHtldmVudH0gLT4gJHt0aGlzLnN0YXRlfWAsICdjb2xvcjogZ3JleScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkZXN0aW5hdGlvblN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uVHJhbnNpdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZGVzdGluYXRpb25TdGF0ZSA9IGRlc3RpbmF0aW9uVHJhbnNpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uVHJhbnNpdGlvbiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZGVzdGluYXRpb25TdGF0ZSA9IGRlc3RpbmF0aW9uVHJhbnNpdGlvbi50YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVidWcoYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgJHt0aGlzLnN0YXRlfSAtPiAke2V2ZW50fSAtPiAke2Rlc3RpbmF0aW9uU3RhdGV9YCwgJ2NvbG9yOiBncmVlbicpO1xyXG4gICAgICAgIChfYSA9IHRoaXMucHJlVHJhbnNpdGlvbkNiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB0aGlzLnN0YXRlLCBkZXN0aW5hdGlvblN0YXRlKTtcclxuICAgICAgICAvLyBDaGFuZ2UgdGhlIHN0YXRlIGJlZm9yZSBjYWxsaW5nIHRoZSB0cmFuc2l0aW9uIGFjdGlvbiB0byBhbGxvdyB0aGUgYWN0aW9uIHRvIHRyaWdnZXIgYSBzdWJzZXF1ZW50IHRyYW5zaXRpb25cclxuICAgICAgICB0aGlzLnN0YXRlID0gZGVzdGluYXRpb25TdGF0ZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uVHJhbnNpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBkZXN0aW5hdGlvblRyYW5zaXRpb24oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZXN0aW5hdGlvblRyYW5zaXRpb24gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIChfYiA9IGRlc3RpbmF0aW9uVHJhbnNpdGlvbi5hY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGRlc3RpbmF0aW9uVHJhbnNpdGlvbiwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIERhdGFNb2RlbFNlcmllcyBleHRlbmRzIFNlcmllcyB7XHJcbiAgICBpc0NvbnRpbnVvdXMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBpc0NvbnRpbnVvdXNYID0gQ29udGludW91c1NjYWxlLmlzKChfYSA9IHRoaXMuYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2FsZSk7XHJcbiAgICAgICAgY29uc3QgaXNDb250aW51b3VzWSA9IENvbnRpbnVvdXNTY2FsZS5pcygoX2IgPSB0aGlzLmF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NhbGUpO1xyXG4gICAgICAgIHJldHVybiB7IGlzQ29udGludW91c1gsIGlzQ29udGludW91c1kgfTtcclxuICAgIH1cclxuICAgIC8vIFJlcXVlc3QgZGF0YSwgYnV0IHdpdGggbWVzc2FnZSBkaXNwYXRjaGluZyB0byBzZXJpZXMtb3B0aW9ucyAobW9kdWxlcykuXHJcbiAgICByZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCBvcHRzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIE1lcmdlIHByb3BlcnRpZXMgb2YgdGhpcyBzZXJpZXMgd2l0aCBwcm9wZXJ0aWVzIG9mIGFsbCB0aGUgYXR0YWNoZWQgc2VyaWVzLW9wdGlvbnNcclxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBvcHRzLnByb3BzO1xyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lclByb3BzID0gKF9hID0gdGhpcy5kaXNwYXRjaCgnZGF0YS1wcmVyZXF1ZXN0JywgdGhpcy5pc0NvbnRpbnVvdXMoKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vcmVQcm9wcyBvZiBsaXN0ZW5lclByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKC4uLm1vcmVQcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHlpZWxkIGRhdGFDb250cm9sbGVyLnJlcXVlc3QodGhpcy5pZCwgZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDogW10sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgcHJvcHMgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbCA9IGRhdGFNb2RlbDtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWREYXRhID0gcHJvY2Vzc2VkRGF0YTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgnZGF0YS1wcm9jZXNzZWQnLCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdHMgPSAoX2IgPSAoX2EgPSB0aGlzLnByb2Nlc3NlZERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWR1Y2VkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYW5pbWF0aW9uVmFsaWRhdGlvbjtcclxuICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHRzKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IG9yZGVyZWRLZXlzLCB1bmlxdWVLZXlzIH0gPSB2YWxpZGF0aW9uUmVzdWx0cztcclxuICAgICAgICByZXR1cm4gISFvcmRlcmVkS2V5cyAmJiAhIXVuaXF1ZUtleXM7XHJcbiAgICB9XHJcbiAgICBjaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFBvbGFyU2VyaWVzIGV4dGVuZHMgRGF0YU1vZGVsU2VyaWVzIHtcclxuICAgIGNvbnN0cnVjdG9yKF9hKSB7XHJcbiAgICAgICAgdmFyIHsgdXNlTGFiZWxMYXllciA9IGZhbHNlLCBwaWNrTW9kZXMgPSBbU2VyaWVzTm9kZVBpY2tNb2RlLkVYQUNUX1NIQVBFX01BVENIXSwgY2FuSGF2ZUF4ZXMgPSBmYWxzZSwgYW5pbWF0aW9uUmVzZXRGbnMgfSA9IF9hLCBvcHRzID0gX19yZXN0KF9hLCBbXCJ1c2VMYWJlbExheWVyXCIsIFwicGlja01vZGVzXCIsIFwiY2FuSGF2ZUF4ZXNcIiwgXCJhbmltYXRpb25SZXNldEZuc1wiXSk7XHJcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyB1c2VMYWJlbExheWVyLFxyXG4gICAgICAgICAgICBwaWNrTW9kZXMsIGNvbnRlbnRHcm91cFZpcnR1YWw6IGZhbHNlLCBkaXJlY3Rpb25LZXlzOiB7XHJcbiAgICAgICAgICAgICAgICBbQ2hhcnRBeGlzRGlyZWN0aW9uLlhdOiBbJ2FuZ2xlS2V5J10sXHJcbiAgICAgICAgICAgICAgICBbQ2hhcnRBeGlzRGlyZWN0aW9uLlldOiBbJ3JhZGl1c0tleSddLFxyXG4gICAgICAgICAgICB9LCBkaXJlY3Rpb25OYW1lczoge1xyXG4gICAgICAgICAgICAgICAgW0NoYXJ0QXhpc0RpcmVjdGlvbi5YXTogWydhbmdsZU5hbWUnXSxcclxuICAgICAgICAgICAgICAgIFtDaGFydEF4aXNEaXJlY3Rpb24uWV06IFsncmFkaXVzTmFtZSddLFxyXG4gICAgICAgICAgICB9LCBjYW5IYXZlQXhlcyB9KSk7XHJcbiAgICAgICAgdGhpcy5zZWN0b3JHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCgpKTtcclxuICAgICAgICB0aGlzLml0ZW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuc2VjdG9yR3JvdXAsICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMubGFiZWxHcm91cCwgVGV4dCwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmhpZ2hsaWdodEdyb3VwLCAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjZW50ZXIgb2YgdGhlIHBvbGFyIHNlcmllcyAoZm9yIGV4YW1wbGUsIHRoZSBjZW50ZXIgb2YgYSBwaWUpLlxyXG4gICAgICAgICAqIElmIHRoZSBwb2xhciBjaGFydCBoYXMgbXVsdGlwbGUgc2VyaWVzLCBhbGwgb2YgdGhlbSB3aWxsIGhhdmUgdGhlaXJcclxuICAgICAgICAgKiBjZW50ZXIgc2V0IHRvIHRoZSBzYW1lIHZhbHVlIGFzIGEgcmVzdWx0IG9mIHRoZSBwb2xhciBjaGFydCBsYXlvdXQuXHJcbiAgICAgICAgICogVGhlIGNlbnRlciBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvc2VkIHRvIGJlIHNldCBieSB0aGUgdXNlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNlbnRlclggPSAwO1xyXG4gICAgICAgIHRoaXMuY2VudGVyWSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1heGltdW0gcmFkaXVzIHRoZSBzZXJpZXMgY2FuIHVzZS5cclxuICAgICAgICAgKiBUaGlzIHZhbHVlIGlzIHNldCBhdXRvbWF0aWNhbGx5IGFzIGEgcmVzdWx0IG9mIHRoZSBwb2xhciBjaGFydCBsYXlvdXRcclxuICAgICAgICAgKiBhbmQgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHNldCBieSB0aGUgdXNlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XHJcbiAgICAgICAgdGhpcy5zZWN0b3JHcm91cC56SW5kZXhTdWJPcmRlciA9IFsoKSA9PiB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyLCAxXTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zID0gYW5pbWF0aW9uUmVzZXRGbnM7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoJ2VtcHR5Jywge1xyXG4gICAgICAgICAgICBlbXB0eToge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAncmVhZHknLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWFkeToge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YTogJ3dhaXRpbmcnLFxyXG4gICAgICAgICAgICAgICAgY2xlYXI6ICdjbGVhcmluZycsXHJcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQ6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSxcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hcmtlcnM6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSksXHJcbiAgICAgICAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2FpdGluZzoge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAncmVhZHknLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsZWFyaW5nOiB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdlbXB0eScsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSwgKCkgPT4gdGhpcy5jaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0TGFiZWxEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVzZXRBbGxBbmltYXRpb24oKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgaXRlbSwgbGFiZWwgfSA9IChfYSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xyXG4gICAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXNldE1vdGlvbihbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbl0sIGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgcmVzZXRNb3Rpb24oW3RoaXMubGFiZWxTZWxlY3Rpb25dLCBsYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5jbGVhbnVwKCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5jbGVhbnVwKCk7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24uY2xlYW51cCgpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcclxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcclxuICAgICAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KF9kYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KF9kYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgaXRlbSB9ID0gKF9hID0gdGhpcy5hbmltYXRpb25SZXNldEZucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmVzZXRNb3Rpb24oW3RoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uXSwgaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhfZGF0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IGZvciBzdWItY2xhc3Nlcy5cclxuICAgIH1cclxuICAgIGFuaW1hdGVSZWFkeVJlc2l6ZShfZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KF9kYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0aW9uVHJhbnNpdGlvbkNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbignY2xlYXInLCB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbmltYXRpb25EYXRhKHNlcmllc1JlY3QpIHtcclxuICAgICAgICByZXR1cm4geyBzZXJpZXNSZWN0IH07XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUGllU2VyaWVzTm9kZUNsaWNrRXZlbnQgZXh0ZW5kcyBTZXJpZXNOb2RlQ2xpY2tFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xyXG4gICAgICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcclxuICAgICAgICB0aGlzLmFuZ2xlS2V5ID0gc2VyaWVzLmFuZ2xlS2V5O1xyXG4gICAgICAgIHRoaXMucmFkaXVzS2V5ID0gc2VyaWVzLnJhZGl1c0tleTtcclxuICAgICAgICB0aGlzLmNhbGxvdXRMYWJlbEtleSA9IHNlcmllcy5jYWxsb3V0TGFiZWxLZXk7XHJcbiAgICAgICAgdGhpcy5zZWN0b3JMYWJlbEtleSA9IHNlcmllcy5zZWN0b3JMYWJlbEtleTtcclxuICAgIH1cclxufVxyXG52YXIgUGllTm9kZVRhZztcclxuKGZ1bmN0aW9uIChQaWVOb2RlVGFnKSB7XHJcbiAgICBQaWVOb2RlVGFnW1BpZU5vZGVUYWdbXCJTZWN0b3JcIl0gPSAwXSA9IFwiU2VjdG9yXCI7XHJcbiAgICBQaWVOb2RlVGFnW1BpZU5vZGVUYWdbXCJDYWxsb3V0XCJdID0gMV0gPSBcIkNhbGxvdXRcIjtcclxuICAgIFBpZU5vZGVUYWdbUGllTm9kZVRhZ1tcIkxhYmVsXCJdID0gMl0gPSBcIkxhYmVsXCI7XHJcbn0pKFBpZU5vZGVUYWcgfHwgKFBpZU5vZGVUYWcgPSB7fSkpO1xyXG5jbGFzcyBQaWVTZXJpZXNDYWxsb3V0TGFiZWwgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMzsgLy8gZnJvbSB0aGUgY2FsbG91dCBsaW5lXHJcbiAgICAgICAgdGhpcy5taW5BbmdsZSA9IDA7IC8vIGluIGRlZ3JlZXNcclxuICAgICAgICB0aGlzLm1pblNwYWNpbmcgPSA0O1xyXG4gICAgICAgIHRoaXMubWF4Q29sbGlzaW9uT2Zmc2V0ID0gNTA7XHJcbiAgICAgICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1pbkFuZ2xlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtYXhDb2xsaXNpb25PZmZzZXRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIHZvaWQgMCk7XHJcbmNsYXNzIFBpZVNlcmllc1NlY3RvckxhYmVsIGV4dGVuZHMgTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uUmF0aW8gPSAwLjU7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFBpZVNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvbk9mZnNldFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDAsIDEpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFBpZVNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvblJhdGlvXCIsIHZvaWQgMCk7XHJcbmNsYXNzIFBpZVNlcmllc0NhbGxvdXRMaW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTA7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HX0FSUkFZKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgUGllU2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFBpZVNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgdm9pZCAwKTtcclxuY2xhc3MgUGllVGl0bGUgZXh0ZW5kcyBDYXB0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5zaG93SW5MZWdlbmQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGllVGl0bGUucHJvdG90eXBlLCBcInNob3dJbkxlZ2VuZFwiLCB2b2lkIDApO1xyXG5jbGFzcyBEb3VnaG51dElubmVyTGFiZWwgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudGV4dCA9ICcnO1xyXG4gICAgICAgIHRoaXMubWFyZ2luID0gMjtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFNUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBEb3VnaG51dElubmVyTGFiZWwucHJvdG90eXBlLCBcInRleHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIERvdWdobnV0SW5uZXJMYWJlbC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XHJcbmNsYXNzIERvdWdobnV0SW5uZXJDaXJjbGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5maWxsID0gJ3RyYW5zcGFyZW50JztcclxuICAgICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKENPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBEb3VnaG51dElubmVyQ2lyY2xlLnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBEb3VnaG51dElubmVyQ2lyY2xlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCB2b2lkIDApO1xyXG5jbGFzcyBQaWVTZXJpZXMgZXh0ZW5kcyBQb2xhclNlcmllcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcclxuICAgICAgICBzdXBlcih7XHJcbiAgICAgICAgICAgIG1vZHVsZUN0eCxcclxuICAgICAgICAgICAgdXNlTGFiZWxMYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHsgaXRlbTogcmVzZXRQaWVTZWxlY3Rpb25zRm4sIGxhYmVsOiByZXNldExhYmVsRm4gfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnJhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XHJcbiAgICAgICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyB0aGUgYmFja2dyb3VuZCBncmFwaGljcy5cclxuICAgICAgICB0aGlzLmJhY2tncm91bmRHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7XHJcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWJhY2tncm91bmRgLFxyXG4gICAgICAgICAgICBsYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgekluZGV4OiBMYXllcnMuU0VSSUVTX0JBQ0tHUk9VTkRfWklOREVYLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLmlubmVydENpcmNsZUdyb3VwID0gdGhpcy5iYWNrZ3JvdW5kR3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0taW5uZXJDaXJjbGVgIH0pKTtcclxuICAgICAgICB0aGlzLm5vZGVEYXRhID0gW107XHJcbiAgICAgICAgLy8gV2hlbiBhIHVzZXIgdG9nZ2xlcyBhIHNlcmllcyBpdGVtIChlLmcuIGZyb20gdGhlIGxlZ2VuZCksIGl0cyBib29sZWFuIHN0YXRlIGlzIHJlY29yZGVkIGhlcmUuXHJcbiAgICAgICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZCA9IFtdO1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jYWxsb3V0TGFiZWwgPSBuZXcgUGllU2VyaWVzQ2FsbG91dExhYmVsKCk7XHJcbiAgICAgICAgdGhpcy5zZWN0b3JMYWJlbCA9IG5ldyBQaWVTZXJpZXNTZWN0b3JMYWJlbCgpO1xyXG4gICAgICAgIHRoaXMuY2FsbG91dExpbmUgPSBuZXcgUGllU2VyaWVzQ2FsbG91dExpbmUoKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBrZXkgb2YgdGhlIG51bWVyaWMgZmllbGQgdG8gdXNlIHRvIGRldGVybWluZSB0aGUgYW5nbGUgKGZvciBleGFtcGxlLFxyXG4gICAgICAgICAqIGEgcGllIHNlY3RvciBhbmdsZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbmdsZUtleSA9ICcnO1xyXG4gICAgICAgIHRoaXMuYW5nbGVOYW1lID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbm5lckxhYmVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5uZXJDaXJjbGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGtleSBvZiB0aGUgbnVtZXJpYyBmaWVsZCB0byB1c2UgdG8gZGV0ZXJtaW5lIHRoZSByYWRpaSBvZiBwaWUgc2VjdG9ycy5cclxuICAgICAgICAgKiBUaGUgbGFyZ2VzdCB2YWx1ZSB3aWxsIGNvcnJlc3BvbmQgdG8gdGhlIGZ1bGwgcmFkaXVzIGFuZCBzbWFsbGVyIHZhbHVlcyB0b1xyXG4gICAgICAgICAqIHByb3BvcnRpb25hbGx5IHNtYWxsZXIgcmFkaWkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yYWRpdXNLZXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yYWRpdXNOYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucmFkaXVzTWluID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucmFkaXVzTWF4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FsbG91dExhYmVsS2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FsbG91dExhYmVsTmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnNlY3RvckxhYmVsS2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc2VjdG9yTGFiZWxOYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubGVnZW5kSXRlbUtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZpbGxzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX0ZJTExTKTtcclxuICAgICAgICB0aGlzLnN0cm9rZXMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfU1RST0tFUyk7XHJcbiAgICAgICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xyXG4gICAgICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzZXJpZXMgcm90YXRpb24gaW4gZGVncmVlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLm91dGVyUmFkaXVzT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLm91dGVyUmFkaXVzUmF0aW8gPSAxO1xyXG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXNPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXNSYXRpbyA9IDE7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5zaGFkb3cgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTdHlsZSA9IG5ldyBIaWdobGlnaHRTdHlsZSgpO1xyXG4gICAgICAgIHRoaXMuc3Vycm91bmRpbmdSYWRpdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5Ob2RlQ2xpY2tFdmVudCA9IFBpZVNlcmllc05vZGVDbGlja0V2ZW50O1xyXG4gICAgICAgIHRoaXMuYW5nbGVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xyXG4gICAgICAgIC8vIEVhY2ggc2VjdG9yIGlzIGEgcmF0aW8gb2YgdGhlIHdob2xlLCB3aGVyZSBhbGwgcmF0aW9zIGFkZCB1cCB0byAxLlxyXG4gICAgICAgIHRoaXMuYW5nbGVTY2FsZS5kb21haW4gPSBbMCwgMV07XHJcbiAgICAgICAgLy8gQWRkIDkwIGRlZyB0byBzdGFydCB0aGUgZmlyc3QgcGllIGF0IDEyIG8nY2xvY2suXHJcbiAgICAgICAgdGhpcy5hbmdsZVNjYWxlLnJhbmdlID0gWy1NYXRoLlBJLCBNYXRoLlBJXS5tYXAoKGFuZ2xlKSA9PiBhbmdsZSArIE1hdGguUEkgLyAyKTtcclxuICAgICAgICBjb25zdCBwaWVDYWxsb3V0TGFiZWxzID0gbmV3IEdyb3VwKHsgbmFtZTogJ3BpZUNhbGxvdXRMYWJlbHMnIH0pO1xyXG4gICAgICAgIGNvbnN0IHBpZVNlY3RvckxhYmVscyA9IG5ldyBHcm91cCh7IG5hbWU6ICdwaWVTZWN0b3JMYWJlbHMnIH0pO1xyXG4gICAgICAgIGNvbnN0IGlubmVyTGFiZWxzID0gbmV3IEdyb3VwKHsgbmFtZTogJ2lubmVyTGFiZWxzJyB9KTtcclxuICAgICAgICB0aGlzLmxhYmVsR3JvdXAuYXBwZW5kKHBpZUNhbGxvdXRMYWJlbHMpO1xyXG4gICAgICAgIHRoaXMubGFiZWxHcm91cC5hcHBlbmQocGllU2VjdG9yTGFiZWxzKTtcclxuICAgICAgICB0aGlzLmxhYmVsR3JvdXAuYXBwZW5kKGlubmVyTGFiZWxzKTtcclxuICAgICAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QocGllQ2FsbG91dExhYmVscywgR3JvdXApO1xyXG4gICAgICAgIHRoaXMuc2VjdG9yTGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHBpZVNlY3RvckxhYmVscywgVGV4dCk7XHJcbiAgICAgICAgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoaW5uZXJMYWJlbHMsIFRleHQpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuaW5uZXJ0Q2lyY2xlR3JvdXAsIENpcmNsZSk7XHJcbiAgICB9XHJcbiAgICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZExpc3RlbmVyKCdsZWdlbmQtaXRlbS1jbGljaycsIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1DbGljayhldmVudCkpO1xyXG4gICAgfVxyXG4gICAgdmlzaWJsZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzU2VyaWVzSXRlbUVuYWJsZWQoKTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NTZXJpZXNJdGVtRW5hYmxlZCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCB2aXNpYmxlIH0gPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSAoX2EgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWFwKCgpID0+IHZpc2libGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgIH1cclxuICAgIG5vZGVGYWN0b3J5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VjdG9yKCk7XHJcbiAgICB9XHJcbiAgICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVTY2FsZS5kb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYWRpdXNTY2FsZS5kb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGEgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYW5nbGVLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSwgc2VyaWVzSXRlbUVuYWJsZWQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChhbmdsZUtleSA9PSBudWxsIHx8IGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBleHRyYUtleVByb3BzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gT3JkZXIgaGVyZSBzaG91bGQgbWF0Y2ggYGdldERhdHVtSWRGcm9tRGF0YSgpYC5cclxuICAgICAgICAgICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eSh0aGlzLCBsZWdlbmRJdGVtS2V5LCBmYWxzZSwgeyBpZDogYGxlZ2VuZEl0ZW1LZXlgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eSh0aGlzLCBjYWxsb3V0TGFiZWxLZXksIGZhbHNlLCB7IGlkOiBgY2FsbG91dExhYmVsS2V5YCB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eSh0aGlzLCBzZWN0b3JMYWJlbEtleSwgZmFsc2UsIHsgaWQ6IGBzZWN0b3JMYWJlbEtleWAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyYWRpdXNLZXkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhUHJvcHMucHVzaChyYW5nZWRWYWx1ZVByb3BlcnR5KHRoaXMsIHJhZGl1c0tleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAncmFkaXVzVmFsdWUnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogKF9hID0gdGhpcy5yYWRpdXNNaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4OiB0aGlzLnJhZGl1c01heCxcclxuICAgICAgICAgICAgICAgIH0pLCB2YWx1ZVByb3BlcnR5KHRoaXMsIHJhZGl1c0tleSwgdHJ1ZSwgeyBpZDogYHJhZGl1c1Jhd2AgfSksIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXHJcbiAgICAgICAgICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKHRoaXMsIHsgaWQ6ICdyYWRpdXNWYWx1ZScgfSwgWzAsIDFdLCAxLCAoX2IgPSB0aGlzLnJhZGl1c01pbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCwgdGhpcy5yYWRpdXNNYXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FsbG91dExhYmVsS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eSh0aGlzLCBjYWxsb3V0TGFiZWxLZXksIGZhbHNlLCB7IGlkOiBgY2FsbG91dExhYmVsVmFsdWVgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KHRoaXMsIHNlY3RvckxhYmVsS2V5LCBmYWxzZSwgeyBpZDogYHNlY3RvckxhYmVsVmFsdWVgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGVnZW5kSXRlbUtleSkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkodGhpcywgbGVnZW5kSXRlbUtleSwgZmFsc2UsIHsgaWQ6IGBsZWdlbmRJdGVtVmFsdWVgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGEgJiYgZXh0cmFLZXlQcm9wcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYVByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbih0aGlzKSk7XHJcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLm1hcCgoZCwgaWR4KSA9PiAoc2VyaWVzSXRlbUVuYWJsZWRbaWR4XSA/IGQgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGQpLCB7IFthbmdsZUtleV06IDAgfSkpKTtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XHJcbiAgICAgICAgICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4dHJhS2V5UHJvcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eSh0aGlzLCBhbmdsZUtleSwgdHJ1ZSwgeyBpZDogYGFuZ2xlVmFsdWVgLCBvbmx5UG9zaXRpdmU6IHRydWUgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVQcm9wZXJ0eSh0aGlzLCBhbmdsZUtleSwgdHJ1ZSwgeyBpZDogYGFuZ2xlUmF3YCB9KSxcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKHRoaXMsIHsgaWQ6ICdhbmdsZVZhbHVlJyB9LCBbMCwgMV0sIDAsIDApLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4dHJhUHJvcHMsXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKCd1cGRhdGVEYXRhJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYXliZVJlZnJlc2hOb2RlRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBbeyBub2RlRGF0YSA9IFtdIH0gPSB7fV0gPSB5aWVsZCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZURhdGEgPSBub2RlRGF0YTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCkge1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZVZhbHVlYCkuaW5kZXg7XHJcbiAgICAgICAgY29uc3QgcmFkaXVzSWR4ID0gdGhpcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1ZhbHVlYCkuaW5kZXggOiAtMTtcclxuICAgICAgICBjb25zdCBjYWxsb3V0TGFiZWxJZHggPSB0aGlzLmNhbGxvdXRMYWJlbEtleVxyXG4gICAgICAgICAgICA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY2FsbG91dExhYmVsVmFsdWVgKS5pbmRleFxyXG4gICAgICAgICAgICA6IC0xO1xyXG4gICAgICAgIGNvbnN0IHNlY3RvckxhYmVsSWR4ID0gdGhpcy5zZWN0b3JMYWJlbEtleVxyXG4gICAgICAgICAgICA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgc2VjdG9yTGFiZWxWYWx1ZWApLmluZGV4XHJcbiAgICAgICAgICAgIDogLTE7XHJcbiAgICAgICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMubGVnZW5kSXRlbUtleVxyXG4gICAgICAgICAgICA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGVnZW5kSXRlbVZhbHVlYCkuaW5kZXhcclxuICAgICAgICAgICAgOiAtMTtcclxuICAgICAgICByZXR1cm4geyBhbmdsZUlkeCwgcmFkaXVzSWR4LCBjYWxsb3V0TGFiZWxJZHgsIHNlY3RvckxhYmVsSWR4LCBsZWdlbmRJdGVtSWR4IH07XHJcbiAgICB9XHJcbiAgICBjcmVhdGVOb2RlRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCByb3RhdGlvbiwgYW5nbGVTY2FsZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS50eXBlICE9PSAndW5ncm91cGVkJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgY29uc3QgeyBhbmdsZUlkeCwgcmFkaXVzSWR4LCBjYWxsb3V0TGFiZWxJZHgsIHNlY3RvckxhYmVsSWR4LCBsZWdlbmRJdGVtSWR4IH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RhcnQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlRGF0YSA9IHByb2Nlc3NlZERhdGEuZGF0YS5tYXAoKGdyb3VwLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBncm91cDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlc1thbmdsZUlkeF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXJ0ID0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFuID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHNwYW4gLyAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGVWYWx1ZSA9IHZhbHVlc1thbmdsZUlkeCArIDFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzSWR4ID49IDAgPyAoX2EgPSB2YWx1ZXNbcmFkaXVzSWR4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSA6IDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpdXNWYWx1ZSA9IHJhZGl1c0lkeCA+PSAwID8gdmFsdWVzW3JhZGl1c0lkeCArIDFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVnZW5kSXRlbVZhbHVlID0gbGVnZW5kSXRlbUlkeCA+PSAwID8gdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoZGF0dW0sIG1pZEFuZ2xlLCBzcGFuLCB0cnVlLCB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSwgdmFsdWVzW3NlY3RvckxhYmVsSWR4XSwgbGVnZW5kSXRlbVZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBpbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBpdGVtSWQ6IGluZGV4LCBzZXJpZXM6IHRoaXMsIGRhdHVtLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlkQW5nbGUsIG1pZENvczogTWF0aC5jb3MobWlkQW5nbGUpLCBtaWRTaW46IE1hdGguc2luKG1pZEFuZ2xlKSwgc3RhcnRBbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBzZWN0b3JGb3JtYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzLCBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSwgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChyYWRpdXMpLCAwKSwgbGVnZW5kSXRlbVZhbHVlIH0sIGxhYmVscyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gW3sgaXRlbUlkOiBzZXJpZXNJZCwgbm9kZURhdGEsIGxhYmVsRGF0YTogbm9kZURhdGEgfV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRMYWJlbHMoZGF0dW0sIG1pZEFuZ2xlLCBzcGFuLCBza2lwRGlzYWJsZWQsIGNhbGxvdXRMYWJlbFZhbHVlLCBzZWN0b3JMYWJlbFZhbHVlLCBsZWdlbmRJdGVtVmFsdWUpIHtcclxuICAgICAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgc2VjdG9yTGFiZWwsIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgY2FsbG91dExhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBjYWxsb3V0TGFiZWwuZW5hYmxlZCA/IHRoaXMuY2FsbG91dExhYmVsS2V5IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHNlY3RvckxhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBzZWN0b3JMYWJlbC5lbmFibGVkID8gdGhpcy5zZWN0b3JMYWJlbEtleSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoIWNhbGxvdXRMYWJlbEtleSAmJiAhc2VjdG9yTGFiZWxLZXkgJiYgIWxlZ2VuZEl0ZW1LZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsYWJlbEZvcm1hdHRlclBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZGF0dW0sXHJcbiAgICAgICAgICAgIGFuZ2xlS2V5OiB0aGlzLmFuZ2xlS2V5LFxyXG4gICAgICAgICAgICBhbmdsZU5hbWU6IHRoaXMuYW5nbGVOYW1lLFxyXG4gICAgICAgICAgICByYWRpdXNLZXk6IHRoaXMucmFkaXVzS2V5LFxyXG4gICAgICAgICAgICByYWRpdXNOYW1lOiB0aGlzLnJhZGl1c05hbWUsXHJcbiAgICAgICAgICAgIGNhbGxvdXRMYWJlbEtleTogdGhpcy5jYWxsb3V0TGFiZWxLZXksXHJcbiAgICAgICAgICAgIGNhbGxvdXRMYWJlbE5hbWU6IHRoaXMuY2FsbG91dExhYmVsTmFtZSxcclxuICAgICAgICAgICAgc2VjdG9yTGFiZWxLZXk6IHRoaXMuc2VjdG9yTGFiZWxLZXksXHJcbiAgICAgICAgICAgIHNlY3RvckxhYmVsTmFtZTogdGhpcy5zZWN0b3JMYWJlbE5hbWUsXHJcbiAgICAgICAgICAgIGxlZ2VuZEl0ZW1LZXk6IHRoaXMubGVnZW5kSXRlbUtleSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgc3BhbiA+IHRvUmFkaWFucyhjYWxsb3V0TGFiZWwubWluQW5nbGUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jYWxsb3V0TGFiZWwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSkpLCB7IHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KGNhbGxvdXRMYWJlbCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsYWJlbEZvcm1hdHRlclBhcmFtcyksIHsgdmFsdWU6IGNhbGxvdXRMYWJlbFZhbHVlIH0pKSwgaGlkZGVuOiBmYWxzZSwgY29sbGlzaW9uVGV4dEFsaWduOiB1bmRlZmluZWQsIGNvbGxpc2lvbk9mZnNldFk6IDAsIGJveDogdW5kZWZpbmVkIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnNlY3RvckxhYmVsID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoc2VjdG9yTGFiZWwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbGFiZWxGb3JtYXR0ZXJQYXJhbXMpLCB7IHZhbHVlOiBzZWN0b3JMYWJlbFZhbHVlIH0pKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCAmJiBsZWdlbmRJdGVtVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQubGVnZW5kSXRlbSA9IHsga2V5OiBsZWdlbmRJdGVtS2V5LCB0ZXh0OiBsZWdlbmRJdGVtVmFsdWUgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldFRleHRBbGlnbm1lbnQobWlkQW5nbGUpIHtcclxuICAgICAgICBjb25zdCBxdWFkcmFudFRleHRPcHRzID0gW1xyXG4gICAgICAgICAgICB7IHRleHRBbGlnbjogJ2NlbnRlcicsIHRleHRCYXNlbGluZTogJ2JvdHRvbScgfSxcclxuICAgICAgICAgICAgeyB0ZXh0QWxpZ246ICdsZWZ0JywgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyB9LFxyXG4gICAgICAgICAgICB7IHRleHRBbGlnbjogJ2NlbnRlcicsIHRleHRCYXNlbGluZTogJ2hhbmdpbmcnIH0sXHJcbiAgICAgICAgICAgIHsgdGV4dEFsaWduOiAncmlnaHQnLCB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnIH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBtaWRBbmdsZTE4MCA9IG5vcm1hbGl6ZUFuZ2xlMTgwKG1pZEFuZ2xlKTtcclxuICAgICAgICAvLyBTcGxpdCB0aGUgY2lyY2xlIGludG8gcXVhZHJhbnRzIGxpa2Ugc286IOKKl1xyXG4gICAgICAgIGNvbnN0IHF1YWRyYW50U3RhcnQgPSAoLTMgKiBNYXRoLlBJKSAvIDQ7IC8vIHNhbWUgYXMgYG5vcm1hbGl6ZUFuZ2xlMTgwKHRvUmFkaWFucygtMTM1KSlgXHJcbiAgICAgICAgY29uc3QgcXVhZHJhbnRPZmZzZXQgPSBtaWRBbmdsZTE4MCAtIHF1YWRyYW50U3RhcnQ7XHJcbiAgICAgICAgY29uc3QgcXVhZHJhbnQgPSBNYXRoLmZsb29yKHF1YWRyYW50T2Zmc2V0IC8gKE1hdGguUEkgLyAyKSk7XHJcbiAgICAgICAgY29uc3QgcXVhZHJhbnRJbmRleCA9IG1vZChxdWFkcmFudCwgcXVhZHJhbnRUZXh0T3B0cy5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBxdWFkcmFudFRleHRPcHRzW3F1YWRyYW50SW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBmb3JtYXRJbmRleCwgaGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgICAgICBjb25zdCB7IGFuZ2xlS2V5LCByYWRpdXNLZXksIGZpbGxzLCBzdHJva2VzLCBmb3JtYXR0ZXIsIGlkOiBzZXJpZXNJZCwgY3R4OiB7IGNhbGxiYWNrQ2FjaGUsIGhpZ2hsaWdodE1hbmFnZXIgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZWREYXR1bSA9IGhpZ2hsaWdodE1hbmFnZXIuZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgaXNEYXR1bUhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0ICYmIChoaWdobGlnaHRlZERhdHVtID09PSBudWxsIHx8IGhpZ2hsaWdodGVkRGF0dW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhpZ2hsaWdodGVkRGF0dW0uc2VyaWVzKSA9PT0gdGhpcyAmJiBmb3JtYXRJbmRleCA9PT0gaGlnaGxpZ2h0ZWREYXR1bS5pdGVtSWQ7XHJcbiAgICAgICAgY29uc3QgeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9ID0gbWVyZ2VEZWZhdWx0cyhpc0RhdHVtSGlnaGxpZ2h0ZWQgJiYgdGhpcy5oaWdobGlnaHRTdHlsZS5pdGVtLCB7XHJcbiAgICAgICAgICAgIGZpbGw6IGZpbGxzW2Zvcm1hdEluZGV4ICUgZmlsbHMubGVuZ3RoXSxcclxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMuZmlsbE9wYWNpdHksXHJcbiAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlc1tmb3JtYXRJbmRleCAlIHN0cm9rZXMubGVuZ3RoXSxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5zdHJva2VXaWR0aCksXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBmb3JtYXQ7XHJcbiAgICAgICAgaWYgKGZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoZm9ybWF0dGVyLCB7XHJcbiAgICAgICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgICAgIGFuZ2xlS2V5LFxyXG4gICAgICAgICAgICAgICAgcmFkaXVzS2V5LFxyXG4gICAgICAgICAgICAgICAgZmlsbCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZSxcclxuICAgICAgICAgICAgICAgIGZpbGxzLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlcyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWQ6IGlzRGF0dW1IaWdobGlnaHRlZCxcclxuICAgICAgICAgICAgICAgIHNlcmllc0lkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogKF9hID0gZm9ybWF0ID09PSBudWxsIHx8IGZvcm1hdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0LmZpbGwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGwsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAoX2IgPSBmb3JtYXQgPT09IG51bGwgfHwgZm9ybWF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXQuZmlsbE9wYWNpdHkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICBzdHJva2U6IChfYyA9IGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5zdHJva2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHN0cm9rZSxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IChfZCA9IGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5zdHJva2VXaWR0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogc3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IChfZSA9IGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5zdHJva2VPcGFjaXR5KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBzdHJva2VPcGFjaXR5LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXRJbm5lclJhZGl1cygpIHtcclxuICAgICAgICBjb25zdCB7IHJhZGl1cywgaW5uZXJSYWRpdXNSYXRpbywgaW5uZXJSYWRpdXNPZmZzZXQgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXMgKiBpbm5lclJhZGl1c1JhdGlvICsgaW5uZXJSYWRpdXNPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGlubmVyUmFkaXVzID09PSByYWRpdXMgfHwgaW5uZXJSYWRpdXMgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5uZXJSYWRpdXM7XHJcbiAgICB9XHJcbiAgICBnZXRPdXRlclJhZGl1cygpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yYWRpdXMgKiB0aGlzLm91dGVyUmFkaXVzUmF0aW8gKyB0aGlzLm91dGVyUmFkaXVzT2Zmc2V0LCAwKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IG5ld1JhbmdlID0gW3RoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgdGhpcy5nZXRPdXRlclJhZGl1cygpXTtcclxuICAgICAgICB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XHJcbiAgICAgICAgaWYgKHJlc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKChfYSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgeyByYWRpdXMgfSA9IF9hLCBkID0gX19yZXN0KF9hLCBbXCJyYWRpdXNcIl0pO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkKSwgeyByYWRpdXMsIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLCBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KHJhZGl1cyksIDApIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0VGl0bGVUcmFuc2xhdGlvblkoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMucmFkaXVzU2NhbGUucmFuZ2VbMV0pO1xyXG4gICAgICAgIGlmIChvdXRlclJhZGl1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzcGFjaW5nID0gKF9iID0gKF9hID0gdGhpcy50aXRsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwYWNpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgY29uc3QgdGl0bGVPZmZzZXQgPSAyICsgc3BhY2luZztcclxuICAgICAgICBjb25zdCBkeSA9IE1hdGgubWF4KDAsIC1vdXRlclJhZGl1cyk7XHJcbiAgICAgICAgcmV0dXJuIC1vdXRlclJhZGl1cyAtIHRpdGxlT2Zmc2V0IC0gZHk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IHtcclxuICAgICAgICAgICAgICAgIHNlcmllc1JlY3RXaWR0aDogc2VyaWVzUmVjdCA9PT0gbnVsbCB8fCBzZXJpZXNSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJpZXNSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzUmVjdEhlaWdodDogc2VyaWVzUmVjdCA9PT0gbnVsbCB8fCBzZXJpZXNSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJpZXNSZWN0LmhlaWdodCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcmVzaXplID0ganNvbkRpZmYodGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcywgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMpICE9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChyZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMgPSBuZXdOb2RlRGF0YURlcGVuZGVuY2llcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGl0bGVOb2RlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sYWJlbEdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aXRsZS5ub2RlLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgICAgICAgICB0aXRsZS5ub2RlLnZpc2libGUgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLmVuYWJsZWQgJiYgaXNGaW5pdGUoZHkpICYmICF0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXModGl0bGVCb3gsIDAsIGR5KTtcclxuICAgICAgICAgICAgICAgIHRpdGxlLm5vZGUudHJhbnNsYXRpb25ZID0gaXNGaW5pdGUoZHkpID8gZHkgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZU1pZFBvaW50KCk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlU2VsZWN0aW9ucygpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVGl0bGVOb2RlcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHsgdGl0bGUsIG9sZFRpdGxlIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmIChvbGRUaXRsZSAhPT0gdGl0bGUpIHtcclxuICAgICAgICAgICAgaWYgKG9sZFRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxhYmVsR3JvdXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChvbGRUaXRsZS5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlLm5vZGUudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmxhYmVsR3JvdXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hcHBlbmRDaGlsZCh0aXRsZS5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9sZFRpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlTm9kZU1pZFBvaW50KCkge1xyXG4gICAgICAgIHRoaXMubm9kZURhdGEuZm9yRWFjaCgoZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSBkLmlubmVyUmFkaXVzICsgKGQub3V0ZXJSYWRpdXMgLSBkLmlubmVyUmFkaXVzKSAvIDI7XHJcbiAgICAgICAgICAgIGQubWlkUG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBkLm1pZENvcyAqIE1hdGgubWF4KDAsIHJhZGl1cyksXHJcbiAgICAgICAgICAgICAgICB5OiBkLm1pZFNpbiAqIE1hdGgubWF4KDAsIHJhZGl1cyksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTZWxlY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlR3JvdXBTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbm5lckNpcmNsZVNlbGVjdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlR3JvdXBTZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIGNhbGxvdXRMYWJlbFNlbGVjdGlvbiwgc2VjdG9yTGFiZWxTZWxlY3Rpb24sIGlubmVyTGFiZWxzU2VsZWN0aW9uIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGUgPSAoc2VsZWN0aW9uLCBjbG9uZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChjbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IG11dGFibGUgc2VjdG9yRm9ybWF0LCBzbyBmb3JtYXR0ZWQgc2VjdG9yIHN0eWxlcyBjYW4gYmUgdXBkYXRlZCBhbmQgdmFyaWVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmV0d2VlbiBub3JtYWwgYW5kIGhpZ2hsaWdodGVkIGNhc2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVEYXRhID0gbm9kZURhdGEubWFwKChkYXR1bSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0dW0pLCB7IHNlY3RvckZvcm1hdDogT2JqZWN0LmFzc2lnbih7fSwgZGF0dW0uc2VjdG9yRm9ybWF0KSB9KSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHVwZGF0ZShpdGVtU2VsZWN0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHVwZGF0ZShoaWdobGlnaHRTZWxlY3Rpb24sIHRydWUpO1xyXG4gICAgICAgICAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMubm9kZURhdGEsIChncm91cCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IG5ldyBMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lLnRhZyA9IFBpZU5vZGVUYWcuQ2FsbG91dDtcclxuICAgICAgICAgICAgICAgIGxpbmUucG9pbnRlckV2ZW50cyA9IFBvaW50ZXJFdmVudHMuTm9uZTtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRhZyA9IFBpZU5vZGVUYWcuTGFiZWw7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSBQb2ludGVyRXZlbnRzLk5vbmU7XHJcbiAgICAgICAgICAgICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlY3RvckxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLm5vZGVEYXRhLCAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wb2ludGVyRXZlbnRzID0gUG9pbnRlckV2ZW50cy5Ob25lO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW5uZXJMYWJlbHNTZWxlY3Rpb24udXBkYXRlKHRoaXMuaW5uZXJMYWJlbHMsIChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBvaW50ZXJFdmVudHMgPSBQb2ludGVyRXZlbnRzLk5vbmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSW5uZXJDaXJjbGVTZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgY29uc3QgeyBpbm5lckNpcmNsZSB9ID0gdGhpcztcclxuICAgICAgICBsZXQgcmFkaXVzID0gMDtcclxuICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKTtcclxuICAgICAgICBpZiAoaW5uZXJSYWRpdXMgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IE1hdGgubWluKGlubmVyUmFkaXVzLCB0aGlzLmdldE91dGVyUmFkaXVzKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBhbnRpQWxpYXNpbmdQYWRkaW5nID0gMTtcclxuICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5jZWlsKGNpcmNsZVJhZGl1cyAqIDIgKyBhbnRpQWxpYXNpbmdQYWRkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0dW1zID0gaW5uZXJDaXJjbGUgPyBbeyByYWRpdXMgfV0gOiBbXTtcclxuICAgICAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLnVwZGF0ZShkYXR1bXMpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTm9kZXMoc2VyaWVzUmVjdCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodGVkRGF0dW0gPSB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLmdldEFjdGl2ZUhpZ2hsaWdodCgpO1xyXG4gICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmluZGV4T2YodHJ1ZSkgPj0gMDtcclxuICAgICAgICAgICAgdGhpcy5yb290R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlICYmIChoaWdobGlnaHRlZERhdHVtID09PSBudWxsIHx8IGhpZ2hsaWdodGVkRGF0dW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhpZ2hsaWdodGVkRGF0dW0uc2VyaWVzKSA9PT0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb250ZW50R3JvdXAub3BhY2l0eSA9IHRoaXMuZ2V0T3BhY2l0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLmVhY2goKG5vZGUsIHsgcmFkaXVzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IChfYSA9IHRoaXMuaW5uZXJDaXJjbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IChfYiA9IHRoaXMuaW5uZXJDaXJjbGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWxsT3BhY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplOiByYWRpdXMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVNlY3RvckZuID0gKHNlY3RvciwgZGF0dW0sIF9pbmRleCwgaXNEYXR1bUhpZ2hsaWdodGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bS5kYXR1bSwgZGF0dW0uaXRlbUlkLCBpc0RhdHVtSGlnaGxpZ2h0ZWQpO1xyXG4gICAgICAgICAgICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwgPSBmb3JtYXQuZmlsbDtcclxuICAgICAgICAgICAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRGlzYWJsZWQgPSB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdG9yLnN0YXJ0QW5nbGUgPSBkYXR1bS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rvci5lbmRBbmdsZSA9IGRhdHVtLmVuZEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rvci5pbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rvci5vdXRlclJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0dW1IaWdobGlnaHRlZCB8fCBhbmltYXRpb25EaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rvci5maWxsID0gZm9ybWF0LmZpbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdG9yLnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWN0b3Iuc3Ryb2tlV2lkdGggPSBmb3JtYXQuc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzZWN0b3IuZmlsbE9wYWNpdHkgPSBmb3JtYXQuZmlsbE9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBzZWN0b3Iuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIHNlY3Rvci5saW5lRGFzaCA9IHRoaXMubGluZURhc2g7XHJcbiAgICAgICAgICAgICAgICBzZWN0b3IubGluZURhc2hPZmZzZXQgPSB0aGlzLmxpbmVEYXNoT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgc2VjdG9yLmZpbGxTaGFkb3cgPSB0aGlzLnNoYWRvdztcclxuICAgICAgICAgICAgICAgIHNlY3Rvci5saW5lSm9pbiA9ICdyb3VuZCc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0RhdHVtSGlnaGxpZ2h0ZWQgPSAoaGlnaGxpZ2h0ZWREYXR1bSA9PT0gbnVsbCB8fCBoaWdobGlnaHRlZERhdHVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoaWdobGlnaHRlZERhdHVtLnNlcmllcykgPT09IHRoaXMgJiYgbm9kZS5kYXR1bS5pdGVtSWQgPT09IGhpZ2hsaWdodGVkRGF0dW0uaXRlbUlkO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBpc0RhdHVtSGlnaGxpZ2h0ZWQpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS52aXNpYmxlID0gaXNEYXR1bUhpZ2hsaWdodGVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWxsb3V0TGluZU5vZGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyTGFiZWxOb2RlcygpO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oJ3VwZGF0ZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2FsbG91dExpbmVOb2RlcygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBjYWxsb3V0TGluZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNhbGxvdXRTdHJva2VXaWR0aCA9IGNhbGxvdXRMaW5lLnN0cm9rZVdpZHRoO1xyXG4gICAgICAgIGNvbnN0IGNhbGxvdXRDb2xvcnMgPSAoX2EgPSBjYWxsb3V0TGluZS5jb2xvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuc3Ryb2tlcztcclxuICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gdGhpcy5jYWxsb3V0TGFiZWw7XHJcbiAgICAgICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoUGllTm9kZVRhZy5DYWxsb3V0KS5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXR1bSA9IGxpbmUuZGF0dW07XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2FsbG91dExhYmVsOiBsYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xyXG4gICAgICAgICAgICBpZiAoKGxhYmVsID09PSBudWxsIHx8IGxhYmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYWJlbC50ZXh0KSAmJiAhbGFiZWwuaGlkZGVuICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGNhbGxvdXRTdHJva2VXaWR0aDtcclxuICAgICAgICAgICAgICAgIGxpbmUuc3Ryb2tlID0gY2FsbG91dENvbG9yc1tpbmRleCAlIGNhbGxvdXRDb2xvcnMubGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIGxpbmUuZmlsbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gZGF0dW0ubWlkQ29zICogb3V0ZXJSYWRpdXM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5MSA9IGRhdHVtLm1pZFNpbiAqIG91dGVyUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHgyID0gZGF0dW0ubWlkQ29zICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgeTIgPSBkYXR1bS5taWRTaW4gKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzTW92ZWQgPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gfHwgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChpc01vdmVkICYmIGxhYmVsLmJveCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjbG9zZXN0IHBvaW50IHRvIHRoZSB0ZXh0IGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IGxhYmVsLmJveDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSB4MjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3kgPSB5MjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeDIgPCBib3gueCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9IGJveC54O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4MiA+IGJveC54ICsgYm94LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4ID0gYm94LnggKyBib3gud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5MiA8IGJveC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gYm94Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkyID4gYm94LnkgKyBib3guaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBsYWJlbCBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkeCA9IGN4IC0geDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSBjeSAtIHkyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRlZExlbmd0aCA9IGxlbmd0aCAtIG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFkZGVkTGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgyICsgKGR4ICogcGFkZGVkTGVuZ3RoKSAvIGxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5MiArIChkeSAqIHBhZGRlZExlbmd0aCkgLyBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGluZS54MSA9IHgxO1xyXG4gICAgICAgICAgICAgICAgbGluZS55MSA9IHkxO1xyXG4gICAgICAgICAgICAgICAgbGluZS54MiA9IHgyO1xyXG4gICAgICAgICAgICAgICAgbGluZS55MiA9IHkyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGluZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldExhYmVsT3ZlcmZsb3codGV4dCwgYm94LCBzZXJpZXNSZWN0KSB7XHJcbiAgICAgICAgY29uc3Qgc2VyaWVzTGVmdCA9IHNlcmllc1JlY3QueCAtIHRoaXMuY2VudGVyWDtcclxuICAgICAgICBjb25zdCBzZXJpZXNSaWdodCA9IHNlcmllc1JlY3QueCArIHNlcmllc1JlY3Qud2lkdGggLSB0aGlzLmNlbnRlclg7XHJcbiAgICAgICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgIGNvbnN0IHNlcmllc0JvdHRvbSA9IHNlcmllc1JlY3QueSArIHNlcmllc1JlY3QuaGVpZ2h0IC0gdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgIGNvbnN0IGVyclB4ID0gMTsgLy8gUHJldmVudHMgZXJyb3JzIHJlbGF0ZWQgdG8gZmxvYXRpbmcgcG9pbnQgY2FsY3VsYXRpb25zXHJcbiAgICAgICAgbGV0IHZpc2libGVUZXh0UGFydCA9IDE7XHJcbiAgICAgICAgaWYgKGJveC54ICsgZXJyUHggPCBzZXJpZXNMZWZ0KSB7XHJcbiAgICAgICAgICAgIHZpc2libGVUZXh0UGFydCA9IChib3gueCArIGJveC53aWR0aCAtIHNlcmllc0xlZnQpIC8gYm94LndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChib3gueCArIGJveC53aWR0aCAtIGVyclB4ID4gc2VyaWVzUmlnaHQpIHtcclxuICAgICAgICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKHNlcmllc1JpZ2h0IC0gYm94LngpIC8gYm94LndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYXNWZXJ0aWNhbE92ZXJmbG93ID0gYm94LnkgKyBlcnJQeCA8IHNlcmllc1RvcCB8fCBib3gueSArIGJveC5oZWlnaHQgLSBlcnJQeCA+IHNlcmllc0JvdHRvbTtcclxuICAgICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdmlzaWJsZVRleHRQYXJ0ID09PSAxID8gdGV4dC5sZW5ndGggOiBNYXRoLmZsb29yKHRleHQubGVuZ3RoICogdmlzaWJsZVRleHRQYXJ0KSAtIDE7XHJcbiAgICAgICAgY29uc3QgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyA9IHRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gpO1xyXG4gICAgICAgIHJldHVybiB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfTtcclxuICAgIH1cclxuICAgIGJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94LCBkeCA9IDAsIGR5ID0gMCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3Vycm91bmRpbmdSYWRpdXMgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHN1cnJvdW5kaW5nUmFkaXVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb3JuZXJzID0gW1xyXG4gICAgICAgICAgICB7IHg6IGJveC54ICsgZHgsIHk6IGJveC55ICsgZHkgfSxcclxuICAgICAgICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCArIGR4LCB5OiBib3gueSArIGR5IH0sXHJcbiAgICAgICAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGggKyBkeCwgeTogYm94LnkgKyBib3guaGVpZ2h0ICsgZHkgfSxcclxuICAgICAgICAgICAgeyB4OiBib3gueCArIGR4LCB5OiBib3gueSArIGJveC5oZWlnaHQgKyBkeSB9LFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3Qgc3VyMiA9IE1hdGgucG93KHN1cnJvdW5kaW5nUmFkaXVzLCAyKTtcclxuICAgICAgICByZXR1cm4gY29ybmVycy5zb21lKChjb3JuZXIpID0+IE1hdGgucG93KGNvcm5lci54LCAyKSArIE1hdGgucG93KGNvcm5lci55LCAyKSA+IHN1cjIpO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKSB7XHJcbiAgICAgICAgY29uc3QgeyByYWRpdXNTY2FsZSwgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IG9mZnNldCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xyXG4gICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcclxuICAgICAgICBjb25zdCBzaG91bGRTa2lwID0gKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xyXG4gICAgICAgICAgICByZXR1cm4gIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZnVsbERhdGEgPSB0aGlzLm5vZGVEYXRhO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm5vZGVEYXRhLmZpbHRlcigodCkgPT4gIXNob3VsZFNraXAodCkpO1xyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBsYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gMDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlZnRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPCAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcclxuICAgICAgICBjb25zdCByaWdodExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA+PSAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcclxuICAgICAgICBjb25zdCB0b3BMYWJlbHMgPSBkYXRhXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGQpID0+IHsgdmFyIF9hOyByZXR1cm4gZC5taWRTaW4gPCAwICYmICgoX2EgPSBkLmNhbGxvdXRMYWJlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRleHRBbGlnbikgPT09ICdjZW50ZXInOyB9KVxyXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5taWRDb3MgLSBiLm1pZENvcyk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGFiZWxzID0gZGF0YVxyXG4gICAgICAgICAgICAuZmlsdGVyKChkKSA9PiB7IHZhciBfYTsgcmV0dXJuIGQubWlkU2luID49IDAgJiYgKChfYSA9IGQuY2FsbG91dExhYmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGV4dEFsaWduKSA9PT0gJ2NlbnRlcic7IH0pXHJcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcclxuICAgICAgICBjb25zdCB0ZW1wVGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGdldFRleHRCQm94ID0gKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCQm94KDAsIDAsIDAsIDApO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExpbmUubGVuZ3RoICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XHJcbiAgICAgICAgICAgIHRlbXBUZXh0Tm9kZS50ZXh0ID0gbGFiZWwudGV4dDtcclxuICAgICAgICAgICAgdGVtcFRleHROb2RlLnggPSB4O1xyXG4gICAgICAgICAgICB0ZW1wVGV4dE5vZGUueSA9IHk7XHJcbiAgICAgICAgICAgIHRlbXBUZXh0Tm9kZS5zZXRGb250KHRoaXMuY2FsbG91dExhYmVsKTtcclxuICAgICAgICAgICAgdGVtcFRleHROb2RlLnNldEFsaWduKHtcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogKF9hID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsYWJlbC50ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wVGV4dE5vZGUuY29tcHV0ZUJCb3goKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbiA9IChsYWJlbCwgbmV4dCwgZGlyZWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IGdldFRleHRCQm94KGxhYmVsKS5ncm93KG1pblNwYWNpbmcgLyAyKTtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBnZXRUZXh0QkJveChuZXh0KS5ncm93KG1pblNwYWNpbmcgLyAyKTtcclxuICAgICAgICAgICAgLy8gVGhlIGZ1bGwgY29sbGlzaW9uIGlzIG5vdCBkZXRlY3RlZCwgYmVjYXVzZSBzb21ldGltZXNcclxuICAgICAgICAgICAgLy8gdGhlIG5leHQgbGFiZWwgY2FuIGFwcGVhciBiZWhpbmQgdGhlIGxhYmVsIHdpdGggb2Zmc2V0XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVzT3JCZWhpbmQgPSBib3gueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgYm94LnggKyBib3gud2lkdGggPiBvdGhlci54ICYmXHJcbiAgICAgICAgICAgICAgICAoZGlyZWN0aW9uID09PSAndG8tdG9wJyA/IGJveC55IDwgb3RoZXIueSArIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCA+IG90aGVyLnkpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXNPckJlaGluZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHkgPSBkaXJlY3Rpb24gPT09ICd0by10b3AnID8gYm94LnkgLSBvdGhlci55IC0gb3RoZXIuaGVpZ2h0IDogYm94LnkgKyBib3guaGVpZ2h0IC0gb3RoZXIueTtcclxuICAgICAgICAgICAgICAgIG5leHQuY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSBkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXZvaWRZQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWlkTGFiZWwgPSBsYWJlbHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBNYXRoLmFicyhhLm1pZFNpbikgLSBNYXRoLmFicyhiLm1pZFNpbikpWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBtaWRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1pZExhYmVsKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBsYWJlbHNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcclxuICAgICAgICAgICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCAndG8tdG9wJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4ICsgMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbGFiZWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsICd0by1ib3R0b20nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXZvaWRYQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSA9IGRhdGEuc29tZSgoZGF0dW0pID0+IGRhdHVtLmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwKTtcclxuICAgICAgICAgICAgY29uc3QgYm94ZXMgPSBsYWJlbHMubWFwKChsYWJlbCkgPT4gZ2V0VGV4dEJCb3gobGFiZWwpKTtcclxuICAgICAgICAgICAgY29uc3QgcGFkZGVkQm94ZXMgPSBib3hlcy5tYXAoKGJveCkgPT4gYm94LmNsb25lKCkuZ3JvdyhtaW5TcGFjaW5nIC8gMikpO1xyXG4gICAgICAgICAgICBsZXQgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlZEJveGVzLmxlbmd0aCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBwYWRkZWRCb3hlc1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxhYmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFkZGVkQm94ZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3gob3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2VjdG9ycyA9IGZ1bGxEYXRhLm1hcCgoZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVTZWN0b3JzID0gYm94ZXMuc29tZSgoYm94KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjdG9ycy5zb21lKChzZWN0b3IpID0+IGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVggJiYgIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgJiYgIWxhYmVsc0NvbGxpZGVTZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiBkLmNhbGxvdXRMYWJlbC50ZXh0QWxpZ24gPT09ICdjZW50ZXInKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZC5jYWxsb3V0TGFiZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5taWRDb3MgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQubWlkQ29zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGF2b2lkWUNvbGxpc2lvbnMobGVmdExhYmVscyk7XHJcbiAgICAgICAgYXZvaWRZQ29sbGlzaW9ucyhyaWdodExhYmVscyk7XHJcbiAgICAgICAgYXZvaWRYQ29sbGlzaW9ucyh0b3BMYWJlbHMpO1xyXG4gICAgICAgIGF2b2lkWENvbGxpc2lvbnMoYm90dG9tTGFiZWxzKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNhbGxvdXRMYWJlbE5vZGVzKHNlcmllc1JlY3QpIHtcclxuICAgICAgICBjb25zdCB7IHJhZGl1c1NjYWxlLCBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgeyBvZmZzZXQsIGNvbG9yIH0gPSBjYWxsb3V0TGFiZWw7XHJcbiAgICAgICAgY29uc3QgdGVtcFRleHROb2RlID0gbmV3IFRleHQoKTtcclxuICAgICAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZyhQaWVOb2RlVGFnLkxhYmVsKS5mb3JFYWNoKCh0ZXh0KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgeyBkYXR1bSB9ID0gdGV4dDtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoZGF0dW0ucmFkaXVzKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCByYWRpdXMpO1xyXG4gICAgICAgICAgICBpZiAoIShsYWJlbCA9PT0gbnVsbCB8fCBsYWJlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFiZWwudGV4dCkgfHwgb3V0ZXJSYWRpdXMgPT09IDAgfHwgbGFiZWwuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xyXG4gICAgICAgICAgICAvLyBEZXRlY3QgdGV4dCBvdmVyZmxvd1xyXG4gICAgICAgICAgICBjb25zdCBhbGlnbiA9IHtcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogKF9hID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsYWJlbC50ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGVtcFRleHROb2RlLnRleHQgPSBsYWJlbC50ZXh0O1xyXG4gICAgICAgICAgICB0ZW1wVGV4dE5vZGUueCA9IHg7XHJcbiAgICAgICAgICAgIHRlbXBUZXh0Tm9kZS55ID0geTtcclxuICAgICAgICAgICAgdGVtcFRleHROb2RlLnNldEZvbnQodGhpcy5jYWxsb3V0TGFiZWwpO1xyXG4gICAgICAgICAgICB0ZW1wVGV4dE5vZGUuc2V0QWxpZ24oYWxpZ24pO1xyXG4gICAgICAgICAgICBjb25zdCBib3ggPSB0ZW1wVGV4dE5vZGUuY29tcHV0ZUJCb3goKTtcclxuICAgICAgICAgICAgbGV0IGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dDtcclxuICAgICAgICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3cobGFiZWwudGV4dCwgYm94LCBzZXJpZXNSZWN0KTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlUZXh0ID0gbGFiZWwudGV4dC5sZW5ndGggPT09IHRleHRMZW5ndGggPyBsYWJlbC50ZXh0IDogYCR7bGFiZWwudGV4dC5zdWJzdHJpbmcoMCwgdGV4dExlbmd0aCl94oCmYDtcclxuICAgICAgICAgICAgICAgIHZpc2libGUgPSAhaGFzVmVydGljYWxPdmVyZmxvdztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0LnRleHQgPSBkaXNwbGF5VGV4dDtcclxuICAgICAgICAgICAgdGV4dC54ID0geDtcclxuICAgICAgICAgICAgdGV4dC55ID0geTtcclxuICAgICAgICAgICAgdGV4dC5zZXRGb250KHRoaXMuY2FsbG91dExhYmVsKTtcclxuICAgICAgICAgICAgdGV4dC5zZXRBbGlnbihhbGlnbik7XHJcbiAgICAgICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xyXG4gICAgICAgICAgICB0ZXh0LnZpc2libGUgPSB2aXNpYmxlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZUxhYmVsc0JCb3gob3B0aW9ucywgc2VyaWVzUmVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0LCBtYXhDb2xsaXNpb25PZmZzZXQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcclxuICAgICAgICAgICAgaWYgKCFjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRCb3hlcyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHQoKTtcclxuICAgICAgICAgICAgbGV0IHRpdGxlQm94O1xyXG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMudGl0bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXh0KSAmJiB0aGlzLnRpdGxlLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQudGV4dCA9IHRoaXMudGl0bGUudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQueSA9IGR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQuc2V0Rm9udCh0aGlzLnRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnNldEFsaWduKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAnYm90dG9tJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZUJveCA9IHRleHQuY29tcHV0ZUJCb3goKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Qm94ZXMucHVzaCh0aXRsZUJveCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ub2RlRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xyXG4gICAgICAgICAgICAgICAgdGV4dC54ID0geDtcclxuICAgICAgICAgICAgICAgIHRleHQueSA9IHk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnNldEZvbnQodGhpcy5jYWxsb3V0TGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRBbGlnbih7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAoX2EgPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxhYmVsLnRleHRBbGlnbixcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm94ID0gdGV4dC5jb21wdXRlQkJveCgpO1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuYm94ID0gYm94O1xyXG4gICAgICAgICAgICAgICAgLy8gSGlkZSBsYWJlbHMgdGhhdCB3aGVyZSBwdXNoZWQgdG9vIGZhciBieSB0aGUgY29sbGlzaW9uIGF2b2lkYW5jZSBhbGdvcml0aG1cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhsYWJlbC5jb2xsaXNpb25PZmZzZXRZKSA+IG1heENvbGxpc2lvbk9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSGlkZSBsYWJlbHMgaW50ZXJzZWN0aW5nIG9yIGFib3ZlIHRoZSB0aXRsZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlQm94KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlQ2xlYW5BcmVhID0gbmV3IEJCb3godGl0bGVCb3gueCAtIG1pblNwYWNpbmcsIHNlcmllc1RvcCwgdGl0bGVCb3gud2lkdGggKyAyICogbWluU3BhY2luZywgdGl0bGVCb3gueSArIHRpdGxlQm94LmhlaWdodCArIG1pblNwYWNpbmcgLSBzZXJpZXNUb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KHRpdGxlQ2xlYW5BcmVhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZVdoZW5OZWNlc3NhcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhsYWJlbC50ZXh0LCBib3gsIHNlcmllc1JlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVG9vU2hvcnQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA+IDIgJiYgdGV4dExlbmd0aCA8IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfHwgaXNUb29TaG9ydCB8fCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRleHRCb3hlcy5wdXNoKGJveCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodGV4dEJveGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEJCb3gubWVyZ2UodGV4dEJveGVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKSB7XHJcbiAgICAgICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XHJcbiAgICAgICAgY29uc3QgeyBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBwb3NpdGlvbk9mZnNldCwgcG9zaXRpb25SYXRpbywgY29sb3IgfSA9IHRoaXMuc2VjdG9yTGFiZWw7XHJcbiAgICAgICAgY29uc3QgaXNEb3VnaG51dCA9IGlubmVyUmFkaXVzID4gMDtcclxuICAgICAgICBjb25zdCBzaW5nbGVWaXNpYmxlU2VjdG9yID0gdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5maWx0ZXIoQm9vbGVhbikubGVuZ3RoID09PSAxO1xyXG4gICAgICAgIHRoaXMuc2VjdG9yTGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBzZWN0b3JMYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xyXG4gICAgICAgICAgICBsZXQgaXNUZXh0VmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoc2VjdG9yTGFiZWwgJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gaW5uZXJSYWRpdXMgKiAoMSAtIHBvc2l0aW9uUmF0aW8pICsgb3V0ZXJSYWRpdXMgKiBwb3NpdGlvblJhdGlvICsgcG9zaXRpb25PZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcclxuICAgICAgICAgICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcclxuICAgICAgICAgICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHQgPSBzZWN0b3JMYWJlbC50ZXh0O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUHV0VGV4dEluQ2VudGVyID0gIWlzRG91Z2hudXQgJiYgc2luZ2xlVmlzaWJsZVNlY3RvcjtcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRQdXRUZXh0SW5DZW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJveCA9IHRleHQuY29tcHV0ZUJCb3goKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcm5lcnMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgW2Jib3gueCwgYmJveC55XSxcclxuICAgICAgICAgICAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55XSxcclxuICAgICAgICAgICAgICAgICAgICBbYmJveC54ICsgYmJveC53aWR0aCwgYmJveC55ICsgYmJveC5oZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtiYm94LngsIGJib3gueSArIGJib3guaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBkYXR1bTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3RvckJvdW5kcyA9IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvcm5lcnMuZXZlcnkoKFt4LCB5XSkgPT4gaXNQb2ludEluU2VjdG9yKHgsIHksIHNlY3RvckJvdW5kcykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNUZXh0VmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGV4dC52aXNpYmxlID0gaXNUZXh0VmlzaWJsZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUlubmVyTGFiZWxOb2RlcygpIHtcclxuICAgICAgICBjb25zdCB0ZXh0QkJveGVzID0gW107XHJcbiAgICAgICAgY29uc3QgbWFyZ2lucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gZGF0dW07XHJcbiAgICAgICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xyXG4gICAgICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xyXG4gICAgICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XHJcbiAgICAgICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XHJcbiAgICAgICAgICAgIHRleHQudGV4dCA9IGRhdHVtLnRleHQ7XHJcbiAgICAgICAgICAgIHRleHQueCA9IDA7XHJcbiAgICAgICAgICAgIHRleHQueSA9IDA7XHJcbiAgICAgICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xyXG4gICAgICAgICAgICB0ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcclxuICAgICAgICAgICAgdGV4dEJCb3hlcy5wdXNoKHRleHQuY29tcHV0ZUJCb3goKSk7XHJcbiAgICAgICAgICAgIG1hcmdpbnMucHVzaChkYXR1bS5tYXJnaW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGdldE1hcmdpblRvcCA9IChpbmRleCkgPT4gKGluZGV4ID09PSAwID8gMCA6IG1hcmdpbnNbaW5kZXhdKTtcclxuICAgICAgICBjb25zdCBnZXRNYXJnaW5Cb3R0b20gPSAoaW5kZXgpID0+IChpbmRleCA9PT0gbWFyZ2lucy5sZW5ndGggLSAxID8gMCA6IG1hcmdpbnNbaW5kZXhdKTtcclxuICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRleHRCQm94ZXMucmVkdWNlKChzdW0sIGJib3gsIGkpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1bSArIGJib3guaGVpZ2h0ICsgZ2V0TWFyZ2luVG9wKGkpICsgZ2V0TWFyZ2luQm90dG9tKGkpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSBNYXRoLm1heCguLi50ZXh0QkJveGVzLm1hcCgoYmJveCkgPT4gYmJveC53aWR0aCkpO1xyXG4gICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gdGhpcy5nZXRJbm5lclJhZGl1cygpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gTWF0aC5zcXJ0KE1hdGgucG93KHRvdGFsV2lkdGggLyAyLCAyKSArIE1hdGgucG93KHRvdGFsSGVpZ2h0IC8gMiwgMikpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsc1Zpc2libGUgPSBsYWJlbFJhZGl1cyA8PSAoaW5uZXJSYWRpdXMgPiAwID8gaW5uZXJSYWRpdXMgOiB0aGlzLmdldE91dGVyUmFkaXVzKCkpO1xyXG4gICAgICAgIGNvbnN0IHRleHRCb3R0b21zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSAtdG90YWxIZWlnaHQgLyAyOyBpIDwgdGV4dEJCb3hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBiYm94ID0gdGV4dEJCb3hlc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gYmJveC5oZWlnaHQgKyBwcmV2ICsgZ2V0TWFyZ2luVG9wKGkpO1xyXG4gICAgICAgICAgICB0ZXh0Qm90dG9tcy5wdXNoKGJvdHRvbSk7XHJcbiAgICAgICAgICAgIHByZXYgPSBib3R0b20gKyBnZXRNYXJnaW5Cb3R0b20oaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24uZWFjaCgodGV4dCwgX2RhdHVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICB0ZXh0LnkgPSB0ZXh0Qm90dG9tc1tpbmRleF07XHJcbiAgICAgICAgICAgIHRleHQudmlzaWJsZSA9IGxhYmVsc1Zpc2libGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKSB7XHJcbiAgICAgICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBjYWxsb3V0TGFiZWwsIGxlZ2VuZEl0ZW0gfSA9IG5vZGVEYXR1bTtcclxuICAgICAgICBpZiAobGVnZW5kSXRlbUtleSAmJiBsZWdlbmRJdGVtICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZ2VuZEl0ZW0udGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5ICYmIGNhbGxvdXRMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgKGNhbGxvdXRMYWJlbCA9PT0gbnVsbCB8fCBjYWxsb3V0TGFiZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxvdXRMYWJlbC50ZXh0KSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsb3V0TGFiZWwudGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkgJiYgc2VjdG9yTGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIChzZWN0b3JMYWJlbCA9PT0gbnVsbCB8fCBzZWN0b3JMYWJlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VjdG9yTGFiZWwudGV4dCkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VjdG9yTGFiZWwudGV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFuZ2xlS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBkYXR1bSwgYW5nbGVWYWx1ZSwgc2VjdG9yRm9ybWF0OiB7IGZpbGw6IGNvbG9yIH0sIH0gPSBub2RlRGF0dW07XHJcbiAgICAgICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwoKF9hID0gdGhpcy50aXRsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRleHQpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpc051bWJlcihhbmdsZVZhbHVlKSA/IHRvRml4ZWQoYW5nbGVWYWx1ZSkgOiBTdHJpbmcoYW5nbGVWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKTtcclxuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwLnRvVG9vbHRpcEh0bWwoe1xyXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogbGFiZWxUZXh0LFxyXG4gICAgICAgICAgICBjb250ZW50OiB0aXRsZSAmJiBsYWJlbFRleHQgPyBgJHtsYWJlbFRleHR9OiAke2NvbnRlbnR9YCA6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIGNvbG9yLFxyXG4gICAgICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcclxuICAgICAgICAgICAgYW5nbGVLZXk6IHRoaXMuYW5nbGVLZXksXHJcbiAgICAgICAgICAgIGFuZ2xlTmFtZTogdGhpcy5hbmdsZU5hbWUsXHJcbiAgICAgICAgICAgIHJhZGl1c0tleTogdGhpcy5yYWRpdXNLZXksXHJcbiAgICAgICAgICAgIHJhZGl1c05hbWU6IHRoaXMucmFkaXVzTmFtZSxcclxuICAgICAgICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLmNhbGxvdXRMYWJlbEtleSxcclxuICAgICAgICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5jYWxsb3V0TGFiZWxOYW1lLFxyXG4gICAgICAgICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5zZWN0b3JMYWJlbEtleSxcclxuICAgICAgICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnNlY3RvckxhYmVsTmFtZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICAgICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSwgaWQsIGRhdGFNb2RlbCB9ID0gdGhpcztcclxuICAgICAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSB8fCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoID09PSAwIHx8IGxlZ2VuZFR5cGUgIT09ICdjYXRlZ29yeScpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICBpZiAoIWxlZ2VuZEl0ZW1LZXkgJiZcclxuICAgICAgICAgICAgKCFjYWxsb3V0TGFiZWxLZXkgfHwgY2FsbG91dExhYmVsS2V5ID09PSBhbmdsZUtleSkgJiZcclxuICAgICAgICAgICAgKCFzZWN0b3JMYWJlbEtleSB8fCBzZWN0b3JMYWJlbEtleSA9PT0gYW5nbGVLZXkpKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgY29uc3QgeyBjYWxsb3V0TGFiZWxJZHgsIHNlY3RvckxhYmVsSWR4LCBsZWdlbmRJdGVtSWR4IH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XHJcbiAgICAgICAgY29uc3QgdGl0bGVUZXh0ID0gKChfYSA9IHRoaXMudGl0bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93SW5MZWdlbmQpICYmIHRoaXMudGl0bGUudGV4dDtcclxuICAgICAgICBjb25zdCBsZWdlbmREYXRhID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBwcm9jZXNzZWREYXRhLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbFBhcnRzID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aXRsZVRleHQpIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsUGFydHMucHVzaCh0aXRsZVRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKGRhdHVtLCAyICogTWF0aC5QSSwgMiAqIE1hdGguUEksIGZhbHNlLCB2YWx1ZXNbY2FsbG91dExhYmVsSWR4XSwgdmFsdWVzW3NlY3RvckxhYmVsSWR4XSwgdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdKTtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGFiZWxzLmxlZ2VuZEl0ZW0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5sZWdlbmRJdGVtLnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmICgoX2IgPSBsYWJlbHMuY2FsbG91dExhYmVsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGV4dCkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKChfYyA9IGxhYmVscy5jYWxsb3V0TGFiZWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgKChfZCA9IGxhYmVscy5zZWN0b3JMYWJlbCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRleHQpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsUGFydHMucHVzaCgoX2UgPSBsYWJlbHMuc2VjdG9yTGFiZWwpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFiZWxQYXJ0cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGxlZ2VuZERhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRUeXBlOiAnY2F0ZWdvcnknLFxyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICBpdGVtSWQ6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzSWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0sXHJcbiAgICAgICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsUGFydHMuam9pbignIC0gJyksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbWFya2VyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogc2VjdG9yRm9ybWF0LmZpbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzZWN0b3JGb3JtYXQuc3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLmZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMuc3Ryb2tlT3BhY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGVnZW5kRGF0YTtcclxuICAgIH1cclxuICAgIG9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgeyBlbmFibGVkLCBpdGVtSWQsIHNlcmllcyB9ID0gZXZlbnQ7XHJcbiAgICAgICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VyaWVzLnR5cGUgPT09ICdwaWUnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlT3RoZXJTZXJpZXNJdGVtcyhzZXJpZXMsIGl0ZW1JZCwgZW5hYmxlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpIHtcclxuICAgICAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2l0ZW1JZF0gPSBlbmFibGVkO1xyXG4gICAgICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRvZ2dsZU90aGVyU2VyaWVzSXRlbXMoc2VyaWVzLCBpdGVtSWQsIGVuYWJsZWQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHsgbGVnZW5kSXRlbUtleSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghbGVnZW5kSXRlbUtleSB8fCAhZGF0YU1vZGVsKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgZGF0dW1Ub2dnbGVkTGVnZW5kSXRlbVZhbHVlID0gc2VyaWVzLmxlZ2VuZEl0ZW1LZXkgJiYgKChfYSA9IHNlcmllcy5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoXywgaW5kZXgpID0+IGluZGV4ID09PSBpdGVtSWQpW3Nlcmllcy5sZWdlbmRJdGVtS2V5XSk7XHJcbiAgICAgICAgaWYgKCFkYXR1bVRvZ2dsZWRMZWdlbmRJdGVtVmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBsZWdlbmRJdGVtSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKS5pbmRleDtcclxuICAgICAgICAoX2IgPSB0aGlzLnByb2Nlc3NlZERhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kYXRhLmZvckVhY2goKHsgdmFsdWVzIH0sIGRhdHVtSXRlbUlkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gPT09IGRhdHVtVG9nZ2xlZExlZ2VuZEl0ZW1WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGRhdHVtSXRlbUlkLCBlbmFibGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcclxuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xyXG4gICAgICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnModHJ1ZSwgdGhpcy5yb3RhdGlvbiwgdGhpcy5yYWRpdXNTY2FsZSwgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlKTtcclxuICAgICAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgJ25vZGVzJywgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaXRlbVNlbGVjdGlvbiwgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb25dLCBmbnMubm9kZXMpO1xyXG4gICAgICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XHJcbiAgICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgJ2NhbGxvdXQnLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb25dKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnc2VjdG9yJywgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuc2VjdG9yTGFiZWxTZWxlY3Rpb25dKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnaW5uZXInLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbl0pO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XHJcbiAgICB9XHJcbiAgICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwcm9jZXNzZWREYXRhLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xyXG4gICAgICAgIGNvbnN0IGRpZmYgPSAoX2EgPSBwcm9jZXNzZWREYXRhID09PSBudWxsIHx8IHByb2Nlc3NlZERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3NlZERhdGEucmVkdWNlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpZmY7XHJcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZERpZmYgPSAoKF9iID0gZGlmZiA9PT0gbnVsbCB8fCBkaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaWZmLm1vdmVkLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgPT09IDAgJiYgKGRpZmYgPT09IG51bGwgfHwgZGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlmZi5hZGRlZEluZGljZXMuZXZlcnkoKGkpID0+ICFkaWZmLnJlbW92ZWRJbmRpY2VzLmluY2x1ZGVzKGkpKSk7XHJcbiAgICAgICAgY29uc3QgaGFzS2V5cyA9ICgoX2MgPSBwcm9jZXNzZWREYXRhID09PSBudWxsIHx8IHByb2Nlc3NlZERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3NlZERhdGEuZGVmcy5rZXlzLmxlbmd0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgPiAwO1xyXG4gICAgICAgIGNvbnN0IGhhc1VuaXF1ZUtleXMgPSAoX2YgPSAoX2UgPSAoX2QgPSBwcm9jZXNzZWREYXRhID09PSBudWxsIHx8IHByb2Nlc3NlZERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3NlZERhdGEucmVkdWNlZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFuaW1hdGlvblZhbGlkYXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS51bmlxdWVLZXlzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlO1xyXG4gICAgICAgIGlmICghc3VwcG9ydGVkRGlmZiB8fCAhaGFzS2V5cyB8fCAhaGFzVW5pcXVlS2V5cykge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhmYWxzZSwgdGhpcy5yb3RhdGlvbiwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUpO1xyXG4gICAgICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCAnbm9kZXMnLCBhbmltYXRpb25NYW5hZ2VyLCBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uXSwgZm5zLm5vZGVzLCAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSksIGRpZmYpO1xyXG4gICAgICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XHJcbiAgICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgJ2NhbGxvdXQnLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb25dKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnc2VjdG9yJywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuc2VjdG9yTGFiZWxTZWxlY3Rpb25dKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnaW5uZXInLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbl0pO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XHJcbiAgICB9XHJcbiAgICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eSgpIHtcclxuICAgICAgICBjb25zdCB7IGl0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcmFkaXVzU2NhbGUsIHByZXZpb3VzUmFkaXVzU2NhbGUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcclxuICAgICAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKGZhbHNlLCB0aGlzLnJvdGF0aW9uLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSk7XHJcbiAgICAgICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsICdub2RlcycsIGFuaW1hdGlvbk1hbmFnZXIsIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb25dLCBmbnMubm9kZXMpO1xyXG4gICAgICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XHJcbiAgICAgICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsICdjYWxsb3V0JywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uXSk7XHJcbiAgICAgICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsICdzZWN0b3InLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5zZWN0b3JMYWJlbFNlbGVjdGlvbl0pO1xyXG4gICAgICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCAnaW5uZXInLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbl0pO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XHJcbiAgICB9XHJcbiAgICBnZXREYXR1bUlkRnJvbURhdGEoZGF0dW0pIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBjb25zdCB7IGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCEoKF9jID0gKF9iID0gKF9hID0gdGhpcy5wcm9jZXNzZWREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkdWNlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFuaW1hdGlvblZhbGlkYXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51bmlxdWVLZXlzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVnZW5kSXRlbUtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0dW1bbGVnZW5kSXRlbUtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0dW1bY2FsbG91dExhYmVsS2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdHVtW3NlY3RvckxhYmVsS2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXREYXR1bUlkKGRhdHVtKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgaW5kZXggfSA9IGRhdHVtO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmdldERhdHVtSWRGcm9tRGF0YShkYXR1bS5kYXR1bSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGAke2luZGV4fWA7XHJcbiAgICB9XHJcbiAgICBvbkRhdGFDaGFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzU2VyaWVzSXRlbUVuYWJsZWQoKTtcclxuICAgIH1cclxufVxyXG5QaWVTZXJpZXMuY2xhc3NOYW1lID0gJ1BpZVNlcmllcyc7XHJcblBpZVNlcmllcy50eXBlID0gJ3BpZSc7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwiYW5nbGVLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShTVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGllU2VyaWVzLnByb3RvdHlwZSwgXCJhbmdsZU5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwicmFkaXVzS2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcInJhZGl1c05hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwicmFkaXVzTWluXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcInJhZGl1c01heFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgUGllU2VyaWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsTmFtZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgUGllU2VyaWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbEtleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgUGllU2VyaWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbE5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUtleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCwgMSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGllU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0xJTkVfREFTSCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZVTkNUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuXSwgUGllU2VyaWVzLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgtMzYwLCAzNjApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNPZmZzZXRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzUmF0aW9cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFBpZVNlcmllcy5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNPZmZzZXRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzUmF0aW9cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQaWVTZXJpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIHZvaWQgMCk7XG5cbmNvbnN0IEpTT05fQVBQTFlfUExVR0lOUyA9IHtcclxuICAgIGNvbnN0cnVjdG9yczoge30sXHJcbiAgICBjb25zdHJ1Y3RlZEFycmF5czogbmV3IFdlYWtNYXAoKSxcclxufTtcclxuZnVuY3Rpb24gYXNzaWduSnNvbkFwcGx5Q29uc3RydWN0ZWRBcnJheShhcnJheSwgY3Rvcikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgKF9hID0gSlNPTl9BUFBMWV9QTFVHSU5TLmNvbnN0cnVjdGVkQXJyYXlzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0KGFycmF5LCBjdG9yKTtcclxufVxyXG5jb25zdCBKU09OX0FQUExZX09QVElPTlMgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcnM6IHtcclxuICAgICAgICB0aXRsZTogQ2FwdGlvbixcclxuICAgICAgICBzdWJ0aXRsZTogQ2FwdGlvbixcclxuICAgICAgICBmb290bm90ZTogQ2FwdGlvbixcclxuICAgICAgICBzaGFkb3c6IERyb3BTaGFkb3csXHJcbiAgICAgICAgaW5uZXJDaXJjbGU6IERvdWdobnV0SW5uZXJDaXJjbGUsXHJcbiAgICAgICAgJ2F4ZXNbXS50aXRsZSc6IEF4aXNUaXRsZSxcclxuICAgICAgICAnc2VyaWVzW10uaW5uZXJMYWJlbHNbXSc6IERvdWdobnV0SW5uZXJMYWJlbCxcclxuICAgIH0sXHJcbiAgICBhbGxvd2VkVHlwZXM6IHtcclxuICAgICAgICAnbGVnZW5kLnBhZ2luYXRpb24ubWFya2VyLnNoYXBlJzogWydwcmltaXRpdmUnLCAnZnVuY3Rpb24nXSxcclxuICAgICAgICAnc2VyaWVzW10ubWFya2VyLnNoYXBlJzogWydwcmltaXRpdmUnLCAnZnVuY3Rpb24nXSxcclxuICAgICAgICAnYXhpc1tdLnRpY2suY291bnQnOiBbJ3ByaW1pdGl2ZScsICdjbGFzcy1pbnN0YW5jZSddLFxyXG4gICAgfSxcclxufTtcclxuZnVuY3Rpb24gZ2V0SnNvbkFwcGx5T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29uc3RydWN0b3JzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEpTT05fQVBQTFlfT1BUSU9OUy5jb25zdHJ1Y3RvcnMpLCBKU09OX0FQUExZX1BMVUdJTlMuY29uc3RydWN0b3JzKSxcclxuICAgICAgICBjb25zdHJ1Y3RlZEFycmF5czogSlNPTl9BUFBMWV9QTFVHSU5TLmNvbnN0cnVjdGVkQXJyYXlzLFxyXG4gICAgICAgIGFsbG93ZWRUeXBlczogT2JqZWN0LmFzc2lnbih7fSwgSlNPTl9BUFBMWV9PUFRJT05TLmFsbG93ZWRUeXBlcyksXHJcbiAgICB9O1xyXG59XG5cbmNsYXNzIFJhbmdlIGV4dGVuZHMgU2hhcGUge1xyXG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgdGhpcy54MSA9IDA7XHJcbiAgICAgICAgdGhpcy55MSA9IDA7XHJcbiAgICAgICAgdGhpcy54MiA9IDA7XHJcbiAgICAgICAgdGhpcy55MiA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydExpbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZExpbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlc3RvcmVPd25TdHlsZXMoKTtcclxuICAgIH1cclxuICAgIGNvbXB1dGVCQm94KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQkJveCh0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyIC0gdGhpcy54MSwgdGhpcy55MiAtIHRoaXMueTEpO1xyXG4gICAgfVxyXG4gICAgaXNQb2ludEluUGF0aChfeCwgX3kpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZW5kZXIocmVuZGVyQ3R4KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PT0gUmVkcmF3VHlwZS5OT05FICYmICFmb3JjZVJlbmRlcikge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHMpXHJcbiAgICAgICAgICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXgudG9Db250ZXh0KGN0eCk7XHJcbiAgICAgICAgbGV0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHRoaXM7XHJcbiAgICAgICAgeDEgPSB0aGlzLmFsaWduKHgxKTtcclxuICAgICAgICB5MSA9IHRoaXMuYWxpZ24oeTEpO1xyXG4gICAgICAgIHgyID0gdGhpcy5hbGlnbih4Mik7XHJcbiAgICAgICAgeTIgPSB0aGlzLmFsaWduKHkyKTtcclxuICAgICAgICBjb25zdCB7IGZpbGwsIG9wYWNpdHksIGlzUmFuZ2UgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgZmlsbEFjdGl2ZSA9ICEhKGlzUmFuZ2UgJiYgZmlsbCk7XHJcbiAgICAgICAgaWYgKGZpbGxBY3RpdmUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBmaWxsT3BhY2l0eSB9ID0gdGhpcztcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHkgKiBmaWxsT3BhY2l0eTtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkxKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgxLCB5Mik7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdGFydExpbmUsIGVuZExpbmUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlQWN0aXZlID0gISEoKHN0YXJ0TGluZSB8fCBlbmRMaW5lKSAmJiBzdHJva2UgJiYgc3Ryb2tlV2lkdGgpO1xyXG4gICAgICAgIGlmIChzdHJva2VBY3RpdmUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGxpbmVDYXAsIGxpbmVKb2luIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHkgKiBzdHJva2VPcGFjaXR5O1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGluZURhc2hPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsaW5lQ2FwKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmVKb2luKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydExpbmUpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kTGluZSkge1xyXG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MiwgeTIpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4MSwgeTIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gdGhpcy5maWxsU2hhZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya0NsZWFuKCk7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XHJcbiAgICB9XHJcbn1cclxuUmFuZ2UuY2xhc3NOYW1lID0gJ1JhbmdlJztcclxuUmFuZ2UuZGVmYXVsdFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgU2hhcGUuZGVmYXVsdFN0eWxlcyksIHsgc3Ryb2tlV2lkdGg6IDEgfSk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUlOT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieDFcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ5MVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1JTk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUmFuZ2UucHJvdG90eXBlLCBcIngyXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUlOT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieTJcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwic3RhcnRMaW5lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUlOT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuXSwgUmFuZ2UucHJvdG90eXBlLCBcImVuZExpbmVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NSU5PUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwiaXNSYW5nZVwiLCB2b2lkIDApO1xuXG5jb25zdCBob3Jpem9udGFsQ3Jvc3NsaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zID0ge1xyXG4gICAgdG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxyXG4gICAgYm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXHJcbiAgICBsZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxyXG4gICAgcmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcclxuICAgIHRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXHJcbiAgICB0b3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXHJcbiAgICBib3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXHJcbiAgICBib3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcclxuICAgIGluc2lkZTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxyXG4gICAgaW5zaWRlTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxyXG4gICAgaW5zaWRlUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXHJcbiAgICBpbnNpZGVUb3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcclxuICAgIGluc2lkZUJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcclxuICAgIGluc2lkZVRvcExlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcclxuICAgIGluc2lkZUJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXHJcbiAgICBpbnNpZGVUb3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcclxuICAgIGluc2lkZUJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcclxufTtcclxuY29uc3QgdmVydGljYWxDcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB7XHJcbiAgICB0b3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcclxuICAgIGJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcclxuICAgIGxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXHJcbiAgICByaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxyXG4gICAgdG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXHJcbiAgICB0b3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcclxuICAgIGJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXHJcbiAgICBib3R0b21SaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxyXG4gICAgaW5zaWRlOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXHJcbiAgICBpbnNpZGVMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXHJcbiAgICBpbnNpZGVSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcclxuICAgIGluc2lkZVRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcclxuICAgIGluc2lkZUJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxyXG4gICAgaW5zaWRlVG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcclxuICAgIGluc2lkZUJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcclxuICAgIGluc2lkZVRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcclxuICAgIGluc2lkZUJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxyXG59O1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHsgeURpcmVjdGlvbiwgcGFkZGluZyA9IDAsIHBvc2l0aW9uID0gJ3RvcCcsIGJib3gsIH0pIHtcclxuICAgIGNvbnN0IGNyb3NzTGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA9IHlEaXJlY3Rpb25cclxuICAgICAgICA/IGhvcml6b250YWxDcm9zc2xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnNcclxuICAgICAgICA6IHZlcnRpY2FsQ3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zO1xyXG4gICAgY29uc3QgeyB4VHJhbnNsYXRpb25EaXJlY3Rpb24sIHlUcmFuc2xhdGlvbkRpcmVjdGlvbiB9ID0gY3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zW3Bvc2l0aW9uXTtcclxuICAgIGNvbnN0IHcgPSB5RGlyZWN0aW9uID8gYmJveC53aWR0aCA6IGJib3guaGVpZ2h0O1xyXG4gICAgY29uc3QgaCA9IHlEaXJlY3Rpb24gPyBiYm94LmhlaWdodCA6IGJib3gud2lkdGg7XHJcbiAgICBjb25zdCB4VHJhbnNsYXRpb24gPSB4VHJhbnNsYXRpb25EaXJlY3Rpb24gKiAocGFkZGluZyArIHcgLyAyKTtcclxuICAgIGNvbnN0IHlUcmFuc2xhdGlvbiA9IHlUcmFuc2xhdGlvbkRpcmVjdGlvbiAqIChwYWRkaW5nICsgaCAvIDIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4VHJhbnNsYXRpb24sXHJcbiAgICAgICAgeVRyYW5zbGF0aW9uLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyh7IHlEaXJlY3Rpb24sIGJib3gsIHBhZGRpbmcgPSAwLCBwb3NpdGlvbiA9ICd0b3AnLCB9KSB7XHJcbiAgICBjb25zdCBjaGFydFBhZGRpbmcgPSB7fTtcclxuICAgIGlmIChwb3NpdGlvbi5zdGFydHNXaXRoKCdpbnNpZGUnKSlcclxuICAgICAgICByZXR1cm4gY2hhcnRQYWRkaW5nO1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJyAmJiAheURpcmVjdGlvbikge1xyXG4gICAgICAgIGNoYXJ0UGFkZGluZy50b3AgPSBwYWRkaW5nICsgYmJveC5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgJiYgIXlEaXJlY3Rpb24pIHtcclxuICAgICAgICBjaGFydFBhZGRpbmcuYm90dG9tID0gcGFkZGluZyArIGJib3guaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyAmJiB5RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY2hhcnRQYWRkaW5nLmxlZnQgPSBwYWRkaW5nICsgYmJveC53aWR0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnICYmIHlEaXJlY3Rpb24pIHtcclxuICAgICAgICBjaGFydFBhZGRpbmcucmlnaHQgPSBwYWRkaW5nICsgYmJveC53aWR0aDtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGFydFBhZGRpbmc7XHJcbn1cclxuY29uc3QgUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcclxuICAgIGlmICh5RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IHlTdGFydCB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeEVuZCwgeTogIWlzTmFOKHlFbmQpID8gKHlTdGFydCArIHlFbmQpIC8gMiA6IHlTdGFydCB9O1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBQT1NJVElPTl9MRUZUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xyXG4gICAgaWYgKHlEaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6ICFpc05hTih5RW5kKSA/ICh5U3RhcnQgKyB5RW5kKSAvIDIgOiB5U3RhcnQgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiB5U3RhcnQgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgUE9TSVRJT05fUklHSFRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xyXG4gICAgaWYgKHlEaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4RW5kLCB5OiAhaXNOYU4oeUVuZCkgPyAoeVN0YXJ0ICsgeUVuZCkgLyAyIDogeVN0YXJ0IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4RW5kIC8gMiwgeTogIWlzTmFOKHlFbmQpID8geUVuZCA6IHlTdGFydCB9O1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBQT1NJVElPTl9CT1RUT01fQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4U3RhcnQsIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XHJcbiAgICBpZiAoeURpcmVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiAhaXNOYU4oeUVuZCkgPyB5RW5kIDogeVN0YXJ0IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6ICFpc05hTih5RW5kKSA/ICh5U3RhcnQgKyB5RW5kKSAvIDIgOiB5U3RhcnQgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgUE9TSVRJT05fSU5TSURFX0NPT1JESU5BVEVTID0gKHsgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcclxuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiAhaXNOYU4oeUVuZCkgPyAoeVN0YXJ0ICsgeUVuZCkgLyAyIDogeVN0YXJ0IH07XHJcbn07XHJcbmNvbnN0IFBPU0lUSU9OX1RPUF9MRUZUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQgfSkgPT4ge1xyXG4gICAgaWYgKHlEaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4U3RhcnQgLyAyLCB5OiB5U3RhcnQgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IHlTdGFydCB9O1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhTdGFydCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcclxuICAgIGlmICh5RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiAhaXNOYU4oeUVuZCkgPyB5RW5kIDogeVN0YXJ0IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IHlTdGFydCB9O1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xyXG4gICAgaWYgKHlEaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4RW5kLCB5OiB5U3RhcnQgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHhFbmQsIHk6ICFpc05hTih5RW5kKSA/IHlFbmQgOiB5U3RhcnQgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xyXG4gICAgaWYgKHlEaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4RW5kLCB5OiAhaXNOYU4oeUVuZCkgPyB5RW5kIDogeVN0YXJ0IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6ICFpc05hTih5RW5kKSA/IHlFbmQgOiB5U3RhcnQgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgbGFiZWxkRGlyZWN0aW9uSGFuZGxpbmcgPSB7XHJcbiAgICB0b3A6IHsgYzogUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTIH0sXHJcbiAgICBib3R0b206IHsgYzogUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTIH0sXHJcbiAgICBsZWZ0OiB7IGM6IFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgfSxcclxuICAgIHJpZ2h0OiB7IGM6IFBPU0lUSU9OX1JJR0hUX0NPT1JESU5BVEVTIH0sXHJcbiAgICB0b3BMZWZ0OiB7IGM6IFBPU0lUSU9OX1RPUF9MRUZUX0NPT1JESU5BVEVTIH0sXHJcbiAgICB0b3BSaWdodDogeyBjOiBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgfSxcclxuICAgIGJvdHRvbUxlZnQ6IHsgYzogUE9TSVRJT05fQk9UVE9NX0xFRlRfQ09PUkRJTkFURVMgfSxcclxuICAgIGJvdHRvbVJpZ2h0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9SSUdIVF9DT09SRElOQVRFUyB9LFxyXG4gICAgaW5zaWRlOiB7IGM6IFBPU0lUSU9OX0lOU0lERV9DT09SRElOQVRFUyB9LFxyXG4gICAgaW5zaWRlTGVmdDogeyBjOiBQT1NJVElPTl9MRUZUX0NPT1JESU5BVEVTIH0sXHJcbiAgICBpbnNpZGVSaWdodDogeyBjOiBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyB9LFxyXG4gICAgaW5zaWRlVG9wOiB7IGM6IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9LFxyXG4gICAgaW5zaWRlQm90dG9tOiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9DT09SRElOQVRFUyB9LFxyXG4gICAgaW5zaWRlVG9wTGVmdDogeyBjOiBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyB9LFxyXG4gICAgaW5zaWRlQm90dG9tTGVmdDogeyBjOiBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyB9LFxyXG4gICAgaW5zaWRlVG9wUmlnaHQ6IHsgYzogUE9TSVRJT05fVE9QX1JJR0hUX0NPT1JESU5BVEVTIH0sXHJcbiAgICBpbnNpZGVCb3R0b21SaWdodDogeyBjOiBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgfSxcclxufTtcblxuY29uc3QgQ1JPU1NMSU5FX0xBQkVMX1BPU0lUSU9OUyA9IFtcclxuICAgICd0b3AnLFxyXG4gICAgJ2xlZnQnLFxyXG4gICAgJ3JpZ2h0JyxcclxuICAgICdib3R0b20nLFxyXG4gICAgJ3RvcExlZnQnLFxyXG4gICAgJ3RvcFJpZ2h0JyxcclxuICAgICdib3R0b21MZWZ0JyxcclxuICAgICdib3R0b21SaWdodCcsXHJcbiAgICAnaW5zaWRlJyxcclxuICAgICdpbnNpZGVMZWZ0JyxcclxuICAgICdpbnNpZGVSaWdodCcsXHJcbiAgICAnaW5zaWRlVG9wJyxcclxuICAgICdpbnNpZGVCb3R0b20nLFxyXG4gICAgJ2luc2lkZVRvcExlZnQnLFxyXG4gICAgJ2luc2lkZUJvdHRvbUxlZnQnLFxyXG4gICAgJ2luc2lkZVRvcFJpZ2h0JyxcclxuICAgICdpbnNpZGVCb3R0b21SaWdodCcsXHJcbl07XHJcbmNvbnN0IE9QVF9DUk9TU0xJTkVfTEFCRUxfUE9TSVRJT04gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsICh2KSA9PiBDUk9TU0xJTkVfTEFCRUxfUE9TSVRJT05TLmluY2x1ZGVzKHYpKSwgYGV4cGVjdGluZyBhbiBvcHRpb25hbCBjcm9zc0xpbmUgbGFiZWwgcG9zaXRpb24ga2V5d29yZCBzdWNoIGFzICd0b3BMZWZ0JywgJ3RvcFJpZ2h0JyBvciAnaW5zaWRlJ2ApO1xyXG5jb25zdCBPUFRfQ1JPU1NMSU5FX1RZUEUgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodiwgY3R4KSA9PiBPUFRJT05BTCh2LCBjdHgsICh2KSA9PiB2ID09PSAncmFuZ2UnIHx8IHYgPT09ICdsaW5lJyksIGBleHBlY3RpbmcgYSBjcm9zc0xpbmUgdHlwZSBrZXl3b3JkIHN1Y2ggYXMgJ3JhbmdlJyBvciAnbGluZSdgKTtcclxuY2xhc3MgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZvbnRTdHlsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IDE0O1xyXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9ICdWZXJkYW5hLCBzYW5zLXNlcmlmJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcGFkZGluZyBiZXR3ZWVuIHRoZSBsYWJlbCBhbmQgdGhlIGxpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sb3Igb2YgdGhlIGxhYmVscy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbG9yID0gJ3JnYmEoODcsIDg3LCA4NywgMSknO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnBhcmFsbGVsID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0JPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9GT05UX1NUWUxFKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRk9OVF9XRUlHSFQpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShTVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0NPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ1JPU1NMSU5FX0xBQkVMX1BPU0lUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoLTM2MCwgMzYwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQk9PTEVBTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInBhcmFsbGVsXCIsIHZvaWQgMCk7XHJcbmNsYXNzIENhcnRlc2lhbkNyb3NzTGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnJhbmdlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5maWxsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZmlsbE9wYWNpdHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdHJva2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5saW5lRGFzaCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxhYmVsID0gbmV3IENhcnRlc2lhbkNyb3NzTGluZUxhYmVsKCk7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNsaXBwZWRSYW5nZSA9IFstSW5maW5pdHksIEluZmluaXR5XTtcclxuICAgICAgICB0aGlzLmdyaWRMZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuc2lkZUZsYWcgPSAtMTtcclxuICAgICAgICB0aGlzLnBhcmFsbGVsRmxpcFJvdGF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLnJlZ3VsYXJGbGlwUm90YXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gQ2hhcnRBeGlzRGlyZWN0aW9uLlg7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9YCwgbGF5ZXI6IHRydWUsIHpJbmRleDogQ2FydGVzaWFuQ3Jvc3NMaW5lLkxJTkVfTEFZRVJfWklOREVYIH0pO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lUmFuZ2UgPSBuZXcgUmFuZ2UoKTtcclxuICAgICAgICB0aGlzLmNyb3NzTGluZUxhYmVsID0gbmV3IFRleHQoKTtcclxuICAgICAgICB0aGlzLmxhYmVsUG9pbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gW107XHJcbiAgICAgICAgdGhpcy5zdGFydExpbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZExpbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB7IGdyb3VwLCBjcm9zc0xpbmVSYW5nZSwgY3Jvc3NMaW5lTGFiZWwgfSA9IHRoaXM7XHJcbiAgICAgICAgZ3JvdXAuYXBwZW5kKFtjcm9zc0xpbmVSYW5nZSwgY3Jvc3NMaW5lTGFiZWxdKTtcclxuICAgICAgICBjcm9zc0xpbmVSYW5nZS5wb2ludGVyRXZlbnRzID0gUG9pbnRlckV2ZW50cy5Ob25lO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHZpc2libGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdmlzaWJsZSB8fCB0aGlzLmRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ncm91cC56SW5kZXggPSB0aGlzLmdldFpJbmRleCh0aGlzLmlzUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTm9kZXMoKTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZUxheW91dCh2aXNpYmxlKSB7XHJcbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YUNyZWF0ZWQgPSB0aGlzLmNyZWF0ZU5vZGVEYXRhKCk7XHJcbiAgICAgICAgaWYgKCFkYXRhQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgc2lkZUZsYWcsIGdyaWRMZW5ndGgsIGRhdGEgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgYm94ZXMgPSBbXTtcclxuICAgICAgICBjb25zdCB4MSA9IDA7XHJcbiAgICAgICAgY29uc3QgeDIgPSBzaWRlRmxhZyAqIGdyaWRMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgeTEgPSBkYXRhWzBdO1xyXG4gICAgICAgIGNvbnN0IHkyID0gZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBjcm9zc0xpbmVCb3ggPSBuZXcgQkJveChNYXRoLm1pbih4MSwgeDIpLCBNYXRoLm1pbih5MSwgeTIpLCBNYXRoLmFicyh4MSAtIHgyKSwgTWF0aC5hYnMoeTEgLSB5MikpO1xyXG4gICAgICAgIGJveGVzLnB1c2goY3Jvc3NMaW5lQm94KTtcclxuICAgICAgICBjb25zdCBsYWJlbEJveCA9IHRoaXMuY29tcHV0ZUxhYmVsQkJveCgpO1xyXG4gICAgICAgIGlmIChsYWJlbEJveCkge1xyXG4gICAgICAgICAgICBib3hlcy5wdXNoKGxhYmVsQm94KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEJCb3gubWVyZ2UoYm94ZXMpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTm9kZXMoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZU5vZGUoKTtcclxuICAgICAgICBpZiAodGhpcy5sYWJlbC5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkxhYmVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlTm9kZURhdGEoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IHNjYWxlLCBncmlkTGVuZ3RoLCBzaWRlRmxhZywgZGlyZWN0aW9uLCBsYWJlbDogeyBwb3NpdGlvbiA9ICd0b3AnIH0sIGNsaXBwZWRSYW5nZSwgc3Ryb2tlV2lkdGggPSAwLCB9ID0gdGhpcztcclxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcclxuICAgICAgICBpZiAoIXNjYWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmFuZHdpZHRoID0gKF9hID0gc2NhbGUuYmFuZHdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgIGNvbnN0IGNsaXBwZWRSYW5nZUNsYW1wZXIgPSAoeCkgPT4gTWF0aC5tYXgoTWF0aC5taW4oLi4uY2xpcHBlZFJhbmdlKSwgTWF0aC5taW4oTWF0aC5tYXgoLi4uY2xpcHBlZFJhbmdlKSwgeCkpO1xyXG4gICAgICAgIGNvbnN0IFt4U3RhcnQsIHhFbmRdID0gWzAsIHNpZGVGbGFnICogZ3JpZExlbmd0aF07XHJcbiAgICAgICAgbGV0IFt5U3RhcnQsIHlFbmRdID0gdGhpcy5nZXRSYW5nZSgpO1xyXG4gICAgICAgIGxldCBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdID0gW1xyXG4gICAgICAgICAgICBOdW1iZXIoc2NhbGUuY29udmVydCh5U3RhcnQsIHsgY2xhbXBNb2RlOiAnY2xhbXBlZCcgfSkpLFxyXG4gICAgICAgICAgICBzY2FsZS5jb252ZXJ0KHlFbmQsIHsgY2xhbXBNb2RlOiAnY2xhbXBlZCcgfSkgKyBiYW5kd2lkdGgsXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjbGFtcGVkWVN0YXJ0ID0gY2xpcHBlZFJhbmdlQ2xhbXBlcihjbGFtcGVkWVN0YXJ0KTtcclxuICAgICAgICBjbGFtcGVkWUVuZCA9IGNsaXBwZWRSYW5nZUNsYW1wZXIoY2xhbXBlZFlFbmQpO1xyXG4gICAgICAgIFt5U3RhcnQsIHlFbmRdID0gW051bWJlcihzY2FsZS5jb252ZXJ0KHlTdGFydCkpLCBzY2FsZS5jb252ZXJ0KHlFbmQpICsgYmFuZHdpZHRoXTtcclxuICAgICAgICBjb25zdCB2YWxpZFJhbmdlID0gIWlzTmFOKGNsYW1wZWRZU3RhcnQpICYmXHJcbiAgICAgICAgICAgICFpc05hTihjbGFtcGVkWUVuZCkgJiZcclxuICAgICAgICAgICAgKHlTdGFydCA9PT0gY2xhbXBlZFlTdGFydCB8fCB5RW5kID09PSBjbGFtcGVkWUVuZCB8fCBjbGFtcGVkWVN0YXJ0ICE9PSBjbGFtcGVkWUVuZCkgJiZcclxuICAgICAgICAgICAgTWF0aC5hYnMoY2xhbXBlZFlFbmQgLSBjbGFtcGVkWVN0YXJ0KSA+IDA7XHJcbiAgICAgICAgaWYgKHZhbGlkUmFuZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZSA9IGNsYW1wZWRZU3RhcnQgIT09IE1hdGgubWluKGNsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kKTtcclxuICAgICAgICAgICAgaWYgKHJldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgIFtjbGFtcGVkWVN0YXJ0LCBjbGFtcGVkWUVuZF0gPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kKSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBbeVN0YXJ0LCB5RW5kXSA9IFt5RW5kLCB5U3RhcnRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNSYW5nZSA9IHZhbGlkUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5zdGFydExpbmUgPSAhaXNOYU4oeVN0YXJ0KSAmJiBzdHJva2VXaWR0aCA+IDAgJiYgeVN0YXJ0ID09PSBjbGFtcGVkWVN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kTGluZSA9ICFpc05hTih5RW5kKSAmJiBzdHJva2VXaWR0aCA+IDAgJiYgeUVuZCA9PT0gY2xhbXBlZFlFbmQ7XHJcbiAgICAgICAgaWYgKCF2YWxpZFJhbmdlICYmICF0aGlzLnN0YXJ0TGluZSAmJiAhdGhpcy5lbmRMaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhID0gW2NsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kXTtcclxuICAgICAgICBpZiAodGhpcy5sYWJlbC5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHlEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IENoYXJ0QXhpc0RpcmVjdGlvbi5ZO1xyXG4gICAgICAgICAgICBjb25zdCB7IGMgPSBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMgfSA9IChfYiA9IGxhYmVsZERpcmVjdGlvbkhhbmRsaW5nW3Bvc2l0aW9uXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeDogbGFiZWxYLCB5OiBsYWJlbFkgfSA9IGMoe1xyXG4gICAgICAgICAgICAgICAgeURpcmVjdGlvbixcclxuICAgICAgICAgICAgICAgIHhTdGFydCxcclxuICAgICAgICAgICAgICAgIHhFbmQsXHJcbiAgICAgICAgICAgICAgICB5U3RhcnQ6IGNsYW1wZWRZU3RhcnQsXHJcbiAgICAgICAgICAgICAgICB5RW5kOiBjbGFtcGVkWUVuZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxQb2ludCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGxhYmVsWCxcclxuICAgICAgICAgICAgICAgIHk6IGxhYmVsWSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVSYW5nZU5vZGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgY3Jvc3NMaW5lUmFuZ2UsIHNpZGVGbGFnLCBncmlkTGVuZ3RoLCBkYXRhLCBzdGFydExpbmUsIGVuZExpbmUsIGlzUmFuZ2UsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBsaW5lRGFzaCwgfSA9IHRoaXM7XHJcbiAgICAgICAgY3Jvc3NMaW5lUmFuZ2UueDEgPSAwO1xyXG4gICAgICAgIGNyb3NzTGluZVJhbmdlLngyID0gc2lkZUZsYWcgKiBncmlkTGVuZ3RoO1xyXG4gICAgICAgIGNyb3NzTGluZVJhbmdlLnkxID0gZGF0YVswXTtcclxuICAgICAgICBjcm9zc0xpbmVSYW5nZS55MiA9IGRhdGFbMV07XHJcbiAgICAgICAgY3Jvc3NMaW5lUmFuZ2Uuc3RhcnRMaW5lID0gc3RhcnRMaW5lO1xyXG4gICAgICAgIGNyb3NzTGluZVJhbmdlLmVuZExpbmUgPSBlbmRMaW5lO1xyXG4gICAgICAgIGNyb3NzTGluZVJhbmdlLmlzUmFuZ2UgPSBpc1JhbmdlO1xyXG4gICAgICAgIGNyb3NzTGluZVJhbmdlLmZpbGwgPSBmaWxsO1xyXG4gICAgICAgIGNyb3NzTGluZVJhbmdlLmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHkgIT09IG51bGwgJiYgZmlsbE9wYWNpdHkgIT09IHZvaWQgMCA/IGZpbGxPcGFjaXR5IDogMTtcclxuICAgICAgICBjcm9zc0xpbmVSYW5nZS5zdHJva2UgPSBzdHJva2U7XHJcbiAgICAgICAgY3Jvc3NMaW5lUmFuZ2Uuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAhPT0gbnVsbCAmJiBzdHJva2VXaWR0aCAhPT0gdm9pZCAwID8gc3Ryb2tlV2lkdGggOiAxO1xyXG4gICAgICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZU9wYWNpdHkgPSAoX2EgPSB0aGlzLnN0cm9rZU9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICAgICAgY3Jvc3NMaW5lUmFuZ2UubGluZURhc2ggPSBsaW5lRGFzaDtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxhYmVsKCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3Jvc3NMaW5lTGFiZWwsIGxhYmVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghbGFiZWwudGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNyb3NzTGluZUxhYmVsLmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcclxuICAgICAgICBjcm9zc0xpbmVMYWJlbC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcclxuICAgICAgICBjcm9zc0xpbmVMYWJlbC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xyXG4gICAgICAgIGNyb3NzTGluZUxhYmVsLmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xyXG4gICAgICAgIGNyb3NzTGluZUxhYmVsLmZpbGwgPSBsYWJlbC5jb2xvcjtcclxuICAgICAgICBjcm9zc0xpbmVMYWJlbC50ZXh0ID0gbGFiZWwudGV4dDtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uTGFiZWwoKSB7XHJcbiAgICAgICAgY29uc3QgeyBjcm9zc0xpbmVMYWJlbCwgbGFiZWxQb2ludDogeyB4ID0gdW5kZWZpbmVkLCB5ID0gdW5kZWZpbmVkIH0gPSB7fSwgbGFiZWw6IHsgcGFyYWxsZWwsIHJvdGF0aW9uLCBwb3NpdGlvbiA9ICd0b3AnLCBwYWRkaW5nID0gMCB9LCBkaXJlY3Rpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uLCB9ID0gdGhpcztcclxuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdFJvdGF0aW9uLCBjb25maWd1cmVkUm90YXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xyXG4gICAgICAgICAgICByb3RhdGlvbixcclxuICAgICAgICAgICAgcGFyYWxsZWwsXHJcbiAgICAgICAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXHJcbiAgICAgICAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNyb3NzTGluZUxhYmVsLnJvdGF0aW9uID0gZGVmYXVsdFJvdGF0aW9uICsgY29uZmlndXJlZFJvdGF0aW9uO1xyXG4gICAgICAgIGNyb3NzTGluZUxhYmVsLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgIGNyb3NzTGluZUxhYmVsLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSBjcm9zc0xpbmVMYWJlbC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XHJcbiAgICAgICAgaWYgKCFiYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlk7XHJcbiAgICAgICAgY29uc3QgeyB4VHJhbnNsYXRpb24sIHlUcmFuc2xhdGlvbiB9ID0gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbih7XHJcbiAgICAgICAgICAgIHlEaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIHBhZGRpbmcsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICBiYm94LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNyb3NzTGluZUxhYmVsLnRyYW5zbGF0aW9uWCA9IHggKyB4VHJhbnNsYXRpb247XHJcbiAgICAgICAgY3Jvc3NMaW5lTGFiZWwudHJhbnNsYXRpb25ZID0geSArIHlUcmFuc2xhdGlvbjtcclxuICAgIH1cclxuICAgIGdldFpJbmRleChpc1JhbmdlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoaXNSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2FydGVzaWFuQ3Jvc3NMaW5lLlJBTkdFX0xBWUVSX1pJTkRFWDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENhcnRlc2lhbkNyb3NzTGluZS5MSU5FX0xBWUVSX1pJTkRFWDtcclxuICAgIH1cclxuICAgIGdldFJhbmdlKCkge1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIHJhbmdlLCBzY2FsZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBpc0NvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUpO1xyXG4gICAgICAgIGxldCBbc3RhcnQsIGVuZF0gPSByYW5nZSAhPT0gbnVsbCAmJiByYW5nZSAhPT0gdm9pZCAwID8gcmFuZ2UgOiBbdmFsdWUsIHVuZGVmaW5lZF07XHJcbiAgICAgICAgaWYgKCFpc0NvbnRpbnVvdXMgJiYgZW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0ID0gY2hlY2tEYXR1bShzdGFydCwgaXNDb250aW51b3VzKSAhPSBudWxsID8gc3RhcnQgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgZW5kID0gY2hlY2tEYXR1bShlbmQsIGlzQ29udGludW91cykgIT0gbnVsbCA/IGVuZCA6IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoaXNDb250aW51b3VzICYmIHN0YXJ0ID09PSBlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCAmJiBlbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcclxuICAgICAgICAgICAgZW5kID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZUxhYmVsQkJveCgpIHtcclxuICAgICAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghbGFiZWwuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUZXh0KCk7XHJcbiAgICAgICAgdGVtcFRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgdGVtcFRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcclxuICAgICAgICB0ZW1wVGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XHJcbiAgICAgICAgdGVtcFRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XHJcbiAgICAgICAgdGVtcFRleHQudGV4dCA9IGxhYmVsLnRleHQ7XHJcbiAgICAgICAgY29uc3QgeyBsYWJlbFBvaW50OiB7IHggPSB1bmRlZmluZWQsIHkgPSB1bmRlZmluZWQgfSA9IHt9LCBsYWJlbDogeyBwYXJhbGxlbCwgcm90YXRpb24sIHBvc2l0aW9uID0gJ3RvcCcsIHBhZGRpbmcgPSAwIH0sIGRpcmVjdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24sIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY29uZmlndXJlZFJvdGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcclxuICAgICAgICAgICAgcm90YXRpb24sXHJcbiAgICAgICAgICAgIHBhcmFsbGVsLFxyXG4gICAgICAgICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxyXG4gICAgICAgICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbjtcclxuICAgICAgICB0ZW1wVGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICAgICAgICB0ZW1wVGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICBjb25zdCBiYm94ID0gdGVtcFRleHQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xyXG4gICAgICAgIGlmICghYmJveCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB5RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBDaGFydEF4aXNEaXJlY3Rpb24uWTtcclxuICAgICAgICBjb25zdCB7IHhUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcclxuICAgICAgICAgICAgeURpcmVjdGlvbixcclxuICAgICAgICAgICAgcGFkZGluZyxcclxuICAgICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIGJib3gsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGVtcFRleHQudHJhbnNsYXRpb25YID0geCArIHhUcmFuc2xhdGlvbjtcclxuICAgICAgICB0ZW1wVGV4dC50cmFuc2xhdGlvblkgPSB5ICsgeVRyYW5zbGF0aW9uO1xyXG4gICAgICAgIHJldHVybiB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVQYWRkaW5nKHBhZGRpbmcpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xyXG4gICAgICAgIGNvbnN0IHsgaXNSYW5nZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBkaXJlY3Rpb24sIGxhYmVsOiB7IHBhZGRpbmc6IGxhYmVsUGFkZGluZyA9IDAsIHBvc2l0aW9uID0gJ3RvcCcgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFpc1JhbmdlICYmICFzdGFydExpbmUgJiYgIWVuZExpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjcm9zc0xpbmVMYWJlbEJCb3ggPSB0aGlzLmNvbXB1dGVMYWJlbEJCb3goKTtcclxuICAgICAgICBjb25zdCBsYWJlbFggPSBjcm9zc0xpbmVMYWJlbEJCb3ggPT09IG51bGwgfHwgY3Jvc3NMaW5lTGFiZWxCQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcm9zc0xpbmVMYWJlbEJCb3gueDtcclxuICAgICAgICBjb25zdCBsYWJlbFkgPSBjcm9zc0xpbmVMYWJlbEJCb3ggPT09IG51bGwgfHwgY3Jvc3NMaW5lTGFiZWxCQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcm9zc0xpbmVMYWJlbEJCb3gueTtcclxuICAgICAgICBpZiAoIWNyb3NzTGluZUxhYmVsQkJveCB8fCBsYWJlbFggPT0gdW5kZWZpbmVkIHx8IGxhYmVsWSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGFydFBhZGRpbmcgPSBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyh7XHJcbiAgICAgICAgICAgIHlEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlksXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGxhYmVsUGFkZGluZyxcclxuICAgICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIGJib3g6IGNyb3NzTGluZUxhYmVsQkJveCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYWRkaW5nLmxlZnQgPSBNYXRoLm1heCgoX2EgPSBwYWRkaW5nLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsIChfYiA9IGNoYXJ0UGFkZGluZy5sZWZ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcclxuICAgICAgICBwYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgoKF9jID0gcGFkZGluZy5yaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCwgKF9kID0gY2hhcnRQYWRkaW5nLnJpZ2h0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKTtcclxuICAgICAgICBwYWRkaW5nLnRvcCA9IE1hdGgubWF4KChfZSA9IHBhZGRpbmcudG9wKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwLCAoX2YgPSBjaGFydFBhZGRpbmcudG9wKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAwKTtcclxuICAgICAgICBwYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KChfZyA9IHBhZGRpbmcuYm90dG9tKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAwLCAoX2ggPSBjaGFydFBhZGRpbmcuYm90dG9tKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAwKTtcclxuICAgIH1cclxufVxyXG5DYXJ0ZXNpYW5Dcm9zc0xpbmUuTElORV9MQVlFUl9aSU5ERVggPSBMYXllcnMuU0VSSUVTX0NST1NTTElORV9MSU5FX1pJTkRFWDtcclxuQ2FydGVzaWFuQ3Jvc3NMaW5lLlJBTkdFX0xBWUVSX1pJTkRFWCA9IExheWVycy5TRVJJRVNfQ1JPU1NMSU5FX1JBTkdFX1pJTkRFWDtcclxuQ2FydGVzaWFuQ3Jvc3NMaW5lLmNsYXNzTmFtZSA9ICdDcm9zc0xpbmUnO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9CT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ1JPU1NMSU5FX1RZUEUpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0FSUkFZKDIpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJyYW5nZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0NPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTElORV9EQVNIKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCB2b2lkIDApO1xuXG5jb25zdCBpZGVudGl0eSA9ICh4KSA9PiB4O1xyXG5jbGFzcyBMb2dTY2FsZSBleHRlbmRzIENvbnRpbnVvdXNTY2FsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihbMSwgMTBdLCBbMCwgMV0pO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdsb2cnO1xyXG4gICAgICAgIHRoaXMuYmFzZSA9IDEwO1xyXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcyA9IFsnZG9tYWluJywgJ3JhbmdlJywgJ25pY2UnLCAndGlja0NvdW50JywgJ2Jhc2UnXTtcclxuICAgICAgICB0aGlzLmJhc2VMb2cgPSBpZGVudGl0eTtcclxuICAgICAgICB0aGlzLmJhc2VQb3cgPSBpZGVudGl0eTtcclxuICAgICAgICB0aGlzLmxvZyA9ICh4KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbWFpblswXSA+PSAwID8gdGhpcy5iYXNlTG9nKHgpIDogLXRoaXMuYmFzZUxvZygteCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBvdyA9ICh4KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbWFpblswXSA+PSAwID8gdGhpcy5iYXNlUG93KHgpIDogLXRoaXMuYmFzZVBvdygteCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBIYW5kbGluZyA8MSBhbmQgY3Jvc3NpbmcgMCBjYXNlcyBpcyB0cmlja3ksIGVhc2llc3Qgc29sdXRpb24gaXMgdG8gZGVmYXVsdCB0byBjbGFtcGluZy5cclxuICAgICAgICB0aGlzLmRlZmF1bHRDbGFtcE1vZGUgPSAnY2xhbXBlZCc7XHJcbiAgICB9XHJcbiAgICB0b0RvbWFpbihkKSB7XHJcbiAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm0oeCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbWFpblswXSA+PSAwID8gTWF0aC5sb2coeCkgOiAtTWF0aC5sb2coLXgpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtSW52ZXJ0KHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb21haW5bMF0gPj0gMCA/IE1hdGguZXhwKHgpIDogLU1hdGguZXhwKC14KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZUxvZ0ZuKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQb3dGbigpO1xyXG4gICAgICAgIGlmICh0aGlzLm5pY2UpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVOaWNlRG9tYWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlTG9nRm4oKSB7XHJcbiAgICAgICAgY29uc3QgeyBiYXNlIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCBsb2c7XHJcbiAgICAgICAgaWYgKGJhc2UgPT09IDEwKSB7XHJcbiAgICAgICAgICAgIGxvZyA9IE1hdGgubG9nMTA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJhc2UgPT09IE1hdGguRSkge1xyXG4gICAgICAgICAgICBsb2cgPSBNYXRoLmxvZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYmFzZSA9PT0gMikge1xyXG4gICAgICAgICAgICBsb2cgPSBNYXRoLmxvZzI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBsb2dCYXNlID0gTWF0aC5sb2coYmFzZSk7XHJcbiAgICAgICAgICAgIGxvZyA9ICh4KSA9PiBNYXRoLmxvZyh4KSAvIGxvZ0Jhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmFzZUxvZyA9IGxvZztcclxuICAgIH1cclxuICAgIHVwZGF0ZVBvd0ZuKCkge1xyXG4gICAgICAgIGNvbnN0IHsgYmFzZSB9ID0gdGhpcztcclxuICAgICAgICBsZXQgcG93O1xyXG4gICAgICAgIGlmIChiYXNlID09PSAxMCkge1xyXG4gICAgICAgICAgICBwb3cgPSBMb2dTY2FsZS5wb3cxMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYmFzZSA9PT0gTWF0aC5FKSB7XHJcbiAgICAgICAgICAgIHBvdyA9IE1hdGguZXhwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcG93ID0gKHgpID0+IE1hdGgucG93KGJhc2UsIHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJhc2VQb3cgPSBwb3c7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVOaWNlRG9tYWluKCkge1xyXG4gICAgICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5kb21haW47XHJcbiAgICAgICAgY29uc3QgbjAgPSB0aGlzLnBvdyhNYXRoLmZsb29yKHRoaXMubG9nKGQwKSkpO1xyXG4gICAgICAgIGNvbnN0IG4xID0gdGhpcy5wb3coTWF0aC5jZWlsKHRoaXMubG9nKGQxKSkpO1xyXG4gICAgICAgIHRoaXMubmljZURvbWFpbiA9IFtuMCwgbjFdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHBvdzEwKHgpIHtcclxuICAgICAgICByZXR1cm4geCA+PSAwID8gTWF0aC5wb3coMTAsIHgpIDogMSAvIE1hdGgucG93KDEwLCAteCk7XHJcbiAgICB9XHJcbiAgICB0aWNrcygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSAoX2EgPSB0aGlzLnRpY2tDb3VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTA7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyIHx8IGNvdW50IDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJhc2U7XHJcbiAgICAgICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmdldERvbWFpbigpO1xyXG4gICAgICAgIGxldCBwMCA9IHRoaXMubG9nKGQwKTtcclxuICAgICAgICBsZXQgcDEgPSB0aGlzLmxvZyhkMSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IE1hdGguYWJzKHRoaXMuaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBjb25zdCBhYnNEaWZmID0gTWF0aC5hYnMocDEgLSBwMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpY2tzID0gcmFuZ2UkMShwMCwgcDEsIE1hdGgubWluKGFic0RpZmYsIHN0ZXApKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoeCkgPT4gdGhpcy5wb3coeCkpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh0KSA9PiB0ID49IGQwICYmIHQgPD0gZDEpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEZW5zZUludGVydmFsKHsgc3RhcnQ6IGQwLCBzdG9wOiBkMSwgaW50ZXJ2YWw6IHN0ZXAsIGNvdW50OiB0aWNrcy5sZW5ndGggfSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aWNrcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc0Jhc2VJbnRlZ2VyID0gYmFzZSAlIDEgPT09IDA7XHJcbiAgICAgICAgY29uc3QgaXNEaWZmTGFyZ2UgPSBwMSAtIHAwID49IGNvdW50O1xyXG4gICAgICAgIGlmICghaXNCYXNlSW50ZWdlciB8fCBpc0RpZmZMYXJnZSkge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm5zIFsxMF4xLCAxMF4yLCAxMF4zLCAxMF40LCAuLi5dXHJcbiAgICAgICAgICAgIHJldHVybiB0aWNrcyhwMCwgcDEsIE1hdGgubWluKHAxIC0gcDAsIGNvdW50KSkubWFwKCh4KSA9PiB0aGlzLnBvdyh4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRpY2tzJDEgPSBbXTtcclxuICAgICAgICBjb25zdCBpc1Bvc2l0aXZlID0gZDAgPiAwO1xyXG4gICAgICAgIHAwID0gTWF0aC5mbG9vcihwMCkgLSAxO1xyXG4gICAgICAgIHAxID0gTWF0aC5yb3VuZChwMSkgKyAxO1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnRoaXMucmFuZ2UpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnRoaXMucmFuZ2UpO1xyXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNwYWNpbmcgPSAobWF4IC0gbWluKSAvIGNvdW50O1xyXG4gICAgICAgIGxldCBsYXN0VGlja1Bvc2l0aW9uID0gSW5maW5pdHk7XHJcbiAgICAgICAgZm9yIChsZXQgcCA9IHAwOyBwIDw9IHAxOyBwKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE1hZ25pdHVkZVRpY2tQb3NpdGlvbiA9IHRoaXMuY29udmVydCh0aGlzLnBvdyhwICsgMSkpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IGJhc2U7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcSA9IGlzUG9zaXRpdmUgPyBrIDogYmFzZSAtIGsgKyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMucG93KHApICogcTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tQb3NpdGlvbiA9IHRoaXMuY29udmVydCh0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZTcGFjaW5nID0gTWF0aC5hYnMobGFzdFRpY2tQb3NpdGlvbiAtIHRpY2tQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3BhY2luZyA9IE1hdGguYWJzKHRpY2tQb3NpdGlvbiAtIG5leHRNYWduaXR1ZGVUaWNrUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZml0cyA9IHByZXZTcGFjaW5nID49IGF2YWlsYWJsZVNwYWNpbmcgJiYgbmV4dFNwYWNpbmcgPj0gYXZhaWxhYmxlU3BhY2luZztcclxuICAgICAgICAgICAgICAgIGlmICh0ID49IGQwICYmIHQgPD0gZDEgJiYgKGsgPT09IDEgfHwgZml0cykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWNrcyQxLnB1c2godCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRpY2tQb3NpdGlvbiA9IHRpY2tQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlja3MkMTtcclxuICAgIH1cclxuICAgIHRpY2tGb3JtYXQoeyBjb3VudCwgdGlja3MsIHNwZWNpZmllciwgfSkge1xyXG4gICAgICAgIGNvbnN0IHsgYmFzZSB9ID0gdGhpcztcclxuICAgICAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyAnLjBlJyA6ICcsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHNwZWNpZmllciA9IGZvcm1hdChzcGVjaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aWNrcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlja3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZXIoZCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIExvZ1NjYWxlLnByb3RvdHlwZSwgXCJiYXNlXCIsIHZvaWQgMCk7XG5cbnZhciBEZWZhdWx0VGltZUZvcm1hdHM7XHJcbihmdW5jdGlvbiAoRGVmYXVsdFRpbWVGb3JtYXRzKSB7XHJcbiAgICBEZWZhdWx0VGltZUZvcm1hdHNbRGVmYXVsdFRpbWVGb3JtYXRzW1wiTUlMTElTRUNPTkRcIl0gPSAwXSA9IFwiTUlMTElTRUNPTkRcIjtcclxuICAgIERlZmF1bHRUaW1lRm9ybWF0c1tEZWZhdWx0VGltZUZvcm1hdHNbXCJTRUNPTkRcIl0gPSAxXSA9IFwiU0VDT05EXCI7XHJcbiAgICBEZWZhdWx0VGltZUZvcm1hdHNbRGVmYXVsdFRpbWVGb3JtYXRzW1wiTUlOVVRFXCJdID0gMl0gPSBcIk1JTlVURVwiO1xyXG4gICAgRGVmYXVsdFRpbWVGb3JtYXRzW0RlZmF1bHRUaW1lRm9ybWF0c1tcIkhPVVJcIl0gPSAzXSA9IFwiSE9VUlwiO1xyXG4gICAgRGVmYXVsdFRpbWVGb3JtYXRzW0RlZmF1bHRUaW1lRm9ybWF0c1tcIldFRUtfREFZXCJdID0gNF0gPSBcIldFRUtfREFZXCI7XHJcbiAgICBEZWZhdWx0VGltZUZvcm1hdHNbRGVmYXVsdFRpbWVGb3JtYXRzW1wiU0hPUlRfTU9OVEhcIl0gPSA1XSA9IFwiU0hPUlRfTU9OVEhcIjtcclxuICAgIERlZmF1bHRUaW1lRm9ybWF0c1tEZWZhdWx0VGltZUZvcm1hdHNbXCJNT05USFwiXSA9IDZdID0gXCJNT05USFwiO1xyXG4gICAgRGVmYXVsdFRpbWVGb3JtYXRzW0RlZmF1bHRUaW1lRm9ybWF0c1tcIlNIT1JUX1lFQVJcIl0gPSA3XSA9IFwiU0hPUlRfWUVBUlwiO1xyXG4gICAgRGVmYXVsdFRpbWVGb3JtYXRzW0RlZmF1bHRUaW1lRm9ybWF0c1tcIllFQVJcIl0gPSA4XSA9IFwiWUVBUlwiO1xyXG59KShEZWZhdWx0VGltZUZvcm1hdHMgfHwgKERlZmF1bHRUaW1lRm9ybWF0cyA9IHt9KSk7XHJcbmNvbnN0IGZvcm1hdFN0cmluZ3MgPSB7XHJcbiAgICBbRGVmYXVsdFRpbWVGb3JtYXRzLk1JTExJU0VDT05EXTogJy4lTCcsXHJcbiAgICBbRGVmYXVsdFRpbWVGb3JtYXRzLlNFQ09ORF06ICc6JVMnLFxyXG4gICAgW0RlZmF1bHRUaW1lRm9ybWF0cy5NSU5VVEVdOiAnJUk6JU0nLFxyXG4gICAgW0RlZmF1bHRUaW1lRm9ybWF0cy5IT1VSXTogJyVJICVwJyxcclxuICAgIFtEZWZhdWx0VGltZUZvcm1hdHMuV0VFS19EQVldOiAnJWEnLFxyXG4gICAgW0RlZmF1bHRUaW1lRm9ybWF0cy5TSE9SVF9NT05USF06ICclYiAlZCcsXHJcbiAgICBbRGVmYXVsdFRpbWVGb3JtYXRzLk1PTlRIXTogJyVCJyxcclxuICAgIFtEZWZhdWx0VGltZUZvcm1hdHMuU0hPUlRfWUVBUl06ICcleScsXHJcbiAgICBbRGVmYXVsdFRpbWVGb3JtYXRzLllFQVJdOiAnJVknLFxyXG59O1xyXG5mdW5jdGlvbiB0b051bWJlcih4KSB7XHJcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIERhdGUgPyB4LmdldFRpbWUoKSA6IHg7XHJcbn1cclxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFtuZXcgRGF0ZSgyMDIyLCAxMSwgNyksIG5ldyBEYXRlKDIwMjIsIDExLCA4KV0sIFswLCAxXSk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3RpbWUnO1xyXG4gICAgICAgIHRoaXMuY2FjaGVQcm9wcyA9IFtcclxuICAgICAgICAgICAgJ2RvbWFpbicsXHJcbiAgICAgICAgICAgICdyYW5nZScsXHJcbiAgICAgICAgICAgICduaWNlJyxcclxuICAgICAgICAgICAgJ3RpY2tDb3VudCcsXHJcbiAgICAgICAgICAgICdpbnRlcnZhbCcsXHJcbiAgICAgICAgICAgICdtaW5UaWNrQ291bnQnLFxyXG4gICAgICAgICAgICAnbWF4VGlja0NvdW50JyxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMueWVhciA9IHllYXI7XHJcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoO1xyXG4gICAgICAgIHRoaXMud2VlayA9IHN1bmRheTtcclxuICAgICAgICB0aGlzLmRheSA9IGRheTtcclxuICAgICAgICB0aGlzLmhvdXIgPSBob3VyO1xyXG4gICAgICAgIHRoaXMubWludXRlID0gbWludXRlO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xyXG4gICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcnJheSBvZiBkZWZhdWx0IHRpY2sgaW50ZXJ2YWxzIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIFtcclxuICAgICAgICAgKiAgICAgICAgIGludGVydmFsICh1bml0IG9mIHRpbWUpLFxyXG4gICAgICAgICAqICAgICAgICAgbnVtYmVyIG9mIHVuaXRzIChzdGVwKSxcclxuICAgICAgICAgKiAgICAgICAgIHRoZSBsZW5ndGggb2YgdGhhdCBudW1iZXIgb2YgdW5pdHMgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICogICAgIF1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbHMgPSBbXHJcbiAgICAgICAgICAgIFt0aGlzLnNlY29uZCwgMSwgZHVyYXRpb25TZWNvbmRdLFxyXG4gICAgICAgICAgICBbdGhpcy5zZWNvbmQsIDUsIDUgKiBkdXJhdGlvblNlY29uZF0sXHJcbiAgICAgICAgICAgIFt0aGlzLnNlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxyXG4gICAgICAgICAgICBbdGhpcy5zZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcclxuICAgICAgICAgICAgW3RoaXMubWludXRlLCAxLCBkdXJhdGlvbk1pbnV0ZV0sXHJcbiAgICAgICAgICAgIFt0aGlzLm1pbnV0ZSwgNSwgNSAqIGR1cmF0aW9uTWludXRlXSxcclxuICAgICAgICAgICAgW3RoaXMubWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXHJcbiAgICAgICAgICAgIFt0aGlzLm1pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxyXG4gICAgICAgICAgICBbdGhpcy5ob3VyLCAxLCBkdXJhdGlvbkhvdXJdLFxyXG4gICAgICAgICAgICBbdGhpcy5ob3VyLCAzLCAzICogZHVyYXRpb25Ib3VyXSxcclxuICAgICAgICAgICAgW3RoaXMuaG91ciwgNiwgNiAqIGR1cmF0aW9uSG91cl0sXHJcbiAgICAgICAgICAgIFt0aGlzLmhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91cl0sXHJcbiAgICAgICAgICAgIFt0aGlzLmRheSwgMSwgZHVyYXRpb25EYXldLFxyXG4gICAgICAgICAgICBbdGhpcy5kYXksIDIsIDIgKiBkdXJhdGlvbkRheV0sXHJcbiAgICAgICAgICAgIFt0aGlzLndlZWssIDEsIGR1cmF0aW9uV2Vla10sXHJcbiAgICAgICAgICAgIFt0aGlzLndlZWssIDIsIDIgKiBkdXJhdGlvbldlZWtdLFxyXG4gICAgICAgICAgICBbdGhpcy53ZWVrLCAzLCAzICogZHVyYXRpb25XZWVrXSxcclxuICAgICAgICAgICAgW3RoaXMubW9udGgsIDEsIGR1cmF0aW9uTW9udGhdLFxyXG4gICAgICAgICAgICBbdGhpcy5tb250aCwgMiwgMiAqIGR1cmF0aW9uTW9udGhdLFxyXG4gICAgICAgICAgICBbdGhpcy5tb250aCwgMywgMyAqIGR1cmF0aW9uTW9udGhdLFxyXG4gICAgICAgICAgICBbdGhpcy5tb250aCwgNCwgNCAqIGR1cmF0aW9uTW9udGhdLFxyXG4gICAgICAgICAgICBbdGhpcy5tb250aCwgNiwgNiAqIGR1cmF0aW9uTW9udGhdLFxyXG4gICAgICAgICAgICBbdGhpcy55ZWFyLCAxLCBkdXJhdGlvblllYXJdLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICB0b0RvbWFpbihkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGQpO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlRGVmYXVsdFRpY2tGb3JtYXQodGlja3MgPSBbXSkge1xyXG4gICAgICAgIGxldCBkZWZhdWx0VGltZUZvcm1hdCA9IERlZmF1bHRUaW1lRm9ybWF0cy5ZRUFSO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZUZvcm1hdCA9IChmb3JtYXQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdCA8IGRlZmF1bHRUaW1lRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGltZUZvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aWNrcykge1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldExvd2VzdEdyYW51bGFyaXR5Rm9ybWF0KHZhbHVlKTtcclxuICAgICAgICAgICAgdXBkYXRlRm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpcnN0VGljayA9IHRvTnVtYmVyKHRpY2tzWzBdKTtcclxuICAgICAgICBjb25zdCBsYXN0VGljayA9IHRvTnVtYmVyKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICBjb25zdCBzdGFydFllYXIgPSBuZXcgRGF0ZShmaXJzdFRpY2spLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgY29uc3Qgc3RvcFllYXIgPSBuZXcgRGF0ZShsYXN0VGljaykuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICBjb25zdCB5ZWFyQ2hhbmdlID0gc3RvcFllYXIgLSBzdGFydFllYXIgPiAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRm9ybWF0U3RyaW5nKGRlZmF1bHRUaW1lRm9ybWF0LCB5ZWFyQ2hhbmdlKTtcclxuICAgIH1cclxuICAgIGJ1aWxkRm9ybWF0U3RyaW5nKGRlZmF1bHRUaW1lRm9ybWF0LCB5ZWFyQ2hhbmdlKSB7XHJcbiAgICAgICAgbGV0IGZvcm1hdFN0cmluZ0FycmF5ID0gW2Zvcm1hdFN0cmluZ3NbZGVmYXVsdFRpbWVGb3JtYXRdXTtcclxuICAgICAgICBsZXQgdGltZUVuZEluZGV4ID0gMDtcclxuICAgICAgICBjb25zdCBkb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4oLi4uZG9tYWluLm1hcCh0b051bWJlcikpO1xyXG4gICAgICAgIGNvbnN0IHN0b3AgPSBNYXRoLm1heCguLi5kb21haW4ubWFwKHRvTnVtYmVyKSk7XHJcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gc3RvcCAtIHN0YXJ0O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdFRpbWVGb3JtYXQpIHtcclxuICAgICAgICAgICAgY2FzZSBEZWZhdWx0VGltZUZvcm1hdHMuU0VDT05EOlxyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudCAvIGR1cmF0aW9uTWludXRlID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmluZ0FycmF5LnB1c2goZm9ybWF0U3RyaW5nc1tEZWZhdWx0VGltZUZvcm1hdHMuTUlOVVRFXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCBkZWxpYmVyYXRlbHlcclxuICAgICAgICAgICAgY2FzZSBEZWZhdWx0VGltZUZvcm1hdHMuTUlOVVRFOlxyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudCAvIGR1cmF0aW9uSG91ciA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRTdHJpbmdBcnJheS5wdXNoKGZvcm1hdFN0cmluZ3NbRGVmYXVsdFRpbWVGb3JtYXRzLkhPVVJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIGRlbGliZXJhdGVseVxyXG4gICAgICAgICAgICBjYXNlIERlZmF1bHRUaW1lRm9ybWF0cy5IT1VSOlxyXG4gICAgICAgICAgICAgICAgdGltZUVuZEluZGV4ID0gZm9ybWF0U3RyaW5nQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudCAvIGR1cmF0aW9uRGF5ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmluZ0FycmF5LnB1c2goZm9ybWF0U3RyaW5nc1tEZWZhdWx0VGltZUZvcm1hdHMuV0VFS19EQVldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIGRlbGliZXJhdGVseVxyXG4gICAgICAgICAgICBjYXNlIERlZmF1bHRUaW1lRm9ybWF0cy5XRUVLX0RBWTpcclxuICAgICAgICAgICAgICAgIGlmIChleHRlbnQgLyBkdXJhdGlvbldlZWsgPiAxIHx8IHllYXJDaGFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIG1vcmUgdGhhbiBhIHdlZWsgb3IgdGhlcmUgaXMgYSB5ZWFyIGNoYW5nZSwgZG9uJ3Qgc2hvdyB3ZWVrIGRheVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtEYXlJbmRleCA9IGZvcm1hdFN0cmluZ0FycmF5LmluZGV4T2YoZm9ybWF0U3RyaW5nc1tEZWZhdWx0VGltZUZvcm1hdHMuV0VFS19EQVldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2Vla0RheUluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyaW5nQXJyYXkuc3BsaWNlKHdlZWtEYXlJbmRleCwgMSwgZm9ybWF0U3RyaW5nc1tEZWZhdWx0VGltZUZvcm1hdHMuU0hPUlRfTU9OVEhdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCBkZWxpYmVyYXRlbHlcclxuICAgICAgICAgICAgY2FzZSBEZWZhdWx0VGltZUZvcm1hdHMuU0hPUlRfTU9OVEg6XHJcbiAgICAgICAgICAgIGNhc2UgRGVmYXVsdFRpbWVGb3JtYXRzLk1PTlRIOlxyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudCAvIGR1cmF0aW9uWWVhciA+IDEgfHwgeWVhckNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmluZ0FycmF5LnB1c2goZm9ybWF0U3RyaW5nc1tEZWZhdWx0VGltZUZvcm1hdHMuWUVBUl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZUVuZEluZGV4IDwgZm9ybWF0U3RyaW5nQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBhIGdhcCBiZXR3ZWVuIGFsbCBkYXRlIGNvbXBvbmVudHMuXHJcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZ0FycmF5ID0gW1xyXG4gICAgICAgICAgICAgICAgLi4uZm9ybWF0U3RyaW5nQXJyYXkuc2xpY2UoMCwgdGltZUVuZEluZGV4KSxcclxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmluZ0FycmF5LnNsaWNlKHRpbWVFbmRJbmRleCkuam9pbignICcpLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZUVuZEluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIG9mIHRpbWUgY29tcG9uZW50cywgc2luY2UgdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgLy8gZ3JhbnVsYXJpdHkuXHJcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZ0FycmF5ID0gW1xyXG4gICAgICAgICAgICAgICAgLi4uZm9ybWF0U3RyaW5nQXJyYXkuc2xpY2UoMCwgdGltZUVuZEluZGV4KS5yZXZlcnNlKCksXHJcbiAgICAgICAgICAgICAgICAuLi5mb3JtYXRTdHJpbmdBcnJheS5zbGljZSh0aW1lRW5kSW5kZXgpLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBpZiAodGltZUVuZEluZGV4IDwgZm9ybWF0U3RyaW5nQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgYSBnYXAgYmV0d2VlbiB0aW1lIGFuZCBkYXRlIGNvbXBvbmVudHMuXHJcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHJpbmdBcnJheS5zcGxpY2UodGltZUVuZEluZGV4LCAwLCAnICcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXRTdHJpbmdBcnJheS5qb2luKCcnKTtcclxuICAgIH1cclxuICAgIGdldExvd2VzdEdyYW51bGFyaXR5Rm9ybWF0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kLmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VGltZUZvcm1hdHMuTUlMTElTRUNPTkQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubWludXRlLmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VGltZUZvcm1hdHMuU0VDT05EO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmhvdXIuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRUaW1lRm9ybWF0cy5NSU5VVEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGF5LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VGltZUZvcm1hdHMuSE9VUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb250aC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy53ZWVrLmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVmYXVsdFRpbWVGb3JtYXRzLldFRUtfREFZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBEZWZhdWx0VGltZUZvcm1hdHMuU0hPUlRfTU9OVEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMueWVhci5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gRGVmYXVsdFRpbWVGb3JtYXRzLk1PTlRIO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRGVmYXVsdFRpbWVGb3JtYXRzLllFQVI7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0VGlja0Zvcm1hdCh0aWNrcykge1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdFN0cmluZyA9IHRoaXMuY2FsY3VsYXRlRGVmYXVsdFRpY2tGb3JtYXQodGlja3MpO1xyXG4gICAgICAgIHJldHVybiAoZGF0ZSkgPT4gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0U3RyaW5nKShkYXRlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGljayBpbnRlcnZhbCBvcHRpb25zLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RhcnQgVGhlIHN0YXJ0IHRpbWUgKHRpbWVzdGFtcCkuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdG9wIFRoZSBlbmQgdGltZSAodGltZXN0YW1wKS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IE51bWJlciBvZiBpbnRlcnZhbHMgYmV0d2VlbiB0aWNrcy5cclxuICAgICAqL1xyXG4gICAgZ2V0VGlja0ludGVydmFsKHsgc3RhcnQsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQsIH0pIHtcclxuICAgICAgICBjb25zdCB7IHRpY2tJbnRlcnZhbHMgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IGNvdW50YWJsZVRpbWVJbnRlcnZhbDtcclxuICAgICAgICBsZXQgc3RlcDtcclxuICAgICAgICBjb25zdCB0aWNrQ291bnQgPSBjb3VudCAhPT0gbnVsbCAmJiBjb3VudCAhPT0gdm9pZCAwID8gY291bnQgOiBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudDtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja0NvdW50LCAxKTtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCB0aWNrSW50ZXJ2YWxzLmxlbmd0aCAmJiB0YXJnZXQgPiB0aWNrSW50ZXJ2YWxzW2ldWzJdKSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCB0aWNrQ291bnQsIG1pbkNvdW50LCBtYXhDb3VudCksIDEpO1xyXG4gICAgICAgICAgICBjb3VudGFibGVUaW1lSW50ZXJ2YWwgPSB0aGlzLm1pbGxpc2Vjb25kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpID09PSB0aWNrSW50ZXJ2YWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCB5MCA9IHN0YXJ0IC8gZHVyYXRpb25ZZWFyO1xyXG4gICAgICAgICAgICBjb25zdCB5MSA9IHN0b3AgLyBkdXJhdGlvblllYXI7XHJcbiAgICAgICAgICAgIHN0ZXAgPSB0aWNrU3RlcCh5MCwgeTEsIHRpY2tDb3VudCwgbWluQ291bnQsIG1heENvdW50KTtcclxuICAgICAgICAgICAgY291bnRhYmxlVGltZUludGVydmFsID0gdGhpcy55ZWFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZjAgPSB0YXJnZXQgLSB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXTtcclxuICAgICAgICAgICAgY29uc3QgZGlmZjEgPSB0aWNrSW50ZXJ2YWxzW2ldWzJdIC0gdGFyZ2V0O1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGRpZmYwIDwgZGlmZjEgPyBpIC0gMSA6IGk7XHJcbiAgICAgICAgICAgIFtjb3VudGFibGVUaW1lSW50ZXJ2YWwsIHN0ZXBdID0gdGlja0ludGVydmFsc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudGFibGVUaW1lSW50ZXJ2YWwuZXZlcnkoc3RlcCk7XHJcbiAgICB9XHJcbiAgICBpbnZlcnQoeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShzdXBlci5pbnZlcnQoeSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHVuaWZvcm1seS1zcGFjZWQgZGF0ZXMgdGhhdCByZXByZXNlbnQgdGhlIHNjYWxlJ3MgZG9tYWluLlxyXG4gICAgICovXHJcbiAgICB0aWNrcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICBjb25zdCBbdDAsIHQxXSA9IHRoaXMuZ2V0RG9tYWluKCkubWFwKHRvTnVtYmVyKTtcclxuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpY2tzRm9ySW50ZXJ2YWwoeyBzdGFydDogdDAsIHN0b3A6IHQxIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5uaWNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdGlja0NvdW50IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGlja0NvdW50ID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uaWNlRG9tYWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aWNrQ291bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5pY2VEb21haW4uc2xpY2UoMCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFRpY2tzKHsgc3RhcnQ6IHQwLCBzdG9wOiB0MSB9KTtcclxuICAgIH1cclxuICAgIGdldERlZmF1bHRUaWNrcyh7IHN0YXJ0LCBzdG9wIH0pIHtcclxuICAgICAgICBjb25zdCB0ID0gdGhpcy5nZXRUaWNrSW50ZXJ2YWwoe1xyXG4gICAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgICAgc3RvcCxcclxuICAgICAgICAgICAgY291bnQ6IHRoaXMudGlja0NvdW50LFxyXG4gICAgICAgICAgICBtaW5Db3VudDogdGhpcy5taW5UaWNrQ291bnQsXHJcbiAgICAgICAgICAgIG1heENvdW50OiB0aGlzLm1heFRpY2tDb3VudCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdCA/IHQucmFuZ2UobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShzdG9wKSkgOiBbXTsgLy8gaW5jbHVzaXZlIHN0b3BcclxuICAgIH1cclxuICAgIGdldFRpY2tzRm9ySW50ZXJ2YWwoeyBzdGFydCwgc3RvcCB9KSB7XHJcbiAgICAgICAgY29uc3QgeyBpbnRlcnZhbCwgdGlja0ludGVydmFscyB9ID0gdGhpcztcclxuICAgICAgICBpZiAoIWludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGludGVydmFsIGluc3RhbmNlb2YgVGltZUludGVydmFsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpY2tzID0gaW50ZXJ2YWwucmFuZ2UobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShzdG9wKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVuc2VJbnRlcnZhbCh7IHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCwgY291bnQ6IHRpY2tzLmxlbmd0aCB9KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFRpY2tzKHsgc3RhcnQsIHN0b3AgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRpY2tzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhYnNJbnRlcnZhbCA9IE1hdGguYWJzKGludGVydmFsKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbnNlSW50ZXJ2YWwoeyBzdGFydCwgc3RvcCwgaW50ZXJ2YWw6IGFic0ludGVydmFsIH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRUaWNrcyh7IHN0YXJ0LCBzdG9wIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXZlcnNlZEludGVydmFsID0gWy4uLnRpY2tJbnRlcnZhbHNdO1xyXG4gICAgICAgIHJldmVyc2VkSW50ZXJ2YWwucmV2ZXJzZSgpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVJbnRlcnZhbCA9IHJldmVyc2VkSW50ZXJ2YWwuZmluZCgodGlja0ludGVydmFsKSA9PiBhYnNJbnRlcnZhbCAlIHRpY2tJbnRlcnZhbFsyXSA9PT0gMCk7XHJcbiAgICAgICAgaWYgKHRpbWVJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gdGltZUludGVydmFsWzBdLmV2ZXJ5KGFic0ludGVydmFsIC8gKHRpbWVJbnRlcnZhbFsyXSAvIHRpbWVJbnRlcnZhbFsxXSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gaS5yYW5nZShuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKHN0b3ApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShzdGFydCk7XHJcbiAgICAgICAgY29uc3Qgc3RvcERhdGUgPSBuZXcgRGF0ZShzdG9wKTtcclxuICAgICAgICBjb25zdCB0aWNrcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChkYXRlIDw9IHN0b3BEYXRlKSB7XHJcbiAgICAgICAgICAgIHRpY2tzLnB1c2goZGF0ZSk7XHJcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgICAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIGFic0ludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpY2tzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgdGltZSBmb3JtYXQgZnVuY3Rpb24gc3VpdGFibGUgZm9yIGRpc3BsYXlpbmcgdGljayB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0gc3BlY2lmaWVyIElmIHRoZSBzcGVjaWZpZXIgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvXHJcbiAgICAgKiB0aGUge0BsaW5rIFRpbWVMb2NhbGVPYmplY3QuZm9ybWF0fSBtZXRob2QuXHJcbiAgICAgKiBJZiBubyBzcGVjaWZpZXIgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRlZmF1bHQgdGltZSBmb3JtYXQgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHRpY2tGb3JtYXQoeyB0aWNrcywgc3BlY2lmaWVyIH0pIHtcclxuICAgICAgICByZXR1cm4gc3BlY2lmaWVyID09IHVuZGVmaW5lZCA/IHRoaXMuZGVmYXVsdFRpY2tGb3JtYXQodGlja3MpIDogYnVpbGRGb3JtYXR0ZXIoc3BlY2lmaWVyKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5uaWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTmljZURvbWFpbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kcyB0aGUgZG9tYWluIHNvIHRoYXQgaXQgc3RhcnRzIGFuZCBlbmRzIG9uIG5pY2Ugcm91bmQgdmFsdWVzLlxyXG4gICAgICogVGhpcyBtZXRob2QgdHlwaWNhbGx5IG1vZGlmaWVzIHRoZSBzY2FsZeKAmXMgZG9tYWluLCBhbmQgbWF5IG9ubHkgZXh0ZW5kIHRoZSBib3VuZHMgdG8gdGhlIG5lYXJlc3Qgcm91bmQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU5pY2VEb21haW4oKSB7XHJcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA0O1xyXG4gICAgICAgIGxldCBbZDAsIGQxXSA9IHRoaXMuZG9tYWluO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW5JdGVyYXRpb24oZDAsIGQxKTtcclxuICAgICAgICAgICAgY29uc3QgW24wLCBuMV0gPSB0aGlzLm5pY2VEb21haW47XHJcbiAgICAgICAgICAgIGlmICh0b051bWJlcihkMCkgPT09IHRvTnVtYmVyKG4wKSAmJiB0b051bWJlcihkMSkgPT09IHRvTnVtYmVyKG4xKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZDAgPSBuMDtcclxuICAgICAgICAgICAgZDEgPSBuMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVOaWNlRG9tYWluSXRlcmF0aW9uKGQwLCBkMSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdG9OdW1iZXIoZDApO1xyXG4gICAgICAgIGNvbnN0IHN0b3AgPSB0b051bWJlcihkMSk7XHJcbiAgICAgICAgY29uc3QgeyBpbnRlcnZhbCB9ID0gdGhpcztcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBpZiAoaW50ZXJ2YWwgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgaSA9IGludGVydmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGlja0NvdW50ID0gdHlwZW9mIGludGVydmFsID09PSAnbnVtYmVyJyA/IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoaW50ZXJ2YWwsIDEpIDogdGhpcy50aWNrQ291bnQ7XHJcbiAgICAgICAgICAgIGkgPSB0aGlzLmdldFRpY2tJbnRlcnZhbCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgICAgICAgIHN0b3AsXHJcbiAgICAgICAgICAgICAgICBjb3VudDogdGlja0NvdW50LFxyXG4gICAgICAgICAgICAgICAgbWluQ291bnQ6IHRoaXMubWluVGlja0NvdW50LFxyXG4gICAgICAgICAgICAgICAgbWF4Q291bnQ6IHRoaXMubWF4VGlja0NvdW50LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWxSYW5nZSA9IGkucmFuZ2UoZDAsIGQxLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgbjAgPSBpbnRlcnZhbFJhbmdlWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBuMSA9IGludGVydmFsUmFuZ2VbaW50ZXJ2YWxSYW5nZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdGhpcy5uaWNlRG9tYWluID0gW24wLCBuMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFBhZGRpbmcge1xyXG4gICAgY29uc3RydWN0b3IodG9wID0gMCwgcmlnaHQgPSB0b3AsIGJvdHRvbSA9IHRvcCwgbGVmdCA9IHJpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnRvcCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IHRoaXMubGVmdCA9IDA7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJ0b3BcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJyaWdodFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcImJvdHRvbVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcImxlZnRcIiwgdm9pZCAwKTtcblxudmFyIHNwYXJrbGluZXNVdGlsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBleHRlbnQ6IGV4dGVudCxcbiAgICBub3JtYWxpc2VkRXh0ZW50OiBub3JtYWxpc2VkRXh0ZW50LFxuICAgIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGE6IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEsXG4gICAgdG9GaXhlZDogdG9GaXhlZCxcbiAgICBpc051bWJlckVxdWFsOiBpc0VxdWFsLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgaW50ZXJwb2xhdGVTdHJpbmc6IGludGVycG9sYXRlLFxuICAgIHRpY2tzOiB0aWNrcyxcbiAgICB0aWNrU3RlcDogdGlja1N0ZXAsXG4gICAgcmFuZ2U6IHJhbmdlJDEsXG4gICAgQ29sb3I6IENvbG9yLFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc1N0cmluZ09iamVjdDogaXNTdHJpbmdPYmplY3QsXG4gICAgaXNEYXRlOiBpc0RhdGUsXG4gICAgaXNEaXNjcmV0ZTogaXNEaXNjcmV0ZSxcbiAgICBpc0NvbnRpbnVvdXM6IGlzQ29udGludW91cyxcbiAgICBjaGVja0RhdHVtOiBjaGVja0RhdHVtLFxuICAgIGlzTnVtYmVyOiBpc051bWJlcixcbiAgICByZXNldElkczogcmVzZXRJZHMsXG4gICAgY3JlYXRlSWQ6IGNyZWF0ZUlkLFxuICAgIFBhZGRpbmc6IFBhZGRpbmcsXG4gICAganNvbkRpZmY6IGpzb25EaWZmLFxuICAgIERFTEVURTogREVMRVRFLFxuICAgIGpzb25NZXJnZToganNvbk1lcmdlLFxuICAgIGpzb25BcHBseToganNvbkFwcGx5LFxuICAgIGpzb25XYWxrOiBqc29uV2FsayxcbiAgICBub3JtYWxpemVBbmdsZTM2MDogbm9ybWFsaXplQW5nbGUzNjAsXG4gICAgbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmU6IG5vcm1hbGl6ZUFuZ2xlMzYwSW5jbHVzaXZlLFxuICAgIG5vcm1hbGl6ZUFuZ2xlMTgwOiBub3JtYWxpemVBbmdsZTE4MCxcbiAgICB0b1JhZGlhbnM6IHRvUmFkaWFucyxcbiAgICB0b0RlZ3JlZXM6IHRvRGVncmVlcyxcbiAgICBhbmdsZUJldHdlZW46IGFuZ2xlQmV0d2VlbixcbiAgICB6aXBPYmplY3Q6IHppcE9iamVjdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgaXNFcXVhbDogaXNFcXVhbCxcbiAgICBpc05lZ2F0aXZlOiBpc05lZ2F0aXZlLFxuICAgIHJvdW5kOiByb3VuZCQxLFxuICAgIG1vZDogbW9kLFxuICAgIHNhbml0aXplSHRtbDogc2FuaXRpemVIdG1sLFxuICAgIExvZ2dlcjogTG9nZ2VyXG59KTtcblxuZnVuY3Rpb24gYXJlQXJyYXlOdW1iZXJzRXF1YWwoYXJyQSwgYXJyQikge1xyXG4gICAgcmV0dXJuIGFyckEubGVuZ3RoID09PSBhcnJCLmxlbmd0aCAmJiBhcnJBLmV2ZXJ5KChpdGVtLCBpKSA9PiBOdW1iZXIoaXRlbSkgPT09IE51bWJlcihhcnJCW2ldKSk7XHJcbn1cblxuZnVuY3Rpb24gY2lyY2xlUmVjdE92ZXJsYXAoYywgeCwgeSwgdywgaCkge1xyXG4gICAgLy8gRmluZCBjbG9zZXN0IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGVkZ2VzLlxyXG4gICAgbGV0IGVkZ2VYID0gYy54O1xyXG4gICAgaWYgKGMueCA8IHgpIHtcclxuICAgICAgICBlZGdlWCA9IHg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjLnggPiB4ICsgdykge1xyXG4gICAgICAgIGVkZ2VYID0geCArIHc7XHJcbiAgICB9XHJcbiAgICBsZXQgZWRnZVkgPSBjLnk7XHJcbiAgICBpZiAoYy55IDwgeSkge1xyXG4gICAgICAgIGVkZ2VZID0geTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGMueSA+IHkgKyBoKSB7XHJcbiAgICAgICAgZWRnZVkgPSB5ICsgaDtcclxuICAgIH1cclxuICAgIC8vIEZpbmQgZGlzdGFuY2UgdG8gY2xvc2VzdCBlZGdlcy5cclxuICAgIGNvbnN0IGR4ID0gYy54IC0gZWRnZVg7XHJcbiAgICBjb25zdCBkeSA9IGMueSAtIGVkZ2VZO1xyXG4gICAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICByZXR1cm4gZCA8PSBjLnNpemUgKiAwLjU7XHJcbn1cclxuZnVuY3Rpb24gcmVjdFJlY3RPdmVybGFwKHIxLCB4MiwgeTIsIHcyLCBoMikge1xyXG4gICAgY29uc3QgeE92ZXJsYXAgPSByMS54ICsgcjEud2lkdGggPiB4MiAmJiByMS54IDwgeDIgKyB3MjtcclxuICAgIGNvbnN0IHlPdmVybGFwID0gcjEueSArIHIxLmhlaWdodCA+IHkyICYmIHIxLnkgPCB5MiArIGgyO1xyXG4gICAgcmV0dXJuIHhPdmVybGFwICYmIHlPdmVybGFwO1xyXG59XHJcbmZ1bmN0aW9uIHJlY3RDb250YWluc1JlY3QocjEsIHIyeCwgcjJ5LCByMncsIHIyaCkge1xyXG4gICAgcmV0dXJuIHIyeCArIHIydyA8IHIxLnggKyByMS53aWR0aCAmJiByMnggPiByMS54ICYmIHIyeSA+IHIxLnkgJiYgcjJ5ICsgcjJoIDwgcjEueSArIHIxLmhlaWdodDtcclxufVxyXG5mdW5jdGlvbiBpc1BvaW50TGFiZWxEYXR1bSh4KSB7XHJcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4LnBvaW50ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgeC5sYWJlbCA9PT0gJ29iamVjdCc7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBkYXRhIFBvaW50cyBhbmQgbGFiZWxzIGZvciBvbmUgb3IgbW9yZSBzZXJpZXMuIFRoZSBvcmRlciBvZiBzZXJpZXMgZGV0ZXJtaW5lcyBsYWJlbCBwbGFjZW1lbnQgcHJlY2VkZW5jZS5cclxuICogQHBhcmFtIGJvdW5kcyBCb3VuZHMgdG8gZml0IHRoZSBsYWJlbHMgaW50by4gSWYgYSBsYWJlbCBjYW4ndCBiZSBmdWxseSBjb250YWluZWQsIGl0IGRvZXNuJ3QgZml0LlxyXG4gKiBAcmV0dXJucyBQbGFjZWQgbGFiZWxzIGZvciB0aGUgZ2l2ZW4gc2VyaWVzIChpbiB0aGUgZ2l2ZW4gb3JkZXIpLlxyXG4gKi9cclxuZnVuY3Rpb24gcGxhY2VMYWJlbHMoZGF0YSwgYm91bmRzLCBwYWRkaW5nID0gNSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBkYXRhID0gZGF0YS5tYXAoKGQpID0+IGQuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBiLnBvaW50LnNpemUgLSBhLnBvaW50LnNpemUpKTtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IChyZXN1bHRbal0gPSBbXSk7XHJcbiAgICAgICAgY29uc3QgZGF0dW0gPSBkYXRhW2pdO1xyXG4gICAgICAgIGlmICghKChkYXR1bSA9PT0gbnVsbCB8fCBkYXR1bSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0dW0ubGVuZ3RoKSAmJiBkYXR1bVswXS5sYWJlbCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsbiA9IGRhdHVtLmxlbmd0aDsgaSA8IGxuOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZCA9IGRhdHVtW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gZC5sYWJlbDtcclxuICAgICAgICAgICAgY29uc3QgciA9IGQucG9pbnQuc2l6ZSAqIDAuNTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGQucG9pbnQueCAtIGwud2lkdGggKiAwLjU7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBkLnBvaW50LnkgLSByIC0gbC5oZWlnaHQgLSBwYWRkaW5nO1xyXG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpdGhpbkJvdW5kcyA9ICFib3VuZHMgfHwgcmVjdENvbnRhaW5zUmVjdChib3VuZHMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAoIXdpdGhpbkJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcFBvaW50cyA9IGRhdGEuc29tZSgoZGF0dW0pID0+IGRhdHVtLnNvbWUoKGQpID0+IGNpcmNsZVJlY3RPdmVybGFwKGQucG9pbnQsIHgsIHksIHdpZHRoLCBoZWlnaHQpKSk7XHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvdmVybGFwTGFiZWxzID0gcmVzdWx0LnNvbWUoKGxhYmVscykgPT4gbGFiZWxzLnNvbWUoKGwpID0+IHJlY3RSZWN0T3ZlcmxhcChsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSkpO1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcExhYmVscykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBsLnRleHQsXHJcbiAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZGF0dW06IGQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gYXhpc0xhYmVsc092ZXJsYXAoZGF0YSwgcGFkZGluZykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkYXR1bSA9IGRhdGFbaV07XHJcbiAgICAgICAgY29uc3QgeyBwb2ludDogeyB4LCB5IH0sIGxhYmVsOiB7IHRleHQgfSwgfSA9IGRhdHVtO1xyXG4gICAgICAgIGxldCB7IGxhYmVsOiB7IHdpZHRoLCBoZWlnaHQgfSwgfSA9IGRhdHVtO1xyXG4gICAgICAgIHdpZHRoICs9IHBhZGRpbmcgIT09IG51bGwgJiYgcGFkZGluZyAhPT0gdm9pZCAwID8gcGFkZGluZyA6IDA7XHJcbiAgICAgICAgaGVpZ2h0ICs9IHBhZGRpbmcgIT09IG51bGwgJiYgcGFkZGluZyAhPT0gdm9pZCAwID8gcGFkZGluZyA6IDA7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxhcExhYmVscyA9IHJlc3VsdC5zb21lKChsKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0UmVjdE92ZXJsYXAobCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG92ZXJsYXBMYWJlbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbmNvbnN0IEdSSURfU1RZTEVfS0VZUyA9IFsnc3Ryb2tlJywgJ2xpbmVEYXNoJ107XHJcbmNvbnN0IEdSSURfU1RZTEUgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShBUlJBWSh1bmRlZmluZWQsIChvKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XHJcbiAgICAgICAgaWYgKCFHUklEX1NUWUxFX0tFWVMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn0pLCBgZXhwZWN0aW5nIGFuIEFycmF5IG9mIG9iamVjdHMgd2l0aCBncmlkbGluZSBzdHlsZSBwcm9wZXJ0aWVzIHN1Y2ggYXMgJ3N0cm9rZScgYW5kICdsaW5lRGFzaCdgKTtcclxuY2xhc3MgQXhpc0dyaWRMaW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBsaW5lRGFzaDogW10sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEdSSURfU1RZTEUpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG5dLCBBeGlzR3JpZExpbmUucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5cbmZ1bmN0aW9uIERlZmF1bHQoZGVmYXVsdFZhbHVlLCByZXBsYWNlcyA9IFt1bmRlZmluZWRdKSB7XHJcbiAgICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KChfLCBfXywgdikgPT4ge1xyXG4gICAgICAgIGlmIChyZXBsYWNlcy5pbmNsdWRlcyh2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0pO1xyXG59XG5cbmNsYXNzIEF4aXNMYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8qKiBJZiBzZXQgdG8gYGZhbHNlYCwgYXhpcyBsYWJlbHMgd2lsbCBub3QgYmUgd3JhcHBlZCBvbiBtdWx0aXBsZSBsaW5lcy4gKi9cclxuICAgICAgICB0aGlzLmF1dG9XcmFwID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIFVzZWQgdG8gY29uc3RyYWluIHRoZSB3aWR0aCBvZiB0aGUgbGFiZWwgd2hlbiBgYXV0b1dyYXBgIGlzIGB0cnVlYCwgaWYgdGhlIGxhYmVsIHRleHQgd2lkdGggZXhjZWVkcyB0aGUgYG1heFdpZHRoYCwgaXQgd2lsbCBiZSB3cmFwcGVkIG9uIG11bHRpcGxlIGxpbmVzIGF1dG9tYXRpY2FsbHkuIElmIGBtYXhXaWR0aGAgaXMgb21pdHRlZCwgYSBkZWZhdWx0IHdpZHRoIGNvbnN0cmFpbnQgd2lsbCBiZSBhcHBsaWVkLiAqL1xyXG4gICAgICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLyoqIFVzZWQgdG8gY29uc3RyYWluIHRoZSBoZWlnaHQgb2YgdGhlIG11bHRpbGluZSBsYWJlbCwgaWYgdGhlIGxhYmVsIHRleHQgaGVpZ2h0IGV4Y2VlZHMgdGhlIGBtYXhIZWlnaHRgLCBpdCB3aWxsIGJlIHRydW5jYXRlZCBhdXRvbWF0aWNhbGx5LiBJZiBgbWF4SGVpZ2h0YCBpcyBvbWl0dGVkLCBhIGRlZmF1bHQgaGVpZ2h0IGNvbnN0cmFpbnQgd2lsbCBiZSBhcHBsaWVkLiAqL1xyXG4gICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZm9udFN0eWxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZvbnRTaXplID0gMTI7XHJcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gJ1ZlcmRhbmEsIHNhbnMtc2VyaWYnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwYWRkaW5nIGJldHdlZW4gdGhlIGxhYmVscyBhbmQgdGhlIHRpY2tzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWluaW11bSBnYXAgaW4gcGl4ZWxzIGJldHdlZW4gdGhlIGF4aXMgbGFiZWxzIGJlZm9yZSBiZWluZyByZW1vdmVkIHRvIGF2b2lkIGNvbGxpc2lvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5taW5TcGFjaW5nID0gTmFOO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xvciBvZiB0aGUgbGFiZWxzLlxyXG4gICAgICAgICAqIFVzZSBgdW5kZWZpbmVkYCByYXRoZXIgdGhhbiBgcmdiYSgwLCAwLCAwLCAwKWAgdG8gbWFrZSBsYWJlbHMgaW52aXNpYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSAncmdiYSg4NywgODcsIDg3LCAxKSc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VzdG9tIGxhYmVsIHJvdGF0aW9uIGluIGRlZ3JlZXMuXHJcbiAgICAgICAgICogTGFiZWxzIGFyZSByZW5kZXJlZCBwZXJwZW5kaWN1bGFyIHRvIHRoZSBheGlzIGxpbmUgYnkgZGVmYXVsdC5cclxuICAgICAgICAgKiBPciBwYXJhbGxlbCB0byB0aGUgYXhpcyBsaW5lLCBpZiB0aGUge0BsaW5rIHBhcmFsbGVsfSBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGlzIGNvbmZpZyBpcyB1c2VkIGFzIHRoZSBhbmd1bGFyIG9mZnNldC9kZWZsZWN0aW9uXHJcbiAgICAgICAgICogZnJvbSB0aGUgZGVmYXVsdCByb3RhdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF2b2lkIGF4aXMgbGFiZWwgY29sbGlzaW9uIGJ5IGF1dG9tYXRpY2FsbHkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiB0aWNrcyBkaXNwbGF5ZWQuIElmIHNldCB0byBgZmFsc2VgLCBheGlzIGxhYmVscyBtYXkgY29sbGlkZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF2b2lkQ29sbGlzaW9ucyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCwgbGFiZWxzIGFuZCB0aWNrcyBhcmUgcG9zaXRpb25lZCB0byB0aGUgbGVmdCBvZiB0aGUgYXhpcyBsaW5lLlxyXG4gICAgICAgICAqIGB0cnVlYCBwb3NpdGlvbnMgdGhlIGxhYmVscyB0byB0aGUgcmlnaHQgb2YgdGhlIGF4aXMgbGluZS5cclxuICAgICAgICAgKiBIb3dldmVyLCBpZiB0aGUgYXhpcyBpcyByb3RhdGVkLCBpdCdzIGVhc2llciB0byB0aGluayBpbiB0ZXJtc1xyXG4gICAgICAgICAqIG9mIHRoaXMgc2lkZSBvciB0aGUgb3Bwb3NpdGUgc2lkZSwgcmF0aGVyIHRoYW4gbGVmdCBhbmQgcmlnaHQuXHJcbiAgICAgICAgICogV2UgdXNlIHRoZSB0ZXJtIGBtaXJyb3JgIGZvciBjb25jaXNlbmVzcywgYWx0aG91Z2ggaXQncyBub3RcclxuICAgICAgICAgKiB0cnVlIG1pcnJvcmluZyAtIGZvciBleGFtcGxlLCB3aGVuIGEgbGFiZWwgaXMgcm90YXRlZCwgc28gdGhhdFxyXG4gICAgICAgICAqIGl0IGlzIGluY2xpbmVkIGF0IHRoZSA0NSBkZWdyZWUgYW5nbGUsIHRleHQgZmxvd2luZyBmcm9tIG5vcnRoLXdlc3RcclxuICAgICAgICAgKiB0byBzb3V0aC1lYXN0LCBlbmRpbmcgYXQgdGhlIHRpY2sgdG8gdGhlIGxlZnQgb2YgdGhlIGF4aXMgbGluZSxcclxuICAgICAgICAgKiBhbmQgdGhlbiB3ZSBzZXQgdGhpcyBjb25maWcgdG8gYHRydWVgLCB0aGUgdGV4dCB3aWxsIHN0aWxsIGJlIGZsb3dpbmdcclxuICAgICAgICAgKiBmcm9tIG5vcnRoLXdlc3QgdG8gc291dGgtZWFzdCwgX3N0YXJ0aW5nXyBhdCB0aGUgdGljayB0byB0aGUgcmlnaHRcclxuICAgICAgICAgKiBvZiB0aGUgYXhpcyBsaW5lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWlycm9yZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMYWJlbHMgYXJlIHJlbmRlcmVkIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGF4aXMgbGluZSBieSBkZWZhdWx0LlxyXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyBjb25maWcgdG8gYHRydWVgIG1ha2VzIGxhYmVscyByZW5kZXIgcGFyYWxsZWwgdG8gdGhlIGF4aXMgbGluZVxyXG4gICAgICAgICAqIGFuZCBjZW50ZXIgYWxpZ25zIGxhYmVscycgdGV4dCBhdCB0aGUgdGlja3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJhbGxlbCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluIGNhc2Uge0BwYXJhbSB2YWx1ZX0gaXMgYSBudW1iZXIsIHRoZSB7QHBhcmFtIGZyYWN0aW9uRGlnaXRzfSBwYXJhbWV0ZXIgd2lsbFxyXG4gICAgICAgICAqIGJlIHByb3ZpZGVkIGFzIHdlbGwuIFRoZSBgZnJhY3Rpb25EaWdpdHNgIGNvcnJlc3BvbmRzIHRvIHRoZSBudW1iZXIgb2YgZnJhY3Rpb25cclxuICAgICAgICAgKiBkaWdpdHMgdXNlZCBieSB0aGUgdGljayBzdGVwLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpY2sgc3RlcCBpcyBgMC4wMDA1YCxcclxuICAgICAgICAgKiB0aGUgYGZyYWN0aW9uRGlnaXRzYCBpcyA0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2lkZSBvZiB0aGUgYXhpcyBsaW5lIHRvIHBvc2l0aW9uIHRoZSBsYWJlbHMgb24uXHJcbiAgICAgKiAtMSA9IGxlZnQgKGRlZmF1bHQpXHJcbiAgICAgKiAxID0gcmlnaHRcclxuICAgICAqL1xyXG4gICAgZ2V0U2lkZUZsYWcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlycm9yZWQgPyAxIDogLTE7XHJcbiAgICB9XHJcbiAgICBnZXRGb250KCkge1xyXG4gICAgICAgIHJldHVybiBnZXRGb250KHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQk9PTEVBTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQk9PTEVBTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJhdXRvV3JhcFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJtYXhIZWlnaHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRk9OVF9TVFlMRSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9GT05UX1dFSUdIVCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUl9PUl9OQU4oKSksXHJcbiAgICBEZWZhdWx0KE5hTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKC0zNjAsIDM2MCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQk9PTEVBTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJtaXJyb3JlZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicGFyYWxsZWxcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5cbmNsYXNzIEF4aXNMaW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQXhpc0xpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBeGlzTGluZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEF4aXNMaW5lLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuXG5jb25zdCBPUFRfVElDS19JTlRFUlZBTCA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2LCBjdHgpID0+IE9QVElPTkFMKHYsIGN0eCwgKHYsIGN0eCkgPT4gKHYgIT09IDAgJiYgTlVNQkVSJDEoMCkodiwgY3R4KSkgfHwgdiBpbnN0YW5jZW9mIFRpbWVJbnRlcnZhbCksIGBleHBlY3RpbmcgYW4gb3B0aW9uYWwgbm9uLXplcm8gcG9zaXRpdmUgTnVtYmVyIHZhbHVlIG9yLCBmb3IgYSB0aW1lIGF4aXMsIGEgVGltZSBJbnRlcnZhbCBzdWNoIGFzICdhZ0NoYXJ0cy50aW1lLm1vbnRoJ2ApO1xyXG5jbGFzcyBBeGlzVGljayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsaW5lIHdpZHRoIHRvIGJlIHVzZWQgYnkgYXhpcyB0aWNrcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGluZSBsZW5ndGggdG8gYmUgdXNlZCBieSBheGlzIHRpY2tzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbG9yIG9mIHRoZSBheGlzIHRpY2tzLlxyXG4gICAgICAgICAqIFVzZSBgdW5kZWZpbmVkYCByYXRoZXIgdGhhbiBgcmdiYSgwLCAwLCAwLCAwKWAgdG8gbWFrZSB0aGUgdGlja3MgaW52aXNpYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnZhbHVlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1pblNwYWNpbmcgPSBOYU47XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9USUNLX0lOVEVSVkFMKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9BUlJBWSgpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcInZhbHVlc1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOKDEpLCBMRVNTX1RIQU4oJ21heFNwYWNpbmcnKSkpLFxyXG4gICAgRGVmYXVsdChOYU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgdm9pZCAwKTtcblxuZnVuY3Rpb24gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KGF4aXMpIHtcclxuICAgIGNvbnN0IHJlcXVlc3RlZFJhbmdlTWluID0gTWF0aC5taW4oLi4uYXhpcy5yYW5nZSk7XHJcbiAgICBjb25zdCByZXF1ZXN0ZWRSYW5nZU1heCA9IE1hdGgubWF4KC4uLmF4aXMucmFuZ2UpO1xyXG4gICAgY29uc3QgbWluID0gTWF0aC5mbG9vcihyZXF1ZXN0ZWRSYW5nZU1pbik7XHJcbiAgICBjb25zdCBtYXggPSBNYXRoLmNlaWwocmVxdWVzdGVkUmFuZ2VNYXgpO1xyXG4gICAgY29uc3QgdmlzaWJsZSA9IG1pbiAhPT0gbWF4O1xyXG4gICAgcmV0dXJuIHsgbWluLCBtYXgsIHZpc2libGUgfTtcclxufVxyXG5jb25zdCBmdWxsQ2lyY2xlID0gTWF0aC5QSSAqIDI7XHJcbmNvbnN0IGhhbGZDaXJjbGUgPSBmdWxsQ2lyY2xlIC8gMjtcclxuZnVuY3Rpb24gbm9ybWFsaXNlRW5kUm90YXRpb24oc3RhcnQsIGVuZCkge1xyXG4gICAgY29uc3QgZGlyZWN0RGlzdGFuY2UgPSBNYXRoLmFicyhlbmQgLSBzdGFydCk7XHJcbiAgICBpZiAoZGlyZWN0RGlzdGFuY2UgPCBoYWxmQ2lyY2xlKVxyXG4gICAgICAgIHJldHVybiBlbmQ7XHJcbiAgICBpZiAoc3RhcnQgPiBlbmQpXHJcbiAgICAgICAgcmV0dXJuIGVuZCArIGZ1bGxDaXJjbGU7XHJcbiAgICByZXR1cm4gZW5kIC0gZnVsbENpcmNsZTtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9ucyhjdHgpIHtcclxuICAgIGNvbnN0IG91dE9mQm91bmRzID0gKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi4oKF9hID0gZGF0dW0ucmFuZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtjdHgubWluXSkpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLigoX2IgPSBkYXR1bS5yYW5nZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW2N0eC5tYXhdKSk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvblkgPCBtaW4gfHwgdHJhbnNsYXRpb25ZID4gbWF4O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGNhbGN1bGF0ZVN0YXR1cyA9IChkYXR1bSwgbm9kZURhdHVtLCBzdGF0dXMpID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzICE9PSAncmVtb3ZlZCcgJiYgb3V0T2ZCb3VuZHMoZGF0dW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncmVtb3ZlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyAhPT0gJ2FkZGVkJyAmJiBvdXRPZkJvdW5kcyhub2RlRGF0dW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnYWRkZWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhdHVzO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZyb21CYXNlID0gKG5vZGUsIGRhdHVtLCBzdGF0dXMpID0+IHtcclxuICAgICAgICAvLyBEZWZhdWx0IHRvIHN0YXJ0aW5nIGF0IHRoZSBzYW1lIHBvc2l0aW9uIHRoYXQgdGhlIG5vZGUgaXMgY3VycmVudGx5IGluLlxyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHsgdHJhbnNsYXRpb25ZOiBNYXRoLnJvdW5kKG5vZGUudHJhbnNsYXRpb25ZKSwgb3BhY2l0eTogbm9kZS5vcGFjaXR5IH07XHJcbiAgICAgICAgc3RhdHVzID0gY2FsY3VsYXRlU3RhdHVzKGRhdHVtLCBub2RlLmRhdHVtLCBzdGF0dXMpO1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdhZGRlZCcpIHtcclxuICAgICAgICAgICAgc291cmNlLnRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKTtcclxuICAgICAgICAgICAgc291cmNlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UpLCBGUk9NX1RPX01JWElOU1tzdGF0dXNdKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB0b0Jhc2UgPSAoX25vZGUsIGRhdHVtLCBzdGF0dXMpID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB7IHRyYW5zbGF0aW9uWTogTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpLCBvcGFjaXR5OiAxIH07XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlbW92ZWQnKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5vcGFjaXR5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH07XHJcbiAgICBjb25zdCB0aWNrID0ge1xyXG4gICAgICAgIGZyb21GbjogZnJvbUJhc2UsXHJcbiAgICAgICAgdG9GbjogdG9CYXNlLFxyXG4gICAgICAgIGludGVybWVkaWF0ZUZuOiAobm9kZSwgX2RhdHVtLCBfc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZpc2libGU6ICFvdXRPZkJvdW5kcyhub2RlKSB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgbGFiZWwgPSB7XHJcbiAgICAgICAgZnJvbUZuOiAoKG5vZGUsIG5ld0RhdHVtLCBzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBkYXR1bSA9IChfYSA9IG5vZGUucHJldmlvdXNEYXR1bSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3RGF0dW07XHJcbiAgICAgICAgICAgIGxldCByb3RhdGlvbiA9IGRhdHVtLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnYWRkZWQnIHx8IHN0YXR1cyA9PT0gJ3JlbW92ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IG5ld0RhdHVtLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZyb21CYXNlKG5vZGUsIG5ld0RhdHVtLCBzdGF0dXMpKSwgeyB4OiBkYXR1bS54LCB5OiBkYXR1bS55LCByb3RhdGlvbiwgcm90YXRpb25DZW50ZXJYOiBkYXR1bS5yb3RhdGlvbkNlbnRlclggfSk7XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgdG9GbjogKChub2RlLCBkYXR1bSwgc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGxldCByb3RhdGlvbjtcclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2FkZGVkJyB8fCBzdGF0dXMgPT09ICdyZW1vdmVkJykge1xyXG4gICAgICAgICAgICAgICAgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gbm9ybWFsaXNlRW5kUm90YXRpb24oKF9iID0gKF9hID0gbm9kZS5wcmV2aW91c0RhdHVtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm90YXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdHVtLnJvdGF0aW9uLCBkYXR1bS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9CYXNlKG5vZGUsIGRhdHVtLCBzdGF0dXMpKSwgeyB4OiBkYXR1bS54LCB5OiBkYXR1bS55LCByb3RhdGlvbiwgcm90YXRpb25DZW50ZXJYOiBkYXR1bS5yb3RhdGlvbkNlbnRlclgsIGZpbmlzaDogeyByb3RhdGlvbjogZGF0dW0ucm90YXRpb24gfSB9KTtcclxuICAgICAgICB9KSxcclxuICAgIH07XHJcbiAgICBjb25zdCBsaW5lID0ge1xyXG4gICAgICAgIGZyb21GbjogKG5vZGUsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoX2IgPSAoX2EgPSBub2RlLnByZXZpb3VzRGF0dW0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdHVtKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7IHk6IG5vZGUueSwgeDE6IG5vZGUueDEsIHgyOiBub2RlLngyIH0pKSwgRlJPTV9UT19NSVhJTlNbJ3VwZGF0ZWQnXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0ZuOiAoX25vZGUsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkYXR1bSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBjb25zdCBncm91cCA9IHtcclxuICAgICAgICBmcm9tRm46IChncm91cCwgX2RhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSBncm91cDtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyByb3RhdGlvbixcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uWCxcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uWSB9LCBGUk9NX1RPX01JWElOU1sndXBkYXRlZCddKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvRm46IChfZ3JvdXAsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSBkYXR1bTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25YLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25ZLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHsgdGljaywgbGluZSwgbGFiZWwsIGdyb3VwIH07XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRBeGlzR3JvdXBGbigpIHtcclxuICAgIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICByb3RhdGlvbkNlbnRlclg6IGRhdHVtLnJvdGF0aW9uQ2VudGVyWCxcclxuICAgICAgICAgICAgcm90YXRpb25DZW50ZXJZOiBkYXR1bS5yb3RhdGlvbkNlbnRlclksXHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0udHJhbnNsYXRpb25YLFxyXG4gICAgICAgICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnRyYW5zbGF0aW9uWSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZXNldEF4aXNTZWxlY3Rpb25GbihjdHgpIHtcclxuICAgIGNvbnN0IHsgdmlzaWJsZTogcmFuZ2VWaXNpYmxlLCBtaW4sIG1heCB9ID0gY3R4O1xyXG4gICAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKGRhdHVtLnRyYW5zbGF0aW9uWSk7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZSA9IHJhbmdlVmlzaWJsZSAmJiB0cmFuc2xhdGlvblkgPj0gbWluICYmIHRyYW5zbGF0aW9uWSA8PSBtYXg7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25ZLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICB2aXNpYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm4oKSB7XHJcbiAgICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGRhdHVtLngsXHJcbiAgICAgICAgICAgIHk6IGRhdHVtLnksXHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogZGF0dW0ucm90YXRpb24sXHJcbiAgICAgICAgICAgIHJvdGF0aW9uQ2VudGVyWDogZGF0dW0ucm90YXRpb25DZW50ZXJYLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbigpIHtcclxuICAgIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRhdHVtKTtcclxuICAgIH07XHJcbn1cblxudmFyIFRhZ3M7XHJcbihmdW5jdGlvbiAoVGFncykge1xyXG4gICAgVGFnc1tUYWdzW1wiVGlja0xpbmVcIl0gPSAwXSA9IFwiVGlja0xpbmVcIjtcclxuICAgIFRhZ3NbVGFnc1tcIlRpY2tMYWJlbFwiXSA9IDFdID0gXCJUaWNrTGFiZWxcIjtcclxuICAgIFRhZ3NbVGFnc1tcIkdyaWRMaW5lXCJdID0gMl0gPSBcIkdyaWRMaW5lXCI7XHJcbiAgICBUYWdzW1RhZ3NbXCJHcmlkQXJjXCJdID0gM10gPSBcIkdyaWRBcmNcIjtcclxuICAgIFRhZ3NbVGFnc1tcIkF4aXNMaW5lXCJdID0gNF0gPSBcIkF4aXNMaW5lXCI7XHJcbn0pKFRhZ3MgfHwgKFRhZ3MgPSB7fSkpO1xyXG52YXIgVGlja0dlbmVyYXRpb25UeXBlO1xyXG4oZnVuY3Rpb24gKFRpY2tHZW5lcmF0aW9uVHlwZSkge1xyXG4gICAgVGlja0dlbmVyYXRpb25UeXBlW1RpY2tHZW5lcmF0aW9uVHlwZVtcIkNSRUFURVwiXSA9IDBdID0gXCJDUkVBVEVcIjtcclxuICAgIFRpY2tHZW5lcmF0aW9uVHlwZVtUaWNrR2VuZXJhdGlvblR5cGVbXCJDUkVBVEVfU0VDT05EQVJZXCJdID0gMV0gPSBcIkNSRUFURV9TRUNPTkRBUllcIjtcclxuICAgIFRpY2tHZW5lcmF0aW9uVHlwZVtUaWNrR2VuZXJhdGlvblR5cGVbXCJGSUxURVJcIl0gPSAyXSA9IFwiRklMVEVSXCI7XHJcbiAgICBUaWNrR2VuZXJhdGlvblR5cGVbVGlja0dlbmVyYXRpb25UeXBlW1wiVkFMVUVTXCJdID0gM10gPSBcIlZBTFVFU1wiO1xyXG59KShUaWNrR2VuZXJhdGlvblR5cGUgfHwgKFRpY2tHZW5lcmF0aW9uVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIGdlbmVyYWwgcHVycG9zZSBsaW5lYXIgYXhpcyB3aXRoIG5vIG5vdGlvbiBvZiBvcmllbnRhdGlvbi5cclxuICogVGhlIGF4aXMgaXMgYWx3YXlzIHJlbmRlcmVkIHZlcnRpY2FsbHksIHdpdGggaG9yaXpvbnRhbCBsYWJlbHMgcG9zaXRpb25lZCB0byB0aGUgbGVmdFxyXG4gKiBvZiB0aGUgYXhpcyBsaW5lIGJ5IGRlZmF1bHQuIFRoZSBheGlzIGNhbiBiZSB7QGxpbmsgcm90YXRpb24gfCByb3RhdGVkfSBieSBhbiBhcmJpdHJhcnkgYW5nbGUsXHJcbiAqIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHJhZGlhbCBvciBhbnkgb3RoZXIga2luZFxyXG4gKiBvZiBsaW5lYXIgYXhpcy5cclxuICogVGhlIGdlbmVyaWMgYERgIHBhcmFtZXRlciBpcyB0aGUgdHlwZSBvZiB0aGUgZG9tYWluIG9mIHRoZSBheGlzJyBzY2FsZS5cclxuICogVGhlIG91dHB1dCByYW5nZSBvZiB0aGUgYXhpcycgc2NhbGUgaXMgYWx3YXlzIG51bWVyaWMgKHNjcmVlbiBjb29yZGluYXRlcykuXHJcbiAqL1xyXG5jbGFzcyBBeGlzIHtcclxuICAgIGdldCB0eXBlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jb25zdHJ1Y3Rvci50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcclxuICAgIH1cclxuICAgIHNldCBjcm9zc0xpbmVzKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAoX2EgPSB0aGlzLl9jcm9zc0xpbmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB0aGlzLmRldGFjaENyb3NzTGluZShjcm9zc0xpbmUpKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25Dcm9zc0xpbmVBcnJheUNvbnN0cnVjdG9yKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3Jvc3NMaW5lcyA9IHZhbHVlO1xyXG4gICAgICAgIChfYiA9IHRoaXMuX2Nyb3NzTGluZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hdHRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY3Jvc3NMaW5lcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3Jvc3NMaW5lcztcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCwgc2NhbGUpIHtcclxuICAgICAgICB0aGlzLm1vZHVsZUN0eCA9IG1vZHVsZUN0eDtcclxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubmljZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kYXRhRG9tYWluID0geyBkb21haW46IFtdLCBjbGlwcGVkOiBmYWxzZSB9O1xyXG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYm91bmRTZXJpZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1heGlzYCwgekluZGV4OiBMYXllcnMuQVhJU19aSU5ERVggfSk7XHJcbiAgICAgICAgdGhpcy5saW5lTm9kZSA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBMaW5lKCkpO1xyXG4gICAgICAgIHRoaXMudGlja0xpbmVHcm91cCA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtdGljay1saW5lc2AsIHpJbmRleDogTGF5ZXJzLkFYSVNfWklOREVYIH0pKTtcclxuICAgICAgICB0aGlzLnRpY2tMYWJlbEdyb3VwID0gdGhpcy5heGlzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy10aWNrLWxhYmVsc2AsIHpJbmRleDogTGF5ZXJzLkFYSVNfWklOREVYIH0pKTtcclxuICAgICAgICB0aGlzLmNyb3NzTGluZUdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQ3Jvc3NMaW5lc2AgfSk7XHJcbiAgICAgICAgdGhpcy5ncmlkR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzLWdyaWRgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JpZExpbmVHcm91cCA9IHRoaXMuZ3JpZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7XHJcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWdyaWRMaW5lc2AsXHJcbiAgICAgICAgICAgIHpJbmRleDogTGF5ZXJzLkFYSVNfR1JJRF9aSU5ERVgsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy50aWNrTGluZUdyb3VwLCBMaW5lLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy50aWNrTGFiZWxHcm91cCwgVGV4dCwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5ncmlkTGluZUdyb3VwLCBMaW5lLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5saW5lID0gbmV3IEF4aXNMaW5lKCk7XHJcbiAgICAgICAgdGhpcy50aWNrID0gdGhpcy5jcmVhdGVUaWNrKCk7XHJcbiAgICAgICAgdGhpcy5ncmlkTGluZSA9IG5ldyBBeGlzR3JpZExpbmUoKTtcclxuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy5jcmVhdGVMYWJlbCgpO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nID0gQXhpcy5kZWZhdWx0VGlja01pblNwYWNpbmc7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbiA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwOyAvLyBheGlzIHJvdGF0aW9uIGFuZ2xlIGluIGRlZ3JlZXNcclxuICAgICAgICB0aGlzLmxheW91dCA9IHtcclxuICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgIGZyYWN0aW9uRGlnaXRzOiAwLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogdGhpcy5sYWJlbC5wYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLmxhYmVsLmZvcm1hdCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSBbMCwgMV07XHJcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2UgPSBbMCwgMV07XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl90aXRsZUNhcHRpb24gPSBuZXcgQ2FwdGlvbigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsZW5ndGggb2YgdGhlIGdyaWQuIFRoZSBncmlkIGlzIG9ubHkgdmlzaWJsZSBpbiBjYXNlIG9mIGEgbm9uLXplcm8gdmFsdWUuXHJcbiAgICAgICAgICogSW4gY2FzZSB7QGxpbmsgcmFkaWFsR3JpZH0gaXMgYHRydWVgLCB0aGUgdmFsdWUgaXMgaW50ZXJwcmV0ZWQgYXMgYW4gYW5nbGVcclxuICAgICAgICAgKiAoaW4gZGVncmVlcykuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZ3JpZExlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmFjdGlvbkRpZ2l0cyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdyaWQgdGlja3MgYW5kIHRoZSBheGlzIHRpY2tzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JpZFBhZGRpbmcgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElzIHVzZWQgdG8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGF4aXMgbGFiZWxzIGFuZCBzZXJpZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyA9IDA7XHJcbiAgICAgICAgdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1heFRoaWNrbmVzcyA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMubW9kdWxlTWFwID0gbmV3IE1vZHVsZU1hcCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuX3RpdGxlQ2FwdGlvbi5ub2RlLnJvdGF0aW9uID0gLU1hdGguUEkgLyAyO1xyXG4gICAgICAgIHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKHRoaXMuX3RpdGxlQ2FwdGlvbi5ub2RlKTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChtb2R1bGVDdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKCdob3ZlcicsIChlKSA9PiB0aGlzLmNoZWNrQXhpc0hvdmVyKGUpKSk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gbW9kdWxlQ3R4LmFuaW1hdGlvbk1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoJ2VtcHR5Jywge1xyXG4gICAgICAgICAgICBlbXB0eToge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAncmVhZHknLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWFkeToge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlVcGRhdGUoZGF0YSksXHJcbiAgICAgICAgICAgICAgICByZXNpemU6ICgpID0+IHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2Nyb3NzTGluZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmFzc2lnbkNyb3NzTGluZUFycmF5Q29uc3RydWN0b3IodGhpcy5fY3Jvc3NMaW5lcyk7XHJcbiAgICAgICAgbGV0IHByZXZpb3VzU2l6ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChtb2R1bGVDdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcignbGF5b3V0LWNvbXBsZXRlJywgKGUpID0+IHtcclxuICAgICAgICAgICAgLy8gRmlyZSByZXNpemUgYW5pbWF0aW9uIGFjdGlvbiBpZiBjaGFydCBjYW52YXMgc2l6ZSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICBpZiAocHJldmlvdXNTaXplICE9IG51bGwgJiYganNvbkRpZmYoZS5jaGFydCwgcHJldmlvdXNTaXplKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oJ3Jlc2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZpb3VzU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIGUuY2hhcnQpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChtb2R1bGVDdHgudXBkYXRlU2VydmljZS5hZGRMaXN0ZW5lcigndXBkYXRlLWNvbXBsZXRlJywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5taW5SZWN0ID0gZS5taW5SZWN0O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIGF0dGFjaENyb3NzTGluZShjcm9zc0xpbmUpIHtcclxuICAgICAgICB0aGlzLmNyb3NzTGluZUdyb3VwLmFwcGVuZENoaWxkKGNyb3NzTGluZS5ncm91cCk7XHJcbiAgICB9XHJcbiAgICBkZXRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSB7XHJcbiAgICAgICAgdGhpcy5jcm9zc0xpbmVHcm91cC5yZW1vdmVDaGlsZChjcm9zc0xpbmUuZ3JvdXApO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLm1vZHVsZU1hcC5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XHJcbiAgICB9XHJcbiAgICByZWZyZXNoU2NhbGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNjYWxlLnJhbmdlLnNsaWNlKCk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jcm9zc0xpbmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdENyb3NzTGluZShjcm9zc0xpbmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUmFuZ2UoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgcmFuZ2U6IHJyLCB2aXNpYmxlUmFuZ2U6IHZyLCBzY2FsZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBzcGFuID0gKHJyWzFdIC0gcnJbMF0pIC8gKHZyWzFdIC0gdnJbMF0pO1xyXG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gc3BhbiAqIHZyWzBdO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcnJbMF0gLSBzaGlmdDtcclxuICAgICAgICBzY2FsZS5yYW5nZSA9IFtzdGFydCwgc3RhcnQgKyBzcGFuXTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNyb3NzTGluZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcclxuICAgICAgICAgICAgY3Jvc3NMaW5lLmNsaXBwZWRSYW5nZSA9IFtyclswXSwgcnJbMV1dO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0Q3Jvc3NMaW5lc1Zpc2libGUodmlzaWJsZSkge1xyXG4gICAgICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB9XHJcbiAgICBhdHRhY2hBeGlzKGF4aXNOb2RlLCBncmlkTm9kZSkge1xyXG4gICAgICAgIGdyaWROb2RlLmFwcGVuZENoaWxkKHRoaXMuZ3JpZEdyb3VwKTtcclxuICAgICAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcm91cCk7XHJcbiAgICAgICAgYXhpc05vZGUuYXBwZW5kQ2hpbGQodGhpcy5jcm9zc0xpbmVHcm91cCk7XHJcbiAgICB9XHJcbiAgICBkZXRhY2hBeGlzKGF4aXNOb2RlLCBncmlkTm9kZSkge1xyXG4gICAgICAgIGdyaWROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZ3JpZEdyb3VwKTtcclxuICAgICAgICBheGlzTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmF4aXNHcm91cCk7XHJcbiAgICAgICAgYXhpc05vZGUucmVtb3ZlQ2hpbGQodGhpcy5jcm9zc0xpbmVHcm91cCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIHBvaW50IG9yIGFuIG9iamVjdCBpcyBpbiByYW5nZS5cclxuICAgICAqIEBwYXJhbSB4IEEgcG9pbnQgKG9yIG9iamVjdCdzIHN0YXJ0aW5nIHBvaW50KS5cclxuICAgICAqIEBwYXJhbSB3aWR0aCBPYmplY3QncyB3aWR0aC5cclxuICAgICAqIEBwYXJhbSB0b2xlcmFuY2UgRXhwYW5kcyB0aGUgcmFuZ2Ugb24gYm90aCBlbmRzIGJ5IHRoaXMgYW1vdW50LlxyXG4gICAgICovXHJcbiAgICBpblJhbmdlKHgsIHdpZHRoID0gMCwgdG9sZXJhbmNlID0gMCkge1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnRoaXMucmFuZ2UpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnRoaXMucmFuZ2UpO1xyXG4gICAgICAgIHJldHVybiB4ICsgd2lkdGggPj0gbWluIC0gdG9sZXJhbmNlICYmIHggPD0gbWF4ICsgdG9sZXJhbmNlO1xyXG4gICAgfVxyXG4gICAgb25MYWJlbEZvcm1hdENoYW5nZSh0aWNrcywgZm9ybWF0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzY2FsZSwgZnJhY3Rpb25EaWdpdHMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgbG9nU2NhbGUgPSBzY2FsZSBpbnN0YW5jZW9mIExvZ1NjYWxlO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRMYWJlbEZvcm1hdHRlciA9ICFsb2dTY2FsZSAmJiBmcmFjdGlvbkRpZ2l0cyA+IDBcclxuICAgICAgICAgICAgPyAoeCkgPT4gKHR5cGVvZiB4ID09PSAnbnVtYmVyJyA/IHgudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykgOiBTdHJpbmcoeCkpXHJcbiAgICAgICAgICAgIDogKHgpID0+IFN0cmluZyh4KTtcclxuICAgICAgICBpZiAoZm9ybWF0ICYmIHNjYWxlICYmIHNjYWxlLnRpY2tGb3JtYXQpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxGb3JtYXR0ZXIgPSBzY2FsZS50aWNrRm9ybWF0KHsgdGlja3MsIHNwZWNpZmllcjogZm9ybWF0IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gZGVmYXVsdExhYmVsRm9ybWF0dGVyO1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUgYXhpcyBsYWJlbCBmb3JtYXQgc3RyaW5nICR7Zm9ybWF0fSBpcyBpbnZhbGlkLiBObyBmb3JtYXR0aW5nIHdpbGwgYmUgYXBwbGllZGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gZGVmYXVsdExhYmVsRm9ybWF0dGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldERvbWFpbigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBzY2FsZSwgZGF0YURvbWFpbjogeyBkb21haW4gfSwgdGljazogeyB2YWx1ZXM6IHRpY2tWYWx1ZXMgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRpY2tWYWx1ZXMgJiYgQ29udGludW91c1NjYWxlLmlzKHNjYWxlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBbdGlja01pbiwgdGlja01heF0gPSAoX2EgPSBleHRlbnQodGlja1ZhbHVlcykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtJbmZpbml0eSwgLUluZmluaXR5XTtcclxuICAgICAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc2NhbGUuZnJvbURvbWFpbihkb21haW5bMF0pLCB0aWNrTWluKTtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc2NhbGUuZnJvbURvbWFpbihkb21haW5bMV0pLCB0aWNrTWF4KTtcclxuICAgICAgICAgICAgc2NhbGUuZG9tYWluID0gW3NjYWxlLnRvRG9tYWluKG1pbiksIHNjYWxlLnRvRG9tYWluKG1heCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2NhbGUuZG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldFRpY2tJbnRlcnZhbChpbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLnNjYWxlLmludGVydmFsID0gKF9hID0gdGhpcy50aWNrLmludGVydmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbnRlcnZhbDtcclxuICAgIH1cclxuICAgIHNldFRpY2tDb3VudChjb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpIHtcclxuICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghKGNvdW50ICYmIENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb3VudCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgc2NhbGUudGlja0NvdW50ID0gY291bnQ7XHJcbiAgICAgICAgICAgIHNjYWxlLm1pblRpY2tDb3VudCA9IG1pblRpY2tDb3VudCAhPT0gbnVsbCAmJiBtaW5UaWNrQ291bnQgIT09IHZvaWQgMCA/IG1pblRpY2tDb3VudCA6IDA7XHJcbiAgICAgICAgICAgIHNjYWxlLm1heFRpY2tDb3VudCA9IG1heFRpY2tDb3VudCAhPT0gbnVsbCAmJiBtYXhUaWNrQ291bnQgIT09IHZvaWQgMCA/IG1heFRpY2tDb3VudCA6IEluZmluaXR5O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2FsZSBpbnN0YW5jZW9mIFRpbWVTY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbChjb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IGdyaWRMZW5ndGgodmFsdWUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gV2FzIHZpc2libGUgYW5kIG5vdyBpbnZpc2libGUsIG9yIHdhcyBpbnZpc2libGUgYW5kIG5vdyB2aXNpYmxlLlxyXG4gICAgICAgIGlmICgodGhpcy5fZ3JpZExlbmd0aCAmJiAhdmFsdWUpIHx8ICghdGhpcy5fZ3JpZExlbmd0aCAmJiB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dyaWRMZW5ndGggPSB2YWx1ZTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNyb3NzTGluZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgZ3JpZExlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JpZExlbmd0aDtcclxuICAgIH1cclxuICAgIGNyZWF0ZVRpY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBeGlzVGljaygpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlTGFiZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBeGlzTGFiZWwoKTtcclxuICAgIH1cclxuICAgIGNoZWNrQXhpc0hvdmVyKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgYmJveCA9IHRoaXMuY29tcHV0ZUJCb3goKTtcclxuICAgICAgICBjb25zdCBpc0luQXhpcyA9IGJib3guY29udGFpbnNQb2ludChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcclxuICAgICAgICBpZiAoIWlzSW5BeGlzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5tb2R1bGVDdHguY2hhcnRFdmVudE1hbmFnZXIuYXhpc0hvdmVyKHRoaXMuaWQsIHRoaXMuZGlyZWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcy9yZW1vdmVzL3VwZGF0ZXMgdGhlIHNjZW5lIGdyYXBoIG5vZGVzIHRoYXQgY29uc3RpdHV0ZSB0aGUgYXhpcy5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHByaW1hcnlUaWNrQ291bnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcclxuICAgICAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgbGluZURhdGEgPSB0aGlzLmdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKTtcclxuICAgICAgICBjb25zdCBfYSA9IHRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQsIHsgdGlja0RhdGEsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH0gPSBfYSwgdGlja3NSZXN1bHQgPSBfX3Jlc3QoX2EsIFtcInRpY2tEYXRhXCIsIFwiY29tYmluZWRSb3RhdGlvblwiLCBcInRleHRCYXNlbGluZVwiLCBcInRleHRBbGlnblwiXSk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNUaWNrcyA9IHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24ubm9kZXMoKS5tYXAoKG5vZGUpID0+IG5vZGUuZGF0dW0udGlja0lkKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMobGluZURhdGEsIHRpY2tEYXRhLnRpY2tzLCB7XHJcbiAgICAgICAgICAgIGNvbWJpbmVkUm90YXRpb24sXHJcbiAgICAgICAgICAgIHRleHRBbGlnbixcclxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lLFxyXG4gICAgICAgICAgICByYW5nZTogdGhpcy5zY2FsZS5yYW5nZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHRoaXMuY2FsY3VsYXRlVXBkYXRlRGlmZihwcmV2aW91c1RpY2tzLCB0aWNrRGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbigndXBkYXRlJywgZGlmZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQXhpc0xpbmUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVscygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlR3JpZExpbmVzKHNpZGVGbGFnKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRpY2tMaW5lcygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGl0bGUoeyBhbnlUaWNrVmlzaWJsZTogdGlja0RhdGEudGlja3MubGVuZ3RoID4gMCB9KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNyb3NzTGluZXMoeyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMYXlvdXRTdGF0ZSgpO1xyXG4gICAgICAgIHByaW1hcnlUaWNrQ291bnQgPSB0aWNrc1Jlc3VsdC5wcmltYXJ5VGlja0NvdW50O1xyXG4gICAgICAgIHJldHVybiBwcmltYXJ5VGlja0NvdW50O1xyXG4gICAgfVxyXG4gICAgZ2V0QXhpc0xpbmVDb29yZGluYXRlcygpIHtcclxuICAgICAgICBjb25zdCB7IHJhbmdlOiBbc3RhcnQsIGVuZF0sIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHggPSAwO1xyXG4gICAgICAgIGNvbnN0IHkxID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgY29uc3QgeTIgPSBNYXRoLm1heChzdGFydCwgZW5kKTtcclxuICAgICAgICByZXR1cm4geyB4LCB5MSwgeTIgfTtcclxuICAgIH1cclxuICAgIGdldFRpY2tMaW5lQ29vcmRpbmF0ZXMoZGF0dW0pIHtcclxuICAgICAgICBjb25zdCB7IHRpY2ssIGxhYmVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcclxuICAgICAgICBjb25zdCB4ID0gc2lkZUZsYWcgKiB0aWNrLnNpemU7XHJcbiAgICAgICAgY29uc3QgeDEgPSBNYXRoLm1pbigwLCB4KTtcclxuICAgICAgICBjb25zdCB4MiA9IHgxICsgTWF0aC5hYnMoeCk7XHJcbiAgICAgICAgY29uc3QgeSA9IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKTtcclxuICAgICAgICByZXR1cm4geyB4MSwgeDIsIHkgfTtcclxuICAgIH1cclxuICAgIGdldFRpY2tMYWJlbFByb3BzKGRhdHVtLCBwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIHJhbmdlIH0gPSBwYXJhbXM7XHJcbiAgICAgICAgY29uc3QgdGV4dCA9IGRhdHVtLnRpY2tMYWJlbDtcclxuICAgICAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XHJcbiAgICAgICAgY29uc3QgdGlja1NpemUgPSB0aGlzLnRpY2suc2l6ZTtcclxuICAgICAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqICh0aWNrU2l6ZSArIGxhYmVsLnBhZGRpbmcgKyB0aGlzLnNlcmllc0FyZWFQYWRkaW5nKTtcclxuICAgICAgICBjb25zdCB2aXNpYmxlID0gdGV4dCAhPT0gJycgJiYgdGV4dCAhPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGlja0lkOiBkYXR1bS50aWNrSWQsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZLFxyXG4gICAgICAgICAgICBmaWxsOiBsYWJlbC5jb2xvcixcclxuICAgICAgICAgICAgZm9udEZhbWlseTogbGFiZWwuZm9udEZhbWlseSxcclxuICAgICAgICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IGxhYmVsLmZvbnRTdHlsZSxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogbGFiZWwuZm9udFdlaWdodCxcclxuICAgICAgICAgICAgcm90YXRpb246IGNvbWJpbmVkUm90YXRpb24sXHJcbiAgICAgICAgICAgIHJvdGF0aW9uQ2VudGVyWDogbGFiZWxYLFxyXG4gICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgIHRleHRCYXNlbGluZSxcclxuICAgICAgICAgICAgdmlzaWJsZSxcclxuICAgICAgICAgICAgeDogbGFiZWxYLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICByYW5nZSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2V0VGl0bGVQcm9wcyhjYXB0aW9uLCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcztcclxuICAgICAgICBpZiAoIXRpdGxlKSB7XHJcbiAgICAgICAgICAgIGNhcHRpb24uZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhcHRpb24uY29sb3IgPSB0aXRsZS5jb2xvcjtcclxuICAgICAgICBjYXB0aW9uLmZvbnRGYW1pbHkgPSB0aXRsZS5mb250RmFtaWx5O1xyXG4gICAgICAgIGNhcHRpb24uZm9udFNpemUgPSB0aXRsZS5mb250U2l6ZTtcclxuICAgICAgICBjYXB0aW9uLmZvbnRTdHlsZSA9IHRpdGxlLmZvbnRTdHlsZTtcclxuICAgICAgICBjYXB0aW9uLmZvbnRXZWlnaHQgPSB0aXRsZS5mb250V2VpZ2h0O1xyXG4gICAgICAgIGNhcHRpb24uZW5hYmxlZCA9IHRpdGxlLmVuYWJsZWQ7XHJcbiAgICAgICAgY2FwdGlvbi53cmFwcGluZyA9IHRpdGxlLndyYXBwaW5nO1xyXG4gICAgICAgIGlmICh0aXRsZS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlTm9kZSA9IGNhcHRpb24ubm9kZTtcclxuICAgICAgICAgICAgY29uc3QgeyB0aWNrU3BhY2UgfSA9IHBhcmFtcztcclxuICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9ICgoX2EgPSB0aXRsZS5zcGFjaW5nKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArIHRpY2tTcGFjZTtcclxuICAgICAgICAgICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFsbGVsRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlUm90YXRpb25GbGFnID0gc2lkZUZsYWcgPT09IC0xICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID4gTWF0aC5QSSAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA8IE1hdGguUEkgKiAyID8gLTEgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCByb3RhdGlvbiA9ICh0aXRsZVJvdGF0aW9uRmxhZyAqIHNpZGVGbGFnICogTWF0aC5QSSkgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSB0aXRsZVJvdGF0aW9uRmxhZyA9PT0gMSA/ICdib3R0b20nIDogJ3RvcCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2UgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKCh0aXRsZVJvdGF0aW9uRmxhZyAqIHNpZGVGbGFnICogKHJhbmdlWzBdICsgcmFuZ2VbMV0pKSAvIDIpO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gc2lkZUZsYWcgPT09IC0xID8gTWF0aC5mbG9vcih0aXRsZVJvdGF0aW9uRmxhZyAqIC1wYWRkaW5nKSA6IE1hdGguZmxvb3IoLXBhZGRpbmcpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNhbGxiYWNrQ2FjaGUgfSA9IHRoaXMubW9kdWxlQ3R4O1xyXG4gICAgICAgICAgICBjb25zdCB7IGZvcm1hdHRlciA9IChwYXJhbXMpID0+IHBhcmFtcy5kZWZhdWx0VmFsdWUgfSA9IHRpdGxlO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwgdGhpcy5nZXRUaXRsZUZvcm1hdHRlclBhcmFtcygpKTtcclxuICAgICAgICAgICAgdGl0bGVOb2RlLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgcm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVMYXlvdXQocHJpbWFyeVRpY2tDb3VudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcclxuICAgICAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcclxuICAgICAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqICh0aGlzLnRpY2suc2l6ZSArIHRoaXMubGFiZWwucGFkZGluZyArIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0ID0gdGhpcy5nZW5lcmF0ZVRpY2tzKHtcclxuICAgICAgICAgICAgcHJpbWFyeVRpY2tDb3VudCxcclxuICAgICAgICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXHJcbiAgICAgICAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXHJcbiAgICAgICAgICAgIGxhYmVsWCxcclxuICAgICAgICAgICAgc2lkZUZsYWcsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgX2IgPSB0aGlzLnRpY2tHZW5lcmF0aW9uUmVzdWx0LCB7IHRpY2tEYXRhLCBjb21iaW5lZFJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9ID0gX2IsIHRpY2tzUmVzdWx0ID0gX19yZXN0KF9iLCBbXCJ0aWNrRGF0YVwiLCBcImNvbWJpbmVkUm90YXRpb25cIiwgXCJ0ZXh0QmFzZWxpbmVcIiwgXCJ0ZXh0QWxpZ25cIl0pO1xyXG4gICAgICAgIGNvbnN0IGJveGVzID0gW107XHJcbiAgICAgICAgY29uc3QgeyB4LCB5MSwgeTIgfSA9IHRoaXMuZ2V0QXhpc0xpbmVDb29yZGluYXRlcygpO1xyXG4gICAgICAgIGNvbnN0IGxpbmVCb3ggPSBuZXcgQkJveCh4LCB5MSwgMCwgeTIgLSB5MSk7XHJcbiAgICAgICAgYm94ZXMucHVzaChsaW5lQm94KTtcclxuICAgICAgICBjb25zdCB7IHRpY2sgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRpY2suZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aWNrRGF0YS50aWNrcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB4MSwgeDIsIHkgfSA9IHRoaXMuZ2V0VGlja0xpbmVDb29yZGluYXRlcyhkYXR1bSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrTGluZUJveCA9IG5ldyBCQm94KHgxLCB5LCB4MiAtIHgxLCAwKTtcclxuICAgICAgICAgICAgICAgIGJveGVzLnB1c2godGlja0xpbmVCb3gpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcztcclxuICAgICAgICBpZiAobGFiZWwuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUZXh0KCk7XHJcbiAgICAgICAgICAgIHRpY2tEYXRhLnRpY2tzLmZvckVhY2goKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFByb3BzID0gdGhpcy5nZXRUaWNrTGFiZWxQcm9wcyhkYXR1bSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkUm90YXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5zY2FsZS5yYW5nZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYWJlbFByb3BzLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbGFiZWxQcm9wcyksIHsgdHJhbnNsYXRpb25ZOiBNYXRoLnJvdW5kKGRhdHVtLnRyYW5zbGF0aW9uWSkgfSkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm94ID0gdGVtcFRleHQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJveCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJveGVzLnB1c2goYm94KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdldFRyYW5zZm9ybUJveCA9IChiYm94KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgY29uc3QgeyByb3RhdGlvbjogYXhpc1JvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwgcm90YXRpb25DZW50ZXJYLCByb3RhdGlvbkNlbnRlclksIH0gPSB0aGlzLmdldEF4aXNUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIDEsIDEsIGF4aXNSb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblksIHtcclxuICAgICAgICAgICAgICAgIHNjYWxpbmdDZW50ZXJYOiAwLFxyXG4gICAgICAgICAgICAgICAgc2NhbGluZ0NlbnRlclk6IDAsXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbkNlbnRlclgsXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvbkNlbnRlclksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4LnRyYW5zZm9ybUJCb3goYmJveCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aXRsZSA9PT0gbnVsbCB8fCB0aXRsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGl0bGUuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0aW9uID0gbmV3IENhcHRpb24oKTtcclxuICAgICAgICAgICAgbGV0IHRpY2tTcGFjZSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aWNrRGF0YS50aWNrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50Qm94ID0gQkJveC5tZXJnZShib3hlcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aWNrV2lkdGggPSBjb250ZW50Qm94LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHRpY2tXaWR0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWNrU3BhY2UgKz0gdGlja1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VGl0bGVQcm9wcyhjYXB0aW9uLCB7IHRpY2tTcGFjZSB9KTtcclxuICAgICAgICAgICAgY29uc3QgdGl0bGVOb2RlID0gY2FwdGlvbi5ub2RlO1xyXG4gICAgICAgICAgICBjb25zdCB0aXRsZUJveCA9IHRpdGxlTm9kZS5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XHJcbiAgICAgICAgICAgIGlmICh0aXRsZUJveCkge1xyXG4gICAgICAgICAgICAgICAgYm94ZXMucHVzaCh0aXRsZUJveCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmJveCA9IEJCb3gubWVyZ2UoYm94ZXMpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQkJveCA9IGdldFRyYW5zZm9ybUJveChiYm94KTtcclxuICAgICAgICBjb25zdCBhbnlTZXJpZXNBY3RpdmUgPSB0aGlzLmlzQW55U2VyaWVzQWN0aXZlKCk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jcm9zc0xpbmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY3Jvc3NMaW5lLnNpZGVGbGFnID0gLXNpZGVGbGFnO1xyXG4gICAgICAgICAgICBjcm9zc0xpbmUuZGlyZWN0aW9uID0gcm90YXRpb24gPT09IC1NYXRoLlBJIC8gMiA/IENoYXJ0QXhpc0RpcmVjdGlvbi5YIDogQ2hhcnRBeGlzRGlyZWN0aW9uLlk7XHJcbiAgICAgICAgICAgIGlmIChjcm9zc0xpbmUgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5Dcm9zc0xpbmUpIHtcclxuICAgICAgICAgICAgICAgIGNyb3NzTGluZS5sYWJlbC5wYXJhbGxlbCA9IChfYSA9IGNyb3NzTGluZS5sYWJlbC5wYXJhbGxlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5sYWJlbC5wYXJhbGxlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjcm9zc0xpbmUucGFyYWxsZWxGbGlwUm90YXRpb24gPSBwYXJhbGxlbEZsaXBSb3RhdGlvbjtcclxuICAgICAgICAgICAgY3Jvc3NMaW5lLnJlZ3VsYXJGbGlwUm90YXRpb24gPSByZWd1bGFyRmxpcFJvdGF0aW9uO1xyXG4gICAgICAgICAgICBjcm9zc0xpbmUuY2FsY3VsYXRlTGF5b3V0KGFueVNlcmllc0FjdGl2ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMYXlvdXRTdGF0ZSgpO1xyXG4gICAgICAgIHByaW1hcnlUaWNrQ291bnQgPSB0aWNrc1Jlc3VsdC5wcmltYXJ5VGlja0NvdW50O1xyXG4gICAgICAgIHJldHVybiB7IHByaW1hcnlUaWNrQ291bnQsIGJib3g6IHRyYW5zZm9ybWVkQkJveCB9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTGF5b3V0U3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5sYXlvdXQubGFiZWwgPSB7XHJcbiAgICAgICAgICAgIGZyYWN0aW9uRGlnaXRzOiB0aGlzLmZyYWN0aW9uRGlnaXRzLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiB0aGlzLmxhYmVsLnBhZGRpbmcsXHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5sYWJlbC5mb3JtYXQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNjYWxlKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2UoKTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2V0RG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5zZXRUaWNrSW50ZXJ2YWwodGhpcy50aWNrLmludGVydmFsKTtcclxuICAgICAgICBjb25zdCB7IHNjYWxlLCBuaWNlIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghQ29udGludW91c1NjYWxlLmlzKHNjYWxlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjYWxlLm5pY2UgPSBuaWNlO1xyXG4gICAgICAgIHNjYWxlLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlUm90YXRpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgIC8vIFdoZW4gbGFiZWxzIGFyZSBwYXJhbGxlbCB0byB0aGUgYXhpcyBsaW5lLCB0aGUgYHBhcmFsbGVsRmxpcEZsYWdgIGlzIHVzZWQgdG9cclxuICAgICAgICAvLyBmbGlwIHRoZSBsYWJlbHMgdG8gYXZvaWQgdXBzaWRlLWRvd24gdGV4dCwgd2hlbiB0aGUgYXhpcyBpcyByb3RhdGVkXHJcbiAgICAgICAgLy8gc3VjaCB0aGF0IGl0IGlzIGluIHRoZSByaWdodCBoZW1pc3BoZXJlLCBpLmUuIHRoZSBhbmdsZSBvZiByb3RhdGlvblxyXG4gICAgICAgIC8vIGlzIGluIHRoZSBbMCwgz4BdIGludGVydmFsLlxyXG4gICAgICAgIC8vIFRoZSByb3RhdGlvbiBhbmdsZSBpcyBub3JtYWxpemVkLCBzbyB0aGF0IHdlIGhhdmUgYW4gZWFzaWVyIHRpbWUgY2hlY2tpbmdcclxuICAgICAgICAvLyBpZiBpdCdzIGluIHRoZSBzYWlkIGludGVydmFsLiBTaW5jZSB0aGUgYXhpcyBpcyBhbHdheXMgcmVuZGVyZWQgdmVydGljYWxseVxyXG4gICAgICAgIC8vIGFuZCB0aGVuIHJvdGF0ZWQsIHplcm8gcm90YXRpb24gbWVhbnMgMTIgKG5vdCAzKSBvLWNsb2NrLlxyXG4gICAgICAgIC8vIC0xID0gZmxpcFxyXG4gICAgICAgIC8vICAxID0gZG9uJ3QgZmxpcCAoZGVmYXVsdClcclxuICAgICAgICBjb25zdCBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uKTtcclxuICAgICAgICBjb25zdCByZWd1bGFyRmxpcFJvdGF0aW9uID0gbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24gLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgcmV0dXJuIHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uIH07XHJcbiAgICB9XHJcbiAgICBnZW5lcmF0ZVRpY2tzKHsgcHJpbWFyeVRpY2tDb3VudCwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24sIGxhYmVsWCwgc2lkZUZsYWcsIH0pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBzY2FsZSwgdGljaywgbGFiZWw6IHsgcGFyYWxsZWwsIHJvdGF0aW9uLCBmb250RmFtaWx5LCBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0IH0sIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHNlY29uZGFyeUF4aXMgPSBwcmltYXJ5VGlja0NvdW50ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0Um90YXRpb24sIGNvbmZpZ3VyZWRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZywgcmVndWxhckZsaXBGbGFnIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcclxuICAgICAgICAgICAgcm90YXRpb24sXHJcbiAgICAgICAgICAgIHBhcmFsbGVsLFxyXG4gICAgICAgICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxyXG4gICAgICAgICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBpbml0aWFsUm90YXRpb24gPSBjb25maWd1cmVkUm90YXRpb24gKyBkZWZhdWx0Um90YXRpb247XHJcbiAgICAgICAgY29uc3QgbGFiZWxNYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgY29uc3QgeyBtYXhUaWNrQ291bnQgfSA9IHRoaXMuZXN0aW1hdGVUaWNrQ291bnQoe1xyXG4gICAgICAgICAgICBtaW5TcGFjaW5nOiB0aWNrLm1pblNwYWNpbmcsXHJcbiAgICAgICAgICAgIG1heFNwYWNpbmc6IChfYSA9IHRpY2subWF4U3BhY2luZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTmFOLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUpO1xyXG4gICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAhY29udGludW91cyB8fCBpc05hTihtYXhUaWNrQ291bnQpID8gMTAgOiBtYXhUaWNrQ291bnQ7XHJcbiAgICAgICAgbGV0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCAwLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKTtcclxuICAgICAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSBnZXRUZXh0QmFzZWxpbmUocGFyYWxsZWwsIGNvbmZpZ3VyZWRSb3RhdGlvbiwgc2lkZUZsYWcsIHBhcmFsbGVsRmxpcEZsYWcpO1xyXG4gICAgICAgIGNvbnN0IHRleHRQcm9wcyA9IHtcclxuICAgICAgICAgICAgZm9udEZhbWlseSxcclxuICAgICAgICAgICAgZm9udFNpemUsXHJcbiAgICAgICAgICAgIGZvbnRTdHlsZSxcclxuICAgICAgICAgICAgZm9udFdlaWdodCxcclxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lLFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ24sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgdGlja0RhdGEgPSB7XHJcbiAgICAgICAgICAgIHJhd1RpY2tzOiBbXSxcclxuICAgICAgICAgICAgdGlja3M6IFtdLFxyXG4gICAgICAgICAgICBsYWJlbENvdW50OiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBsZXQgYXV0b1JvdGF0aW9uID0gMDtcclxuICAgICAgICBsZXQgbGFiZWxPdmVybGFwID0gdHJ1ZTtcclxuICAgICAgICBsZXQgdGVybWluYXRlID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKGxhYmVsT3ZlcmxhcCAmJiBpbmRleCA8PSBtYXhJdGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXJtaW5hdGUpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF1dG9Sb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCAwLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKTtcclxuICAgICAgICAgICAgY29uc3QgdGlja1N0cmF0ZWdpZXMgPSB0aGlzLmdldFRpY2tTdHJhdGVnaWVzKHsgc2Vjb25kYXJ5QXhpcywgaW5kZXggfSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3RyYXRlZ3kgb2YgdGlja1N0cmF0ZWdpZXMpIHtcclxuICAgICAgICAgICAgICAgICh7IHRpY2tEYXRhLCBpbmRleCwgYXV0b1JvdGF0aW9uLCB0ZXJtaW5hdGUgfSA9IHN0cmF0ZWd5KHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB0aWNrRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0UHJvcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxPdmVybGFwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5VGlja0NvdW50LFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm90YXRlZCA9IGNvbmZpZ3VyZWRSb3RhdGlvbiAhPT0gMCB8fCBhdXRvUm90YXRpb24gIT09IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3RhdGlvbiA9IGluaXRpYWxSb3RhdGlvbiArIGF1dG9Sb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCBhdXRvUm90YXRpb24sIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpO1xyXG4gICAgICAgICAgICAgICAgbGFiZWxPdmVybGFwID0gdGhpcy5jaGVja0xhYmVsT3ZlcmxhcChyb3RhdGlvbiwgcm90YXRlZCwgbGFiZWxNYXRyaXgsIHRpY2tEYXRhLnRpY2tzLCBsYWJlbFgsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGV4dFByb3BzKSwgeyB0ZXh0QWxpZ24gfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkUm90YXRpb24gPSBkZWZhdWx0Um90YXRpb24gKyBjb25maWd1cmVkUm90YXRpb24gKyBhdXRvUm90YXRpb247XHJcbiAgICAgICAgaWYgKCFzZWNvbmRhcnlBeGlzICYmIHRpY2tEYXRhLnJhd1RpY2tzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcHJpbWFyeVRpY2tDb3VudCA9IHRpY2tEYXRhLnJhd1RpY2tzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdGlja0RhdGEsIHByaW1hcnlUaWNrQ291bnQsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH07XHJcbiAgICB9XHJcbiAgICBnZXRUaWNrU3RyYXRlZ2llcyh7IGluZGV4LCBzZWNvbmRhcnlBeGlzIH0pIHtcclxuICAgICAgICBjb25zdCB7IHNjYWxlLCBsYWJlbCwgdGljayB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlKTtcclxuICAgICAgICBjb25zdCBhdm9pZExhYmVsQ29sbGlzaW9ucyA9IGxhYmVsLmVuYWJsZWQgJiYgbGFiZWwuYXZvaWRDb2xsaXNpb25zO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlclRpY2tzID0gIWNvbnRpbnVvdXMgJiYgaW5kZXggIT09IDAgJiYgYXZvaWRMYWJlbENvbGxpc2lvbnM7XHJcbiAgICAgICAgY29uc3QgYXV0b1JvdGF0ZSA9IGxhYmVsLmF1dG9Sb3RhdGUgPT09IHRydWUgJiYgbGFiZWwucm90YXRpb24gPT09IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBzdHJhdGVnaWVzID0gW107XHJcbiAgICAgICAgbGV0IHRpY2tHZW5lcmF0aW9uVHlwZTtcclxuICAgICAgICBpZiAodGhpcy50aWNrLnZhbHVlcykge1xyXG4gICAgICAgICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSBUaWNrR2VuZXJhdGlvblR5cGUuVkFMVUVTO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWNvbmRhcnlBeGlzKSB7XHJcbiAgICAgICAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IFRpY2tHZW5lcmF0aW9uVHlwZS5DUkVBVEVfU0VDT05EQVJZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmaWx0ZXJUaWNrcykge1xyXG4gICAgICAgICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSBUaWNrR2VuZXJhdGlvblR5cGUuRklMVEVSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gVGlja0dlbmVyYXRpb25UeXBlLkNSRUFURTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGlja0dlbmVyYXRpb25TdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgcHJpbWFyeVRpY2tDb3VudCwgdGVybWluYXRlIH0pID0+IHRoaXMuY3JlYXRlVGlja0RhdGEodGlja0dlbmVyYXRpb25UeXBlLCBpbmRleCwgdGlja0RhdGEsIHRlcm1pbmF0ZSwgcHJpbWFyeVRpY2tDb3VudCk7XHJcbiAgICAgICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tHZW5lcmF0aW9uU3RyYXRlZ3kpO1xyXG4gICAgICAgIGlmICghY29udGludW91cyAmJiAhaXNOYU4odGljay5taW5TcGFjaW5nKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aWNrRmlsdGVyU3RyYXRlZ3kgPSAoeyBpbmRleCwgdGlja0RhdGEsIHByaW1hcnlUaWNrQ291bnQsIHRlcm1pbmF0ZSB9KSA9PiB0aGlzLmNyZWF0ZVRpY2tEYXRhKFRpY2tHZW5lcmF0aW9uVHlwZS5GSUxURVIsIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KTtcclxuICAgICAgICAgICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tGaWx0ZXJTdHJhdGVneSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXZvaWRMYWJlbENvbGxpc2lvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWdpZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYWJlbC5hdXRvV3JhcCkge1xyXG4gICAgICAgICAgICBjb25zdCBhdXRvV3JhcFN0cmF0ZWd5ID0gKHsgaW5kZXgsIHRpY2tEYXRhLCB0ZXh0UHJvcHMgfSkgPT4gdGhpcy53cmFwTGFiZWxzKHRpY2tEYXRhLCBpbmRleCwgdGV4dFByb3BzKTtcclxuICAgICAgICAgICAgc3RyYXRlZ2llcy5wdXNoKGF1dG9XcmFwU3RyYXRlZ3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhdXRvUm90YXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1dG9Sb3RhdGVTdHJhdGVneSA9ICh7IGluZGV4LCB0aWNrRGF0YSwgbGFiZWxPdmVybGFwLCB0ZXJtaW5hdGUgfSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgdGlja0RhdGEsXHJcbiAgICAgICAgICAgICAgICBhdXRvUm90YXRpb246IHRoaXMuZ2V0QXV0b1JvdGF0aW9uKGxhYmVsT3ZlcmxhcCksXHJcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdHJhdGVnaWVzLnB1c2goYXV0b1JvdGF0ZVN0cmF0ZWd5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWdpZXM7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVUaWNrRGF0YSh0aWNrR2VuZXJhdGlvblR5cGUsIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgc2NhbGUsIHRpY2sgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBtYXhUaWNrQ291bnQsIG1pblRpY2tDb3VudCwgZGVmYXVsdFRpY2tDb3VudCB9ID0gdGhpcy5lc3RpbWF0ZVRpY2tDb3VudCh7XHJcbiAgICAgICAgICAgIG1pblNwYWNpbmc6IHRpY2subWluU3BhY2luZyxcclxuICAgICAgICAgICAgbWF4U3BhY2luZzogKF9hID0gdGljay5tYXhTcGFjaW5nKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBOYU4sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY29udGludW91cyA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZSk7XHJcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9ICFjb250aW51b3VzIHx8IGlzTmFOKG1heFRpY2tDb3VudCkgPyAxMCA6IG1heFRpY2tDb3VudDtcclxuICAgICAgICBsZXQgdGlja0NvdW50ID0gY29udGludW91cyA/IE1hdGgubWF4KGRlZmF1bHRUaWNrQ291bnQgLSBpbmRleCwgbWluVGlja0NvdW50KSA6IG1heFRpY2tDb3VudDtcclxuICAgICAgICBjb25zdCByZWdlbmVyYXRlVGlja3MgPSB0aWNrLmludGVydmFsID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgdGljay52YWx1ZXMgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICB0aWNrQ291bnQgPiBtaW5UaWNrQ291bnQgJiZcclxuICAgICAgICAgICAgKGNvbnRpbnVvdXMgfHwgdGlja0dlbmVyYXRpb25UeXBlID09PSBUaWNrR2VuZXJhdGlvblR5cGUuRklMVEVSKTtcclxuICAgICAgICBsZXQgdW5jaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB3aGlsZSAodW5jaGFuZ2VkICYmIGluZGV4IDw9IG1heEl0ZXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldlRpY2tzID0gdGlja0RhdGEucmF3VGlja3M7XHJcbiAgICAgICAgICAgIHRpY2tDb3VudCA9IGNvbnRpbnVvdXMgPyBNYXRoLm1heChkZWZhdWx0VGlja0NvdW50IC0gaW5kZXgsIG1pblRpY2tDb3VudCkgOiBtYXhUaWNrQ291bnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcmF3VGlja3MsIHRpY2tzLCBsYWJlbENvdW50IH0gPSB0aGlzLmdldFRpY2tzKHtcclxuICAgICAgICAgICAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVGlja3M6IHByZXZUaWNrcyxcclxuICAgICAgICAgICAgICAgIHRpY2tDb3VudCxcclxuICAgICAgICAgICAgICAgIG1pblRpY2tDb3VudCxcclxuICAgICAgICAgICAgICAgIG1heFRpY2tDb3VudCxcclxuICAgICAgICAgICAgICAgIHByaW1hcnlUaWNrQ291bnQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aWNrRGF0YS5yYXdUaWNrcyA9IHJhd1RpY2tzO1xyXG4gICAgICAgICAgICB0aWNrRGF0YS50aWNrcyA9IHRpY2tzO1xyXG4gICAgICAgICAgICB0aWNrRGF0YS5sYWJlbENvdW50ID0gbGFiZWxDb3VudDtcclxuICAgICAgICAgICAgdW5jaGFuZ2VkID0gcmVnZW5lcmF0ZVRpY2tzID8gYXJlQXJyYXlOdW1iZXJzRXF1YWwocmF3VGlja3MsIHByZXZUaWNrcykgOiBmYWxzZTtcclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkVGVybWluYXRlID0gdGljay5pbnRlcnZhbCAhPT0gdW5kZWZpbmVkIHx8IHRpY2sudmFsdWVzICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGVybWluYXRlIHx8ICh0ZXJtaW5hdGUgPSBzaG91bGRUZXJtaW5hdGUpO1xyXG4gICAgICAgIHJldHVybiB7IHRpY2tEYXRhLCBpbmRleCwgYXV0b1JvdGF0aW9uOiAwLCB0ZXJtaW5hdGUgfTtcclxuICAgIH1cclxuICAgIGNoZWNrTGFiZWxPdmVybGFwKHJvdGF0aW9uLCByb3RhdGVkLCBsYWJlbE1hdHJpeCwgdGlja0RhdGEsIGxhYmVsWCwgdGV4dFByb3BzKSB7XHJcbiAgICAgICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeChsYWJlbE1hdHJpeCwgMSwgMSwgcm90YXRpb24sIDAsIDApO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IHRoaXMuY3JlYXRlTGFiZWxEYXRhKHRpY2tEYXRhLCBsYWJlbFgsIHRleHRQcm9wcywgbGFiZWxNYXRyaXgpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsU3BhY2luZyA9IGdldExhYmVsU3BhY2luZyh0aGlzLmxhYmVsLm1pblNwYWNpbmcsIHJvdGF0ZWQpO1xyXG4gICAgICAgIHJldHVybiBheGlzTGFiZWxzT3ZlcmxhcChsYWJlbERhdGEsIGxhYmVsU3BhY2luZyk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVMYWJlbERhdGEodGlja0RhdGEsIGxhYmVsWCwgdGV4dFByb3BzLCBsYWJlbE1hdHJpeCkge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlja0RhdHVtIG9mIHRpY2tEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdGlja0xhYmVsLCB0cmFuc2xhdGlvblkgfSA9IHRpY2tEYXR1bTtcclxuICAgICAgICAgICAgaWYgKHRpY2tMYWJlbCA9PT0gJycgfHwgdGlja0xhYmVsID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCB1c2VyIGhpZGRlbiB0aWNrc1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzcGxpdFRleHQodGlja0xhYmVsKTtcclxuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBtZWFzdXJlVGV4dChsaW5lcywgbGFiZWxYLCB0cmFuc2xhdGlvblksIHRleHRQcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSBuZXcgQkJveChsYWJlbFgsIHRyYW5zbGF0aW9uWSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsRGF0dW0gPSBjYWxjdWxhdGVMYWJlbEJCb3godGlja0xhYmVsLCBiYm94LCBsYWJlbFgsIHRyYW5zbGF0aW9uWSwgbGFiZWxNYXRyaXgpO1xyXG4gICAgICAgICAgICBsYWJlbERhdGEucHVzaChsYWJlbERhdHVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsRGF0YTtcclxuICAgIH1cclxuICAgIGdldEF1dG9Sb3RhdGlvbihsYWJlbE92ZXJsYXApIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsT3ZlcmxhcCA/IG5vcm1hbGl6ZUFuZ2xlMzYwKHRvUmFkaWFucygoX2EgPSB0aGlzLmxhYmVsLmF1dG9Sb3RhdGVBbmdsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkpIDogMDtcclxuICAgIH1cclxuICAgIGdldFRpY2tzKHsgdGlja0dlbmVyYXRpb25UeXBlLCBwcmV2aW91c1RpY2tzLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50LCBwcmltYXJ5VGlja0NvdW50LCB9KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgcmFuZ2UsIHNjYWxlLCB2aXNpYmxlUmFuZ2UgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IHJhd1RpY2tzID0gW107XHJcbiAgICAgICAgc3dpdGNoICh0aWNrR2VuZXJhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUaWNrR2VuZXJhdGlvblR5cGUuVkFMVUVTOlxyXG4gICAgICAgICAgICAgICAgcmF3VGlja3MgPSB0aGlzLnRpY2sudmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgVGlja0dlbmVyYXRpb25UeXBlLkNSRUFURV9TRUNPTkRBUlk6XHJcbiAgICAgICAgICAgICAgICAvLyBgdXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzYCBtdXRhdGVzIGBzY2FsZS5kb21haW5gIGJhc2VkIG9uIGBwcmltYXJ5VGlja0NvdW50YFxyXG4gICAgICAgICAgICAgICAgcmF3VGlja3MgPSB0aGlzLnVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcyhwcmltYXJ5VGlja0NvdW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFRpY2tHZW5lcmF0aW9uVHlwZS5GSUxURVI6XHJcbiAgICAgICAgICAgICAgICByYXdUaWNrcyA9IHRoaXMuZmlsdGVyVGlja3MocHJldmlvdXNUaWNrcywgdGlja0NvdW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmF3VGlja3MgPSB0aGlzLmNyZWF0ZVRpY2tzKHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdoZW4gdGhlIHNjYWxlIGRvbWFpbiBvciB0aGUgdGlja3MgY2hhbmdlLCB0aGUgbGFiZWwgZm9ybWF0IG1heSBjaGFuZ2VcclxuICAgICAgICB0aGlzLm9uTGFiZWxGb3JtYXRDaGFuZ2UocmF3VGlja3MsIHRoaXMubGFiZWwuZm9ybWF0KTtcclxuICAgICAgICAvLyBgdGlja3MgaW5zdGFuY2VvZiBOdW1lcmljVGlja3NgIGRvZXNuJ3Qgd29yayBoZXJlLCBzbyB3ZSBmZWF0dXJlIGRldGVjdC5cclxuICAgICAgICB0aGlzLmZyYWN0aW9uRGlnaXRzID0gcmF3VGlja3MuZnJhY3Rpb25EaWdpdHMgPj0gMCA/IHJhd1RpY2tzLmZyYWN0aW9uRGlnaXRzIDogMDtcclxuICAgICAgICBjb25zdCBoYWxmQmFuZHdpZHRoID0gKChfYSA9IHNjYWxlLmJhbmR3aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLyAyO1xyXG4gICAgICAgIGNvbnN0IHRpY2tzID0gW107XHJcbiAgICAgICAgbGV0IGxhYmVsQ291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHRpY2tJZENvdW50cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvLyBPbmx5IGdldCB0aGUgdGlja3Mgd2l0aGluIGEgc2xpZGluZyB3aW5kb3cgb2YgdGhlIHZpc2libGUgcmFuZ2UgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcih2aXNpYmxlUmFuZ2VbMF0gKiByYXdUaWNrcy5sZW5ndGgpKTtcclxuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihyYXdUaWNrcy5sZW5ndGgsIE1hdGguY2VpbCh2aXNpYmxlUmFuZ2VbMV0gKiByYXdUaWNrcy5sZW5ndGgpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCByYXdUaWNrID0gcmF3VGlja3NbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IHNjYWxlLmNvbnZlcnQocmF3VGljaykgKyBoYWxmQmFuZHdpZHRoO1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgcmVuZGVyIHRpY2tzIG91dHNpZGUgdGhlIHJhbmdlIHdpdGggYSBzbWFsbCB0b2xlcmFuY2UuIEEgY2xpcCByZWN0IHdvdWxkIHRyaW0gbG9uZyBsYWJlbHMsIHNvXHJcbiAgICAgICAgICAgIC8vIGluc3RlYWQgaGlkZSB0aWNrcyBiYXNlZCBvbiB0aGVpciB0cmFuc2xhdGlvbi5cclxuICAgICAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IDAgJiYgIXRoaXMuaW5SYW5nZSh0cmFuc2xhdGlvblksIDAsIDAuMDAxKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBjb25zdCB0aWNrTGFiZWwgPSB0aGlzLmZvcm1hdFRpY2socmF3VGljaywgaSk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRpY2sgaWQgZnJvbSB0aGUgbGFiZWwsIG9yIGFzIGFuIGluY3JlbWVudCBvZiB0aGUgbGFzdCBsYWJlbCBpZiB0aGlzIHRpY2sgbGFiZWwgaXMgYmxhbmtcclxuICAgICAgICAgICAgbGV0IHRpY2tJZCA9IHRpY2tMYWJlbDtcclxuICAgICAgICAgICAgaWYgKHRpY2tJZENvdW50cy5oYXModGlja0lkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aWNrSWRDb3VudHMuZ2V0KHRpY2tJZCk7XHJcbiAgICAgICAgICAgICAgICB0aWNrSWRDb3VudHMuc2V0KHRpY2tJZCwgY291bnQgKyAxKTtcclxuICAgICAgICAgICAgICAgIHRpY2tJZCA9IGAke3RpY2tJZH1fJHtjb3VudH1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGlja0lkQ291bnRzLnNldCh0aWNrSWQsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpY2tzLnB1c2goeyB0aWNrOiByYXdUaWNrLCB0aWNrSWQsIHRpY2tMYWJlbCwgdHJhbnNsYXRpb25ZIH0pO1xyXG4gICAgICAgICAgICBpZiAodGlja0xhYmVsID09PSAnJyB8fCB0aWNrTGFiZWwgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYWJlbENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHJhd1RpY2tzLCB0aWNrcywgbGFiZWxDb3VudCB9O1xyXG4gICAgfVxyXG4gICAgZmlsdGVyVGlja3ModGlja3MsIHRpY2tDb3VudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB0aWNrU3BhY2luZyA9ICFpc05hTih0aGlzLnRpY2subWluU3BhY2luZykgfHwgIWlzTmFOKChfYSA9IHRoaXMudGljay5tYXhTcGFjaW5nKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBOYU4pO1xyXG4gICAgICAgIGNvbnN0IGtlZXBFdmVyeSA9IHRpY2tTcGFjaW5nID8gTWF0aC5jZWlsKHRpY2tzLmxlbmd0aCAvIHRpY2tDb3VudCkgOiAyO1xyXG4gICAgICAgIHJldHVybiB0aWNrcy5maWx0ZXIoKF8sIGkpID0+IGkgJSBrZWVwRXZlcnkgPT09IDApO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlVGlja3ModGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHRoaXMuc2V0VGlja0NvdW50KHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xyXG4gICAgICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNjYWxlKS50aWNrcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcclxuICAgIH1cclxuICAgIGVzdGltYXRlVGlja0NvdW50KHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9KSB7XHJcbiAgICAgICAgY29uc3QgeyBtaW5SZWN0IH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlV2l0aEJsZWVkID0gdGhpcy5jYWxjdWxhdGVSYW5nZVdpdGhCbGVlZCgpO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5TcGFjaW5nID0gTWF0aC5tYXgodGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcsIHJhbmdlV2l0aEJsZWVkIC8gQ29udGludW91c1NjYWxlLmRlZmF1bHRNYXhUaWNrQ291bnQpO1xyXG4gICAgICAgIGxldCBjbGFtcE1heFRpY2tDb3VudCA9ICFpc05hTihtYXhTcGFjaW5nKTtcclxuICAgICAgICBpZiAoaXNOYU4obWluU3BhY2luZykpIHtcclxuICAgICAgICAgICAgbWluU3BhY2luZyA9IGRlZmF1bHRNaW5TcGFjaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4obWF4U3BhY2luZykpIHtcclxuICAgICAgICAgICAgbWF4U3BhY2luZyA9IHJhbmdlV2l0aEJsZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWluU3BhY2luZyA+IG1heFNwYWNpbmcpIHtcclxuICAgICAgICAgICAgaWYgKG1pblNwYWNpbmcgPT09IGRlZmF1bHRNaW5TcGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5TcGFjaW5nID0gbWF4U3BhY2luZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1heFNwYWNpbmcgPSBtaW5TcGFjaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsYW1wcyB0aGUgbWluIHNwYWNpbmcgYmV0d2VlbiB0aWNrcyB0byBiZSBubyBtb3JlIHRoYW4gdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIGRhdHVtc1xyXG4gICAgICAgIGNvbnN0IG1pblJlY3REaXN0YW5jZSA9IG1pblJlY3RcclxuICAgICAgICAgICAgPyB0aGlzLmRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlhcclxuICAgICAgICAgICAgICAgID8gbWluUmVjdC53aWR0aFxyXG4gICAgICAgICAgICAgICAgOiBtaW5SZWN0LmhlaWdodFxyXG4gICAgICAgICAgICA6IDE7XHJcbiAgICAgICAgY2xhbXBNYXhUaWNrQ291bnQgJiYgKGNsYW1wTWF4VGlja0NvdW50ID0gbWluUmVjdERpc3RhbmNlIDwgZGVmYXVsdE1pblNwYWNpbmcpO1xyXG4gICAgICAgIGNvbnN0IG1heFRpY2tDb3VudCA9IGNsYW1wKDEsIE1hdGguZmxvb3IocmFuZ2VXaXRoQmxlZWQgLyBtaW5TcGFjaW5nKSwgY2xhbXBNYXhUaWNrQ291bnQgPyBNYXRoLmZsb29yKHJhbmdlV2l0aEJsZWVkIC8gbWluUmVjdERpc3RhbmNlKSA6IEluZmluaXR5KTtcclxuICAgICAgICBjb25zdCBtaW5UaWNrQ291bnQgPSBNYXRoLm1pbihtYXhUaWNrQ291bnQsIE1hdGguY2VpbChyYW5nZVdpdGhCbGVlZCAvIG1heFNwYWNpbmcpKTtcclxuICAgICAgICBjb25zdCBkZWZhdWx0VGlja0NvdW50ID0gY2xhbXAobWluVGlja0NvdW50LCBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcclxuICAgICAgICByZXR1cm4geyBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCwgZGVmYXVsdFRpY2tDb3VudCB9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVmlzaWJpbGl0eSgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb2R1bGVDdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aWNrTGluZUdyb3VwLnZpc2libGUgPSB0aGlzLnRpY2suZW5hYmxlZDtcclxuICAgICAgICB0aGlzLmdyaWRMaW5lR3JvdXAudmlzaWJsZSA9IHRoaXMuZ3JpZExpbmUuZW5hYmxlZDtcclxuICAgICAgICB0aGlzLnRpY2tMYWJlbEdyb3VwLnZpc2libGUgPSB0aGlzLmxhYmVsLmVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVDcm9zc0xpbmVzKHsgcm90YXRpb24sIHBhcmFsbGVsRmxpcFJvdGF0aW9uLCByZWd1bGFyRmxpcFJvdGF0aW9uLCB9KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xyXG4gICAgICAgIGNvbnN0IGFueVNlcmllc0FjdGl2ZSA9IHRoaXMuaXNBbnlTZXJpZXNBY3RpdmUoKTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNyb3NzTGluZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjcm9zc0xpbmUuc2lkZUZsYWcgPSAtc2lkZUZsYWc7XHJcbiAgICAgICAgICAgIGNyb3NzTGluZS5kaXJlY3Rpb24gPSByb3RhdGlvbiA9PT0gLU1hdGguUEkgLyAyID8gQ2hhcnRBeGlzRGlyZWN0aW9uLlggOiBDaGFydEF4aXNEaXJlY3Rpb24uWTtcclxuICAgICAgICAgICAgaWYgKGNyb3NzTGluZSBpbnN0YW5jZW9mIENhcnRlc2lhbkNyb3NzTGluZSkge1xyXG4gICAgICAgICAgICAgICAgY3Jvc3NMaW5lLmxhYmVsLnBhcmFsbGVsID0gKF9hID0gY3Jvc3NMaW5lLmxhYmVsLnBhcmFsbGVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmxhYmVsLnBhcmFsbGVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNyb3NzTGluZS5wYXJhbGxlbEZsaXBSb3RhdGlvbiA9IHBhcmFsbGVsRmxpcFJvdGF0aW9uO1xyXG4gICAgICAgICAgICBjcm9zc0xpbmUucmVndWxhckZsaXBSb3RhdGlvbiA9IHJlZ3VsYXJGbGlwUm90YXRpb247XHJcbiAgICAgICAgICAgIGNyb3NzTGluZS51cGRhdGUoYW55U2VyaWVzQWN0aXZlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRpY2tMaW5lcygpIHtcclxuICAgICAgICBjb25zdCB7IHRpY2ssIGxhYmVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcclxuICAgICAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24uZWFjaCgobGluZSkgPT4ge1xyXG4gICAgICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gdGljay53aWR0aDtcclxuICAgICAgICAgICAgbGluZS5zdHJva2UgPSB0aWNrLmNvbG9yO1xyXG4gICAgICAgICAgICBsaW5lLngxID0gc2lkZUZsYWcgKiB0aWNrLnNpemU7XHJcbiAgICAgICAgICAgIGxpbmUueDIgPSAwO1xyXG4gICAgICAgICAgICBsaW5lLnkxID0gMDtcclxuICAgICAgICAgICAgbGluZS55MiA9IDA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVBdmFpbGFibGVSYW5nZSgpIHtcclxuICAgICAgICBjb25zdCB7IHJhbmdlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnJhbmdlKTtcclxuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heCguLi5yYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIG1heCAtIG1pbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYXZhaWxhYmxlIHJhbmdlIHdpdGggYW4gYWRkaXRpb25hbCBcImJsZWVkXCIgYmV5b25kIHRoZSBjYW52YXMgdGhhdCBlbmNvbXBhc3NlcyB0aGUgZnVsbCBheGlzIHdoZW5cclxuICAgICAqIHRoZSB2aXNpYmxlIHJhbmdlIGlzIG9ubHkgYSBwb3J0aW9uIG9mIHRoZSBheGlzLlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVSYW5nZVdpdGhCbGVlZCgpIHtcclxuICAgICAgICBjb25zdCB7IHZpc2libGVSYW5nZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB2aXNpYmxlU2NhbGUgPSAxIC8gKHZpc2libGVSYW5nZVsxXSAtIHZpc2libGVSYW5nZVswXSk7XHJcbiAgICAgICAgcmV0dXJuIHJvdW5kJDEodGhpcy5jYWxjdWxhdGVBdmFpbGFibGVSYW5nZSgpICogdmlzaWJsZVNjYWxlLCAyKTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZURvbWFpbigpIHtcclxuICAgICAgICBpZiAodGhpcy5saW5rZWRUbykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFEb21haW4gPSB0aGlzLmxpbmtlZFRvLmRhdGFEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlU2VyaWVzID0gdGhpcy5ib3VuZFNlcmllcy5maWx0ZXIoKHMpID0+IHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgfHwgcy5pc0VuYWJsZWQoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbnMgPSB2aXNpYmxlU2VyaWVzLmZsYXRNYXAoKHNlcmllcykgPT4gc2VyaWVzLmdldERvbWFpbih0aGlzLmRpcmVjdGlvbikpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFEb21haW4gPSB0aGlzLm5vcm1hbGlzZURhdGFEb21haW4oZG9tYWlucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0QXhpc1RyYW5zZm9ybSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3RhdGlvbjogdG9SYWRpYW5zKHRoaXMucm90YXRpb24pLFxyXG4gICAgICAgICAgICByb3RhdGlvbkNlbnRlclg6IDAsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uQ2VudGVyWTogMCxcclxuICAgICAgICAgICAgdHJhbnNsYXRpb25YOiB0aGlzLnRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uWTogdGhpcy50cmFuc2xhdGlvbi55LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQb3NpdGlvbigpIHtcclxuICAgICAgICBjb25zdCB7IGNyb3NzTGluZUdyb3VwLCBheGlzR3JvdXAsIGdyaWRHcm91cCwgdHJhbnNsYXRpb24sIGdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIGdyaWRQYWRkaW5nLCBncmlkTGVuZ3RoIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XHJcbiAgICAgICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcih0cmFuc2xhdGlvbi54KTtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHRyYW5zbGF0aW9uLnkpO1xyXG4gICAgICAgIGNyb3NzTGluZUdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XHJcbiAgICAgICAgYXhpc0dyb3VwLmRhdHVtID0gdGhpcy5nZXRBeGlzVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgZ3JpZEdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XHJcbiAgICAgICAgZ3JpZExpbmVHcm91cFNlbGVjdGlvbi5lYWNoKChsaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIGxpbmUueDEgPSBncmlkUGFkZGluZztcclxuICAgICAgICAgICAgbGluZS54MiA9IC1zaWRlRmxhZyAqIGdyaWRMZW5ndGggKyBncmlkUGFkZGluZztcclxuICAgICAgICAgICAgbGluZS55ID0gMDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcyhfcHJpbWFyeVRpY2tDb3VudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQUcgQ2hhcnRzIC0gdW5leHBlY3RlZCBjYWxsIHRvIHVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcygpIC0gY2hlY2sgYXhlcyBjb25maWd1cmF0aW9uLicpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2VsZWN0aW9ucyhsaW5lRGF0YSwgZGF0YSwgcGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5saW5lTm9kZS5kYXR1bSA9IGxpbmVEYXRhO1xyXG4gICAgICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi51cGRhdGUodGhpcy5ncmlkTGVuZ3RoID8gZGF0YSA6IFtdLCAoZ3JvdXApID0+IGdyb3VwLmFwcGVuZChuZXcgTGluZSh7IHRhZzogVGFncy5HcmlkTGluZSB9KSksIChkYXR1bSkgPT4gZGF0dW0udGlja0lkKTtcclxuICAgICAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKGRhdGEsIChncm91cCkgPT4gZ3JvdXAuYXBwZW5kQ2hpbGQobmV3IExpbmUoeyB0YWc6IFRhZ3MuVGlja0xpbmUgfSkpLCAoZGF0dW0pID0+IGRhdHVtLnRpY2tJZCk7XHJcbiAgICAgICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi51cGRhdGUoZGF0YS5tYXAoKGQpID0+IHRoaXMuZ2V0VGlja0xhYmVsUHJvcHMoZCwgcGFyYW1zKSksIChncm91cCkgPT4gZ3JvdXAuYXBwZW5kQ2hpbGQobmV3IFRleHQoeyB0YWc6IFRhZ3MuVGlja0xhYmVsIH0pKSwgKGRhdHVtKSA9PiBkYXR1bS50aWNrSWQpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQXhpc0xpbmUoKSB7XHJcbiAgICAgICAgY29uc3QgeyBsaW5lIH0gPSB0aGlzO1xyXG4gICAgICAgIC8vIFdpdGhvdXQgdGhpcyB0aGUgbGF5b3V0IGlzbid0IGNvbnNpc3RlbnQgd2hlbiBlbmFibGluZy9kaXNhYmxpbmcgdGhlIGxpbmUsIHBhZGRpbmcgY29uZmlndXJhdGlvbnMgYXJlIG5vdCByZXNwZWN0ZWQuXHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBsaW5lLmVuYWJsZWQgPyBsaW5lLndpZHRoIDogMDtcclxuICAgICAgICB0aGlzLmxpbmVOb2RlLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBzdHJva2U6IGxpbmUuY29sb3IsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlR3JpZExpbmVzKHNpZGVGbGFnKSB7XHJcbiAgICAgICAgY29uc3QgeyBncmlkTGluZTogeyBzdHlsZSwgd2lkdGggfSwgZ3JpZFBhZGRpbmcsIGdyaWRMZW5ndGgsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmIChncmlkTGVuZ3RoID09PSAwIHx8IHN0eWxlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi5lYWNoKChsaW5lLCBfLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHN0cm9rZSwgbGluZURhc2ggfSA9IHN0eWxlW2luZGV4ICUgc3R5bGUubGVuZ3RoXTtcclxuICAgICAgICAgICAgbGluZS5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHgxOiBncmlkUGFkZGluZyxcclxuICAgICAgICAgICAgICAgIHgyOiAtc2lkZUZsYWcgKiBncmlkTGVuZ3RoICsgZ3JpZFBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgbGluZURhc2gsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTGFiZWxzKCkge1xyXG4gICAgICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFsYWJlbC5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXBwbHkgbGFiZWwgb3B0aW9uIHZhbHVlc1xyXG4gICAgICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGRhdHVtLCBbXHJcbiAgICAgICAgICAgICAgICAnZmlsbCcsXHJcbiAgICAgICAgICAgICAgICAnZm9udEZhbWlseScsXHJcbiAgICAgICAgICAgICAgICAnZm9udFNpemUnLFxyXG4gICAgICAgICAgICAgICAgJ2ZvbnRTdHlsZScsXHJcbiAgICAgICAgICAgICAgICAnZm9udFdlaWdodCcsXHJcbiAgICAgICAgICAgICAgICAndGV4dCcsXHJcbiAgICAgICAgICAgICAgICAndGV4dEFsaWduJyxcclxuICAgICAgICAgICAgICAgICd0ZXh0QmFzZWxpbmUnLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHdyYXBMYWJlbHModGlja0RhdGEsIGluZGV4LCBsYWJlbFByb3BzKSB7XHJcbiAgICAgICAgY29uc3QgeyBwYXJhbGxlbCwgbWF4V2lkdGgsIG1heEhlaWdodCB9ID0gdGhpcy5sYWJlbDtcclxuICAgICAgICBsZXQgZGVmYXVsdE1heFdpZHRoID0gdGhpcy5tYXhUaGlja25lc3M7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRNYXhIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuY2FsY3VsYXRlQXZhaWxhYmxlUmFuZ2UoKSAvIHRpY2tEYXRhLmxhYmVsQ291bnQpO1xyXG4gICAgICAgIGlmIChwYXJhbGxlbCkge1xyXG4gICAgICAgICAgICBbZGVmYXVsdE1heFdpZHRoLCBkZWZhdWx0TWF4SGVpZ2h0XSA9IFtkZWZhdWx0TWF4SGVpZ2h0LCBkZWZhdWx0TWF4V2lkdGhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aWNrRGF0YS50aWNrcy5mb3JFYWNoKCh0aWNrRGF0dW0pID0+IHtcclxuICAgICAgICAgICAgdGlja0RhdHVtLnRpY2tMYWJlbCA9IFRleHQud3JhcCh0aWNrRGF0dW0udGlja0xhYmVsLCBtYXhXaWR0aCAhPT0gbnVsbCAmJiBtYXhXaWR0aCAhPT0gdm9pZCAwID8gbWF4V2lkdGggOiBkZWZhdWx0TWF4V2lkdGgsIG1heEhlaWdodCAhPT0gbnVsbCAmJiBtYXhIZWlnaHQgIT09IHZvaWQgMCA/IG1heEhlaWdodCA6IGRlZmF1bHRNYXhIZWlnaHQsIGxhYmVsUHJvcHMsICdoeXBoZW5hdGUnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4geyB0aWNrRGF0YSwgaW5kZXgsIGF1dG9Sb3RhdGlvbjogMCwgdGVybWluYXRlOiB0cnVlIH07XHJcbiAgICB9XHJcbiAgICB1cGRhdGVUaXRsZShwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCB7IHJvdGF0aW9uLCB0aXRsZSwgX3RpdGxlQ2FwdGlvbiwgbGluZU5vZGUsIHRpY2tMaW5lR3JvdXAsIHRpY2tMYWJlbEdyb3VwIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGl0bGUpIHtcclxuICAgICAgICAgICAgX3RpdGxlQ2FwdGlvbi5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRpY2tTcGFjZSA9IDA7XHJcbiAgICAgICAgY29uc3QgeyBhbnlUaWNrVmlzaWJsZSB9ID0gcGFyYW1zO1xyXG4gICAgICAgIGlmICh0aXRsZS5lbmFibGVkICYmIGFueVRpY2tWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpY2tCQm94ID0gR3JvdXAuY29tcHV0ZUJCb3goW3RpY2tMaW5lR3JvdXAsIHRpY2tMYWJlbEdyb3VwLCBsaW5lTm9kZV0pO1xyXG4gICAgICAgICAgICBjb25zdCB0aWNrV2lkdGggPSByb3RhdGlvbiA9PT0gMCA/IHRpY2tCQm94LndpZHRoIDogdGlja0JCb3guaGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGlja1dpZHRoKSA8IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aWNrU3BhY2UgKz0gdGlja1dpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0VGl0bGVQcm9wcyhfdGl0bGVDYXB0aW9uLCB7IHRpY2tTcGFjZSB9KTtcclxuICAgIH1cclxuICAgIC8vIEZvciBmb3JtYXR0aW5nIChuaWNlIHJvdW5kZWQpIHRpY2sgdmFsdWVzLlxyXG4gICAgZm9ybWF0VGljayhkYXR1bSwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHsgbGFiZWwsIGxhYmVsRm9ybWF0dGVyLCBmcmFjdGlvbkRpZ2l0cywgbW9kdWxlQ3R4OiB7IGNhbGxiYWNrQ2FjaGUgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGxhYmVsLmZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZyYWN0aW9uRGlnaXRzID4gMCA/IGRhdHVtIDogU3RyaW5nKGRhdHVtKTtcclxuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuZm9ybWF0dGVyLCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgZnJhY3Rpb25EaWdpdHMsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGxhYmVsRm9ybWF0dGVyLFxyXG4gICAgICAgICAgICB9KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYWJlbEZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKF9iID0gY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsRm9ybWF0dGVyLCBkYXR1bSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFN0cmluZyhkYXR1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBheGlzIGlzIHVzaW5nIGEgbG9nU2NhbGUgb3IgdGhlYGRhdHVtYCBpcyBhbiBpbnRlZ2VyLCBhIHN0cmluZyBvciBhbiBvYmplY3RcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGRhdHVtKTtcclxuICAgIH1cclxuICAgIC8vIEZvciBmb3JtYXR0aW5nIGFyYml0cmFyeSB2YWx1ZXMgYmV0d2VlbiB0aGUgdGlja3MuXHJcbiAgICBmb3JtYXREYXR1bShkYXR1bSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoZGF0dW0pO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZUJCb3goKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpc0dyb3VwLmNvbXB1dGVCQm94KCk7XHJcbiAgICB9XHJcbiAgICBpbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkge1xyXG4gICAgICAgIGNyb3NzTGluZS5zY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgY3Jvc3NMaW5lLmdyaWRMZW5ndGggPSB0aGlzLmdyaWRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpc0FueVNlcmllc0FjdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZFNlcmllcy5zb21lKChzKSA9PiB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zIHx8IHMuaXNFbmFibGVkKCkpO1xyXG4gICAgfVxyXG4gICAgY2xpcFRpY2tMaW5lcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy50aWNrTGluZUdyb3VwLnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XHJcbiAgICB9XHJcbiAgICBjbGlwR3JpZCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5ncmlkR3JvdXAuc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZVBhZGRpbmcobWluLCBfbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIFtNYXRoLmFicyhtaW4gKiAwLjAxKSwgTWF0aC5hYnMobWluICogMC4wMSldO1xyXG4gICAgfVxyXG4gICAgZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU2VyaWVzID0gdGhpcy5ib3VuZFNlcmllcy5yZWR1Y2UoKGFjYywgbmV4dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gbmV4dC5nZXRLZXlzKHRoaXMuZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBuZXh0LmdldE5hbWVzKHRoaXMuZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwga2V5cy5sZW5ndGg7IGlkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGtleToga2V5c1tpZHhdLCBuYW1lOiBuYW1lc1tpZHhdIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIGJvdW5kU2VyaWVzLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IChfYSA9IHRoaXMudGl0bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXh0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcclxuICAgICAgICByZXR1cm4geyBkb21haW46IGQsIGNsaXBwZWQ6IGZhbHNlIH07XHJcbiAgICB9XHJcbiAgICBnZXRMYXlvdXRTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHJlY3Q6IHRoaXMuY29tcHV0ZUJCb3goKSwgZ3JpZFBhZGRpbmc6IHRoaXMuZ3JpZFBhZGRpbmcsIHNlcmllc0FyZWFQYWRkaW5nOiB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLCB0aWNrU2l6ZTogdGhpcy50aWNrLnNpemUgfSwgdGhpcy5sYXlvdXQpO1xyXG4gICAgfVxyXG4gICAgZ2V0TW9kdWxlTWFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcDtcclxuICAgIH1cclxuICAgIGNyZWF0ZU1vZHVsZUNvbnRleHQoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuYXhpc0NvbnRleHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLmF4aXNDb250ZXh0ID0gdGhpcy5jcmVhdGVBeGlzQ29udGV4dCgpKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1vZHVsZUN0eCksIHsgcGFyZW50OiB0aGlzLmF4aXNDb250ZXh0IH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQXhpc0NvbnRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXhpc0lkOiB0aGlzLmlkLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICBjb250aW51b3VzOiBDb250aW51b3VzU2NhbGUuaXModGhpcy5zY2FsZSksXHJcbiAgICAgICAgICAgIGtleXM6ICgpID0+IHRoaXMuYm91bmRTZXJpZXMuZmxhdE1hcCgocykgPT4gcy5nZXRLZXlzKHRoaXMuZGlyZWN0aW9uKSksXHJcbiAgICAgICAgICAgIHNjYWxlVmFsdWVGb3JtYXR0ZXI6IChzcGVjaWZpZXIpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuc2NhbGUpLnRpY2tGb3JtYXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7IHNwZWNpZmllciB9KTsgfSxcclxuICAgICAgICAgICAgc2NhbGVCYW5kd2lkdGg6ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5zY2FsZS5iYW5kd2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7IH0sXHJcbiAgICAgICAgICAgIHNjYWxlQ29udmVydDogKHZhbCkgPT4gdGhpcy5zY2FsZS5jb252ZXJ0KHZhbCksXHJcbiAgICAgICAgICAgIHNjYWxlSW52ZXJ0OiAodmFsKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnNjYWxlKS5pbnZlcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB2YWwpOyB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhbmltYXRlUmVhZHlVcGRhdGUoZGlmZikge1xyXG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5tb2R1bGVDdHg7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ3R4ID0gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IGZucyA9IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zKHNlbGVjdGlvbkN0eCk7XHJcbiAgICAgICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsICdheGlzLWdyb3VwJywgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuYXhpc0dyb3VwXSwgZm5zLmdyb3VwKTtcclxuICAgICAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgJ2xpbmUnLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5saW5lTm9kZV0sIGZucy5saW5lKTtcclxuICAgICAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgJ2xpbmUtcGF0aHMnLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLCB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb25dLCBmbnMudGljaywgKF8sIGQpID0+IGQudGlja0lkLCBkaWZmKTtcclxuICAgICAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgJ3RpY2stbGFiZWxzJywgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb25dLCBmbnMubGFiZWwsIChfLCBkKSA9PiBkLnRpY2tJZCwgZGlmZik7XHJcbiAgICB9XHJcbiAgICByZXNldFNlbGVjdGlvbk5vZGVzKCkge1xyXG4gICAgICAgIGNvbnN0IHsgZ3JpZExpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xpbmVHcm91cFNlbGVjdGlvbiwgdGlja0xhYmVsR3JvdXBTZWxlY3Rpb24sIGxpbmVOb2RlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkN0eCA9IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCh0aGlzKTtcclxuICAgICAgICByZXNldE1vdGlvbihbdGhpcy5heGlzR3JvdXBdLCByZXNldEF4aXNHcm91cEZuKCkpO1xyXG4gICAgICAgIHJlc2V0TW90aW9uKFtncmlkTGluZUdyb3VwU2VsZWN0aW9uLCB0aWNrTGluZUdyb3VwU2VsZWN0aW9uXSwgcmVzZXRBeGlzU2VsZWN0aW9uRm4oc2VsZWN0aW9uQ3R4KSk7XHJcbiAgICAgICAgcmVzZXRNb3Rpb24oW3RpY2tMYWJlbEdyb3VwU2VsZWN0aW9uXSwgcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbigpKTtcclxuICAgICAgICByZXNldE1vdGlvbihbbGluZU5vZGVdLCByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm4oKSk7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVVcGRhdGVEaWZmKHByZXZpb3VzLCB0aWNrRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGFkZGVkID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgdGlja0NvdW50ID0gTWF0aC5tYXgocHJldmlvdXMubGVuZ3RoLCB0aWNrRGF0YS50aWNrcy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdGlja0RhdHVtID0gdGlja0RhdGEudGlja3NbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBwcmV2aW91c1tpXTtcclxuICAgICAgICAgICAgY29uc3QgdGljayA9IHRpY2tEYXR1bSA9PT0gbnVsbCB8fCB0aWNrRGF0dW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpY2tEYXR1bS50aWNrSWQ7XHJcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSB0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVtb3ZlZC5oYXModGljaykpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWQuZGVsZXRlKHRpY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpY2spIHtcclxuICAgICAgICAgICAgICAgIGFkZGVkLmFkZCh0aWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWRkZWQuaGFzKHByZXYpKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRlZC5kZWxldGUocHJldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocHJldikge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5hZGQocHJldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2hhbmdlZDogYWRkZWQuc2l6ZSA+IDAgfHwgcmVtb3ZlZC5zaXplID4gMCxcclxuICAgICAgICAgICAgYWRkZWQ6IFsuLi5hZGRlZC52YWx1ZXMoKV0sXHJcbiAgICAgICAgICAgIHJlbW92ZWQ6IFsuLi5yZW1vdmVkLnZhbHVlcygpXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbkF4aXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nID0gNTA7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQk9PTEVBTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuXSwgQXhpcy5wcm90b3R5cGUsIFwibmljZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFNUUklOR19BUlJBWSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIEF4aXMucHJvdG90eXBlLCBcImtleXNcIiwgdm9pZCAwKTtcblxuY2xhc3MgQ2FydGVzaWFuQXhpc0xhYmVsIGV4dGVuZHMgQXhpc0xhYmVsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm90YXRpb24gYW5nbGUgdG8gdXNlIHdoZW4gYXV0b1JvdGF0ZSBpcyBhcHBsaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXV0b1JvdGF0ZUFuZ2xlID0gMzM1O1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0JPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbl0sIENhcnRlc2lhbkF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXV0b1JvdGF0ZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKC0zNjAsIDM2MCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQ2FydGVzaWFuQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJhdXRvUm90YXRlQW5nbGVcIiwgdm9pZCAwKTtcblxuY2xhc3MgQ2FydGVzaWFuQXhpcyBleHRlbmRzIEF4aXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdsZWZ0JztcclxuICAgIH1cclxuICAgIGdldCBkaXJlY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKHRoaXMucG9zaXRpb24pID8gQ2hhcnRBeGlzRGlyZWN0aW9uLlggOiBDaGFydEF4aXNEaXJlY3Rpb24uWTtcclxuICAgIH1cclxuICAgIHVwZGF0ZURpcmVjdGlvbigpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAtOTA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAtOTA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbC5taXJyb3JlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbC5wYXJhbGxlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF4aXNDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpc0NvbnRleHQucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmF4aXNDb250ZXh0LmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZShwcmltYXJ5VGlja0NvdW50KSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIudXBkYXRlKHByaW1hcnlUaWNrQ291bnQpO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlTGF5b3V0KHByaW1hcnlUaWNrQ291bnQpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBzdXBlci5jYWxjdWxhdGVMYXlvdXQocHJpbWFyeVRpY2tDb3VudCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVBeGlzQ29udGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdXBlci5jcmVhdGVBeGlzQ29udGV4dCgpKSwgeyBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbiB9KTtcclxuICAgIH1cclxuICAgIGFzc2lnbkNyb3NzTGluZUFycmF5Q29uc3RydWN0b3IoY3Jvc3NMaW5lcykge1xyXG4gICAgICAgIGFzc2lnbkpzb25BcHBseUNvbnN0cnVjdGVkQXJyYXkoY3Jvc3NMaW5lcywgQ2FydGVzaWFuQ3Jvc3NMaW5lKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUxhYmVsKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuQXhpc0xhYmVsKCk7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBDYXJ0ZXNpYW5BeGlzLnByb3RvdHlwZSwgXCJ0aGlja25lc3NcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShQT1NJVElPTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBDYXJ0ZXNpYW5BeGlzLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuXG5jbGFzcyBDYXRlZ29yeUF4aXMgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcclxuICAgIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xyXG4gICAgICAgIHN1cGVyKG1vZHVsZUN0eCwgbmV3IEJhbmRTY2FsZSgpKTtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nT3ZlcnJpZGVFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ncm91cFBhZGRpbmdJbm5lciA9IDAuMTtcclxuICAgICAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldCBwYWRkaW5nSW5uZXIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nT3ZlcnJpZGVFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNjYWxlLnBhZGRpbmdJbm5lciA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhZGRpbmdJbm5lcigpIHtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nT3ZlcnJpZGVFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS5wYWRkaW5nSW5uZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgcGFkZGluZ091dGVyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zY2FsZS5wYWRkaW5nT3V0ZXIgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBwYWRkaW5nT3V0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUucGFkZGluZ091dGVyO1xyXG4gICAgfVxyXG4gICAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gW107XHJcbiAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHYgaW5zdGFuY2VvZiBEYXRlID8gdi5nZXRUaW1lKCkgOiB2O1xyXG4gICAgICAgICAgICBpZiAoIXVuaXF1ZVZhbHVlcy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdW5pcXVlVmFsdWVzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgdW5pcXVlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2godik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgZG9tYWluLCBjbGlwcGVkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlRG9tYWluKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcGFkZGluZ092ZXJyaWRlRW5hYmxlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBwYWRkaW5ncyA9IHRoaXMuYm91bmRTZXJpZXMubWFwKChzKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHMuZ2V0QmFuZFNjYWxlUGFkZGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocyk7IH0pLmZpbHRlcigocCkgPT4gcCAhPSBudWxsKTtcclxuICAgICAgICAgICAgaWYgKHBhZGRpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUucGFkZGluZ0lubmVyID0gTWF0aC5taW4oLi4ucGFkZGluZ3MubWFwKChwKSA9PiBwLmlubmVyKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnBhZGRpbmdPdXRlciA9IE1hdGgubWF4KC4uLnBhZGRpbmdzLm1hcCgocCkgPT4gcC5vdXRlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5jYWxjdWxhdGVEb21haW4oKTtcclxuICAgIH1cclxufVxyXG5DYXRlZ29yeUF4aXMuY2xhc3NOYW1lID0gJ0NhdGVnb3J5QXhpcyc7XHJcbkNhdGVnb3J5QXhpcy50eXBlID0gJ2NhdGVnb3J5JztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBDYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcImdyb3VwUGFkZGluZ0lubmVyXCIsIHZvaWQgMCk7XG5cbi8qKlxyXG4gKiBUaGUgdHJlZSBsYXlvdXQgaXMgY2FsY3VsYXRlZCBpbiBhYnN0cmFjdCB4L3kgY29vcmRpbmF0ZXMsIHdoZXJlIHRoZSByb290IGlzIGF0ICgwLCAwKVxyXG4gKiBhbmQgdGhlIHRyZWUgZ3Jvd3MgZG93bndhcmQgZnJvbSB0aGUgcm9vdC5cclxuICovXHJcbmNsYXNzIFRyZWVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGxhYmVsID0gJycsIHBhcmVudCwgbnVtYmVyID0gMCkge1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB0aGlzLnN1YnRyZWVMZWZ0ID0gTmFOO1xyXG4gICAgICAgIHRoaXMuc3VidHJlZVJpZ2h0ID0gTmFOO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuWCA9IDA7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5ZID0gMDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgdGhpcy5sZWFmQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMucHJlbGltID0gMDtcclxuICAgICAgICB0aGlzLm1vZCA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmNlc3RvciA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2UgPSAwO1xyXG4gICAgICAgIHRoaXMuc2hpZnQgPSAwO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuICAgICAgICAvLyBzY3JlZW5YIGFuZCBzY3JlZW5ZIGFyZSBtZWFudCB0byBiZSByZWNvbXB1dGVkIGZyb20gKGxheW91dCkgeCBhbmQgeVxyXG4gICAgICAgIC8vIHdoZW4gdGhlIHRyZWUgaXMgcmVzaXplZCAod2l0aG91dCBwZXJmb3JtaW5nIGFub3RoZXIgbGF5b3V0KVxyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcclxuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcclxuICAgIH1cclxuICAgIGdldExlZnRTaWJsaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlciA+IDAgJiYgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jaGlsZHJlblt0aGlzLm51bWJlciAtIDFdIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0TGVmdG1vc3RTaWJsaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlciA+IDAgJiYgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jaGlsZHJlblswXSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIHRyYXZlcnNlIHRoZSBsZWZ0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlLCByZXR1cm4gdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91clxyXG4gICAgbmV4dExlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuWzBdIDogdGhpcy50aHJlYWQ7XHJcbiAgICB9XHJcbiAgICAvLyB0cmF2ZXJzZSB0aGUgcmlnaHQgY29udG91ciBvZiBhIHN1YnRyZWUsIHJldHVybiB0aGUgc3VjY2Vzc29yIG9mIHYgb24gdGhpcyBjb250b3VyXHJcbiAgICBuZXh0UmlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB0aGlzLnRocmVhZDtcclxuICAgIH1cclxuICAgIGdldFNpYmxpbmdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNoaWxkcmVuLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gdGhpcy5udW1iZXIpIDogW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHRpY2tzLCB3aGVyZSBlYWNoIHRpY2sgaGFzIGFuIGFycmF5IG9mIGxhYmVscywgdG8gYSBsYWJlbCB0cmVlLlxyXG4gKiBJZiBgcGFkYCBpcyBgdHJ1ZWAsIHdpbGwgZW5zdXJlIHRoYXQgZXZlcnkgYnJhbmNoIG1hdGNoZXMgdGhlIGRlcHRoIG9mIHRoZSB0cmVlIGJ5XHJcbiAqIGNyZWF0aW5nIGVtcHR5IGxhYmVscy5cclxuICovXHJcbmZ1bmN0aW9uIHRpY2tzVG9UcmVlKHRpY2tzLCBwYWQgPSB0cnVlKSB7XHJcbiAgICBjb25zdCByb290ID0gbmV3IFRyZWVOb2RlKCk7XHJcbiAgICBsZXQgZGVwdGggPSAwO1xyXG4gICAgaWYgKHBhZCkge1xyXG4gICAgICAgIHRpY2tzLmZvckVhY2goKHRpY2spID0+IChkZXB0aCA9IE1hdGgubWF4KGRlcHRoLCB0aWNrLmxhYmVscy5sZW5ndGgpKSk7XHJcbiAgICB9XHJcbiAgICB0aWNrcy5mb3JFYWNoKCh0aWNrKSA9PiB7XHJcbiAgICAgICAgaWYgKHBhZCkge1xyXG4gICAgICAgICAgICB3aGlsZSAodGljay5sYWJlbHMubGVuZ3RoIDwgZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIHRpY2subGFiZWxzLnVuc2hpZnQoJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydFRpY2socm9vdCwgdGljayk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByb290O1xyXG59XHJcbmZ1bmN0aW9uIGluc2VydFRpY2socm9vdCwgdGljaykge1xyXG4gICAgY29uc3QgcGF0aFBhcnRzID0gdGljay5sYWJlbHMuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIHBhdGggZWxlbWVudHMgZnJvbSByb290IHRvIGxlYWYgbGFiZWxcclxuICAgIGNvbnN0IGxhc3RQYXJ0SW5kZXggPSBwYXRoUGFydHMubGVuZ3RoIC0gMTtcclxuICAgIHBhdGhQYXJ0cy5mb3JFYWNoKChwYXRoUGFydCwgcGFydEluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSByb290LmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTm9kZSA9IGNoaWxkcmVuLmZpbmQoKGNoaWxkKSA9PiBjaGlsZC5sYWJlbCA9PT0gcGF0aFBhcnQpO1xyXG4gICAgICAgIGNvbnN0IGlzTm90TGVhZiA9IHBhcnRJbmRleCAhPT0gbGFzdFBhcnRJbmRleDtcclxuICAgICAgICBpZiAoZXhpc3RpbmdOb2RlICYmIGlzTm90TGVhZikge1xyXG4gICAgICAgICAgICAvLyB0aGUgaXNOb3RMZWFmIGNoZWNrIGlzIHRvIGFsbG93IGR1cGxpY2F0ZSBsZWFmc1xyXG4gICAgICAgICAgICByb290ID0gZXhpc3RpbmdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcmVlTm9kZShwYXRoUGFydCwgcm9vdCk7XHJcbiAgICAgICAgICAgIG5vZGUubnVtYmVyID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaXNOb3RMZWFmKSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8vIFNoaWZ0IHRoZSBzdWJ0cmVlLlxyXG5mdW5jdGlvbiBtb3ZlU3VidHJlZSh3bSwgd3AsIHNoaWZ0KSB7XHJcbiAgICBjb25zdCBzdWJ0cmVlcyA9IHdwLm51bWJlciAtIHdtLm51bWJlcjtcclxuICAgIGNvbnN0IHJhdGlvID0gc2hpZnQgLyBzdWJ0cmVlcztcclxuICAgIHdwLmNoYW5nZSAtPSByYXRpbztcclxuICAgIHdwLnNoaWZ0ICs9IHNoaWZ0O1xyXG4gICAgd20uY2hhbmdlICs9IHJhdGlvO1xyXG4gICAgd3AucHJlbGltICs9IHNoaWZ0O1xyXG4gICAgd3AubW9kICs9IHNoaWZ0O1xyXG59XHJcbmZ1bmN0aW9uIGFuY2VzdG9yKHZpbSwgdiwgZGVmYXVsdEFuY2VzdG9yKSB7XHJcbiAgICByZXR1cm4gdi5nZXRTaWJsaW5ncygpLmluZGV4T2YodmltLmFuY2VzdG9yKSA+PSAwID8gdmltLmFuY2VzdG9yIDogZGVmYXVsdEFuY2VzdG9yO1xyXG59XHJcbi8vIFNwYWNlcyBvdXQgdGhlIGNoaWxkcmVuLlxyXG5mdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcclxuICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIGxldCBzaGlmdCA9IDA7XHJcbiAgICAgICAgbGV0IGNoYW5nZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgdy5wcmVsaW0gKz0gc2hpZnQ7XHJcbiAgICAgICAgICAgIHcubW9kICs9IHNoaWZ0O1xyXG4gICAgICAgICAgICBjaGFuZ2UgKz0gdy5jaGFuZ2U7XHJcbiAgICAgICAgICAgIHNoaWZ0ICs9IHcuc2hpZnQgKyBjaGFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIE1vdmVzIGN1cnJlbnQgc3VidHJlZSB3aXRoIHYgYXMgdGhlIHJvb3QgaWYgc29tZSBub2RlcyBhcmUgY29uZmxpY3RpbmcgaW4gc3BhY2UuXHJcbmZ1bmN0aW9uIGFwcG9ydGlvbih2LCBkZWZhdWx0QW5jZXN0b3IsIGRpc3RhbmNlKSB7XHJcbiAgICBjb25zdCB3ID0gdi5nZXRMZWZ0U2libGluZygpO1xyXG4gICAgaWYgKHcpIHtcclxuICAgICAgICBsZXQgdm9wID0gdjtcclxuICAgICAgICBsZXQgdmlwID0gdjtcclxuICAgICAgICBsZXQgdmltID0gdztcclxuICAgICAgICBsZXQgdm9tID0gdmlwLmdldExlZnRtb3N0U2libGluZygpO1xyXG4gICAgICAgIGxldCBzaXAgPSB2aXAubW9kO1xyXG4gICAgICAgIGxldCBzb3AgPSB2b3AubW9kO1xyXG4gICAgICAgIGxldCBzaW0gPSB2aW0ubW9kO1xyXG4gICAgICAgIGxldCBzb20gPSB2b20ubW9kO1xyXG4gICAgICAgIHdoaWxlICh2aW0ubmV4dFJpZ2h0KCkgJiYgdmlwLm5leHRMZWZ0KCkpIHtcclxuICAgICAgICAgICAgdmltID0gdmltLm5leHRSaWdodCgpO1xyXG4gICAgICAgICAgICB2aXAgPSB2aXAubmV4dExlZnQoKTtcclxuICAgICAgICAgICAgdm9tID0gdm9tLm5leHRMZWZ0KCk7XHJcbiAgICAgICAgICAgIHZvcCA9IHZvcC5uZXh0UmlnaHQoKTtcclxuICAgICAgICAgICAgdm9wLmFuY2VzdG9yID0gdjtcclxuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSB2aW0ucHJlbGltICsgc2ltIC0gKHZpcC5wcmVsaW0gKyBzaXApICsgZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIGlmIChzaGlmdCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG1vdmVTdWJ0cmVlKGFuY2VzdG9yKHZpbSwgdiwgZGVmYXVsdEFuY2VzdG9yKSwgdiwgc2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgc2lwICs9IHNoaWZ0O1xyXG4gICAgICAgICAgICAgICAgc29wICs9IHNoaWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNpbSArPSB2aW0ubW9kO1xyXG4gICAgICAgICAgICBzaXAgKz0gdmlwLm1vZDtcclxuICAgICAgICAgICAgc29tICs9IHZvbS5tb2Q7XHJcbiAgICAgICAgICAgIHNvcCArPSB2b3AubW9kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmltLm5leHRSaWdodCgpICYmICF2b3AubmV4dFJpZ2h0KCkpIHtcclxuICAgICAgICAgICAgdm9wLnRocmVhZCA9IHZpbS5uZXh0UmlnaHQoKTtcclxuICAgICAgICAgICAgdm9wLm1vZCArPSBzaW0gLSBzb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmlwLm5leHRMZWZ0KCkgJiYgIXZvbS5uZXh0TGVmdCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2b20udGhyZWFkID0gdmlwLm5leHRMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB2b20ubW9kICs9IHNpcCAtIHNvbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0QW5jZXN0b3IgPSB2O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0QW5jZXN0b3I7XHJcbn1cclxuLy8gQ29tcHV0ZSB0aGUgcHJlbGltaW5hcnkgeC1jb29yZGluYXRlIG9mIG5vZGUgYW5kIGl0cyBjaGlsZHJlbiAocmVjdXJzaXZlbHkpLlxyXG5mdW5jdGlvbiBmaXJzdFdhbGsobm9kZSwgZGlzdGFuY2UpIHtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdEFuY2VzdG9yID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgZmlyc3RXYWxrKGNoaWxkLCBkaXN0YW5jZSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHRBbmNlc3RvciA9IGFwcG9ydGlvbihjaGlsZCwgZGVmYXVsdEFuY2VzdG9yLCBkaXN0YW5jZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXhlY3V0ZVNoaWZ0cyhub2RlKTtcclxuICAgICAgICBjb25zdCBtaWRwb2ludCA9IChjaGlsZHJlblswXS5wcmVsaW0gKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS5wcmVsaW0pIC8gMjtcclxuICAgICAgICBjb25zdCBsZWZ0U2libGluZyA9IG5vZGUuZ2V0TGVmdFNpYmxpbmcoKTtcclxuICAgICAgICBpZiAobGVmdFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgbm9kZS5wcmVsaW0gPSBsZWZ0U2libGluZy5wcmVsaW0gKyBkaXN0YW5jZTtcclxuICAgICAgICAgICAgbm9kZS5tb2QgPSBub2RlLnByZWxpbSAtIG1pZHBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5wcmVsaW0gPSBtaWRwb2ludDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBsZWZ0U2libGluZyA9IG5vZGUuZ2V0TGVmdFNpYmxpbmcoKTtcclxuICAgICAgICBub2RlLnByZWxpbSA9IGxlZnRTaWJsaW5nID8gbGVmdFNpYmxpbmcucHJlbGltICsgZGlzdGFuY2UgOiAwO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERpbWVuc2lvbnMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50b3AgPSBJbmZpbml0eTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gLUluZmluaXR5O1xyXG4gICAgICAgIHRoaXMuYm90dG9tID0gLUluZmluaXR5O1xyXG4gICAgICAgIHRoaXMubGVmdCA9IEluZmluaXR5O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKG5vZGUsIHh5KSB7XHJcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB4eShub2RlKTtcclxuICAgICAgICBpZiAoeCA+IHRoaXMucmlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4IDwgdGhpcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID4gdGhpcy5ib3R0b20pIHtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA8IHRoaXMudG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9wID0geTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2Vjb25kV2Fsayh2LCBtLCBsYXlvdXQpIHtcclxuICAgIHYueCA9IHYucHJlbGltICsgbTtcclxuICAgIHYueSA9IHYuZGVwdGg7XHJcbiAgICBsYXlvdXQudXBkYXRlKHYpO1xyXG4gICAgdi5jaGlsZHJlbi5mb3JFYWNoKCh3KSA9PiBzZWNvbmRXYWxrKHcsIG0gKyB2Lm1vZCwgbGF5b3V0KSk7XHJcbn1cclxuLy8gQWZ0ZXIgdGhlIHNlY29uZCB3YWxrIHRoZSBwYXJlbnQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgYXQgdGhlIGNlbnRlciBvZiB0aGVpciBpbW1lZGlhdGUgY2hpbGRyZW4uXHJcbi8vIElmIHdlIHdhbnQgdGhlIHBhcmVudCBub2RlcyB0byBiZSBwb3NpdGlvbmVkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHN1YnRyZWUgZm9yIHdoaWNoIHRoZXkgYXJlIHJvb3RzLFxyXG4vLyB3ZSBuZWVkIGEgdGhpcmQgd2FsayB0byBhZGp1c3QgdGhlIHBvc2l0aW9ucy5cclxuZnVuY3Rpb24gdGhpcmRXYWxrKHYpIHtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcclxuICAgIGxldCBsZWFmQ291bnQgPSAwO1xyXG4gICAgY2hpbGRyZW4uZm9yRWFjaCgodykgPT4ge1xyXG4gICAgICAgIHRoaXJkV2Fsayh3KTtcclxuICAgICAgICBpZiAody5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGVhZkNvdW50ICs9IHcubGVhZkNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVhZkNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2LmxlYWZDb3VudCA9IGxlYWZDb3VudDtcclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICB2LnN1YnRyZWVMZWZ0ID0gY2hpbGRyZW5bMF0uc3VidHJlZUxlZnQ7XHJcbiAgICAgICAgdi5zdWJ0cmVlUmlnaHQgPSBjaGlsZHJlblt2LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN1YnRyZWVSaWdodDtcclxuICAgICAgICB2LnggPSAodi5zdWJ0cmVlTGVmdCArIHYuc3VidHJlZVJpZ2h0KSAvIDI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2LnN1YnRyZWVMZWZ0ID0gdi54O1xyXG4gICAgICAgIHYuc3VidHJlZVJpZ2h0ID0gdi54O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyZWVMYXlvdXQocm9vdCkge1xyXG4gICAgY29uc3QgbGF5b3V0ID0gbmV3IFRyZWVMYXlvdXQoKTtcclxuICAgIGZpcnN0V2Fsayhyb290LCAxKTtcclxuICAgIHNlY29uZFdhbGsocm9vdCwgLXJvb3QucHJlbGltLCBsYXlvdXQpO1xyXG4gICAgdGhpcmRXYWxrKHJvb3QpO1xyXG4gICAgcmV0dXJuIGxheW91dDtcclxufVxyXG5jbGFzcyBUcmVlTGF5b3V0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgdGhpcy5sZWFmQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuICAgICAgICAvLyBPbmUgbWlnaHQgd2FudCB0byBwcm9jZXNzIGxlYWYgbm9kZXMgc2VwYXJhdGVseSBmcm9tIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxyXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBwb3NpdGlvbiBsYWJlbHMgY29ycmVzcG9uZGluZyB0byBsZWFmcyB2ZXJ0aWNhbGx5LCByYXRoZXIgdGhhbiBob3Jpem9udGFsbHkuXHJcbiAgICAgICAgdGhpcy5sZWFmTm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm5vbkxlYWZOb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKG5vZGUpIHtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbnMudXBkYXRlKG5vZGUsIChub2RlKSA9PiAoeyB4OiBub2RlLngsIHk6IG5vZGUueSB9KSk7XHJcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlYWZDb3VudCsrO1xyXG4gICAgICAgICAgICB0aGlzLmxlYWZOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ub25MZWFmTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuZGVwdGggPiB0aGlzLmRlcHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGggPSBub2RlLmRlcHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXNpemUod2lkdGgsIGhlaWdodCwgc2hpZnRYID0gMCwgc2hpZnRZID0gMCwgZmxpcFggPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHhTdGVwcyA9IHRoaXMubGVhZkNvdW50IC0gMTtcclxuICAgICAgICBjb25zdCB5U3RlcHMgPSB0aGlzLmRlcHRoO1xyXG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmRpbWVuc2lvbnM7XHJcbiAgICAgICAgbGV0IHNjYWxpbmdYID0gMTtcclxuICAgICAgICBsZXQgc2NhbGluZ1kgPSAxO1xyXG4gICAgICAgIGlmICh3aWR0aCA+IDAgJiYgeFN0ZXBzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3BhY2luZ1ggPSAoZGltZW5zaW9ucy5yaWdodCAtIGRpbWVuc2lvbnMubGVmdCkgLyB4U3RlcHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRTcGFjaW5nWCA9IHdpZHRoIC8geFN0ZXBzO1xyXG4gICAgICAgICAgICBzY2FsaW5nWCA9IGRlc2lyZWRTcGFjaW5nWCAvIGV4aXN0aW5nU3BhY2luZ1g7XHJcbiAgICAgICAgICAgIGlmIChmbGlwWCkge1xyXG4gICAgICAgICAgICAgICAgc2NhbGluZ1ggPSAtc2NhbGluZ1g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA+IDAgJiYgeVN0ZXBzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3BhY2luZ1kgPSAoZGltZW5zaW9ucy5ib3R0b20gLSBkaW1lbnNpb25zLnRvcCkgLyB5U3RlcHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRTcGFjaW5nWSA9IGhlaWdodCAvIHlTdGVwcztcclxuICAgICAgICAgICAgc2NhbGluZ1kgPSBkZXNpcmVkU3BhY2luZ1kgLyBleGlzdGluZ1NwYWNpbmdZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzY3JlZW5EaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMoKTtcclxuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgbm9kZS5zY3JlZW5YID0gbm9kZS54ICogc2NhbGluZ1g7XHJcbiAgICAgICAgICAgIG5vZGUuc2NyZWVuWSA9IG5vZGUueSAqIHNjYWxpbmdZO1xyXG4gICAgICAgICAgICBzY3JlZW5EaW1lbnNpb25zLnVwZGF0ZShub2RlLCAobm9kZSkgPT4gKHsgeDogbm9kZS5zY3JlZW5YLCB5OiBub2RlLnNjcmVlblkgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBzbyB0aGF0IHJvb3QgdG9wIGFuZCBsZWZ0bW9zdCBsZWFmIGxlZnQgc3RhcnQgYXQgemVyby5cclxuICAgICAgICBjb25zdCBvZmZzZXRYID0gLXNjcmVlbkRpbWVuc2lvbnMubGVmdDtcclxuICAgICAgICBjb25zdCBvZmZzZXRZID0gLXNjcmVlbkRpbWVuc2lvbnMudG9wO1xyXG4gICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBub2RlLnNjcmVlblggKz0gb2Zmc2V0WCArIHNoaWZ0WDtcclxuICAgICAgICAgICAgbm9kZS5zY3JlZW5ZICs9IG9mZnNldFkgKyBzaGlmdFk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgR3JvdXBlZENhdGVnb3J5QXhpc0xhYmVsIGV4dGVuZHMgQXhpc0xhYmVsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5ncmlkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBHcm91cGVkQ2F0ZWdvcnlBeGlzTGFiZWwucHJvdG90eXBlLCBcImdyaWRcIiwgdm9pZCAwKTtcclxuY2xhc3MgR3JvdXBlZENhdGVnb3J5QXhpcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xyXG4gICAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XHJcbiAgICAgICAgc3VwZXIobW9kdWxlQ3R4LCBuZXcgQmFuZFNjYWxlKCkpO1xyXG4gICAgICAgIC8vIExhYmVsIHNjYWxlIChsYWJlbHMgYXJlIHBvc2l0aW9uZWQgYmV0d2VlbiB0aWNrcywgdGljayBjb3VudCA9IGxhYmVsIGNvdW50ICsgMSkuXHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgY2FsbCBpcyBgbGFiZWxTY2FsZWAgZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgYXhlcy5cclxuICAgICAgICB0aGlzLnRpY2tTY2FsZSA9IG5ldyBCYW5kU2NhbGUoKTtcclxuICAgICAgICB0aGlzLmxpbmUgPSBuZXcgQXhpc0xpbmUoKTtcclxuICAgICAgICB0aGlzLmxhYmVsID0gbmV3IEdyb3VwZWRDYXRlZ29yeUF4aXNMYWJlbCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xvciBvZiB0aGUgbGFiZWxzLlxyXG4gICAgICAgICAqIFVzZSBgdW5kZWZpbmVkYCByYXRoZXIgdGhhbiBgcmdiYSgwLCAwLCAwLCAwKWAgdG8gbWFrZSBsYWJlbHMgaW52aXNpYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFiZWxDb2xvciA9ICdyZ2JhKDg3LCA4NywgODcsIDEpJztcclxuICAgICAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IHRpY2tMaW5lR3JvdXAsIHRpY2tMYWJlbEdyb3VwLCBncmlkTGluZUdyb3VwLCB0aWNrU2NhbGUsIHNjYWxlIH0gPSB0aGlzO1xyXG4gICAgICAgIHNjYWxlLnBhZGRpbmdPdXRlciA9IDAuMTtcclxuICAgICAgICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBzY2FsZS5wYWRkaW5nT3V0ZXIgKiAyO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSBzY2FsZS5yYW5nZS5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaFNjYWxlKCk7XHJcbiAgICAgICAgdGlja1NjYWxlLnBhZGRpbmdJbm5lciA9IDE7XHJcbiAgICAgICAgdGlja1NjYWxlLnBhZGRpbmdPdXRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5ncmlkTGluZVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoZ3JpZExpbmVHcm91cCwgTGluZSk7XHJcbiAgICAgICAgdGhpcy5heGlzTGluZVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGlja0xpbmVHcm91cCwgTGluZSk7XHJcbiAgICAgICAgdGhpcy5zZXBhcmF0b3JTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRpY2tMaW5lR3JvdXAsIExpbmUpO1xyXG4gICAgICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRpY2tMYWJlbEdyb3VwLCBUZXh0KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVJhbmdlKCkge1xyXG4gICAgICAgIGNvbnN0IHsgcmFuZ2U6IHJyLCB2aXNpYmxlUmFuZ2U6IHZyLCBzY2FsZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBzcGFuID0gKHJyWzFdIC0gcnJbMF0pIC8gKHZyWzFdIC0gdnJbMF0pO1xyXG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gc3BhbiAqIHZyWzBdO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcnJbMF0gLSBzaGlmdDtcclxuICAgICAgICB0aGlzLnRpY2tTY2FsZS5yYW5nZSA9IHNjYWxlLnJhbmdlID0gW3N0YXJ0LCBzdGFydCArIHNwYW5dO1xyXG4gICAgICAgIHRoaXMucmVzaXplVGlja1RyZWUoKTtcclxuICAgIH1cclxuICAgIHJlc2l6ZVRpY2tUcmVlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBzID0gdGhpcy5zY2FsZTtcclxuICAgICAgICBjb25zdCByYW5nZSA9IHMuZG9tYWluLmxlbmd0aCA/IFtzLmNvbnZlcnQocy5kb21haW5bMF0pLCBzLmNvbnZlcnQocy5kb21haW5bcy5kb21haW4ubGVuZ3RoIC0gMV0pXSA6IHMucmFuZ2U7XHJcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy50aWNrVHJlZUxheW91dDtcclxuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xyXG4gICAgICAgIGlmIChsYXlvdXQpIHtcclxuICAgICAgICAgICAgbGF5b3V0LnJlc2l6ZShNYXRoLmFicyhyYW5nZVsxXSAtIHJhbmdlWzBdKSwgbGF5b3V0LmRlcHRoICogbGluZUhlaWdodCwgKE1hdGgubWluKHJhbmdlWzBdLCByYW5nZVsxXSkgfHwgMCkgKyAoKF9hID0gcy5iYW5kd2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIC8gMiwgLWxheW91dC5kZXB0aCAqIGxpbmVIZWlnaHQsIHJhbmdlWzFdIC0gcmFuZ2VbMF0gPCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbGluZUhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5mb250U2l6ZSAqIDEuNTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxlbmd0aCBvZiB0aGUgZ3JpZC4gVGhlIGdyaWQgaXMgb25seSB2aXNpYmxlIGluIGNhc2Ugb2YgYSBub24temVybyB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgc2V0IGdyaWRMZW5ndGgodmFsdWUpIHtcclxuICAgICAgICAvLyBXYXMgdmlzaWJsZSBhbmQgbm93IGludmlzaWJsZSwgb3Igd2FzIGludmlzaWJsZSBhbmQgbm93IHZpc2libGUuXHJcbiAgICAgICAgaWYgKCh0aGlzLl9ncmlkTGVuZ3RoICYmICF2YWx1ZSkgfHwgKCF0aGlzLl9ncmlkTGVuZ3RoICYmIHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRMaW5lU2VsZWN0aW9uLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JpZExlbmd0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGdyaWRMZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyaWRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVEb21haW4oKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGRvbWFpbnMgPSBbXTtcclxuICAgICAgICBsZXQgaXNOdW1lcmljWDtcclxuICAgICAgICB0aGlzLmJvdW5kU2VyaWVzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHMpID0+IHMudmlzaWJsZSlcclxuICAgICAgICAgICAgLmZvckVhY2goKHNlcmllcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBDaGFydEF4aXNEaXJlY3Rpb24uWCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtZXJpY1ggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBhZGQgZmlyc3QgWCBkb21haW5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBzZXJpZXMuZ2V0RG9tYWluKGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWlucy5wdXNoKGRvbWFpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNOdW1lcmljWCA9IHR5cGVvZiBkb21haW5bMF0gPT09ICdudW1iZXInO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1lcmljWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIGZ1cnRoZXIgWCBkb21haW5zIGlmIHRoZSBheGlzIGlzIG51bWVyaWNcclxuICAgICAgICAgICAgICAgICAgICBkb21haW5zLnB1c2goc2VyaWVzLmdldERvbWFpbihkaXJlY3Rpb24pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbWFpbnMucHVzaChzZXJpZXMuZ2V0RG9tYWluKGRpcmVjdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZG9tYWluID0gbmV3IEFycmF5KCkuY29uY2F0KC4uLmRvbWFpbnMpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IChfYSA9IGV4dGVudChkb21haW4pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkb21haW47XHJcbiAgICAgICAgdGhpcy5kYXRhRG9tYWluID0gdGhpcy5ub3JtYWxpc2VEYXRhRG9tYWluKHZhbHVlcyk7XHJcbiAgICAgICAgdGhpcy5zY2FsZS5kb21haW4gPSB0aGlzLmRhdGFEb21haW4uZG9tYWluO1xyXG4gICAgfVxyXG4gICAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XHJcbiAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGUgY2F0ZWdvcmllcy5cclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkLmZpbHRlcigocywgaSwgYXJyKSA9PiBhcnIuaW5kZXhPZihzKSA9PT0gaSk7XHJcbiAgICAgICAgY29uc3QgdGlja1RyZWUgPSB0aWNrc1RvVHJlZSh2YWx1ZXMpO1xyXG4gICAgICAgIHRoaXMudGlja1RyZWVMYXlvdXQgPSB0cmVlTGF5b3V0KHRpY2tUcmVlKTtcclxuICAgICAgICBjb25zdCB0aWNrU2NhbGVEb21haW4gPSB2YWx1ZXMuc2xpY2UoKTtcclxuICAgICAgICB0aWNrU2NhbGVEb21haW4ucHVzaCgnJyk7XHJcbiAgICAgICAgdGhpcy50aWNrU2NhbGUuZG9tYWluID0gdGlja1NjYWxlRG9tYWluO1xyXG4gICAgICAgIHRoaXMucmVzaXplVGlja1RyZWUoKTtcclxuICAgICAgICByZXR1cm4geyBkb21haW46IHZhbHVlcywgY2xpcHBlZDogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcy9yZW1vdmVzL3VwZGF0ZXMgdGhlIHNjZW5lIGdyYXBoIG5vZGVzIHRoYXQgY29uc3RpdHV0ZSB0aGUgYXhpcy5cclxuICAgICAqIFN1cHBvc2VkIHRvIGJlIGNhbGxlZCBfbWFudWFsbHlfIGFmdGVyIGNoYW5naW5nIF9hbnlfIG9mIHRoZSBheGlzIHByb3BlcnRpZXMuXHJcbiAgICAgKiBUaGlzIGFsbG93cyB0byBidWxrIHNldCBheGlzIHByb3BlcnRpZXMgYmVmb3JlIHVwZGF0aW5nIHRoZSBub2Rlcy5cclxuICAgICAqIFRoZSBub2RlIGNoYW5nZXMgbWFkZSBieSB0aGlzIG1ldGhvZCBhcmUgcmVuZGVyZWQgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICogV2UgY291bGQgc2NoZWR1bGUgdGhpcyBtZXRob2QgY2FsbCBhdXRvbWF0aWNhbGx5IG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICogd2hlbiBhbnkgb2YgdGhlIGF4aXMgcHJvcGVydGllcyBjaGFuZ2UgKHRoZSB3YXkgd2UgZG8gd2hlbiBwcm9wZXJ0aWVzIG9mIHNjZW5lIGdyYXBoJ3NcclxuICAgICAqIG5vZGVzIGNoYW5nZSksIGJ1dCB0aGlzIHdpbGwgbWVhbiB0aGF0IHdlIGZpcnN0IHdhaXQgZm9yIHRoZSBuZXh0IGFuaW1hdGlvblxyXG4gICAgICogZnJhbWUgdG8gbWFrZSBjaGFuZ2VzIHRvIHRoZSBub2RlcyBvZiB0aGUgYXhpcywgdGhlbiB3YWl0IGZvciBhbm90aGVyIGFuaW1hdGlvblxyXG4gICAgICogZnJhbWUgdG8gcmVuZGVyIHRob3NlIGNoYW5nZXMuIEl0J3MgbmljZSB0byBoYXZlIGV2ZXJ5dGhpbmcgdXBkYXRlIGF1dG9tYXRpY2FsbHksXHJcbiAgICAgKiBidXQgdGhpcyBleHRyYSBsZXZlbCBvZiBhc3luYyBpbmRpcmVjdGlvbiB3aWxsIG5vdCBqdXN0IGludHJvZHVjZSBhbiB1bndhbnRlZCBkZWxheSxcclxuICAgICAqIGl0IHdpbGwgYWxzbyBtYWtlIGl0IGhhcmRlciB0byByZWFzb24gYWJvdXQgdGhlIHByb2dyYW0uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaXRsZUNhcHRpb24oKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhdGVnb3J5TGFiZWxzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTZXBhcmF0b3JzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBeGlzTGluZXMoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhdGVnb3J5R3JpZExpbmVzKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRpdGxlQ2FwdGlvbigpIHtcclxuICAgICAgICAvLyBUaGUgVGV4dCBgbm9kZWAgb2YgdGhlIENhcHRpb24gaXMgbm90IHVzZWQgdG8gcmVuZGVyIHRoZSB0aXRsZSBvZiB0aGUgZ3JvdXBlZCBjYXRlZ29yeSBheGlzLlxyXG4gICAgICAgIC8vIFRoZSBwaGFudG9tIHJvb3Qgb2YgdGhlIHRyZWUgbGF5b3V0IGlzIHVzZWQgaW5zdGVhZC5cclxuICAgICAgICBjb25zdCB7IF90aXRsZUNhcHRpb24gfSA9IHRoaXM7XHJcbiAgICAgICAgX3RpdGxlQ2FwdGlvbi5ub2RlLnZpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNhdGVnb3J5TGFiZWxzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHsgdGlja0xhYmVsTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xyXG4gICAgICAgIGNvbnN0IGxhYmVsU2VsZWN0aW9uID0gdGhpcy5sYWJlbFNlbGVjdGlvbi51cGRhdGUodGlja0xhYmVsTGF5b3V0KTtcclxuICAgICAgICBsYWJlbFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoZGF0dW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2VwYXJhdG9ycygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCB7IHNlcGFyYXRvckxheW91dCB9ID0gdGhpcy5jb21wdXRlZExheW91dDtcclxuICAgICAgICBjb25zdCB7IHJhbmdlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSAwLjAwMDAwMDE7XHJcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yU2VsZWN0aW9uID0gdGhpcy5zZXBhcmF0b3JTZWxlY3Rpb24udXBkYXRlKHNlcGFyYXRvckxheW91dCk7XHJcbiAgICAgICAgc2VwYXJhdG9yU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGxpbmUueDEgPSBkYXR1bS54MTtcclxuICAgICAgICAgICAgbGluZS54MiA9IGRhdHVtLngyO1xyXG4gICAgICAgICAgICBsaW5lLnkxID0gZGF0dW0ueTtcclxuICAgICAgICAgICAgbGluZS55MiA9IGRhdHVtLnk7XHJcbiAgICAgICAgICAgIGxpbmUudmlzaWJsZSA9IGRhdHVtLnkgPj0gcmFuZ2VbMF0gLSBlcHNpbG9uICYmIGRhdHVtLnkgPD0gcmFuZ2VbMV0gKyBlcHNpbG9uO1xyXG4gICAgICAgICAgICBsaW5lLnN0cm9rZSA9IHRoaXMudGljay5jb2xvcjtcclxuICAgICAgICAgICAgbGluZS5maWxsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gMTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUF4aXNMaW5lcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCB7IGF4aXNMaW5lTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xyXG4gICAgICAgIGNvbnN0IGF4aXNMaW5lU2VsZWN0aW9uID0gdGhpcy5heGlzTGluZVNlbGVjdGlvbi51cGRhdGUoYXhpc0xpbmVMYXlvdXQpO1xyXG4gICAgICAgIGF4aXNMaW5lU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGxpbmUuc2V0UHJvcGVydGllcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdHVtKSwgeyBzdHJva2U6IHRoaXMubGluZS5jb2xvciwgc3Ryb2tlV2lkdGg6IHRoaXMubGluZS53aWR0aCB9KSk7XHJcbiAgICAgICAgICAgIGxpbmUueDEgPSBkYXR1bS54O1xyXG4gICAgICAgICAgICBsaW5lLngyID0gZGF0dW0ueDtcclxuICAgICAgICAgICAgbGluZS55MSA9IGRhdHVtLnkxO1xyXG4gICAgICAgICAgICBsaW5lLnkyID0gZGF0dW0ueTI7XHJcbiAgICAgICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB0aGlzLmxpbmUud2lkdGg7XHJcbiAgICAgICAgICAgIGxpbmUuc3Ryb2tlID0gdGhpcy5saW5lLmNvbG9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2F0ZWdvcnlHcmlkTGluZXMoKSB7XHJcbiAgICAgICAgY29uc3QgeyBncmlkTGVuZ3RoLCBncmlkTGluZSwgbGFiZWwsIHJhbmdlLCB0aWNrU2NhbGUgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgdGlja3MgPSB0aWNrU2NhbGUudGlja3MoKTtcclxuICAgICAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XHJcbiAgICAgICAgY29uc3QgZ3JpZFNlbGVjdGlvbiA9IHRoaXMuZ3JpZExpbmVTZWxlY3Rpb24udXBkYXRlKGdyaWRMZW5ndGggPyB0aWNrcyA6IFtdKTtcclxuICAgICAgICBpZiAoZ3JpZExlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBzdHlsZSB9ID0gZ3JpZExpbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlQ291bnQgPSBzdHlsZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGdyaWRTZWxlY3Rpb24uZWFjaCgobGluZSwgZGF0dW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh0aWNrU2NhbGUuY29udmVydChkYXR1bSkpO1xyXG4gICAgICAgICAgICAgICAgbGluZS54MSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsaW5lLngyID0gLXNpZGVGbGFnICogZ3JpZExlbmd0aDtcclxuICAgICAgICAgICAgICAgIGxpbmUueTEgPSB5O1xyXG4gICAgICAgICAgICAgICAgbGluZS55MiA9IHk7XHJcbiAgICAgICAgICAgICAgICBsaW5lLnZpc2libGUgPSB5ID49IHJhbmdlWzBdICYmIHkgPD0gcmFuZ2VbMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0cm9rZSwgbGluZURhc2ggfSA9IHN0eWxlW2luZGV4ICUgc3R5bGVDb3VudF07XHJcbiAgICAgICAgICAgICAgICBsaW5lLnN0cm9rZSA9IHN0cm9rZTtcclxuICAgICAgICAgICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIGxpbmUubGluZURhc2ggPSBsaW5lRGFzaDtcclxuICAgICAgICAgICAgICAgIGxpbmUuZmlsbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcHV0ZUxheW91dCgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZSgpO1xyXG4gICAgICAgIGNvbnN0IHsgc2NhbGUsIGxhYmVsLCBsYWJlbDogeyBwYXJhbGxlbCB9LCBtb2R1bGVDdHg6IHsgY2FsbGJhY2tDYWNoZSB9LCByYW5nZSwgdGl0bGUsIHRpdGxlOiB7IGZvcm1hdHRlciA9IChwKSA9PiBwLmRlZmF1bHRWYWx1ZSB9ID0ge30sIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBzY2FsZS5yYW5nZVswXTtcclxuICAgICAgICBjb25zdCByYW5nZUVuZCA9IHNjYWxlLnJhbmdlWzFdO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlTGVuZ3RoID0gTWF0aC5hYnMocmFuZ2VFbmQgLSByYW5nZVN0YXJ0KTtcclxuICAgICAgICBjb25zdCBiYW5kd2lkdGggPSByYW5nZUxlbmd0aCAvIHNjYWxlLmRvbWFpbi5sZW5ndGggfHwgMDtcclxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3RhdGlvbikpIDwgMWUtODtcclxuICAgICAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XHJcbiAgICAgICAgLy8gVGhlIFRleHQgYG5vZGVgIG9mIHRoZSBDYXB0aW9uIGlzIG5vdCB1c2VkIHRvIHJlbmRlciB0aGUgdGl0bGUgb2YgdGhlIGdyb3VwZWQgY2F0ZWdvcnkgYXhpcy5cclxuICAgICAgICAvLyBUaGUgcGhhbnRvbSByb290IG9mIHRoZSB0cmVlIGxheW91dCBpcyB1c2VkIGluc3RlYWQuXHJcbiAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcclxuICAgICAgICAvLyBSZW5kZXIgdGlja3MgYW5kIGxhYmVscy5cclxuICAgICAgICBjb25zdCB0aWNrVHJlZUxheW91dCA9IHRoaXMudGlja1RyZWVMYXlvdXQ7XHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gc2NhbGUudGlja3MoKTtcclxuICAgICAgICBjb25zdCB0cmVlTGFiZWxzID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5ub2RlcyA6IFtdO1xyXG4gICAgICAgIGNvbnN0IGlzTGFiZWxUcmVlID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5kZXB0aCA+IDEgOiBmYWxzZTtcclxuICAgICAgICAvLyBXaGVuIGxhYmVscyBhcmUgcGFyYWxsZWwgdG8gdGhlIGF4aXMgbGluZSwgdGhlIGBwYXJhbGxlbEZsaXBGbGFnYCBpcyB1c2VkIHRvXHJcbiAgICAgICAgLy8gZmxpcCB0aGUgbGFiZWxzIHRvIGF2b2lkIHVwc2lkZS1kb3duIHRleHQsIHdoZW4gdGhlIGF4aXMgaXMgcm90YXRlZFxyXG4gICAgICAgIC8vIHN1Y2ggdGhhdCBpdCBpcyBpbiB0aGUgcmlnaHQgaGVtaXNwaGVyZSwgaS5lLiB0aGUgYW5nbGUgb2Ygcm90YXRpb25cclxuICAgICAgICAvLyBpcyBpbiB0aGUgWzAsIM+AXSBpbnRlcnZhbC5cclxuICAgICAgICAvLyBUaGUgcm90YXRpb24gYW5nbGUgaXMgbm9ybWFsaXplZCwgc28gdGhhdCB3ZSBoYXZlIGFuIGVhc2llciB0aW1lIGNoZWNraW5nXHJcbiAgICAgICAgLy8gaWYgaXQncyBpbiB0aGUgc2FpZCBpbnRlcnZhbC4gU2luY2UgdGhlIGF4aXMgaXMgYWx3YXlzIHJlbmRlcmVkIHZlcnRpY2FsbHlcclxuICAgICAgICAvLyBhbmQgdGhlbiByb3RhdGVkLCB6ZXJvIHJvdGF0aW9uIG1lYW5zIDEyIChub3QgMykgby1jbG9jay5cclxuICAgICAgICAvLyAtMSA9IGZsaXBcclxuICAgICAgICAvLyAgMSA9IGRvbid0IGZsaXAgKGRlZmF1bHQpXHJcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0Um90YXRpb24sIGNvbmZpZ3VyZWRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZyB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbC5yb3RhdGlvbixcclxuICAgICAgICAgICAgcGFyYWxsZWwsXHJcbiAgICAgICAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb246IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpLFxyXG4gICAgICAgICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbjogbm9ybWFsaXplQW5nbGUzNjAocm90YXRpb24pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHRpY2tMYWJlbExheW91dCA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNvcHlMYWJlbFByb3BzID0gKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IG5vZGUuZmlsbCxcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IG5vZGUuZm9udEZhbWlseSxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBub2RlLmZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiBub2RlLmZvbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IG5vZGUuZm9udFdlaWdodCxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBub2RlLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb25DZW50ZXJYOiBub2RlLnJvdGF0aW9uQ2VudGVyWCxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uQ2VudGVyWTogbm9kZS5yb3RhdGlvbkNlbnRlclksXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBub2RlLnRleHQsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IG5vZGUudGV4dEFsaWduLFxyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiBub2RlLnRleHRCYXNlbGluZSxcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uWDogbm9kZS50cmFuc2xhdGlvblgsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblk6IG5vZGUudHJhbnNsYXRpb25ZLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogbm9kZS52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgeDogbm9kZS54LFxyXG4gICAgICAgICAgICAgICAgeTogbm9kZS55LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbGFiZWxCQm94ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgbGV0IG1heExlYWZMYWJlbFdpZHRoID0gMDtcclxuICAgICAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUZXh0KCk7XHJcbiAgICAgICAgY29uc3Qgc2V0TGFiZWxQcm9wcyA9IChkYXR1bSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IGxhYmVsLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogbGFiZWwuZm9udEZhbWlseSxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBsYWJlbC5mb250U2l6ZSxcclxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogbGFiZWwuZm9udFdlaWdodCxcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHBhcmFsbGVsRmxpcEZsYWcgPT09IC0xID8gJ2JvdHRvbScgOiAnaGFuZ2luZycsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnNjcmVlblkgLSBsYWJlbC5mb250U2l6ZSAqIDAuMjUsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnNjcmVlblgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2FwdGlvbkVuYWJsZWQgPSAodGl0bGUgPT09IG51bGwgfHwgdGl0bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpdGxlLmVuYWJsZWQpICYmIGxhYmVscy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0NhcHRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHRoaXMuZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0aXRsZS5jb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiB0aXRsZS5mb250RmFtaWx5LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0aXRsZS5mb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBmb250U3R5bGU6IHRpdGxlLmZvbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiB0aXRsZS5mb250V2VpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAnaGFuZ2luZycsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25YOiBkYXR1bS5zY3JlZW5ZIC0gbGFiZWwuZm9udFNpemUgKiAwLjI1LFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0uc2NyZWVuWCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNJblJhbmdlID0gZGF0dW0uc2NyZWVuWCA+PSByYW5nZVswXSAmJiBkYXR1bS5zY3JlZW5YIDw9IHJhbmdlWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0luUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwuZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRleHQudGV4dCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcoZGF0dW0ubGFiZWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBTdHJpbmcoZGF0dW0ubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRleHQudGV4dCA9IFN0cmluZyhkYXR1bS5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cmVlTGFiZWxzLmZvckVhY2goKGRhdHVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBzZXRMYWJlbFByb3BzKGRhdHVtLCBpbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChpc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJib3ggPSB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmJveCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsQkJveGVzLnNldChpbmRleCwgYmJveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJib3gud2lkdGggPiBtYXhMZWFmTGFiZWxXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhMZWFmTGFiZWxXaWR0aCA9IGJib3gud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbGFiZWxYID0gc2lkZUZsYWcgKiBsYWJlbC5wYWRkaW5nO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsR3JpZCA9IHRoaXMubGFiZWwuZ3JpZDtcclxuICAgICAgICBjb25zdCBzZXBhcmF0b3JEYXRhID0gW107XHJcbiAgICAgICAgdHJlZUxhYmVscy5mb3JFYWNoKChkYXR1bSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHZpc2libGUgPSBzZXRMYWJlbFByb3BzKGRhdHVtLCBpbmRleCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHRlbXBUZXh0LnggPSBsYWJlbFg7XHJcbiAgICAgICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uQ2VudGVyWCA9IGxhYmVsWDtcclxuICAgICAgICAgICAgY29uc3QgaXNMZWFmID0gIWRhdHVtLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGlzTGVhZikge1xyXG4gICAgICAgICAgICAgICAgdGVtcFRleHQucm90YXRpb24gPSBjb25maWd1cmVkUm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB0ZW1wVGV4dC50ZXh0QWxpZ24gPSAnZW5kJztcclxuICAgICAgICAgICAgICAgIHRlbXBUZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJveCA9IGxhYmVsQkJveGVzLmdldChpZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmJveCAmJiBiYm94LmhlaWdodCA+IGJhbmR3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbEJCb3hlcy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGVtcFRleHQudHJhbnNsYXRpb25YIC09IG1heExlYWZMYWJlbFdpZHRoIC0gbGluZUhlaWdodCArIHRoaXMubGFiZWwucGFkZGluZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZVJhbmdlID0gZGF0dW0ubGVhZkNvdW50ICogYmFuZHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJveCA9IGxhYmVsQkJveGVzLmdldChpZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmJveCAmJiBiYm94LndpZHRoID4gYXZhaWxhYmxlUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxCQm94ZXMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gZGVmYXVsdFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRleHQucm90YXRpb24gPSAtTWF0aC5QSSAvIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9ucyBvZiBsYWJlbCBzZXBhcmF0b3JzIGZvciBhbGwgbm9kZXMgZXhjZXB0IHRoZSByb290LlxyXG4gICAgICAgICAgICAvLyBFYWNoIHNlcGFyYXRvciBpcyBwbGFjZWQgdG8gdGhlIHRvcCBvZiB0aGUgY3VycmVudCBsYWJlbC5cclxuICAgICAgICAgICAgaWYgKGRhdHVtLnBhcmVudCAmJiBpc0xhYmVsVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGlzTGVhZiA/IGRhdHVtLnNjcmVlblggLSBiYW5kd2lkdGggLyAyIDogZGF0dW0uc2NyZWVuWCAtIChkYXR1bS5sZWFmQ291bnQgKiBiYW5kd2lkdGgpIC8gMjtcclxuICAgICAgICAgICAgICAgIGlmIChpc0xlYWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0dW0ubnVtYmVyICE9PSBkYXR1bS5jaGlsZHJlbi5sZW5ndGggLSAxIHx8IGxhYmVsR3JpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI6IC1tYXhMZWFmTGFiZWxXaWR0aCAtIHRoaXMubGFiZWwucGFkZGluZyAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSAtbWF4TGVhZkxhYmVsV2lkdGggLSB0aGlzLmxhYmVsLnBhZGRpbmcgKiAyICsgZGF0dW0uc2NyZWVuWTtcclxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogeCArIGxpbmVIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiB4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBwcm9wcztcclxuICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJib3ggPSB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmJveCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsQkJveGVzLnNldChpbmRleCwgYmJveCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weUxhYmVsUHJvcHModGVtcFRleHQpKSwgeyB2aXNpYmxlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxCQm94ZXMuZGVsZXRlKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHByb3BzID0geyB2aXNpYmxlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGlja0xhYmVsTGF5b3V0LnB1c2gocHJvcHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGxvbmcgc2VwYXJhdG9yIG9uIHRoZSBmYXIgYm90dG9tIG9mIHRoZSBheGlzLlxyXG4gICAgICAgIGxldCBtaW5YID0gMDtcclxuICAgICAgICBzZXBhcmF0b3JEYXRhLmZvckVhY2goKGQpID0+IChtaW5YID0gTWF0aC5taW4obWluWCwgZC54MikpKTtcclxuICAgICAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICB5OiBNYXRoLm1heChyYW5nZVN0YXJ0LCByYW5nZUVuZCksXHJcbiAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICB4MjogbWluWCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBzZXBhcmF0b3JMYXlvdXQgPSBbXTtcclxuICAgICAgICBjb25zdCBzZXBhcmF0b3JCb3hlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSAwLjAwMDAwMDE7XHJcbiAgICAgICAgc2VwYXJhdG9yRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZGF0dW0ueSA+PSByYW5nZVswXSAtIGVwc2lsb24gJiYgZGF0dW0ueSA8PSByYW5nZVsxXSArIGVwc2lsb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDEsIHgyLCB5IH0gPSBkYXR1bTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckJveCA9IG5ldyBCQm94KE1hdGgubWluKHgxLCB4MiksIHksIE1hdGguYWJzKHgxIC0geDIpLCAwKTtcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRvckJveGVzLnB1c2goc2VwYXJhdG9yQm94KTtcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRvckxheW91dC5wdXNoKHsgeDEsIHgyLCB5IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgYXhpc0xpbmVMYXlvdXQgPSBbXTtcclxuICAgICAgICBjb25zdCBheGlzTGluZUJveGVzID0gW107XHJcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5kZXB0aCArIDEgOiAxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9IGxhYmVscy5sZW5ndGggPiAwICYmIChpID09PSAwIHx8IChsYWJlbEdyaWQgJiYgaXNMYWJlbFRyZWUpKTtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGkgPiAwID8gLW1heExlYWZMYWJlbFdpZHRoIC0gdGhpcy5sYWJlbC5wYWRkaW5nICogMiAtIChpIC0gMSkgKiBsaW5lSGVpZ2h0IDogMDtcclxuICAgICAgICAgICAgY29uc3QgbGluZUJveCA9IG5ldyBCQm94KHgsIE1hdGgubWluKC4uLnJhbmdlKSwgMCwgTWF0aC5hYnMocmFuZ2VbMV0gLSByYW5nZVswXSkpO1xyXG4gICAgICAgICAgICBheGlzTGluZUJveGVzLnB1c2gobGluZUJveCk7XHJcbiAgICAgICAgICAgIGF4aXNMaW5lTGF5b3V0LnB1c2goeyB4LCB5MTogcmFuZ2VbMF0sIHkyOiByYW5nZVsxXSwgdmlzaWJsZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZ2V0VHJhbnNmb3JtQm94ID0gKGJib3gpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHJvdGF0aW9uOiBheGlzUm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZLCByb3RhdGlvbkNlbnRlclgsIHJvdGF0aW9uQ2VudGVyWSwgfSA9IHRoaXMuZ2V0QXhpc1RyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgMSwgMSwgYXhpc1JvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwge1xyXG4gICAgICAgICAgICAgICAgc2NhbGluZ0NlbnRlclg6IDAsXHJcbiAgICAgICAgICAgICAgICBzY2FsaW5nQ2VudGVyWTogMCxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uQ2VudGVyWCxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uQ2VudGVyWSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXgudHJhbnNmb3JtQkJveChiYm94KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSBCQm94Lm1lcmdlKFsuLi5sYWJlbEJCb3hlcy52YWx1ZXMoKSwgLi4uc2VwYXJhdG9yQm94ZXMsIC4uLmF4aXNMaW5lQm94ZXNdKTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJCb3ggPSBnZXRUcmFuc2Zvcm1Cb3goYmJveCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYmJveDogdHJhbnNmb3JtZWRCQm94LFxyXG4gICAgICAgICAgICB0aWNrTGFiZWxMYXlvdXQsXHJcbiAgICAgICAgICAgIHNlcGFyYXRvckxheW91dCxcclxuICAgICAgICAgICAgYXhpc0xpbmVMYXlvdXQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZUxheW91dCgpIHtcclxuICAgICAgICBjb25zdCB7IGF4aXNMaW5lTGF5b3V0LCBzZXBhcmF0b3JMYXlvdXQsIHRpY2tMYWJlbExheW91dCwgYmJveCB9ID0gdGhpcy5jb21wdXRlTGF5b3V0KCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlZExheW91dCA9IHtcclxuICAgICAgICAgICAgYXhpc0xpbmVMYXlvdXQsXHJcbiAgICAgICAgICAgIHNlcGFyYXRvckxheW91dCxcclxuICAgICAgICAgICAgdGlja0xhYmVsTGF5b3V0LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHsgYmJveCwgcHJpbWFyeVRpY2tDb3VudDogdW5kZWZpbmVkIH07XHJcbiAgICB9XHJcbn1cclxuR3JvdXBlZENhdGVnb3J5QXhpcy5jbGFzc05hbWUgPSAnR3JvdXBlZENhdGVnb3J5QXhpcyc7XHJcbkdyb3VwZWRDYXRlZ29yeUF4aXMudHlwZSA9ICdncm91cGVkLWNhdGVnb3J5JztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEdyb3VwZWRDYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcImxhYmVsQ29sb3JcIiwgdm9pZCAwKTtcblxuLyoqXHJcbiAqIFdyYXBzIGEgbmF0aXZlIE9mZnNjcmVlbkNhbnZhcyBhbmQgb3ZlcnJpZGVzIGl0cyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgdG9cclxuICogcHJvdmlkZSByZXNvbHV0aW9uIGluZGVwZW5kZW50IHJlbmRlcmluZyBiYXNlZCBvbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gLlxyXG4gKi9cclxuY2xhc3MgSGRwaU9mZnNjcmVlbkNhbnZhcyB7XHJcbiAgICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIE9mZnNjcmVlbkNhbnZhcy5wcm90b3R5cGUudHJhbnNmZXJUb0ltYWdlQml0bWFwICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgd2lkdGgvaGVpZ2h0IGF0dHJpYnV0ZXMgb2YgdGhlIENhbnZhcyBlbGVtZW50IGRlZmF1bHQgdG9cclxuICAgIC8vIDMwMC8xNTAgYWNjb3JkaW5nIHRvIHczLm9yZy5cclxuICAgIGNvbnN0cnVjdG9yKHsgd2lkdGggPSA2MDAsIGhlaWdodCA9IDMwMCwgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvIH0pIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIGBOYU5gIGlzIGRlbGliZXJhdGUgaGVyZSwgc28gdGhhdCBvdmVycmlkZXMgYXJlIGFsd2F5cyBhcHBsaWVkXHJcbiAgICAgICAgLy8gYW5kIHRoZSBgcmVzZXRUcmFuc2Zvcm1gIGluc2lkZSB0aGUgYHJlc2l6ZWAgbWV0aG9kIHdvcmtzIGluIElFMTEuXHJcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpbyA9IE5hTjtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5yZWFsQ29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgdGhpcy5pbWFnZVNvdXJjZSA9IHRoaXMuY2FudmFzLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuc2V0UGl4ZWxSYXRpbyhvdmVycmlkZURldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgc25hcHNob3QoKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZVNvdXJjZS5jbG9zZSgpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VTb3VyY2UgPSB0aGlzLmNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZVNvdXJjZS5jbG9zZSgpO1xyXG4gICAgICAgIC8vIFdvcmthcm91bmQgbWVtb3J5IGFsbG9jYXRpb24gcXVpcmtzIGluIGlPUyBTYWZhcmkgYnkgcmVzaXppbmcgdG8gMHgwIGFuZCBjbGVhcmluZy5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTMyNS5cclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQucmVzZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBpeGVsUmF0aW8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBDYW52YXMgZWxlbWVudCB0byB0aGUgZ2l2ZW4gdmFsdWUsXHJcbiAgICAgKiBvciB1c2VzIHRoZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAoZGVmYXVsdCksIHRoZW4gcmVzaXplcyB0aGUgQ2FudmFzXHJcbiAgICAgKiBlbGVtZW50IGFjY29yZGluZ2x5IChkZWZhdWx0KS5cclxuICAgICAqL1xyXG4gICAgc2V0UGl4ZWxSYXRpbyhyYXRpbykge1xyXG4gICAgICAgIGxldCBwaXhlbFJhdGlvID0gcmF0aW8gIT09IG51bGwgJiYgcmF0aW8gIT09IHZvaWQgMCA/IHJhdGlvIDogd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICAgICAgaWYgKCFpc0Rlc2t0b3AoKSkge1xyXG4gICAgICAgICAgICAvLyBNb2JpbGUgYnJvd3NlcnMgaGF2ZSBzdHJpY3RlciBtZW1vcnkgbGltaXRzLCB3ZSByZWR1Y2UgcmVuZGVyaW5nIHJlc29sdXRpb24gdG9cclxuICAgICAgICAgICAgLy8gaW1wcm92ZSBzdGFiaWxpdHkgb24gbW9iaWxlIGJyb3dzZXJzLiBpT1MgU2FmYXJpIDEyLT4xNiBhcmUgcGFpbi1wb2ludHMgc2luY2UgdGhleVxyXG4gICAgICAgICAgICAvLyBoYXZlIG1lbW9yeSBhbGxvY2F0aW9uIHF1aXJrcyAtIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MzI1LlxyXG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XHJcbiAgICAgICAgcmV0dXJuIEhkcGlDYW52YXMub3ZlcnJpZGVTY2FsZSh0aGlzLnJlYWxDb250ZXh0LCBwaXhlbFJhdGlvKTtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGlmICghKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY2FudmFzLCBjb250ZXh0LCBwaXhlbFJhdGlvIH0gPSB0aGlzO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGgucm91bmQod2lkdGggKiBwaXhlbFJhdGlvKTtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiBwaXhlbFJhdGlvKTtcclxuICAgICAgICBjb250ZXh0LnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbn1cblxudmFyIERlYnVnU2VsZWN0b3JzO1xyXG4oZnVuY3Rpb24gKERlYnVnU2VsZWN0b3JzKSB7XHJcbiAgICBEZWJ1Z1NlbGVjdG9yc1tcIlNDRU5FXCJdID0gXCJzY2VuZVwiO1xyXG4gICAgRGVidWdTZWxlY3RvcnNbXCJTQ0VORV9TVEFUU1wiXSA9IFwic2NlbmU6c3RhdHNcIjtcclxuICAgIERlYnVnU2VsZWN0b3JzW1wiU0NFTkVfU1RBVFNfVkVSQk9TRVwiXSA9IFwic2NlbmU6c3RhdHM6dmVyYm9zZVwiO1xyXG4gICAgRGVidWdTZWxlY3RvcnNbXCJTQ0VORV9ESVJUWV9UUkVFXCJdID0gXCJzY2VuZTpkaXJ0eVRyZWVcIjtcclxufSkoRGVidWdTZWxlY3RvcnMgfHwgKERlYnVnU2VsZWN0b3JzID0ge30pKTtcclxuY29uc3QgYWR2YW5jZWRDb21wb3NpdGVJZGVudGlmaWVyID0gJ2Fkdi1jb21wb3NpdGUnO1xyXG5jb25zdCBkb21Db21wb3NpdGVJZGVudGlmaWVyID0gJ2RvbS1jb21wb3NpdGUnO1xyXG5jbGFzcyBTY2VuZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmxheWVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX25leHRaSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuX25leHRMYXllcklkID0gMDtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgRGVidWdTZWxlY3RvcnMuU0NFTkUpO1xyXG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQsIHdpbmRvdywgbW9kZSA9IChfYSA9IHdpbmRvd1ZhbHVlKCdhZ0NoYXJ0c1NjZW5lUmVuZGVyTW9kZWwnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYWR2YW5jZWRDb21wb3NpdGVJZGVudGlmaWVyLCB3aWR0aCwgaGVpZ2h0LCBvdmVycmlkZURldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQsIH0gPSBvcHRzO1xyXG4gICAgICAgIHRoaXMub3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvID0gb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgIHRoaXMub3B0cyA9IHsgZG9jdW1lbnQsIHdpbmRvdywgbW9kZSB9O1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IEhkcGlDYW52YXMoeyBkb2N1bWVudCwgd2luZG93LCB3aWR0aCwgaGVpZ2h0LCBvdmVycmlkZURldmljZVBpeGVsUmF0aW8gfSk7XHJcbiAgICB9XHJcbiAgICBzZXQgY29udGFpbmVyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuY29udGFpbmVyID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgY29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5jb250YWluZXI7XHJcbiAgICB9XHJcbiAgICBkb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCkge1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmRvd25sb2FkKGZpbGVOYW1lLCBmaWxlRm9ybWF0KTtcclxuICAgIH1cclxuICAgIGdldERhdGFVUkwodHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXREYXRhVVJMKHR5cGUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdTaXplID8gdGhpcy5wZW5kaW5nU2l6ZVswXSA6IHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nU2l6ZSA/IHRoaXMucGVuZGluZ1NpemVbMV0gOiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xyXG4gICAgICAgIC8vIEhkcGlDYW52YXMgZG9lc24ndCBhbGxvdyB3aWR0aC9oZWlnaHQgPD0gMC5cclxuICAgICAgICBjb25zdCBsZXNzVGhhblplcm8gPSB3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwO1xyXG4gICAgICAgIGNvbnN0IG5hbiA9IGlzTmFOKHdpZHRoKSB8fCBpc05hTihoZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKHVuY2hhbmdlZCB8fCBuYW4gfHwgbGVzc1RoYW5aZXJvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgYWRkTGF5ZXIob3B0cykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHRoaXMub3B0cztcclxuICAgICAgICBjb25zdCBsYXllcmVkTW9kZXMgPSBbJ2NvbXBvc2l0ZScsIGRvbUNvbXBvc2l0ZUlkZW50aWZpZXIsIGFkdmFuY2VkQ29tcG9zaXRlSWRlbnRpZmllcl07XHJcbiAgICAgICAgaWYgKCFsYXllcmVkTW9kZXMuaW5jbHVkZXMobW9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB6SW5kZXggPSB0aGlzLl9uZXh0WkluZGV4KyssIG5hbWUsIHpJbmRleFN1Yk9yZGVyLCBnZXRDb21wdXRlZE9wYWNpdHksIGdldFZpc2liaWxpdHkgfSA9IG9wdHM7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBvdmVycmlkZURldmljZVBpeGVsUmF0aW8gfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgZG9tTGF5ZXIgPSBtb2RlID09PSBkb21Db21wb3NpdGVJZGVudGlmaWVyO1xyXG4gICAgICAgIGNvbnN0IGFkdkxheWVyID0gbW9kZSA9PT0gYWR2YW5jZWRDb21wb3NpdGVJZGVudGlmaWVyO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9ICFhZHZMYXllciB8fCAhSGRwaU9mZnNjcmVlbkNhbnZhcy5pc1N1cHBvcnRlZCgpXHJcbiAgICAgICAgICAgID8gbmV3IEhkcGlDYW52YXMoe1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMub3B0cy5kb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIHdpbmRvdzogdGhpcy5vcHRzLndpbmRvdyxcclxuICAgICAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZG9tTGF5ZXIsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXgsXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IG5ldyBIZHBpT2Zmc2NyZWVuQ2FudmFzKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBuZXdMYXllciA9IHtcclxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRMYXllcklkKyssXHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHpJbmRleCxcclxuICAgICAgICAgICAgekluZGV4U3ViT3JkZXIsXHJcbiAgICAgICAgICAgIGNhbnZhcyxcclxuICAgICAgICAgICAgZ2V0Q29tcHV0ZWRPcGFjaXR5LFxyXG4gICAgICAgICAgICBnZXRWaXNpYmlsaXR5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHpJbmRleCA+PSB0aGlzLl9uZXh0WkluZGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25leHRaSW5kZXggPSB6SW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxheWVycy5wdXNoKG5ld0xheWVyKTtcclxuICAgICAgICB0aGlzLnNvcnRMYXllcnMoKTtcclxuICAgICAgICBpZiAoZG9tTGF5ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9tQ2FudmFzZXMgPSB0aGlzLmxheWVyc1xyXG4gICAgICAgICAgICAgICAgLm1hcCgodikgPT4gdi5jYW52YXMpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiB2IGluc3RhbmNlb2YgSGRwaUNhbnZhcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0xheWVySW5kZXggPSBkb21DYW52YXNlcy5maW5kSW5kZXgoKHYpID0+IHYgPT09IGNhbnZhcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMYXllciA9IChfYSA9IGRvbUNhbnZhc2VzW25ld0xheWVySW5kZXggLSAxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jYW52YXM7XHJcbiAgICAgICAgICAgIGxhc3RMYXllci5lbGVtZW50Lmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBjYW52YXMuZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVidWcoJ1NjZW5lLmFkZExheWVyKCkgLSBsYXllcnMnLCB0aGlzLmxheWVycyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0xheWVyLmNhbnZhcztcclxuICAgIH1cclxuICAgIHJlbW92ZUxheWVyKGNhbnZhcykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5sYXllcnMuZmluZEluZGV4KChsKSA9PiBsLmNhbnZhcyA9PT0gY2FudmFzKTtcclxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBjYW52YXMuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdTY2VuZS5yZW1vdmVMYXllcigpIC0gIGxheWVycycsIHRoaXMubGF5ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtb3ZlTGF5ZXIoY2FudmFzLCBuZXdaSW5kZXgsIG5ld1pJbmRleFN1Yk9yZGVyKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVycy5maW5kKChsKSA9PiBsLmNhbnZhcyA9PT0gY2FudmFzKTtcclxuICAgICAgICBpZiAobGF5ZXIpIHtcclxuICAgICAgICAgICAgbGF5ZXIuekluZGV4ID0gbmV3WkluZGV4O1xyXG4gICAgICAgICAgICBsYXllci56SW5kZXhTdWJPcmRlciA9IG5ld1pJbmRleFN1Yk9yZGVyO1xyXG4gICAgICAgICAgICB0aGlzLnNvcnRMYXllcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnU2NlbmUubW92ZUxheWVyKCkgLSAgbGF5ZXJzJywgdGhpcy5sYXllcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNvcnRMYXllcnMoKSB7XHJcbiAgICAgICAgdGhpcy5sYXllcnMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG91bmRBc2NlbmRpbmcoW2EuekluZGV4LCAuLi4oKF9hID0gYS56SW5kZXhTdWJPcmRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW3VuZGVmaW5lZCwgdW5kZWZpbmVkXSksIGEuaWRdLCBbYi56SW5kZXgsIC4uLigoX2IgPSBiLnpJbmRleFN1Yk9yZGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdKSwgYi5pZF0sIGFzY2VuZGluZ1N0cmluZ051bWJlclVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYXJrRGlydHkoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRpcnR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcclxuICAgIH1cclxuICAgIHNldCByb290KG5vZGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2EgPSB0aGlzLl9yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3NldExheWVyTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBub2RlO1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuX3NldExheWVyTWFuYWdlcih7XHJcbiAgICAgICAgICAgICAgICBhZGRMYXllcjogKG9wdHMpID0+IHRoaXMuYWRkTGF5ZXIob3B0cyksXHJcbiAgICAgICAgICAgICAgICBtb3ZlTGF5ZXI6ICguLi5vcHRzKSA9PiB0aGlzLm1vdmVMYXllciguLi5vcHRzKSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxheWVyOiAoLi4ub3B0cykgPT4gdGhpcy5yZW1vdmVMYXllciguLi5vcHRzKSxcclxuICAgICAgICAgICAgICAgIG1hcmtEaXJ0eTogKCkgPT4gdGhpcy5tYXJrRGlydHkoKSxcclxuICAgICAgICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXHJcbiAgICAgICAgICAgICAgICBkZWJ1ZzogRGVidWcuY3JlYXRlKERlYnVnU2VsZWN0b3JzLlNDRU5FKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcm9vdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgIH1cclxuICAgIC8qKiBBbHRlcm5hdGl2ZSB0byBkZXN0cm95KCkgdGhhdCBwcmVzZXJ2ZXMgcmUtdXNhYmxlIHJlc291cmNlcy4gKi9cclxuICAgIHN0cmlwKCkge1xyXG4gICAgICAgIGNvbnN0IHsgbGF5ZXJzIH0gPSB0aGlzO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGxheWVyLmNhbnZhcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsYXllclsnY2FudmFzJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxheWVycy5zcGxpY2UoMCwgbGF5ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmNvbnRleHQucmVzZXRUcmFuc2Zvcm0oKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdHJpcCgpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmRlc3Ryb3koKTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgY2FudmFzOiB1bmRlZmluZWQsIGN0eDogdW5kZWZpbmVkIH0pO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKG9wdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGVidWdTcGxpdFRpbWVzID0geyBzdGFydDogcGVyZm9ybWFuY2Uubm93KCkgfSwgZXh0cmFEZWJ1Z1N0YXRzID0ge30gfSA9IG9wdHMgIT09IG51bGwgJiYgb3B0cyAhPT0gdm9pZCAwID8gb3B0cyA6IHt9O1xyXG4gICAgICAgICAgICBjb25zdCB7IGNhbnZhcywgY2FudmFzOiB7IGNvbnRleHQ6IGN0eCB9LCByb290LCBsYXllcnMsIHBlbmRpbmdTaXplLCBvcHRzOiB7IG1vZGUgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMucmVzaXplKC4uLnBlbmRpbmdTaXplKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiBsYXllci5jYW52YXMucmVzaXplKC4uLnBlbmRpbmdTaXplKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTaXplID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyb290ICYmICFyb290LnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJvb3QgJiYgIXRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ1NjZW5lLnJlbmRlcigpIC0gbm8tb3AnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3VHlwZTogUmVkcmF3VHlwZVtyb290LmRpcnR5XSxcclxuICAgICAgICAgICAgICAgICAgICB0cmVlOiB0aGlzLmJ1aWxkVHJlZShyb290KSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z1N0YXRzKGRlYnVnU3BsaXRUaW1lcywgY3R4LCB1bmRlZmluZWQsIGV4dHJhRGVidWdTdGF0cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xyXG4gICAgICAgICAgICAgICAgY3R4LFxyXG4gICAgICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogKF9hID0gdGhpcy5jYW52YXMucGl4ZWxSYXRpbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSxcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcmVzaXplZDogISFwZW5kaW5nU2l6ZSxcclxuICAgICAgICAgICAgICAgIGRlYnVnTm9kZXM6IHt9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoRGVidWcuY2hlY2soRGVidWdTZWxlY3RvcnMuU0NFTkVfU1RBVFNfVkVSQk9TRSkpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlckN0eC5zdGF0cyA9IHsgbGF5ZXJzUmVuZGVyZWQ6IDAsIGxheWVyc1NraXBwZWQ6IDAsIG5vZGVzUmVuZGVyZWQ6IDAsIG5vZGVzU2tpcHBlZDogMCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYW52YXNDbGVhcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghcm9vdCB8fCByb290LmRpcnR5ID49IFJlZHJhd1R5cGUuVFJJVklBTCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCBhIGJsYW5rIGNhbnZhcywgY2xlYXIgcHJldmlvdXMgZHJhd2luZ1xyXG4gICAgICAgICAgICAgICAgY2FudmFzQ2xlYXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocm9vdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkaXJ0eVRyZWUsIHBhdGhzIH0gPSB0aGlzLmJ1aWxkRGlydHlUcmVlKHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgRGVidWcuY3JlYXRlKERlYnVnU2VsZWN0b3JzLlNDRU5FX0RJUlRZX1RSRUUpKCdTY2VuZS5yZW5kZXIoKSAtIGRpcnR5VHJlZScsIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXJ0eVRyZWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocm9vdCAmJiBjYW52YXNDbGVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdTY2VuZS5yZW5kZXIoKSAtIGJlZm9yZScsIHtcclxuICAgICAgICAgICAgICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NsZWFyZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogdGhpcy5idWlsZFRyZWUocm9vdCksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChyb290LnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVuZGVyKHJlbmRlckN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWJ1Z1NwbGl0VGltZXNbJ+Kcje+4jyddID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgIGlmIChtb2RlICE9PSBkb21Db21wb3NpdGVJZGVudGlmaWVyICYmIGxheWVycy5sZW5ndGggPiAwICYmIGNhbnZhc0NsZWFyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29ydExheWVycygpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSAvIGNhbnZhcy5waXhlbFJhdGlvLCAwLCAwLCAxIC8gY2FudmFzLnBpeGVsUmF0aW8sIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJzLmZvckVhY2goKHsgY2FudmFzOiB7IGltYWdlU291cmNlLCBlbmFibGVkIH0sIGdldENvbXB1dGVkT3BhY2l0eSwgZ2V0VmlzaWJpbGl0eSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkIHx8ICFnZXRWaXNpYmlsaXR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnZXRDb21wdXRlZE9wYWNpdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlU291cmNlLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIGRlYnVnU3BsaXRUaW1lc1sn4puZJ10gPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igc2F2ZS9yZXN0b3JlIGRlcHRoIG9mIHplcm8hXHJcbiAgICAgICAgICAgIChfYiA9IGN0eC52ZXJpZnlEZXB0aFplcm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGN0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWdTdGF0cyhkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgcmVuZGVyQ3R4LnN0YXRzLCBleHRyYURlYnVnU3RhdHMpO1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCwgcmVuZGVyQ3R4LmRlYnVnTm9kZXMpO1xyXG4gICAgICAgICAgICBpZiAocm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnU2NlbmUucmVuZGVyKCkgLSBhZnRlcicsIHtcclxuICAgICAgICAgICAgICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NsZWFyZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogdGhpcy5idWlsZFRyZWUocm9vdCksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVidWdTdGF0cyhkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgcmVuZGVyQ3R4U3RhdHMsIGV4dHJhRGVidWdTdGF0cyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKERlYnVnLmNoZWNrKERlYnVnU2VsZWN0b3JzLlNDRU5FX1NUQVRTLCBEZWJ1Z1NlbGVjdG9ycy5TQ0VORV9TVEFUU19WRVJCT1NFKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBkZWJ1Z1NwbGl0VGltZXNbJ3N0YXJ0J107XHJcbiAgICAgICAgICAgIGRlYnVnU3BsaXRUaW1lc1snZW5kJ10gPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc3QgcGN0ID0gKHJlbmRlcmVkLCBza2lwcGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IHJlbmRlcmVkICsgc2tpcHBlZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtyZW5kZXJlZH0gLyAke3RvdGFsfSAoJHtNYXRoLnJvdW5kKCgxMDAgKiByZW5kZXJlZCkgLyB0b3RhbCl9JSlgO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lID0gKG5hbWUsIHN0YXJ0LCBlbmQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfTogJHtNYXRoLnJvdW5kKChlbmQgLSBzdGFydCkgKiAxMDApIC8gMTAwfW1zYDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgeyBsYXllcnNSZW5kZXJlZCA9IDAsIGxheWVyc1NraXBwZWQgPSAwLCBub2Rlc1JlbmRlcmVkID0gMCwgbm9kZXNTa2lwcGVkID0gMCB9ID0gcmVuZGVyQ3R4U3RhdHMgIT09IG51bGwgJiYgcmVuZGVyQ3R4U3RhdHMgIT09IHZvaWQgMCA/IHJlbmRlckN0eFN0YXRzIDoge307XHJcbiAgICAgICAgICAgIGxldCBsYXN0U3BsaXQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBzcGxpdHMgPSBPYmplY3QuZW50cmllcyhkZWJ1Z1NwbGl0VGltZXMpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbbl0pID0+IG4gIT09ICdlbmQnKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoW24sIHRdLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpID4gMCA/IHRpbWUobiwgbGFzdFNwbGl0LCB0KSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsYXN0U3BsaXQgPSB0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHYpID0+IHYgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC5qb2luKCcgKyAnKTtcclxuICAgICAgICAgICAgY29uc3QgZXh0cmFzID0gT2JqZWN0LmVudHJpZXMoZXh0cmFEZWJ1Z1N0YXRzKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtrfTogJHt2fWApXHJcbiAgICAgICAgICAgICAgICAuam9pbignIDsgJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbGVkU3RhdHMgPSBEZWJ1Zy5jaGVjayhEZWJ1Z1NlbGVjdG9ycy5TQ0VORV9TVEFUU19WRVJCT1NFKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBbXHJcbiAgICAgICAgICAgICAgICBgJHt0aW1lKCfij7HvuI8nLCBzdGFydCwgZW5kKX0gKCR7c3BsaXRzfSlgLFxyXG4gICAgICAgICAgICAgICAgYCR7ZXh0cmFzfWAsXHJcbiAgICAgICAgICAgICAgICBgTGF5ZXJzOiAke2RldGFpbGVkU3RhdHMgPyBwY3QobGF5ZXJzUmVuZGVyZWQsIGxheWVyc1NraXBwZWQpIDogdGhpcy5sYXllcnMubGVuZ3RofWAsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxlZFN0YXRzID8gYE5vZGVzOiAke3BjdChub2Rlc1JlbmRlcmVkLCBub2Rlc1NraXBwZWQpfWAgOiBudWxsLFxyXG4gICAgICAgICAgICBdLmZpbHRlcigodikgPT4gdiAhPSBudWxsKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdHNTaXplID0gc3RhdHMubWFwKCh0KSA9PiBbdCwgSGRwaUNhbnZhcy5nZXRUZXh0U2l6ZSh0LCBjdHguZm9udCldKTtcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCguLi5zdGF0c1NpemUubWFwKChbLCB7IHdpZHRoIH1dKSA9PiB3aWR0aCkpO1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBzdGF0c1NpemUucmVkdWNlKCh0b3RhbCwgWywgeyBoZWlnaHQgfV0pID0+IHRvdGFsICsgaGVpZ2h0LCAwKTtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XHJcbiAgICAgICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbc3RhdCwgc2l6ZV0gb2Ygc3RhdHNTaXplKSB7XHJcbiAgICAgICAgICAgICAgICB5ICs9IHNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHN0YXQsIDIsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVidWdTY2VuZU5vZGVIaWdobGlnaHQoY3R4LCBkZWJ1Z05vZGVzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHJlZ2V4cFByZWRpY2F0ZSA9IChtYXRjaGVyKSA9PiAobikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hlci50ZXN0KG4uaWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIEdyb3VwICYmIG4ubmFtZSAhPSBudWxsICYmIG1hdGNoZXIudGVzdChuLm5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc3RyaW5nUHJlZGljYXRlID0gKG1hdGNoKSA9PiAobikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWF0Y2ggPT09IG4uaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgR3JvdXAgJiYgbi5uYW1lICE9IG51bGwgJiYgbWF0Y2ggPT09IG4ubmFtZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNjZW5lTm9kZUhpZ2hsaWdodCA9IHRvQXJyYXkod2luZG93VmFsdWUoJ2FnQ2hhcnRzU2NlbmVEZWJ1ZycpKS5mbGF0TWFwKChuYW1lKSA9PiBuYW1lID09PSAnbGF5b3V0JyA/IFsnc2VyaWVzUm9vdCcsICdsZWdlbmQnLCAncm9vdCcsIC8uKkF4aXMtXFxkKy1heGlzLiovXSA6IG5hbWUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbmV4dCBvZiBzY2VuZU5vZGVIaWdobGlnaHQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSAnc3RyaW5nJyAmJiBkZWJ1Z05vZGVzW25leHRdICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlID0gdHlwZW9mIG5leHQgPT09ICdzdHJpbmcnID8gc3RyaW5nUHJlZGljYXRlKG5leHQpIDogcmVnZXhwUHJlZGljYXRlKG5leHQpO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IChfYSA9IHRoaXMucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmROb2RlcyhwcmVkaWNhdGUpO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVzIHx8IG5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhgU2NlbmUucmVuZGVyKCkgLSBubyBkZWJ1Z2dpbmcgbm9kZSB3aXRoIGlkIFske25leHR9XSBpbiBzY2VuZSBncmFwaC5gKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcm91cCAmJiBub2RlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z05vZGVzW25vZGUubmFtZV0gPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVidWdOb2Rlc1tub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBub2RlXSBvZiBPYmplY3QuZW50cmllcyhkZWJ1Z05vZGVzKSkge1xyXG4gICAgICAgICAgICBjb25zdCBiYm94ID0gbm9kZS5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XHJcbiAgICAgICAgICAgIGlmICghYmJveCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhgU2NlbmUucmVuZGVyKCkgLSBubyBiYm94IGZvciBkZWJ1Z2dlZCBub2RlIFske25hbWV9XS5gKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuODtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdChiYm94LngsIGJib3gueSwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgIGN0eC5mb250ID0gJzE2cHggc2Fucy1zZXJpZic7XHJcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcclxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KG5hbWUsIGJib3gueCwgYmJveC55LCBiYm94LndpZHRoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KG5hbWUsIGJib3gueCwgYmJveC55LCBiYm94LndpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGJ1aWxkVHJlZShub2RlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gKG5vZGUgaW5zdGFuY2VvZiBHcm91cCA/IG5vZGUubmFtZSA6IG51bGwpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBub2RlLmlkO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBuYW1lLFxyXG4gICAgICAgICAgICBub2RlLCBkaXJ0eTogUmVkcmF3VHlwZVtub2RlLmRpcnR5XSB9LCAoKChfYiA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNWaXJ0dWFsKVxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIHZpcnR1YWxQYXJlbnREaXJ0eTogUmVkcmF3VHlwZVtub2RlLnBhcmVudC5kaXJ0eV0sXHJcbiAgICAgICAgICAgICAgICB2aXJ0dWFsUGFyZW50OiBub2RlLnBhcmVudCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHt9KSksIG5vZGUuY2hpbGRyZW5cclxuICAgICAgICAgICAgLm1hcCgoYykgPT4gdGhpcy5idWlsZFRyZWUoYykpXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB7IG5hbWU6IHRyZWVOb2RlTmFtZSB9ID0gY2hpbGRUcmVlO1xyXG4gICAgICAgICAgICBjb25zdCB7IG5vZGU6IHsgdmlzaWJsZSwgb3BhY2l0eSwgekluZGV4LCB6SW5kZXhTdWJPcmRlciB9LCBub2RlOiBjaGlsZE5vZGUsIHZpcnR1YWxQYXJlbnQsIH0gPSBjaGlsZFRyZWU7XHJcbiAgICAgICAgICAgIGlmICghdmlzaWJsZSB8fCBvcGFjaXR5IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRyZWVOb2RlTmFtZSA9IGAoJHt0cmVlTm9kZU5hbWV9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSBpbnN0YW5jZW9mIEdyb3VwICYmIGNoaWxkTm9kZS5pc0xheWVyKCkpIHtcclxuICAgICAgICAgICAgICAgIHRyZWVOb2RlTmFtZSA9IGAqJHt0cmVlTm9kZU5hbWV9KmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gW1xyXG4gICAgICAgICAgICAgICAgYCR7dHJlZU5vZGVOYW1lICE9PSBudWxsICYmIHRyZWVOb2RlTmFtZSAhPT0gdm9pZCAwID8gdHJlZU5vZGVOYW1lIDogJzx1bmtub3duPid9YCxcclxuICAgICAgICAgICAgICAgIGB6OiAke3pJbmRleH1gLFxyXG4gICAgICAgICAgICAgICAgekluZGV4U3ViT3JkZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICBgem86ICR7ekluZGV4U3ViT3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodikgPT4gKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nID8gYCR7digpfSAoZm4pYCA6IHYpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignIC8gJyl9YCxcclxuICAgICAgICAgICAgICAgIHZpcnR1YWxQYXJlbnQgJiYgYCh2aXJ0dWFsIHBhcmVudClgLFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiAhIXYpXHJcbiAgICAgICAgICAgICAgICAuam9pbignICcpO1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDE7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHRbc2VsZWN0ZWRLZXldICE9IG51bGwgJiYgaW5kZXggPCAxMDApIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkS2V5ID0gYCR7a2V5fSAoJHtpbmRleCsrfSlgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtzZWxlY3RlZEtleV0gPSBjaGlsZFRyZWU7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSwge30pKTtcclxuICAgIH1cclxuICAgIGJ1aWxkRGlydHlUcmVlKG5vZGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKG5vZGUuZGlydHkgPT09IFJlZHJhd1R5cGUuTk9ORSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBkaXJ0eVRyZWU6IHt9LCBwYXRoczogW10gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW5EaXJ0eVRyZWUgPSBub2RlLmNoaWxkcmVuLm1hcCgoYykgPT4gdGhpcy5idWlsZERpcnR5VHJlZShjKSkuZmlsdGVyKChjKSA9PiBjLnBhdGhzLmxlbmd0aCA+IDApO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSAoX2EgPSAobm9kZSBpbnN0YW5jZW9mIEdyb3VwID8gbm9kZS5uYW1lIDogbnVsbCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5vZGUuaWQ7XHJcbiAgICAgICAgY29uc3QgcGF0aHMgPSBjaGlsZHJlbkRpcnR5VHJlZS5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgPyBbbmFtZV1cclxuICAgICAgICAgICAgOiBjaGlsZHJlbkRpcnR5VHJlZVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoYykgPT4gYy5wYXRocylcclxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKHIsIHApID0+IHIuY29uY2F0KHApLCBbXSlcclxuICAgICAgICAgICAgICAgIC5tYXAoKHApID0+IGAke25hbWV9LiR7cH1gKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXJ0eVRyZWU6IE9iamVjdC5hc3NpZ24oeyBuYW1lLFxyXG4gICAgICAgICAgICAgICAgbm9kZSwgZGlydHk6IFJlZHJhd1R5cGVbbm9kZS5kaXJ0eV0gfSwgY2hpbGRyZW5EaXJ0eVRyZWVcclxuICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IGMuZGlydHlUcmVlKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodCkgPT4gdC5kaXJ0eSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgocmVzdWx0LCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFsoX2EgPSBjaGlsZFRyZWUubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJzx1bmtub3duPiddID0gY2hpbGRUcmVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSwge30pKSxcclxuICAgICAgICAgICAgcGF0aHMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5TY2VuZS5jbGFzc05hbWUgPSAnU2NlbmUnO1xuXG5mdW5jdGlvbiBzbGVlcChzbGVlcFRpbWVvdXRNcykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHVuZGVmaW5lZCksIHNsZWVwVGltZW91dE1zKTtcclxuICAgIH0pO1xyXG59XG5cbmNsYXNzIENhbGxiYWNrQ2FjaGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB9XHJcbiAgICBjYWxsKGZuLCAuLi5wYXJhbXMpIHtcclxuICAgICAgICBsZXQgc2VyaWFsaXNlZFBhcmFtcztcclxuICAgICAgICBsZXQgcGFyYW1DYWNoZSA9IHRoaXMuY2FjaGUuZ2V0KGZuKTtcclxuICAgICAgICBjb25zdCBpbnZva2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbiguLi5wYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtQ2FjaGUgJiYgc2VyaWFsaXNlZFBhcmFtcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1DYWNoZS5zZXQoc2VyaWFsaXNlZFBhcmFtcywgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci53YXJuT25jZShgVXNlciBjYWxsYmFjayBlcnJvcmVkLCBpZ25vcmluZ2AsIGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc2VyaWFsaXNlZFBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFVuYWJsZSB0byBzZXJpYWxpc2UgcGFyYW1zIVxyXG4gICAgICAgICAgICAvLyBObyBjYWNoaW5nIHBvc3NpYmxlLlxyXG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJhbUNhY2hlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcGFyYW1DYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoZm4sIHBhcmFtQ2FjaGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcmFtQ2FjaGUuaGFzKHNlcmlhbGlzZWRQYXJhbXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtQ2FjaGUuZ2V0KHNlcmlhbGlzZWRQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZUNhY2hlKCkge1xyXG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIE11dGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFjcXVpcmVRdWV1ZSA9IFtdO1xyXG4gICAgfVxyXG4gICAgYWNxdWlyZShjYikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFjcXVpcmVRdWV1ZS5wdXNoKFtjYiwgcmVzb2x2ZV0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFjcXVpcmVJbW1lZGlhdGVseShjYikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmFjcXVpcmUoY2IpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHdhaXRGb3JDbGVhckFjcXVpcmVRdWV1ZSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGlzcGF0Y2hOZXh0KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IFtuZXh0LCBkb25lXSA9IChfYSA9IHRoaXMuYWNxdWlyZVF1ZXVlLnNoaWZ0KCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9PT0gbnVsbCB8fCBkb25lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZXJyb3IoJ211dGV4IGNhbGxiYWNrIGVycm9yJywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPT09IG51bGwgfHwgZG9uZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgW25leHQsIGRvbmVdID0gKF9iID0gdGhpcy5hY3F1aXJlUXVldWUuc2hpZnQoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBXcmFwIGEgZnVuY3Rpb24gaW4gZGVib3VuY2luZyB0cmlnZ2VyIGZ1bmN0aW9uLiBBIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIGlzIHNjaGVkdWxlZFxyXG4gKiBhZnRlciB0aGUgZmlyc3Qgc2NoZWR1bGUoKSBjYWxsLCBhbmQgc3Vic2VxdWVudCBzY2hlZHVsZSgpIGNhbGxzIHdpbGwgYmUgaWdub3JlZCB1bnRpbCB0aGVcclxuICogYW5pbWF0aW9uIGNhbGxiYWNrIGV4ZWN1dGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVib3VuY2VkQW5pbWF0aW9uRnJhbWUoY2IpIHtcclxuICAgIHJldHVybiBidWlsZFNjaGVkdWxlcigoY2IsIF9kZWxheU1zKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpLCBjYik7XHJcbn1cclxuZnVuY3Rpb24gZGVib3VuY2VkQ2FsbGJhY2soY2IpIHtcclxuICAgIHJldHVybiBidWlsZFNjaGVkdWxlcigoY2IsIGRlbGF5TXMgPSAwKSA9PiBzZXRUaW1lb3V0KGNiLCBkZWxheU1zKSwgY2IpO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkU2NoZWR1bGVyKHNjaGVkdWxlRm4sIGNiKSB7XHJcbiAgICBsZXQgc2NoZWR1bGVDb3VudCA9IDA7XHJcbiAgICBsZXQgcHJvbWlzZVJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIGxldCBhd2FpdGluZ1Byb21pc2U7XHJcbiAgICBsZXQgYXdhaXRpbmdEb25lO1xyXG4gICAgY29uc3QgYnVzeSA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZVJ1bm5pbmc7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcclxuICAgICAgICBwcm9taXNlUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIGF3YWl0aW5nRG9uZSA9PT0gbnVsbCB8fCBhd2FpdGluZ0RvbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF3YWl0aW5nRG9uZSgpO1xyXG4gICAgICAgIGF3YWl0aW5nRG9uZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBhd2FpdGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHNjaGVkdWxlQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlRm4oc2NoZWR1bGVDYik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNjaGVkdWxlQ2IgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBzY2hlZHVsZUNvdW50O1xyXG4gICAgICAgIHNjaGVkdWxlQ291bnQgPSAwO1xyXG4gICAgICAgIHByb21pc2VSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBtYXliZVByb21pc2UgPSBjYih7IGNvdW50IH0pO1xyXG4gICAgICAgIGlmICghbWF5YmVQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXliZVByb21pc2UudGhlbihkb25lKS5jYXRjaChkb25lKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNjaGVkdWxlKGRlbGF5TXMpIHtcclxuICAgICAgICAgICAgaWYgKHNjaGVkdWxlQ291bnQgPT09IDAgJiYgIWJ1c3koKSkge1xyXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVGbihzY2hlZHVsZUNiLCBkZWxheU1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzY2hlZHVsZUNvdW50Kys7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhd2FpdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYnVzeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGF3YWl0aW5nUHJvbWlzZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXRpbmdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXRpbmdEb25lID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlIChidXN5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBhd2FpdGluZ1Byb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmNsYXNzIFNpemVNb25pdG9yIHtcclxuICAgIHN0YXRpYyBpbml0KGRvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBlbnRyeS5jb250ZW50UmVjdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLmVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpLCBlbnRyeS50YXJnZXQsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHBvbHlmaWxsIChtb3JlIHJlbGlhYmxlIGV2ZW4gaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IFJlc2l6ZU9ic2VydmVyKVxyXG4gICAgICAgICAgICBjb25zdCBzdGVwID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKChlbnRyeSwgZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDbGllbnRTaXplKGVsZW1lbnQsIGVudHJ5KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnBvbGxlckhhbmRsZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoc3RlcCwgMTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnO1xyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50UmVhZHkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyBBZGQgRE9NQ29udGVudExvYWRlZCBsaXN0ZW5lciBzbyB3ZSBjYW4gY2hlY2sgaWYgdGhlIG1haW4gZG9jdW1lbnQgaXMgcmVhZHkgYWdhaW4sIGFuZFxyXG4gICAgICAgIC8vIGlmIGl0IGlzIHRoZW4gYXR0YWNoIGFueSBxdWV1ZWQgcmVxdWVzdHMgZm9yIHJlc2l6ZSBtb25pdG9yaW5nLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gSWYgd2UgYXR0YWNoIGJlZm9yZSBlbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnLCB0aGVuIGFkZGl0aW9uYWwgaW5jb3JyZWN0IHJlc2l6ZSBldmVudHNcclxuICAgICAgICAvLyBhcmUgZmlyZWQsIGxlYWRpbmcgdG8gbXVsdGlwbGUgcmUtcmVuZGVyaW5ncyBvbiBjaGFydCBpbml0aWFsIGxvYWQuIFdhaXRpbmcgZm9yIHRoZVxyXG4gICAgICAgIC8vIGRvY3VtZW50IHRvIGJlIGxvYWRlZCBpcm9ucyBvdXQgdGhpcyBicm93c2VyIHF1aXJrLlxyXG4gICAgICAgIHRoaXMucmVhZHlFdmVudEZuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJztcclxuICAgICAgICAgICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmRvY3VtZW50UmVhZHk7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRSZWFkeSA9IG5ld1N0YXRlO1xyXG4gICAgICAgICAgICBpZiAoIW5ld1N0YXRlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IG9sZFN0YXRlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtlbCwgY2JdIG9mIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmUoZWwsIGNiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMucmVhZHlFdmVudEZuKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXN0cm95KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5wb2xsZXJIYW5kbGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnBvbGxlckhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnBvbGxlckhhbmRsZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJlYWR5RXZlbnRGbikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5yZWFkeUV2ZW50Rm4pO1xyXG4gICAgICAgICAgICB0aGlzLnJlYWR5RXZlbnRGbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gdGhpcy5yZXNpemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjaGVja1NpemUoZW50cnksIGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAoIWVudHJ5KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKCFlbnRyeS5zaXplIHx8IHdpZHRoICE9PSBlbnRyeS5zaXplLndpZHRoIHx8IGhlaWdodCAhPT0gZW50cnkuc2l6ZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgZW50cnkuc2l6ZSA9IHsgd2lkdGgsIGhlaWdodCB9O1xyXG4gICAgICAgICAgICBlbnRyeS5jYihlbnRyeS5zaXplLCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBPbmx5IGEgc2luZ2xlIGNhbGxiYWNrIGlzIHN1cHBvcnRlZC5cclxuICAgIHN0YXRpYyBvYnNlcnZlKGVsZW1lbnQsIGNiKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlYWR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdChlbGVtZW50Lm93bmVyRG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuZG9jdW1lbnRSZWFkeSkge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cy5wdXNoKFtlbGVtZW50LCBjYl0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudW5vYnNlcnZlKGVsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KGVsZW1lbnQsIHsgY2IgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdW5vYnNlcnZlKGVsZW1lbnQsIGNsZWFudXAgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzID0gdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMuZmlsdGVyKChbZWxdKSA9PiBlbCA9PT0gZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGNsZWFudXAgJiYgdGhpcy5lbGVtZW50cy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBjaGVja0NsaWVudFNpemUoZWxlbWVudCwgZW50cnkpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggPyBlbGVtZW50LmNsaWVudFdpZHRoIDogMDtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCA/IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDogMDtcclxuICAgICAgICB0aGlzLmNoZWNrU2l6ZShlbnRyeSwgZWxlbWVudCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbn1cclxuU2l6ZU1vbml0b3IuZWxlbWVudHMgPSBuZXcgTWFwKCk7XHJcblNpemVNb25pdG9yLnJlYWR5ID0gZmFsc2U7XHJcblNpemVNb25pdG9yLmRvY3VtZW50UmVhZHkgPSBmYWxzZTtcclxuU2l6ZU1vbml0b3IucXVldWVkT2JzZXJ2ZVJlcXVlc3RzID0gW107XG5cbmNsYXNzIENoYXJ0SGlnaGxpZ2h0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSAndG9vbHRpcCc7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShTVFJJTkdfVU5JT04oJ3Rvb2x0aXAnLCAnbm9kZScpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIENoYXJ0SGlnaGxpZ2h0LnByb3RvdHlwZSwgXCJyYW5nZVwiLCB2b2lkIDApO1xuXG4vKiogVHlwZXMgb2YgY2hhcnQtdXBkYXRlLCBpbiBwaXBlbGluZSBleGVjdXRpb24gb3JkZXIuICovXHJcbnZhciBDaGFydFVwZGF0ZVR5cGU7XHJcbihmdW5jdGlvbiAoQ2hhcnRVcGRhdGVUeXBlKSB7XHJcbiAgICBDaGFydFVwZGF0ZVR5cGVbQ2hhcnRVcGRhdGVUeXBlW1wiRlVMTFwiXSA9IDBdID0gXCJGVUxMXCI7XHJcbiAgICBDaGFydFVwZGF0ZVR5cGVbQ2hhcnRVcGRhdGVUeXBlW1wiUFJPQ0VTU19EQVRBXCJdID0gMV0gPSBcIlBST0NFU1NfREFUQVwiO1xyXG4gICAgQ2hhcnRVcGRhdGVUeXBlW0NoYXJ0VXBkYXRlVHlwZVtcIlBFUkZPUk1fTEFZT1VUXCJdID0gMl0gPSBcIlBFUkZPUk1fTEFZT1VUXCI7XHJcbiAgICBDaGFydFVwZGF0ZVR5cGVbQ2hhcnRVcGRhdGVUeXBlW1wiU0VSSUVTX1VQREFURVwiXSA9IDNdID0gXCJTRVJJRVNfVVBEQVRFXCI7XHJcbiAgICBDaGFydFVwZGF0ZVR5cGVbQ2hhcnRVcGRhdGVUeXBlW1wiVE9PTFRJUF9SRUNBTENVTEFUSU9OXCJdID0gNF0gPSBcIlRPT0xUSVBfUkVDQUxDVUxBVElPTlwiO1xyXG4gICAgQ2hhcnRVcGRhdGVUeXBlW0NoYXJ0VXBkYXRlVHlwZVtcIlNDRU5FX1JFTkRFUlwiXSA9IDVdID0gXCJTQ0VORV9SRU5ERVJcIjtcclxuICAgIENoYXJ0VXBkYXRlVHlwZVtDaGFydFVwZGF0ZVR5cGVbXCJOT05FXCJdID0gNl0gPSBcIk5PTkVcIjtcclxufSkoQ2hhcnRVcGRhdGVUeXBlIHx8IChDaGFydFVwZGF0ZVR5cGUgPSB7fSkpO1xuXG5jbGFzcyBEYXRhRG9tYWluIHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuY29udGludW91c0RvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcclxuICAgICAgICB0aGlzLmRpc2NyZXRlRG9tYWluID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgZXh0ZW5kKHZhbCkge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXNjcmV0ZScpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjcmV0ZURvbWFpbi5hZGQodmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAnY29udGludW91cycpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludW91c0RvbWFpblswXSA+IHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51b3VzRG9tYWluWzBdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVvdXNEb21haW5bMV0gPCB2YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludW91c0RvbWFpblsxXSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldERvbWFpbigpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZGlzY3JldGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2NyZXRlRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdjb250aW51b3VzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250aW51b3VzRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIFVuc3VwcG9ydGVkIGRhdGEgZG9tYWluIHR5cGU6ICcgKyB0aGlzLnR5cGUpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHRvS2V5U3RyaW5nKGtleXMpIHtcclxuICAgIHJldHVybiBrZXlzXHJcbiAgICAgICAgLm1hcCgodikgPT4ge1xyXG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9KVxyXG4gICAgICAgIC5qb2luKCctJyk7XHJcbn1cclxuZnVuY3Rpb24gcm91bmQodmFsKSB7XHJcbiAgICBjb25zdCBhY2N1cmFjeSA9IDEwMDAwO1xyXG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChNYXRoLmFicyh2YWwpID4gYWNjdXJhY3kpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsICogYWNjdXJhY3kpIC8gYWNjdXJhY3k7XHJcbn1cclxuZnVuY3Rpb24gZml4TnVtZXJpY0V4dGVudEludGVybmFsKGV4dGVudCkge1xyXG4gICAgaWYgKGV4dGVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gRG9uJ3QgcmV0dXJuIGEgcmFuZ2UsIHRoZXJlIGlzIG5vIHJhbmdlLlxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGxldCBbbWluLCBtYXhdID0gZXh0ZW50O1xyXG4gICAgbWluID0gK21pbjtcclxuICAgIG1heCA9ICttYXg7XHJcbiAgICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMCkge1xyXG4gICAgICAgIC8vIGRvbWFpbiBoYXMgemVybyBsZW5ndGggYW5kIHRoZSBzaW5nbGUgdmFsaWQgdmFsdWUgaXMgMC4gVXNlIHRoZSBkZWZhdWx0IG9mIFswLCAxXS5cclxuICAgICAgICByZXR1cm4gWzAsIDFdO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pbiA9PT0gSW5maW5pdHkgJiYgbWF4ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAvLyBUaGVyZSdzIG5vIGRhdGEgaW4gdGhlIGRvbWFpbi5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBpZiAobWluID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgIG1pbiA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAobWF4ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICBtYXggPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoaXNOdW1iZXIobWluKSAmJiBpc051bWJlcihtYXgpKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbbWluLCBtYXhdO1xyXG59XHJcbmZ1bmN0aW9uIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50LCBheGlzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBmaXhlZEV4dGVudCA9IGZpeE51bWVyaWNFeHRlbnRJbnRlcm5hbChleHRlbnQpO1xyXG4gICAgaWYgKGZpeGVkRXh0ZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmaXhlZEV4dGVudDtcclxuICAgIH1cclxuICAgIGxldCBbbWluLCBtYXhdID0gZml4ZWRFeHRlbnQ7XHJcbiAgICBpZiAobWluID09PSBtYXgpIHtcclxuICAgICAgICAvLyBkb21haW4gaGFzIHplcm8gbGVuZ3RoLCB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIHZhbGlkIHZhbHVlIGluIGRhdGFcclxuICAgICAgICBjb25zdCBbcGFkZGluZ01pbiwgcGFkZGluZ01heF0gPSAoX2EgPSBheGlzID09PSBudWxsIHx8IGF4aXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4aXMuY2FsY3VsYXRlUGFkZGluZyhtaW4sIG1heCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFsxLCAxXTtcclxuICAgICAgICBtaW4gLT0gcGFkZGluZ01pbjtcclxuICAgICAgICBtYXggKz0gcGFkZGluZ01heDtcclxuICAgIH1cclxuICAgIHJldHVybiBbbWluLCBtYXhdO1xyXG59XHJcbmNvbnN0IElOVkFMSURfVkFMVUUgPSBTeW1ib2woJ2ludmFsaWQnKTtcclxuY2xhc3MgRGF0YU1vZGVsIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBjb25zdCB7IHByb3BzLCBtb2RlID0gJ3N0YW5kYWxvbmUnIH0gPSBvcHRzO1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCBrZXlzIGFwcGVhciBiZWZvcmUgdmFsdWVzIGluIHRoZSBkZWZpbml0aW9ucywgYXMgb3V0cHV0IG9yZGVyaW5nIGRlcGVuZHNcclxuICAgICAgICAvLyBvbiBjb25maWd1cmF0aW9uIG9yZGVyaW5nLCBidXQgd2UgcHJvY2VzcyBrZXlzIGJlZm9yZSB2YWx1ZXMuXHJcbiAgICAgICAgbGV0IGtleXMgPSB0cnVlO1xyXG4gICAgICAgIGZvciAoY29uc3QgbmV4dCBvZiBwcm9wcykge1xyXG4gICAgICAgICAgICBpZiAobmV4dC50eXBlID09PSAna2V5JyAmJiAha2V5cykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IGtleXMgbXVzdCBjb21lIGJlZm9yZSB2YWx1ZXMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5leHQudHlwZSA9PT0gJ3ZhbHVlJyAmJiBrZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7IGRhdGFWaXNpYmxlOiB0cnVlIH0sIG9wdHMpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IHByb3BzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGRlZikgPT4gZGVmLnR5cGUgPT09ICdrZXknKVxyXG4gICAgICAgICAgICAubWFwKChkZWYsIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWYpLCB7IGluZGV4LCBtaXNzaW5nOiAwIH0pKSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBwcm9wc1xyXG4gICAgICAgICAgICAuZmlsdGVyKChkZWYpID0+IGRlZi50eXBlID09PSAndmFsdWUnKVxyXG4gICAgICAgICAgICAubWFwKChkZWYsIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWYpLCB7IGluZGV4LCBtaXNzaW5nOiAwIH0pKSk7XHJcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVzID0gcHJvcHNcclxuICAgICAgICAgICAgLmZpbHRlcigoZGVmKSA9PiBkZWYudHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpXHJcbiAgICAgICAgICAgIC5tYXAoKGRlZiwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZiksIHsgaW5kZXggfSkpKTtcclxuICAgICAgICB0aGlzLmdyb3VwUHJvY2Vzc29ycyA9IHByb3BzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGRlZikgPT4gZGVmLnR5cGUgPT09ICdncm91cC12YWx1ZS1wcm9jZXNzb3InKVxyXG4gICAgICAgICAgICAubWFwKChkZWYsIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWYpLCB7IGluZGV4IH0pKSk7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMgPSBwcm9wc1xyXG4gICAgICAgICAgICAuZmlsdGVyKChkZWYpID0+IGRlZi50eXBlID09PSAncHJvcGVydHktdmFsdWUtcHJvY2Vzc29yJylcclxuICAgICAgICAgICAgLm1hcCgoZGVmLCBpbmRleCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmKSwgeyBpbmRleCB9KSkpO1xyXG4gICAgICAgIHRoaXMucmVkdWNlcnMgPSBwcm9wc1xyXG4gICAgICAgICAgICAuZmlsdGVyKChkZWYpID0+IGRlZi50eXBlID09PSAncmVkdWNlcicpXHJcbiAgICAgICAgICAgIC5tYXAoKGRlZiwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZiksIHsgaW5kZXggfSkpKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NvcnMgPSBwcm9wc1xyXG4gICAgICAgICAgICAuZmlsdGVyKChkZWYpID0+IGRlZi50eXBlID09PSAncHJvY2Vzc29yJylcclxuICAgICAgICAgICAgLm1hcCgoZGVmLCBpbmRleCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmKSwgeyBpbmRleCB9KSkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIHRoaXMudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWYucHJvcGVydHkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IG5vIHByb3BlcnRpZXMgc3BlY2lmaWVkIGZvciB2YWx1ZSBkZWZpbml0aW9uczogJHtKU09OLnN0cmluZ2lmeShkZWYpfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZlcmlmeU1hdGNoR3JvdXBJZCA9ICh7IG1hdGNoR3JvdXBJZHMgfSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoR3JvdXBJZCBvZiBtYXRjaEdyb3VwSWRzICE9PSBudWxsICYmIG1hdGNoR3JvdXBJZHMgIT09IHZvaWQgMCA/IG1hdGNoR3JvdXBJZHMgOiBbXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbHVlcy5zb21lKChkZWYpID0+IGRlZi5ncm91cElkID09PSBtYXRjaEdyb3VwSWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IG1hdGNoR3JvdXBJZHMgcHJvcGVydGllcyBtdXN0IG1hdGNoIGRlZmluZWQgZ3JvdXBzICgke21hdGNoR3JvdXBJZH0pLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB2ZXJpZnlNYXRjaElkcyA9ICh7IG1hdGNoSWRzIH0pID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaElkIG9mIG1hdGNoSWRzICE9PSBudWxsICYmIG1hdGNoSWRzICE9PSB2b2lkIDAgPyBtYXRjaElkcyA6IFtdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsdWVzLnNvbWUoKGRlZikgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBkZWYuaWRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoW3Njb3BlLCBpZF0pID0+IHNjb3BlID09PSBtYXRjaElkWzBdICYmIGlkID09PSBtYXRjaElkWzFdKTsgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZyBlcnJvcjogbWF0Y2hHcm91cElkcyBwcm9wZXJ0aWVzIG11c3QgbWF0Y2ggZGVmaW5lZCBncm91cHMgKCR7bWF0Y2hJZH0pLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBbLi4udGhpcy5ncm91cFByb2Nlc3NvcnMsIC4uLnRoaXMuYWdncmVnYXRlc10pIHtcclxuICAgICAgICAgICAgdmVyaWZ5TWF0Y2hJZHMoZGVmKTtcclxuICAgICAgICAgICAgdmVyaWZ5TWF0Y2hHcm91cElkKGRlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQoc2NvcGUsIHNlYXJjaElkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgaW5kZXgsIGRlZiB9ID0gKF9hID0gdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XHJcbiAgICAgICAgcmV0dXJuIHsgaW5kZXgsIGRlZiB9O1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRpY2VzQnlJZChzY29wZSwgc2VhcmNoSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZnNCeUlkKHNjb3BlLCBzZWFyY2hJZCkubWFwKCh7IGluZGV4LCBkZWYgfSkgPT4gKHsgaW5kZXgsIGRlZiB9KSk7XHJcbiAgICB9XHJcbiAgICByZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzQnlJZChzY29wZSwgc2VhcmNoSWQpWzBdO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzQnlJZHMoc2NvcGUsIHNlYXJjaElkcykge1xyXG4gICAgICAgIGNvbnN0IGRlZnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNlYXJjaElkIG9mIHNlYXJjaElkcykge1xyXG4gICAgICAgICAgICBkZWZzLnB1c2goW3NlYXJjaElkLCB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmc0J5SWQoc2NvcGUsIHNlYXJjaElkKV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmcztcclxuICAgIH1cclxuICAgIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmc1ZhbHVlcyhkZWZzLCB7IGtleXMsIHZhbHVlcyB9KSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBbc2VhcmNoSWQsIFt7IGluZGV4LCBkZWYgfV1dIG9mIGRlZnMpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IGRlZi50eXBlID09PSAna2V5JyA/IGtleXMgOiB2YWx1ZXM7XHJcbiAgICAgICAgICAgIHJlc3VsdFtzZWFyY2hJZF0gPSBwcm9jZXNzZWREYXRhW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmc0J5SWQoc2VhcmNoU2NvcGUsIHNlYXJjaElkKSB7XHJcbiAgICAgICAgY29uc3QgeyBrZXlzLCB2YWx1ZXMsIGFnZ3JlZ2F0ZXMsIGdyb3VwUHJvY2Vzc29ycywgcmVkdWNlcnMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAocHJvcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGlkcywgc2NvcGVzIH0gPSBwcm9wO1xyXG4gICAgICAgICAgICBpZiAoaWRzID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hTY29wZSAhPSBudWxsICYmICEoc2NvcGVzID09PSBudWxsIHx8IHNjb3BlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NvcGVzLnNvbWUoKHNjb3BlKSA9PiBzY29wZSA9PT0gc2VhcmNoU2NvcGUuaWQpKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKChbc2NvcGUsIGlkXSkgPT4gc2NvcGUgPT09IHNlYXJjaFNjb3BlLmlkICYmICh0eXBlb2Ygc2VhcmNoSWQgPT09ICdzdHJpbmcnID8gaWQgPT09IHNlYXJjaElkIDogc2VhcmNoSWQudGVzdChpZCkpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGFsbERlZnMgPSBbXHJcbiAgICAgICAgICAgIGtleXMsXHJcbiAgICAgICAgICAgIHZhbHVlcyxcclxuICAgICAgICAgICAgYWdncmVnYXRlcyxcclxuICAgICAgICAgICAgZ3JvdXBQcm9jZXNzb3JzLFxyXG4gICAgICAgICAgICByZWR1Y2VycyxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgZGVmcyBvZiBhbGxEZWZzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmRlZnMuZmlsdGVyKG1hdGNoKS5tYXAoKGRlZikgPT4gKHsgaW5kZXg6IGRlZi5pbmRleCwgZGVmIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRpZG4ndCBmaW5kIHByb3BlcnR5IGRlZmluaXRpb24gZm9yIFske3NlYXJjaElkfSwgJHtzZWFyY2hTY29wZS5pZH1dYCk7XHJcbiAgICB9XHJcbiAgICBnZXREb21haW4oc2NvcGUsIHNlYXJjaElkLCB0eXBlID0gJ3ZhbHVlJywgcHJvY2Vzc2VkRGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBsZXQgbWF0Y2hlcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBtYXRjaGVzID0gdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGljZXNCeUlkKHNjb3BlLCBzZWFyY2hJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoSWQgIT09ICdzdHJpbmcnICYmIC9kaWRuJ3QgZmluZCBwcm9wZXJ0eSBkZWZpbml0aW9uLy50ZXN0KGUubWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkb21haW5Qcm9wO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdrZXknOlxyXG4gICAgICAgICAgICAgICAgZG9tYWluUHJvcCA9ICdrZXlzJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd2YWx1ZSc6XHJcbiAgICAgICAgICAgICAgICBkb21haW5Qcm9wID0gJ3ZhbHVlcyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYWdncmVnYXRlJzpcclxuICAgICAgICAgICAgICAgIGRvbWFpblByb3AgPSAnYWdnVmFsdWVzJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdncm91cC12YWx1ZS1wcm9jZXNzb3InOlxyXG4gICAgICAgICAgICAgICAgZG9tYWluUHJvcCA9ICdncm91cHMnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSAoX2IgPSAoX2EgPSBwcm9jZXNzZWREYXRhLmRvbWFpbltkb21haW5Qcm9wXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW21hdGNoZXNbMF0uaW5kZXhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcclxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0TWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5maXJzdE1hdGNoXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGlkeCBvZiBtYXRjaGVzLnNsaWNlKDEpKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZERvbWFpbigoX2QgPSAoX2MgPSBwcm9jZXNzZWREYXRhLmRvbWFpbltkb21haW5Qcm9wXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2lkeC5pbmRleF0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc0RhdGEoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHsgb3B0czogeyBncm91cEJ5S2V5cywgZ3JvdXBCeUZuIH0sIGFnZ3JlZ2F0ZXMsIGdyb3VwUHJvY2Vzc29ycywgcmVkdWNlcnMsIHByb2Nlc3NvcnMsIHByb3BlcnR5UHJvY2Vzc29ycywgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBbLi4udGhpcy5rZXlzLCAuLi50aGlzLnZhbHVlc10pIHtcclxuICAgICAgICAgICAgZGVmLm1pc3NpbmcgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JvdXBCeUtleXMgJiYgdGhpcy5rZXlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZXh0cmFjdERhdGEoZGF0YSk7XHJcbiAgICAgICAgaWYgKGdyb3VwQnlLZXlzKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLmdyb3VwRGF0YShwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZ3JvdXBCeUZuKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLmdyb3VwRGF0YShwcm9jZXNzZWREYXRhLCBncm91cEJ5Rm4ocHJvY2Vzc2VkRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JvdXBQcm9jZXNzb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc0dyb3Vwcyhwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFnZ3JlZ2F0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmFnZ3JlZ2F0ZURhdGEocHJvY2Vzc2VkRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wZXJ0eVByb2Nlc3NvcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzUHJvcGVydGllcyhwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZHVjZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5yZWR1Y2VEYXRhKHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvY2Vzc29ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NEYXRhKHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBbLi4udGhpcy5rZXlzLCAuLi50aGlzLnZhbHVlc10pIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCAmJiBkZWYubWlzc2luZyA+PSBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUga2V5ICcke2RlZi5wcm9wZXJ0eX0nIHdhcyBub3QgZm91bmQgaW4gYW55IGRhdGEgZWxlbWVudC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBwcm9jZXNzZWREYXRhLnRpbWUgPSBlbmQgLSBzdGFydDtcclxuICAgICAgICBpZiAoRGVidWcuY2hlY2sodHJ1ZSwgJ2RhdGEtbW9kZWwnKSkge1xyXG4gICAgICAgICAgICBsb2dQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YTtcclxuICAgIH1cclxuICAgIHZhbHVlR3JvdXBJZHhMb29rdXAoeyBtYXRjaEdyb3VwSWRzLCBtYXRjaElkcyB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzXHJcbiAgICAgICAgICAgIC5tYXAoKGRlZiwgaW5kZXgpID0+ICh7IGRlZiwgaW5kZXggfSkpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgZGVmIH0pID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoR3JvdXBJZHMgJiYgKGRlZi5ncm91cElkID09IG51bGwgfHwgIW1hdGNoR3JvdXBJZHMuaW5jbHVkZXMoZGVmLmdyb3VwSWQpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2hJZHMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGRlZi5pZHMgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoSWRzLnNvbWUoKFttYXRjaFNjb3BlLCBtYXRjaElkXSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBkZWYuaWRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoW2RlZlNjb3BlLCBkZWZJZF0pID0+IGRlZlNjb3BlID09PSBtYXRjaFNjb3BlICYmIGRlZklkID09PSBtYXRjaElkKTsgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm1hcCgoeyBpbmRleCB9KSA9PiBpbmRleCk7XHJcbiAgICB9XHJcbiAgICB2YWx1ZUlkeExvb2t1cChzY29wZXMsIHByb3ApIHtcclxuICAgICAgICBjb25zdCBub1Njb3Blc1RvTWF0Y2ggPSBzY29wZXMgPT0gbnVsbCB8fCBzY29wZXMubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIGNvbnN0IHNjb3BlTWF0Y2ggPSAoY29tcGFyZVRvKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFueVNjb3BlID0gY29tcGFyZVRvID09IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChhbnlTY29wZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBub1Njb3BlcyA9IGNvbXBhcmVUbyA9PSBudWxsIHx8IGNvbXBhcmVUby5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgIGlmIChub1Njb3Blc1RvTWF0Y2ggPT09IG5vU2NvcGVzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVG8gPT09IG51bGwgfHwgY29tcGFyZVRvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wYXJlVG8uc29tZSgocykgPT4gc2NvcGVzLmluY2x1ZGVzKHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHByb3BJZCA9IHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyA/IHByb3AgOiBwcm9wLmlkO1xyXG4gICAgICAgIGNvbnN0IGlkTWF0Y2ggPSAoW3Njb3BlLCBpZF0pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlTWF0Y2goW3Njb3BlXSkgJiYgaWQgPT09IHByb3BJZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsdWVzLmZpbmRJbmRleCgoZGVmKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChzY29wZU1hdGNoKGRlZi5zY29wZXMpICYmXHJcbiAgICAgICAgICAgICAgICAoKChfYSA9IGRlZi5pZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChpZCkgPT4gaWRNYXRjaChpZCkpKSB8fCBkZWYucHJvcGVydHkgPT09IHByb3BJZCB8fCBkZWYuaWQgPT09IHByb3BJZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGNvbmZpZ3VyYXRpb24gZXJyb3IsIHVua25vd24gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShwcm9wKX0gaW4gc2NvcGUocykgJHtKU09OLnN0cmluZ2lmeShzY29wZXMpfWApO1xyXG4gICAgfVxyXG4gICAgZXh0cmFjdERhdGEoZGF0YSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IGtleXM6IGtleURlZnMsIHZhbHVlczogdmFsdWVEZWZzLCBvcHRzOiB7IGRhdGFWaXNpYmxlIH0sIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YURvbWFpbiwgcHJvY2Vzc1ZhbHVlLCBzY29wZXMsIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyB9ID0gdGhpcy5pbml0RGF0YURvbWFpblByb2Nlc3NvcigpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdERhdGEgPSBuZXcgQXJyYXkoZGF0YVZpc2libGUgPyBkYXRhLmxlbmd0aCA6IDApO1xyXG4gICAgICAgIGxldCByZXN1bHREYXRhSWR4ID0gMDtcclxuICAgICAgICBsZXQgcGFydGlhbFZhbGlkRGF0YUNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRTY29wZXMgPSBzY29wZXMuc2l6ZSA+IDAgPyBuZXcgU2V0KHNjb3BlcykgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBkYXRhVmlzaWJsZSA/IG5ldyBBcnJheShrZXlEZWZzLmxlbmd0aCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBrZXlJZHggPSAwO1xyXG4gICAgICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBrZXlEZWZzKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBwcm9jZXNzVmFsdWUoZGVmLCBkYXR1bSwga2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IElOVkFMSURfVkFMVUUpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXNba2V5SWR4KytdID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IElOVkFMSURfVkFMVUUpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZGF0YVZpc2libGUgJiYgdmFsdWVEZWZzLmxlbmd0aCA+IDAgPyBuZXcgQXJyYXkodmFsdWVEZWZzLmxlbmd0aCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZUlkeCA9IDA7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgdmFsdWVEZWZzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb2Nlc3NWYWx1ZShkZWYsIGRhdHVtLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsU2NvcGVzSGF2ZVNhbWVEZWZzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIChfYSA9IGRlZi5zY29wZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNjb3Blcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFNjb3BlcyA9PT0gbnVsbCB8fCB2YWxpZFNjb3BlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRTY29wZXMuZGVsZXRlKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVJZHgrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbGlkU2NvcGVzID09PSBudWxsIHx8IHZhbGlkU2NvcGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWxpZFNjb3Blcy5zaXplKSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbdmFsdWVJZHgrK10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUgJiYgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmICgodmFsaWRTY29wZXMgPT09IG51bGwgfHwgdmFsaWRTY29wZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkU2NvcGVzLnNpemUpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChkYXRhVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IGtleXMsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmICghYWxsU2NvcGVzSGF2ZVNhbWVEZWZzICYmIHZhbGlkU2NvcGVzICYmIHZhbGlkU2NvcGVzLnNpemUgPCBzY29wZXMuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxWYWxpZERhdGFDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWxpZFNjb3BlcyA9IFsuLi52YWxpZFNjb3Blc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHREYXRhW3Jlc3VsdERhdGFJZHgrK10gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0RGF0YS5sZW5ndGggPSByZXN1bHREYXRhSWR4O1xyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5RG9tYWluID0gKGRlZikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkYXRhRG9tYWluLmdldChkZWYpLmdldERvbWFpbigpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdFswXSA+IHJlc3VsdFsxXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHN0YXJ0aW5nIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlc3VsdF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAndW5ncm91cGVkJyxcclxuICAgICAgICAgICAgaW5wdXQ6IHsgY291bnQ6IGRhdGEubGVuZ3RoIH0sXHJcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdERhdGEsXHJcbiAgICAgICAgICAgIGRvbWFpbjoge1xyXG4gICAgICAgICAgICAgICAga2V5czoga2V5RGVmcy5tYXAoKGRlZikgPT4gcHJvcGVydHlEb21haW4oZGVmKSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlRGVmcy5tYXAoKGRlZikgPT4gcHJvcGVydHlEb21haW4oZGVmKSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlZnM6IHtcclxuICAgICAgICAgICAgICAgIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyxcclxuICAgICAgICAgICAgICAgIGtleXM6IGtleURlZnMsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlRGVmcyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFydGlhbFZhbGlkRGF0YUNvdW50LFxyXG4gICAgICAgICAgICB0aW1lOiAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBncm91cERhdGEoZGF0YSwgZ3JvdXBpbmdGbikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZGF0YUVudHJ5IG9mIGRhdGEuZGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleXMsIHZhbHVlcywgZGF0dW0sIHZhbGlkU2NvcGVzIH0gPSBkYXRhRW50cnk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBpbmdGbiA/IGdyb3VwaW5nRm4oZGF0YUVudHJ5KSA6IGtleXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwU3RyID0gdG9LZXlTdHJpbmcoZ3JvdXApO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkRGF0YS5oYXMoZ3JvdXBTdHIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0RhdGEgPSBwcm9jZXNzZWREYXRhLmdldChncm91cFN0cik7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ0RhdGEudmFsdWVzLnB1c2godmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nRGF0YS5kYXR1bS5wdXNoKGRhdHVtKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWxpZFNjb3BlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJzZWN0aW9uIG9mIGV4aXN0aW5nIHZhbGlkU2NvcGVzIHdpdGggbmV3IHZhbGlkU2NvcGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAoKF9iID0gKF9hID0gZXhpc3RpbmdEYXRhLnZhbGlkU2NvcGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY29wZSA9IChfYyA9IGV4aXN0aW5nRGF0YS52YWxpZFNjb3BlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkU2NvcGVzLnNvbWUoKHMpID0+IHMgPT09IHNjb3BlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2QgPSBleGlzdGluZ0RhdGEudmFsaWRTY29wZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZERhdGEuc2V0KGdyb3VwU3RyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5czogZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbdmFsdWVzXSxcclxuICAgICAgICAgICAgICAgICAgICBkYXR1bTogW2RhdHVtXSxcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZFNjb3BlcyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdERhdGEgPSBuZXcgQXJyYXkocHJvY2Vzc2VkRGF0YS5zaXplKTtcclxuICAgICAgICBjb25zdCByZXN1bHRHcm91cHMgPSBuZXcgQXJyYXkocHJvY2Vzc2VkRGF0YS5zaXplKTtcclxuICAgICAgICBsZXQgZGF0YUluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IFssIHsga2V5cywgdmFsdWVzLCBkYXR1bSwgdmFsaWRTY29wZXMgfV0gb2YgcHJvY2Vzc2VkRGF0YS5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKCh2YWxpZFNjb3BlcyA9PT0gbnVsbCB8fCB2YWxpZFNjb3BlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRTY29wZXMubGVuZ3RoKSA9PT0gMClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICByZXN1bHRHcm91cHNbZGF0YUluZGV4XSA9IGtleXM7XHJcbiAgICAgICAgICAgIHJlc3VsdERhdGFbZGF0YUluZGV4KytdID0ge1xyXG4gICAgICAgICAgICAgICAga2V5cyxcclxuICAgICAgICAgICAgICAgIHZhbHVlcyxcclxuICAgICAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgICAgICAgICAgdmFsaWRTY29wZXMsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHR5cGU6ICdncm91cGVkJywgZGF0YTogcmVzdWx0RGF0YSwgZG9tYWluOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEuZG9tYWluKSwgeyBncm91cHM6IHJlc3VsdEdyb3VwcyB9KSB9KTtcclxuICAgIH1cclxuICAgIGFnZ3JlZ2F0ZURhdGEocHJvY2Vzc2VkRGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XHJcbiAgICAgICAgY29uc3QgeyBhZ2dyZWdhdGVzOiBhZ2dEZWZzIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghYWdnRGVmcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdEFnZ1ZhbHVlcyA9IGFnZ0RlZnMubWFwKCgpID0+IFtJbmZpbml0eSwgLUluZmluaXR5XSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0QWdnVmFsdWVJbmRpY2VzID0gYWdnRGVmcy5tYXAoKGRlZikgPT4gdGhpcy52YWx1ZUdyb3VwSWR4TG9va3VwKGRlZikpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdEFnZ0ZucyA9IGFnZ0RlZnMubWFwKChkZWYpID0+IGRlZi5hZ2dyZWdhdGVGdW5jdGlvbik7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0R3JvdXBBZ2dGbnMgPSBhZ2dEZWZzLm1hcCgoZGVmKSA9PiBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbik7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0RmluYWxGbnMgPSBhZ2dEZWZzLm1hcCgoZGVmKSA9PiBkZWYuZmluYWxGdW5jdGlvbik7XHJcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBwcm9jZXNzZWREYXRhLmRhdGEpIHtcclxuICAgICAgICAgICAgbGV0IHsgdmFsdWVzIH0gPSBncm91cDtcclxuICAgICAgICAgICAgY29uc3QgeyB2YWxpZFNjb3BlcyB9ID0gZ3JvdXA7XHJcbiAgICAgICAgICAgIChfYSA9IGdyb3VwLmFnZ1ZhbHVlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGdyb3VwLmFnZ1ZhbHVlcyA9IG5ldyBBcnJheShyZXN1bHRBZ2dWYWx1ZUluZGljZXMubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzZWREYXRhLnR5cGUgPT09ICd1bmdyb3VwZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcmVzdWx0SWR4ID0gMDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRpY2VzIG9mIHJlc3VsdEFnZ1ZhbHVlSW5kaWNlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVWYWxpZCA9IChfYiA9IHZhbGlkU2NvcGVzID09PSBudWxsIHx8IHZhbGlkU2NvcGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWxpZFNjb3Blcy5zb21lKChzKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGFnZ0RlZnNbcmVzdWx0SWR4XS5tYXRjaFNjb3BlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKGFzKSA9PiBzID09PSBhcyk7IH0pKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZVZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SWR4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBBZ2dWYWx1ZXMgPSAoX2QgPSAoX2MgPSByZXN1bHRHcm91cEFnZ0Zuc1tyZXN1bHRJZHhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChyZXN1bHRHcm91cEFnZ0ZucykpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGV4dGVuZERvbWFpbihbXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRpc3RpbmN0VmFsdWVzIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlc1RvQWdnID0gaW5kaWNlcy5tYXAoKHZhbHVlSWR4KSA9PiBkaXN0aW5jdFZhbHVlc1t2YWx1ZUlkeF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlc0FnZyA9IHJlc3VsdEFnZ0Zuc1tyZXN1bHRJZHhdKHZhbHVlc1RvQWdnLCBncm91cC5rZXlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzQWdnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQWdnVmFsdWVzID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfZiA9IChfZSA9IHJlc3VsdEdyb3VwQWdnRm5zW3Jlc3VsdElkeF0pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKHJlc3VsdEdyb3VwQWdnRm5zLCB2YWx1ZXNBZ2csIGdyb3VwQWdnVmFsdWVzKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZXh0ZW5kRG9tYWluKHZhbHVlc0FnZywgZ3JvdXBBZ2dWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVmFsdWVzID0gKChfaCA9IChfZyA9IHJlc3VsdEZpbmFsRm5zW3Jlc3VsdElkeF0pID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5jYWxsKHJlc3VsdEZpbmFsRm5zLCBncm91cEFnZ1ZhbHVlcykpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IGdyb3VwQWdnVmFsdWVzKS5tYXAoKHYpID0+IHJvdW5kKHYpKTtcclxuICAgICAgICAgICAgICAgIGV4dGVuZERvbWFpbihmaW5hbFZhbHVlcywgcmVzdWx0QWdnVmFsdWVzW3Jlc3VsdElkeF0pO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAuYWdnVmFsdWVzW3Jlc3VsdElkeCsrXSA9IGZpbmFsVmFsdWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcyA9IHJlc3VsdEFnZ1ZhbHVlcztcclxuICAgIH1cclxuICAgIHBvc3RQcm9jZXNzR3JvdXBzKHByb2Nlc3NlZERhdGEpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xyXG4gICAgICAgIGNvbnN0IHsgZ3JvdXBQcm9jZXNzb3JzIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghZ3JvdXBQcm9jZXNzb3JzKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgYWZmZWN0ZWRJbmRpY2VzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWREb21haW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGdyb3VwUHJvY2Vzc29ySW5kaWNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBncm91cFByb2Nlc3NvckluaXRGbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgZ3JvdXBQcm9jZXNzb3JzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnZhbHVlR3JvdXBJZHhMb29rdXAocHJvY2Vzc29yKTtcclxuICAgICAgICAgICAgZ3JvdXBQcm9jZXNzb3JJbmRpY2VzLnNldChwcm9jZXNzb3IsIGluZGljZXMpO1xyXG4gICAgICAgICAgICBncm91cFByb2Nlc3NvckluaXRGbnMuc2V0KHByb2Nlc3NvciwgcHJvY2Vzc29yLmFkanVzdCgpKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpZHggb2YgaW5kaWNlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVEZWYgPSB0aGlzLnZhbHVlc1tpZHhdO1xyXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbmRpY2VzLmFkZChpZHgpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlZERvbWFpbnMuc2V0KGlkeCwgbmV3IERhdGFEb21haW4odmFsdWVEZWYudmFsdWVUeXBlID09PSAnY2F0ZWdvcnknID8gJ2Rpc2NyZXRlJyA6ICdjb250aW51b3VzJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHVwZGF0ZURvbWFpbnMgPSAodmFsdWVzKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZUluZGV4IG9mIGFmZmVjdGVkSW5kaWNlcykge1xyXG4gICAgICAgICAgICAgICAgKF9hID0gdXBkYXRlZERvbWFpbnMuZ2V0KHZhbHVlSW5kZXgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXh0ZW5kKHZhbHVlc1t2YWx1ZUluZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgcHJvY2Vzc2VkRGF0YS5kYXRhKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvY2Vzc29yIG9mIGdyb3VwUHJvY2Vzc29ycykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVWYWxpZCA9IChfYiA9IChfYSA9IGdyb3VwLnZhbGlkU2NvcGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgocykgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBwcm9jZXNzb3IubWF0Y2hTY29wZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChhcykgPT4gcyA9PT0gYXMpOyB9KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghc2NvcGVWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVJbmRleGVzID0gKF9jID0gZ3JvdXBQcm9jZXNzb3JJbmRpY2VzLmdldChwcm9jZXNzb3IpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdEZuID0gKF9lID0gKF9kID0gZ3JvdXBQcm9jZXNzb3JJbml0Rm5zLmdldChwcm9jZXNzb3IpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QoKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKCgpID0+IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSAnZ3JvdXBlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cC52YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0Rm4odmFsdWVzLCB2YWx1ZUluZGV4ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLnZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkanVzdEZuKGdyb3VwLnZhbHVlcywgdmFsdWVJbmRleGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSAnZ3JvdXBlZCcpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWVzIG9mIGdyb3VwLnZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZURvbWFpbnModmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZURvbWFpbnMoZ3JvdXAudmFsdWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIGRhdGFEb21haW5dIG9mIHVwZGF0ZWREb21haW5zKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tpZHhdID0gWy4uLmRhdGFEb21haW4uZ2V0RG9tYWluKCldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvc3RQcm9jZXNzUHJvcGVydGllcyhwcm9jZXNzZWREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0eVByb2Nlc3NvcnMgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFwcm9wZXJ0eVByb2Nlc3NvcnMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgYWRqdXN0LCBwcm9wZXJ0eSwgc2NvcGVzIH0gb2YgcHJvcGVydHlQcm9jZXNzb3JzKSB7XHJcbiAgICAgICAgICAgIGFkanVzdCgpKHByb2Nlc3NlZERhdGEsIHRoaXMudmFsdWVJZHhMb29rdXAoc2NvcGVzICE9PSBudWxsICYmIHNjb3BlcyAhPT0gdm9pZCAwID8gc2NvcGVzIDogW10sIHByb3BlcnR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVkdWNlRGF0YShwcm9jZXNzZWREYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgY29uc3QgeyByZWR1Y2VyczogcmVkdWNlckRlZnMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gcmVkdWNlckRlZnMubWFwKChkZWYpID0+IGRlZi5zY29wZXMpO1xyXG4gICAgICAgIGNvbnN0IHJlZHVjZXJzID0gcmVkdWNlckRlZnMubWFwKChkZWYpID0+IGRlZi5yZWR1Y2VyKCkpO1xyXG4gICAgICAgIGNvbnN0IGFjY1ZhbHVlcyA9IHJlZHVjZXJEZWZzLm1hcCgoZGVmKSA9PiBkZWYuaW5pdGlhbFZhbHVlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHByb2Nlc3NlZERhdGEuZGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgcmVkdWNlckluZGV4ID0gMDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCByZWR1Y2VyIG9mIHJlZHVjZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY29wZVZhbGlkID0gKF9iID0gKF9hID0gZ3JvdXAudmFsaWRTY29wZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChzKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHNjb3Blc1tyZWR1Y2VySW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoYXMpID0+IHMgPT09IGFzKTsgfSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWR1Y2VySW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFjY1ZhbHVlc1tyZWR1Y2VySW5kZXhdID0gcmVkdWNlcihhY2NWYWx1ZXNbcmVkdWNlckluZGV4XSwgZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlckluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgYWNjSWR4ID0gMDsgYWNjSWR4IDwgYWNjVmFsdWVzLmxlbmd0aDsgYWNjSWR4KyspIHtcclxuICAgICAgICAgICAgKF9jID0gcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAocHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID0ge30pO1xyXG4gICAgICAgICAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWRbcmVkdWNlckRlZnNbYWNjSWR4XS5wcm9wZXJ0eV0gPSBhY2NWYWx1ZXNbYWNjSWR4XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3N0UHJvY2Vzc0RhdGEocHJvY2Vzc2VkRGF0YSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IHByb2Nlc3NvcnM6IHByb2Nlc3NvckRlZnMgfSA9IHRoaXM7XHJcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgcHJvY2Vzc29yRGVmcykge1xyXG4gICAgICAgICAgICAoX2EgPSBwcm9jZXNzZWREYXRhLnJlZHVjZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChwcm9jZXNzZWREYXRhLnJlZHVjZWQgPSB7fSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZFtkZWYucHJvcGVydHldID0gZGVmLmNhbGN1bGF0ZShwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbml0RGF0YURvbWFpblByb2Nlc3NvcigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBrZXlzOiBrZXlEZWZzLCB2YWx1ZXM6IHZhbHVlRGVmcyB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZURlZiBvZiB2YWx1ZURlZnMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiAoX2EgPSB2YWx1ZURlZi5zY29wZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZXMuYWRkKHNjb3BlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzY29wZXNDb3VudCA9IHNjb3Blcy5zaXplO1xyXG4gICAgICAgIGNvbnN0IGRhdGFEb21haW4gPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc29yRm5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGxldCBhbGxTY29wZXNIYXZlU2FtZURlZnMgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGluaXREYXRhRG9tYWluS2V5ID0gKGtleSwgdHlwZSwgdXBkYXRlRGF0YURvbWFpbiA9IGRhdGFEb21haW4pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRGF0YURvbWFpbi5zZXQoa2V5LCBuZXcgRGF0YURvbWFpbignZGlzY3JldGUnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhRG9tYWluLnNldChrZXksIG5ldyBEYXRhRG9tYWluKCdjb250aW51b3VzJykpO1xyXG4gICAgICAgICAgICAgICAgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzICYmIChhbGxTY29wZXNIYXZlU2FtZURlZnMgPSAoKF9hID0ga2V5LnNjb3BlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmxlbmd0aCA9PT0gc2NvcGVzQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBpbml0RGF0YURvbWFpbiA9ICgpID0+IHtcclxuICAgICAgICAgICAga2V5RGVmcy5mb3JFYWNoKChkZWYpID0+IGluaXREYXRhRG9tYWluS2V5KGRlZiwgZGVmLnZhbHVlVHlwZSkpO1xyXG4gICAgICAgICAgICB2YWx1ZURlZnMuZm9yRWFjaCgoZGVmKSA9PiBpbml0RGF0YURvbWFpbktleShkZWYsIGRlZi52YWx1ZVR5cGUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGluaXREYXRhRG9tYWluKCk7XHJcbiAgICAgICAgY29uc3QgYWNjZXNzb3JzID0gdGhpcy5idWlsZEFjY2Vzc29ycyguLi5rZXlEZWZzLCAuLi52YWx1ZURlZnMpO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NWYWx1ZSA9IChkZWYsIGRhdHVtLCBwcmV2aW91c0RhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAgICAgY29uc3QgaGFzQWNjZXNzb3IgPSBkZWYucHJvcGVydHkgaW4gYWNjZXNzb3JzO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWVJbkRhdHVtID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGhhc0FjY2Vzc29yKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWNjZXNzb3JzW2RlZi5wcm9wZXJ0eV0oZGF0dW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3dhbGxvdyBlcnJvcnMgLSB0aGVzZSBnZXQgcmVwb3J0ZWQgYXMgbWlzc2luZyB2YWx1ZXMgdG8gdGhlIHVzZXIgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUluRGF0dW0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVJbkRhdHVtID0gZGVmLnByb3BlcnR5IGluIGRhdHVtO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZUluRGF0dW0gPyBkYXR1bVtkZWYucHJvcGVydHldIDogZGVmLm1pc3NpbmdWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmLmZvcmNlVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWFpbnRhaW4gc2lnbiBvZiBmb3JjZVZhbHVlIGZyb20gYWN0dWFsIHZhbHVlLCB0aGlzIG1heWJlIHNpZ25pZmljYW50IGxhdGVyIHdoZW5cclxuICAgICAgICAgICAgICAgIC8vIHdlIGFjY291bnQgZm8gdGhlIHZhbHVlIGZhbGxpbmcgaW50byBwb3NpdGl2ZS9uZWdhdGl2ZSBidWNrZXRzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlSW5EYXR1bSAmJiBpc05lZ2F0aXZlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVOZWdhdGl2ZSA/IC0xICogZGVmLmZvcmNlVmFsdWUgOiBkZWYuZm9yY2VWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlSW5EYXR1bSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbWlzc2luZ1ZhbHVlRGVmID0gJ21pc3NpbmdWYWx1ZScgaW4gZGVmO1xyXG4gICAgICAgICAgICBpZiAoIXZhbHVlSW5EYXR1bSAmJiAhbWlzc2luZ1ZhbHVlRGVmKSB7XHJcbiAgICAgICAgICAgICAgICBkZWYubWlzc2luZysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGF0YURvbWFpbi5oYXMoZGVmKSkge1xyXG4gICAgICAgICAgICAgICAgaW5pdERhdGFEb21haW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWVJbkRhdHVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IChfYiA9IChfYSA9IGRlZi52YWxpZGF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkZWYsIHZhbHVlLCBkYXR1bSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpbnZhbGlkVmFsdWUnIGluIGRlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZi5pbnZhbGlkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRF9WQUxVRTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlZi5wcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc29yRm5zLmhhcyhkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc29yRm5zLnNldChkZWYsIGRlZi5wcm9jZXNzb3IoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IChfYyA9IHByb2Nlc3NvckZucy5nZXQoZGVmKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jKHZhbHVlLCBwcmV2aW91c0RhdHVtICE9PSBJTlZBTElEX1ZBTFVFID8gcHJldmlvdXNEYXR1bSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKF9kID0gZGF0YURvbWFpbi5nZXQoZGVmKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmV4dGVuZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7IGRhdGFEb21haW4sIHByb2Nlc3NWYWx1ZSwgaW5pdERhdGFEb21haW4sIHNjb3BlcywgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzIH07XHJcbiAgICB9XHJcbiAgICBidWlsZEFjY2Vzc29ycyguLi5kZWZzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2ludGVncmF0ZWQnKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNQYXRoID0gZGVmLnByb3BlcnR5LmluZGV4T2YoJy4nKSA+PSAwIHx8IGRlZi5wcm9wZXJ0eS5pbmRleE9mKCdbJykgPj0gMDtcclxuICAgICAgICAgICAgaWYgKCFpc1BhdGgpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgbGV0IGZuQm9keTtcclxuICAgICAgICAgICAgaWYgKGRlZi5wcm9wZXJ0eS5zdGFydHNXaXRoKCdbJykpIHtcclxuICAgICAgICAgICAgICAgIGZuQm9keSA9IGByZXR1cm4gZGF0dW0ke2RlZi5wcm9wZXJ0eX07YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZuQm9keSA9IGByZXR1cm4gZGF0dW0uJHtkZWYucHJvcGVydHl9O2A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W2RlZi5wcm9wZXJ0eV0gPSBuZXcgRnVuY3Rpb24oJ2RhdHVtJywgZm5Cb2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBsb2dQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBjb25zdCBsb2dWYWx1ZXMgPSAobmFtZSwgZGF0YSkgPT4ge1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhgRGF0YU1vZGVsLnByb2Nlc3NEYXRhKCkgLSAke25hbWV9YCk7XHJcbiAgICAgICAgICAgIExvZ2dlci50YWJsZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9nZ2VyLmxvZygnRGF0YU1vZGVsLnByb2Nlc3NEYXRhKCkgLSBwcm9jZXNzZWREYXRhJywgcHJvY2Vzc2VkRGF0YSk7XHJcbiAgICBsb2dWYWx1ZXMoJ0tleSBEb21haW5zJywgcHJvY2Vzc2VkRGF0YS5kb21haW4ua2V5cyk7XHJcbiAgICBsb2dWYWx1ZXMoJ0dyb3VwIERvbWFpbnMnLCAoX2EgPSBwcm9jZXNzZWREYXRhLmRvbWFpbi5ncm91cHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcclxuICAgIGxvZ1ZhbHVlcygnVmFsdWUgRG9tYWlucycsIHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlcyk7XHJcbiAgICBsb2dWYWx1ZXMoJ0FnZ3JlZ2F0ZSBEb21haW5zJywgKF9iID0gcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XHJcbiAgICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSAnZ3JvdXBlZCcpIHtcclxuICAgICAgICBjb25zdCBmbGF0dGVuZWRWYWx1ZXMgPSBwcm9jZXNzZWREYXRhLmRhdGEucmVkdWNlKChhY2MsIG5leHQpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IChfYSA9IG5leHQua2V5cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICAgICAgICAgIGNvbnN0IGFnZ1ZhbHVlcyA9IChfYiA9IG5leHQuYWdnVmFsdWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcclxuICAgICAgICAgICAgY29uc3Qgc2tpcEtleXMgPSBuZXh0LmtleXMubWFwKCgpID0+IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNraXBBZ2dWYWx1ZXMgPSBhZ2dWYWx1ZXMgPT09IG51bGwgfHwgYWdnVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZ2dWYWx1ZXMubWFwKCgpID0+IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGFjYy5wdXNoKC4uLm5leHQudmFsdWVzLm1hcCgodiwgaSkgPT4gW1xyXG4gICAgICAgICAgICAgICAgLi4uKGkgPT09IDAgPyBrZXlzIDogc2tpcEtleXMpLFxyXG4gICAgICAgICAgICAgICAgLi4uKHYgIT09IG51bGwgJiYgdiAhPT0gdm9pZCAwID8gdiA6IFtdKSxcclxuICAgICAgICAgICAgICAgIC4uLihpID09IDAgPyBhZ2dWYWx1ZXMgOiBza2lwQWdnVmFsdWVzKSxcclxuICAgICAgICAgICAgXSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICBsb2dWYWx1ZXMoJ1ZhbHVlcycsIGZsYXR0ZW5lZFZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBmbGF0dGVuZWRWYWx1ZXMgPSBwcm9jZXNzZWREYXRhLmRhdGEucmVkdWNlKChhY2MsIG5leHQpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBhZ2dWYWx1ZXMgPSAoX2EgPSBuZXh0LmFnZ1ZhbHVlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICAgICAgICAgIGFjYy5wdXNoKFsuLi5uZXh0LmtleXMsIC4uLm5leHQudmFsdWVzLCAuLi5hZ2dWYWx1ZXNdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgbG9nVmFsdWVzKCdWYWx1ZXMnLCBmbGF0dGVuZWRWYWx1ZXMpO1xyXG4gICAgfVxyXG59XG5cbi8qKiBJbXBsZW1lbnRzIGNyb3NzLXNlcmllcyBkYXRhIG1vZGVsIGNvb3JkaW5hdGlvbi4gKi9cclxuY2xhc3MgRGF0YUNvbnRyb2xsZXIge1xyXG4gICAgY29uc3RydWN0b3IobW9kZSkge1xyXG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCAnZGF0YS1tb2RlbCcpO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdGVkID0gW107XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnc2V0dXAnO1xyXG4gICAgfVxyXG4gICAgcmVxdWVzdChpZCwgZGF0YSwgb3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gJ3NldHVwJylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gZGF0YSByZXF1ZXN0IGFmdGVyIGRhdGEgc2V0dXAgcGhhc2UuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RlZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2I6IHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09ICdzZXR1cCcpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRhdGEgcmVxdWVzdCBhZnRlciBkYXRhIHNldHVwIHBoYXNlLmApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9ICdleGVjdXRlZCc7XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ0RhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIHJlcXVlc3RlZCcsIHRoaXMucmVxdWVzdGVkKTtcclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tZXJnZVJlcXVlc3RlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdEYXRhQ29udHJvbGxlci5leGVjdXRlKCkgLSBtZXJnZWQnLCBtZXJnZWQpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWJ1Z01vZGUgPSBEZWJ1Zy5jaGVjayh0cnVlLCAnZGF0YS1tb2RlbCcpO1xyXG4gICAgICAgICAgICBpZiAoZGVidWdNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucHJvY2Vzc2VkRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBvcHRzLCBkYXRhLCByZXN1bHRDYnMsIHJlamVjdHMsIGlkcyB9IG9mIG1lcmdlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhTW9kZWwgPSBuZXcgRGF0YU1vZGVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgbW9kZTogdGhpcy5tb2RlIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gZGF0YU1vZGVsLnByb2Nlc3NEYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Z01vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnByb2Nlc3NlZERhdGEucHVzaChwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZERhdGEgJiYgcHJvY2Vzc2VkRGF0YS5wYXJ0aWFsVmFsaWREYXRhQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2JzLmZvckVhY2goKGNiKSA9PiBjYih7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3NlZERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdFJlc3VsdChkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGlkcywgcmVzdWx0Q2JzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdHMuZm9yRWFjaCgoY2IpID0+IGNiKG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gbm8gcHJvY2Vzc2VkIGRhdGEgZ2VuZXJhdGVkYCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3RzLmZvckVhY2goKGNiKSA9PiBjYihlcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtZXJnZVJlcXVlc3RlZCgpIHtcclxuICAgICAgICBjb25zdCBncm91cGVkID0gW107XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IChwcm9wcykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHApID0+IHAudHlwZSA9PT0gJ2tleScpXHJcbiAgICAgICAgICAgICAgICAubWFwKChwKSA9PiBwLnByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJzsnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGdyb3VwTWF0Y2ggPSAoeyBvcHRzLCBkYXRhIH0pID0+IChncikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKGdyWzBdLmRhdGEgPT09IGRhdGEgJiZcclxuICAgICAgICAgICAgICAgIGdyWzBdLm9wdHMuZ3JvdXBCeUtleXMgPT09IG9wdHMuZ3JvdXBCeUtleXMgJiZcclxuICAgICAgICAgICAgICAgIGdyWzBdLm9wdHMuZGF0YVZpc2libGUgPT09IG9wdHMuZGF0YVZpc2libGUgJiZcclxuICAgICAgICAgICAgICAgIGdyWzBdLm9wdHMuZ3JvdXBCeUZuID09PSBvcHRzLmdyb3VwQnlGbiAmJlxyXG4gICAgICAgICAgICAgICAga2V5cyhnclswXS5vcHRzLnByb3BzKSA9PT0ga2V5cyhvcHRzLnByb3BzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwcm9wTWF0Y2ggPSAocHJvcCkgPT4gKGV4aXN0aW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nLnR5cGUgIT09IHByb3AudHlwZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IChfYSA9IGpzb25EaWZmKGV4aXN0aW5nLCBwcm9wKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkaWZmWydzY29wZXMnXTtcclxuICAgICAgICAgICAgZGVsZXRlIGRpZmZbJ2lkJ107XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkaWZmWydpZHMnXTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG1lcmdlT3B0cyA9IChvcHRzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHNbMF0pLCB7IHByb3BzOiBvcHRzLnJlZHVjZSgocmVzdWx0LCBuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIG5leHQucHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AuaWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gcHJvcC5pZHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChwcm9wLmlkcyA9IFtdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IHByb3Auc2NvcGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgoc2NvcGUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcHJvcC5pZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKFtzY29wZSwgcHJvcC5pZF0pOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlc3VsdC5maW5kKHByb3BNYXRjaChwcm9wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gbWF0Y2guc2NvcGVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAobWF0Y2guc2NvcGVzID0gW10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5zY29wZXMucHVzaCguLi4oKF9kID0gcHJvcC5zY29wZXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC50eXBlICE9PSAna2V5JyAmJiBtYXRjaC50eXBlICE9PSAndmFsdWUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChfZSA9IG1hdGNoLmlkcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnB1c2goLi4uKChfZiA9IHByb3AuaWRzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSwgW10pIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSAocHJvcHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlkczogcHJvcHMubWFwKCh7IGlkIH0pID0+IGlkKSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdENiczogcHJvcHMubWFwKCh7IHJlc3VsdENiIH0pID0+IHJlc3VsdENiKSxcclxuICAgICAgICAgICAgICAgIHJlamVjdHM6IHByb3BzLm1hcCgoeyByZWplY3QgfSkgPT4gcmVqZWN0KSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHByb3BzWzBdLmRhdGEsXHJcbiAgICAgICAgICAgICAgICBvcHRzOiBtZXJnZU9wdHMocHJvcHMubWFwKCh7IG9wdHMgfSkgPT4gb3B0cykpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHRoaXMucmVxdWVzdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gZ3JvdXBlZC5maW5kKGdyb3VwTWF0Y2gocmVxdWVzdCkpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoLnB1c2gocmVxdWVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBncm91cGVkLnB1c2goW3JlcXVlc3RdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ3JvdXBlZC5tYXAobWVyZ2UpO1xyXG4gICAgfVxyXG4gICAgc3BsaXRSZXN1bHQoZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBzY29wZXMsIHJlc3VsdENicykge1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzY29wZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gc2NvcGVzW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0Q2IgPSByZXN1bHRDYnNbaW5kZXhdO1xyXG4gICAgICAgICAgICByZXN1bHRDYih7XHJcbiAgICAgICAgICAgICAgICBkYXRhTW9kZWwsXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWREYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3NlZERhdGEpLCB7IGRhdGE6IHByb2Nlc3NlZERhdGEuZGF0YS5maWx0ZXIoKHsgdmFsaWRTY29wZXMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRTY29wZXMgPT0gbnVsbCB8fCB2YWxpZFNjb3Blcy5zb21lKChzKSA9PiBzID09PSBzY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkgfSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBEYXRhU2VydmljZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXRTZXJpZXMpIHtcclxuICAgICAgICB0aGlzLmdldFNlcmllcyA9IGdldFNlcmllcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBCYXNlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuICAgIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG1ldGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlciwgbWV0YSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lclN5bWJvbCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyU3ltYm9sKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBERUJVR19TRUxFQ1RPUlMgPSBbdHJ1ZSwgJ2FuaW1hdGlvbiddO1xyXG4vKipcclxuICogTWFuYWdlIGFuaW1hdGlvbnMgYWNyb3NzIGEgY2hhcnQsIHJ1bm5pbmcgYWxsIGFuaW1hdGlvbnMgdGhyb3VnaCBvbmx5IG9uZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjayxcclxuICogcHJldmVudGluZyBkdXBsaWNhdGUgYW5pbWF0aW9ucyBhbmQgaGFuZGxpbmcgdGhlaXIgbGlmZWN5Y2xlLlxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uTWFuYWdlciwgY2hhcnRVcGRhdGVNdXRleCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBpbnRlcmFjdGlvbk1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5jaGFydFVwZGF0ZU11dGV4ID0gY2hhcnRVcGRhdGVNdXRleDtcclxuICAgICAgICB0aGlzLmRlZmF1bHREdXJhdGlvbiA9IDEwMDA7XHJcbiAgICAgICAgdGhpcy5iYXRjaCA9IG5ldyBBbmltYXRpb25CYXRjaCgpO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUoLi4uREVCVUdfU0VMRUNUT1JTKTtcclxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNraXBBbmltYXRpb25zID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gdG8gdHdlZW4gYSB2YWx1ZSBiZXR3ZWVuIHRoZSBgZnJvbWAgYW5kIGB0b2AgcHJvcGVydGllcy4gSWYgYW4gYW5pbWF0aW9uIGFscmVhZHkgZXhpc3RzXHJcbiAgICAgKiB3aXRoIHRoZSBzYW1lIGBpZGAsIGltbWVkaWF0ZWx5IHN0b3AgaXQuXHJcbiAgICAgKi9cclxuICAgIGFuaW1hdGUoX2EpIHtcclxuICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgICAgIHZhciB7IGRpc2FibGVJbnRlcmFjdGlvbnMgPSB0cnVlLCBpbW11dGFibGUgPSB0cnVlIH0gPSBfYSwgb3B0cyA9IF9fcmVzdChfYSwgW1wiZGlzYWJsZUludGVyYWN0aW9uc1wiLCBcImltbXV0YWJsZVwiXSk7XHJcbiAgICAgICAgY29uc3QgeyBiYXRjaCB9ID0gdGhpcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAob3B0cy5pZCAhPSBudWxsICYmIGJhdGNoLmNvbnRyb2xsZXJzLmhhcyhvcHRzLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbW11dGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2guY29udHJvbGxlcnMuZ2V0KG9wdHMuaWQpLnJlc2V0KG9wdHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYmF0Y2guY29udHJvbGxlcnMuZ2V0KG9wdHMuaWQpLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYFNraXBwaW5nIGFuaW1hdGlvbiBiYXRjaCBkdWUgdG8gdXBkYXRlIG9mIGV4aXN0aW5nIGFuaW1hdGlvbjogJHtvcHRzLmlkfWApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaC5za2lwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZCA9IChfYiA9IG9wdHMuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBza2lwID0gdGhpcy5pc1NraXBwZWQoKTtcclxuICAgICAgICBpZiAoc2tpcCkge1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdBbmltYXRpb25NYW5hZ2VyIC0gc2tpcHBpbmcgYW5pbWF0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgaWQsXHJcbiAgICAgICAgICAgIHNraXAsIGF1dG9wbGF5OiB0aGlzLmlzUGxheWluZyA/IG9wdHMuYXV0b3BsYXkgOiBmYWxzZSwgZHVyYXRpb246IChfYyA9IG9wdHMuZHVyYXRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuZGVmYXVsdER1cmF0aW9uLCBvblBsYXk6IChjb250cm9sbGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5jb250cm9sbGVycy5zZXQoaWQsIGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZUludGVyYWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLnBhdXNlKCdhbmltYXRpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIChfYSA9IG9wdHMub25QbGF5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb250cm9sbGVyLCBjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgfSwgb25TdG9wOiAoY29udHJvbGxlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guY29udHJvbGxlcnMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlSW50ZXJhY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIucmVzdW1lKCdhbmltYXRpb24nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIChfYSA9IG9wdHMub25TdG9wKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjb250cm9sbGVyLCBjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgfSB9KSk7XHJcbiAgICB9XHJcbiAgICBwbGF5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUGxheWluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRlYnVnKCdBbmltYXRpb25NYW5hZ2VyLnBsYXkoKScpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmJhdGNoLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnBsYXkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oKTtcclxuICAgIH1cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZygnQW5pbWF0aW9uTWFuYWdlci5wYXVzZSgpJyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuYmF0Y2guY29udHJvbGxlcnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIucGF1c2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xyXG4gICAgICAgIHRoaXMuZGVidWcoJ0FuaW1hdGlvbk1hbmFnZXIuc3RvcCgpJyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuYmF0Y2guY29udHJvbGxlcnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3BCeUFuaW1hdGlvbklkKGlkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsICYmIHRoaXMuYmF0Y2guY29udHJvbGxlcnMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5iYXRjaC5jb250cm9sbGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wQnlBbmltYXRpb25Hcm91cElkKGlkKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuYmF0Y2guY29udHJvbGxlcnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuZ3JvdXBJZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEJ5QW5pbWF0aW9uSWQoY29udHJvbGxlci5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2tpcChza2lwID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBza2lwO1xyXG4gICAgfVxyXG4gICAgaXNTa2lwcGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNraXBBbmltYXRpb25zIHx8IHRoaXMuYmF0Y2guaXNTa2lwcGVkKCk7XHJcbiAgICB9XHJcbiAgICBpc0FjdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1BsYXlpbmcgJiYgdGhpcy5iYXRjaC5pc0FjdGl2ZSgpO1xyXG4gICAgfVxyXG4gICAgc2tpcEN1cnJlbnRCYXRjaCgpIHtcclxuICAgICAgICBpZiAoRGVidWcuY2hlY2soLi4uREVCVUdfU0VMRUNUT1JTKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25NYW5hZ2VyIC0gc2tpcEN1cnJlbnRCYXRjaCgpYCwgeyBzdGFjazogbmV3IEVycm9yKCkuc3RhY2sgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmF0Y2guc2tpcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIGd1YXJhbnRlZSB0aGF0IGFuaW1hdGlvbiB1cGRhdGVzIGhhcHBlbi4gKi9cclxuICAgIGlzU2tpcHBpbmdGcmFtZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKiogTW9ja2luZyBwb2ludCBmb3IgdGVzdHMgdG8gY2FwdHVyZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2tzLiAqL1xyXG4gICAgc2NoZWR1bGVBbmltYXRpb25GcmFtZShjYikge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcclxuICAgIH1cclxuICAgIHJlcXVlc3RBbmltYXRpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoLmlzQWN0aXZlKCkgfHwgdGhpcy5yZXF1ZXN0SWQgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBsZXQgcHJldlRpbWU7XHJcbiAgICAgICAgY29uc3Qgb25BbmltYXRpb25GcmFtZSA9ICh0aW1lKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVBbmltYXRpb25GcmFtZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhVGltZSA9IHRpbWUgLSAocHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgIT09IHZvaWQgMCA/IHByZXZUaW1lIDogdGltZSk7XHJcbiAgICAgICAgICAgICAgICBwcmV2VGltZSA9IHRpbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdBbmltYXRpb25NYW5hZ2VyIC0gb25BbmltYXRpb25GcmFtZSgpJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJzQ291bnQ6IHRoaXMuYmF0Y2guY29udHJvbGxlcnMuc2l6ZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuYmF0Y2guY29udHJvbGxlcnMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKCdhbmltYXRpb24tZnJhbWUnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FuaW1hdGlvbi1mcmFtZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFNczogZGVsdGFUaW1lLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NraXBwaW5nRnJhbWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBhbmltYXRpb24gZnJhbWUgaWYgd2UgY2FuIGFjcXVpcmUgdGhlIGNoYXJ0IHVwZGF0ZSBtdXRleCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlSW1tZWRpYXRlbHkoZXhlY3V0ZUFuaW1hdGlvbkZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGF2YWlsYWJsZSBwb2ludCB3ZSBjYW4gZXhlY3V0ZS5cclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlKGV4ZWN1dGVBbmltYXRpb25GcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2guaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUFuaW1hdGlvbkZyYW1lKG9uQW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zY2hlZHVsZUFuaW1hdGlvbkZyYW1lKG9uQW5pbWF0aW9uRnJhbWUpO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsQW5pbWF0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RJZCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdElkKTtcclxuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKCk7XHJcbiAgICB9XHJcbiAgICBmYWlsc2FmZU9uRXJyb3IoZXJyb3IsIGNhbmNlbEFuaW1hdGlvbiA9IHRydWUpIHtcclxuICAgICAgICBMb2dnZXIuZXJyb3IoJ0Vycm9yIGR1cmluZyBhbmltYXRpb24sIHNraXBwaW5nIGFuaW1hdGlvbnMnLCBlcnJvcik7XHJcbiAgICAgICAgaWYgKGNhbmNlbEFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0QmF0Y2goc2tpcEFuaW1hdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25NYW5hZ2VyIC0gc3RhcnRCYXRjaCgpIHdpdGggc2tpcEFuaW1hdGlvbnM9JHtza2lwQW5pbWF0aW9uc30uYCk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuYmF0Y2guZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuYmF0Y2ggPSBuZXcgQW5pbWF0aW9uQmF0Y2goKTtcclxuICAgICAgICBpZiAoc2tpcEFuaW1hdGlvbnMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXRjaC5za2lwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5kQmF0Y2goKSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uTWFuYWdlciAtIGVuZEJhdGNoKCkgd2l0aCAke3RoaXMuYmF0Y2guY29udHJvbGxlcnMuc2l6ZX0gYW5pbWF0aW9uczsgc2tpcHBlZDogJHt0aGlzLmJhdGNoLmlzU2tpcHBlZCgpfS5gKTtcclxuICAgICAgICBpZiAodGhpcy5iYXRjaC5pc1NraXBwZWQoKSAmJiAhdGhpcy5iYXRjaC5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2guc2tpcChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGJhdGNoIG9mIGFuaW1hdGlvbnMgdGhhdCBhcmUgc3luY2hyb25pc2VkIHRvZ2V0aGVyLiBDYW4gYmUgc2tpcHBlZCBpbmRlcGVuZGVudGx5IG9mIG90aGVyIGJhdGNoZXMgYW5kIHRoZSBtYWluXHJcbiAqIGFuaW1hdGlvbiBza2lwcGluZyBzdGF0dXMuXHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb25CYXRjaCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIHByaXZhdGUgcGhhc2U/OiAnaW5pdGlhbC1sb2FkJyB8ICdyZW1vdmUnIHwgJ3VwZGF0ZScgfCAnYWRkJztcclxuICAgIGlzQWN0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzLnNpemUgPiAwO1xyXG4gICAgfVxyXG4gICAgc2tpcChza2lwID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNraXBBbmltYXRpb25zID09PSBmYWxzZSAmJiBza2lwID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJzLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBza2lwO1xyXG4gICAgfVxyXG4gICAgaXNTa2lwcGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNraXBBbmltYXRpb25zO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHsgfVxyXG59XG5cbmNsYXNzIENoYXJ0RXZlbnRNYW5hZ2VyIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xyXG4gICAgbGVnZW5kSXRlbUNsaWNrKHNlcmllcywgaXRlbUlkLCBlbmFibGVkLCBsZWdlbmRJdGVtTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnbGVnZW5kLWl0ZW0tY2xpY2snLFxyXG4gICAgICAgICAgICBzZXJpZXMsXHJcbiAgICAgICAgICAgIGl0ZW1JZCxcclxuICAgICAgICAgICAgZW5hYmxlZCxcclxuICAgICAgICAgICAgbGVnZW5kSXRlbU5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaCgnbGVnZW5kLWl0ZW0tY2xpY2snLCBldmVudCk7XHJcbiAgICB9XHJcbiAgICBsZWdlbmRJdGVtRG91YmxlQ2xpY2soc2VyaWVzLCBpdGVtSWQsIGVuYWJsZWQsIG51bVZpc2libGVJdGVtcywgbGVnZW5kSXRlbU5hbWUpIHtcclxuICAgICAgICBjb25zdCBldmVudCA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2xlZ2VuZC1pdGVtLWRvdWJsZS1jbGljaycsXHJcbiAgICAgICAgICAgIHNlcmllcyxcclxuICAgICAgICAgICAgaXRlbUlkLFxyXG4gICAgICAgICAgICBlbmFibGVkLFxyXG4gICAgICAgICAgICBsZWdlbmRJdGVtTmFtZSxcclxuICAgICAgICAgICAgbnVtVmlzaWJsZUl0ZW1zLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goJ2xlZ2VuZC1pdGVtLWRvdWJsZS1jbGljaycsIGV2ZW50KTtcclxuICAgIH1cclxuICAgIGF4aXNIb3ZlcihheGlzSWQsIGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnYXhpcy1ob3ZlcicsXHJcbiAgICAgICAgICAgIGF4aXNJZCxcclxuICAgICAgICAgICAgZGlyZWN0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goJ2F4aXMtaG92ZXInLCBldmVudCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIE1hbmFnZXMgdGhlIGN1cnNvciBzdHlsaW5nIGZvciBhbiBlbGVtZW50LiBUcmFja3MgdGhlIHJlcXVlc3RlZCBzdHlsaW5nIGZyb20gZGlzdGluY3RcclxuICogZGVwZW5kZW50cyBhbmQgaGFuZGxlcyBjb25mbGljdGluZyBzdHlsaW5nIHJlcXVlc3RzLlxyXG4gKi9cclxuY2xhc3MgQ3Vyc29yTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ3Vyc29yKGNhbGxlcklkLCBzdHlsZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0YXRlc1tjYWxsZXJJZF07XHJcbiAgICAgICAgaWYgKHN0eWxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZXNbY2FsbGVySWRdID0geyBzdHlsZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XHJcbiAgICB9XHJcbiAgICBhcHBseVN0YXRlcygpIHtcclxuICAgICAgICBsZXQgc3R5bGVUb0FwcGx5ID0gJ2RlZmF1bHQnO1xyXG4gICAgICAgIC8vIExhc3QgYWRkZWQgZW50cnkgd2lucy5cclxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnN0YXRlcylcclxuICAgICAgICAgICAgLnJldmVyc2UoKVxyXG4gICAgICAgICAgICAuc2xpY2UoMCwgMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKFtfLCB7IHN0eWxlIH1dKSA9PiAoc3R5bGVUb0FwcGx5ID0gc3R5bGUpKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGVUb0FwcGx5O1xyXG4gICAgfVxyXG4gICAgZ2V0Q3Vyc29yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBNYW5hZ2VzIHRoZSBhY3RpdmVseSBoaWdobGlnaHRlZCBzZXJpZXMvZGF0dW0gZm9yIGEgY2hhcnQuIFRyYWNrcyB0aGUgcmVxdWVzdGVkIGhpZ2hsaWdodHMgZnJvbVxyXG4gKiBkaXN0aW5jdCBkZXBlbmRlbnRzIGFuZCBoYW5kbGVzIGNvbmZsaWN0aW5nIGhpZ2hsaWdodCByZXF1ZXN0cy5cclxuICovXHJcbmNsYXNzIEhpZ2hsaWdodE1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U3RhdGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucGlja2VkU3RhdGVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSGlnaGxpZ2h0KGNhbGxlcklkLCBoaWdobGlnaHRlZERhdHVtKSB7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTdGF0ZXMuZGVsZXRlKGNhbGxlcklkKTtcclxuICAgICAgICBpZiAoaGlnaGxpZ2h0ZWREYXR1bSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0U3RhdGVzLnNldChjYWxsZXJJZCwgaGlnaGxpZ2h0ZWREYXR1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwbHlIaWdobGlnaHRTdGF0ZXMoKTtcclxuICAgIH1cclxuICAgIGdldEFjdGl2ZUhpZ2hsaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVIaWdobGlnaHQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQaWNrZWQoY2FsbGVySWQsIGNsaWNrYWJsZURhdHVtKSB7XHJcbiAgICAgICAgdGhpcy5waWNrZWRTdGF0ZXMuZGVsZXRlKGNhbGxlcklkKTtcclxuICAgICAgICBpZiAoY2xpY2thYmxlRGF0dW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnBpY2tlZFN0YXRlcy5zZXQoY2FsbGVySWQsIGNsaWNrYWJsZURhdHVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcHBseVBpY2tlZFN0YXRlcygpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWN0aXZlUGlja2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVBpY2tlZDtcclxuICAgIH1cclxuICAgIGFwcGx5SGlnaGxpZ2h0U3RhdGVzKCkge1xyXG4gICAgICAgIC8vIExhc3QgYWRkZWQgZW50cnkgd2lucy5cclxuICAgICAgICBjb25zdCB7IGFjdGl2ZUhpZ2hsaWdodDogcHJldmlvdXNIaWdobGlnaHQgfSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVIaWdobGlnaHQgPSBBcnJheS5mcm9tKHRoaXMuaGlnaGxpZ2h0U3RhdGVzLnZhbHVlcygpKS5wb3AoKTtcclxuICAgICAgICBpZiAoIXRoaXMuaXNFcXVhbCh0aGlzLmFjdGl2ZUhpZ2hsaWdodCwgcHJldmlvdXNIaWdobGlnaHQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKCdoaWdobGlnaHQtY2hhbmdlJywge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZ2hsaWdodC1jaGFuZ2UnLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudEhpZ2hsaWdodDogdGhpcy5hY3RpdmVIaWdobGlnaHQsXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c0hpZ2hsaWdodCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXBwbHlQaWNrZWRTdGF0ZXMoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVQaWNrZWQgPSBBcnJheS5mcm9tKHRoaXMucGlja2VkU3RhdGVzLnZhbHVlcygpKS5wb3AoKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhID09PSBiIHx8ICgoYSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLnNlcmllcykgPT09IChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIuc2VyaWVzKSAmJiAoYSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLml0ZW1JZCkgPT09IChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIuaXRlbUlkKSAmJiAoYSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLmRhdHVtKSA9PT0gKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5kYXR1bSkpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IFdJTkRPV19FVkVOVF9IQU5ETEVSUyA9IFsncGFnZWhpZGUnLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnXTtcclxuY29uc3QgRVZFTlRfSEFORExFUlMgPSBbXHJcbiAgICAnY2xpY2snLFxyXG4gICAgJ2RibGNsaWNrJyxcclxuICAgICdjb250ZXh0bWVudScsXHJcbiAgICAnbW91c2Vkb3duJyxcclxuICAgICdtb3VzZW91dCcsXHJcbiAgICAnbW91c2VlbnRlcicsXHJcbiAgICAndG91Y2hzdGFydCcsXHJcbiAgICAndG91Y2htb3ZlJyxcclxuICAgICd0b3VjaGVuZCcsXHJcbiAgICAndG91Y2hjYW5jZWwnLFxyXG4gICAgJ3doZWVsJyxcclxuXTtcclxuY29uc3QgQ1NTID0gYFxuLmFnLWNoYXJ0LXdyYXBwZXIge1xuICAgIHRvdWNoLWFjdGlvbjogbm9uZTtcbn1cbmA7XHJcbi8qKlxyXG4gKiBNYW5hZ2VzIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggYSBzcGVjaWZpYyBIVE1MRWxlbWVudCAob3IgaW50ZXJhY3Rpb25zIHRoYXQgYnViYmxlIGZyb20gaXQnc1xyXG4gKiBjaGlsZHJlbilcclxuICovXHJcbmNsYXNzIEludGVyYWN0aW9uTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGRvY3VtZW50LCB3aW5kb3cpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gKGV2ZW50KSA9PiB0aGlzLnByb2Nlc3NFdmVudChldmVudCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvdWNoRG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGF1c2VycyA9IHsgYW5pbWF0aW9uOiAwLCAnY29udGV4dC1tZW51JzogMCB9O1xyXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XHJcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIEVWRU5UX0hBTkRMRVJTKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3RvdWNoJykpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICd3aGVlbCcpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFdJTkRPV19FVkVOVF9IQU5ETEVSUykge1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFJbnRlcmFjdGlvbk1hbmFnZXIuaW50ZXJhY3Rpb25Eb2N1bWVudHMuaW5jbHVkZXMoZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGluamVjdFN0eWxlKGRvY3VtZW50LCBDU1MpO1xyXG4gICAgICAgICAgICBJbnRlcmFjdGlvbk1hbmFnZXIuaW50ZXJhY3Rpb25Eb2N1bWVudHMucHVzaChkb2N1bWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgV0lORE9XX0VWRU5UX0hBTkRMRVJTKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgRVZFTlRfSEFORExFUlMpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VtZShwYXVzZVR5cGUpIHtcclxuICAgICAgICB0aGlzLnBhdXNlcnNbcGF1c2VUeXBlXS0tO1xyXG4gICAgfVxyXG4gICAgcGF1c2UocGF1c2VUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5wYXVzZXJzW3BhdXNlVHlwZV0rKztcclxuICAgIH1cclxuICAgIHByb2Nlc3NFdmVudChldmVudCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5kZWNpZGVJbnRlcmFjdGlvbkV2ZW50VHlwZXMoZXZlbnQpO1xyXG4gICAgICAgIGlmICh0eXBlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIEFzeW5jIGRpc3BhdGNoIHRvIGF2b2lkIGJsb2NraW5nIHRoZSBldmVudC1wcm9jZXNzaW5nIHRocmVhZC5cclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0eXBlcykuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHR5cGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5jYWxjdWxhdGVDb29yZGluYXRlcyhldmVudCk7XHJcbiAgICAgICAgICAgIGlmIChjb29yZHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdXNlcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMucGF1c2VycylcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFssIGNvdW50XSkgPT4gY291bnQgPiAwKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoW3BhdXNlXSkgPT4gcGF1c2UpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoV3JhcEhhbmRsZXJzKHR5cGUsIChoYW5kbGVyLCBtZXRhLCBpbnRlcmFjdGlvbkV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXVzZXMubGVuZ3RoID4gMCAmJiAhKChfYSA9IG1ldGEgPT09IG51bGwgfHwgbWV0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YS5ieXBhc3NQYXVzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKHApID0+IHBhdXNlcy5pbmNsdWRlcyhwKSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGlvbkV2ZW50LmNvbnN1bWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoaW50ZXJhY3Rpb25FdmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5idWlsZEV2ZW50KE9iamVjdC5hc3NpZ24oeyB0eXBlLCBldmVudCwgcGF1c2VzIH0sIGNvb3JkcykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVjaWRlSW50ZXJhY3Rpb25FdmVudFR5cGVzKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgZHJhZ1N0YXJ0ID0gJ2RyYWctc3RhcnQnO1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdjbGljayc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydjbGljayddO1xyXG4gICAgICAgICAgICBjYXNlICdkYmxjbGljayc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkYmxjbGljayddO1xyXG4gICAgICAgICAgICBjYXNlICdjb250ZXh0bWVudSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydjb250ZXh0bWVudSddO1xyXG4gICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtkcmFnU3RhcnRdO1xyXG4gICAgICAgICAgICBjYXNlICd0b3VjaHN0YXJ0JzpcclxuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hEb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZHJhZ1N0YXJ0XTtcclxuICAgICAgICAgICAgY2FzZSAndG91Y2htb3ZlJzpcclxuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tb3VzZURvd24gJiYgIXRoaXMudG91Y2hEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlc2UgZXZlbnRzIGlmIHRoZSB0YXJnZXQgaXMgdGhlIGNhbnZhcywgdW5sZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIGRyYWcvc2xpZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duIHx8IHRoaXMudG91Y2hEb3duID8gWydkcmFnJ10gOiBbJ2hvdmVyJ107XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93biAmJiAhdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IHRoZXNlIGV2ZW50cyBpZiB0aGUgdGFyZ2V0IGlzIHRoZSBjYW52YXMsIHVubGVzc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSBkcmFnLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydEVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkcmFnLWVuZCddO1xyXG4gICAgICAgICAgICBjYXNlICd0b3VjaGVuZCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudG91Y2hEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlc2UgZXZlbnRzIGlmIHRoZSB0YXJnZXQgaXMgdGhlIGNhbnZhcywgdW5sZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHNsaWRlLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hEb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydEVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkcmFnLWVuZCddO1xyXG4gICAgICAgICAgICBjYXNlICdtb3VzZW91dCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvdWNoY2FuY2VsJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2xlYXZlJ107XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VCdXR0b25Eb3duID0gZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ICYmIChldmVudC5idXR0b25zICYgMSkgPT09IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3VzZURvd24gIT09IG1vdXNlQnV0dG9uRG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW91c2VEb3duID0gbW91c2VCdXR0b25Eb3duO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbW91c2VCdXR0b25Eb3duID8gZHJhZ1N0YXJ0IDogJ2RyYWctZW5kJ107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIGNhc2UgJ3BhZ2VoaWRlJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ3BhZ2UtbGVmdCddO1xyXG4gICAgICAgICAgICBjYXNlICd3aGVlbCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWyd3aGVlbCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBpc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5lbGVtZW50IHx8ICgoX2EgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50KSA9PT0gdGhpcy5lbGVtZW50O1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlQ29vcmRpbmF0ZXMoZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSwgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpeE9mZnNldHMoZXZlbnQsIHsgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZLCBvZmZzZXRYLCBvZmZzZXRZIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgVG91Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RUb3VjaCA9IChfYSA9IGV2ZW50LnRvdWNoZXNbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSB9ID0gbGFzdFRvdWNoO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBJbnRlcmFjdGlvbk1hbmFnZXIuTlVMTF9DT09SRFMpLCB7IGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBQYWdlVHJhbnNpdGlvbkV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGZpcmUgdGhlIHBhZ2UtbGVmdCBldmVudCBzaW5jZSB0aGUgcGFnZSBtYXliZSByZXZpc2l0ZWQuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVW5zdXBwb3J0ZWQgZXZlbnQgLSBhYm9ydC5cclxuICAgIH1cclxuICAgIGZpeE9mZnNldHMoZXZlbnQsIGNvb3Jkcykge1xyXG4gICAgICAgIGNvbnN0IG9mZnNldHMgPSAoZWwpID0+IHtcclxuICAgICAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgICAgICBsZXQgeSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xyXG4gICAgICAgICAgICAgICAgeCArPSBlbC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgeSArPSBlbC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5kcmFnU3RhcnRFbGVtZW50ICE9IG51bGwgJiYgZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRyYWdTdGFydEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLy8gT2Zmc2V0cyBuZWVkIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBkcmFnLXN0YXJ0IGVsZW1lbnQgdG8gYXZvaWQganVtcHMgd2hlblxyXG4gICAgICAgICAgICAvLyB0aGUgcG9pbnRlciBtb3ZlcyBiZXR3ZWVuIGVsZW1lbnQgYm91bmRhcmllcy5cclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0RHJhZ1N0YXJ0ID0gb2Zmc2V0cyh0aGlzLmRyYWdTdGFydEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRFdmVudCA9IG9mZnNldHMoZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgY29vcmRzLm9mZnNldFggLT0gb2Zmc2V0RHJhZ1N0YXJ0LnggLSBvZmZzZXRFdmVudC54O1xyXG4gICAgICAgICAgICBjb29yZHMub2Zmc2V0WSAtPSBvZmZzZXREcmFnU3RhcnQueSAtIG9mZnNldEV2ZW50Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb29yZHM7XHJcbiAgICB9XHJcbiAgICBidWlsZEV2ZW50KG9wdHMpIHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIGV2ZW50LCBjbGllbnRYLCBjbGllbnRZLCBwYXVzZXMgfSA9IG9wdHM7XHJcbiAgICAgICAgbGV0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgcGFnZVgsIHBhZ2VZIH0gPSBvcHRzO1xyXG4gICAgICAgIGlmICghaXNOdW1iZXIob2Zmc2V0WCkgfHwgIWlzTnVtYmVyKG9mZnNldFkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIG9mZnNldFggPSBjbGllbnRYIC0gcmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICBvZmZzZXRZID0gY2xpZW50WSAtIHJlY3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzTnVtYmVyKHBhZ2VYKSB8fCAhaXNOdW1iZXIocGFnZVkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VSZWN0ID0gdGhpcy5yb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgcGFnZVggPSBjbGllbnRYIC0gcGFnZVJlY3QubGVmdDtcclxuICAgICAgICAgICAgcGFnZVkgPSBjbGllbnRZIC0gcGFnZVJlY3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBidWlsdEV2ZW50ID0ge1xyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBvZmZzZXRYOiBvZmZzZXRYLFxyXG4gICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZLFxyXG4gICAgICAgICAgICBwYWdlWDogcGFnZVgsXHJcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcclxuICAgICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgICAgICBjb25zdW1lZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhdXNlcyxcclxuICAgICAgICAgICAgY29uc3VtZSgpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWx0RXZlbnQuY29uc3VtZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGJ1aWx0RXZlbnQ7XHJcbiAgICB9XHJcbn1cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLmludGVyYWN0aW9uRG9jdW1lbnRzID0gW107XHJcbkludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUyA9IHtcclxuICAgIGNsaWVudFg6IC1JbmZpbml0eSxcclxuICAgIGNsaWVudFk6IC1JbmZpbml0eSxcclxuICAgIHBhZ2VYOiAtSW5maW5pdHksXHJcbiAgICBwYWdlWTogLUluZmluaXR5LFxyXG4gICAgb2Zmc2V0WDogLUluZmluaXR5LFxyXG4gICAgb2Zmc2V0WTogLUluZmluaXR5LFxyXG59O1xuXG4vKipcclxuICogTWFuYWdlcyB0aGUgdG9vbHRpcCBIVE1MIGFuIGVsZW1lbnQuIFRyYWNrcyB0aGUgcmVxdWVzdGVkIEhUTUwgZnJvbSBkaXN0aW5jdCBkZXBlbmRlbnRzIGFuZFxyXG4gKiBoYW5kbGVzIGNvbmZsaWN0aW5nIHRvb2x0aXAgcmVxdWVzdHMuXHJcbiAqL1xyXG5jbGFzcyBUb29sdGlwTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0b29sdGlwLCBpbnRlcmFjdGlvbk1hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXhjbHVzaXZlQXJlYXMgPSB7fTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcignaG92ZXInLCAoZSkgPT4gdGhpcy5jaGVja0V4Y2x1c2l2ZVJlY3RzKGUpKSk7XHJcbiAgICB9XHJcbiAgICBnZXRSYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwLnJhbmdlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVG9vbHRpcChjYWxsZXJJZCwgbWV0YSwgY29udGVudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSAoX2EgPSB0aGlzLnN0YXRlc1tjYWxsZXJJZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlc1tjYWxsZXJJZF0gPSB7IGNvbnRlbnQsIG1ldGEgfTtcclxuICAgICAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVFeGNsdXNpdmVSZWN0KGNhbGxlcklkLCBhcmVhKSB7XHJcbiAgICAgICAgaWYgKGFyZWEpIHtcclxuICAgICAgICAgICAgdGhpcy5leGNsdXNpdmVBcmVhc1tjYWxsZXJJZF0gPSBhcmVhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXhjbHVzaXZlQXJlYXNbY2FsbGVySWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZVRvb2x0aXAoY2FsbGVySWQpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5zdGF0ZXNbY2FsbGVySWRdO1xyXG4gICAgICAgIHRoaXMuYXBwbHlTdGF0ZXMoKTtcclxuICAgIH1cclxuICAgIGdldFRvb2x0aXBNZXRhKGNhbGxlcklkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0YXRlc1tjYWxsZXJJZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXRhO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlc3Ryb3lGbiBvZiB0aGlzLmRlc3Ryb3lGbnMpIHtcclxuICAgICAgICAgICAgZGVzdHJveUZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hlY2tFeGNsdXNpdmVSZWN0cyhlKSB7XHJcbiAgICAgICAgbGV0IG5ld0FwcGxpZWRFeGNsdXNpdmVBcmVhO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5SWQsIGFyZWFdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZXhjbHVzaXZlQXJlYXMpKSB7XHJcbiAgICAgICAgICAgIGlmICghYXJlYS5jb250YWluc1BvaW50KGUub2Zmc2V0WCwgZS5vZmZzZXRZKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3QXBwbGllZEV4Y2x1c2l2ZUFyZWEgPSBlbnRyeUlkO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5ld0FwcGxpZWRFeGNsdXNpdmVBcmVhID09PSB0aGlzLmFwcGxpZWRFeGNsdXNpdmVBcmVhKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcHBsaWVkRXhjbHVzaXZlQXJlYSA9IG5ld0FwcGxpZWRFeGNsdXNpdmVBcmVhO1xyXG4gICAgICAgIHRoaXMuYXBwbHlTdGF0ZXMoKTtcclxuICAgIH1cclxuICAgIGFwcGx5U3RhdGVzKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBpZHMgPSB0aGlzLmFwcGxpZWRFeGNsdXNpdmVBcmVhID8gW3RoaXMuYXBwbGllZEV4Y2x1c2l2ZUFyZWFdIDogT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpO1xyXG4gICAgICAgIGxldCBjb250ZW50VG9BcHBseTtcclxuICAgICAgICBsZXQgbWV0YVRvQXBwbHk7XHJcbiAgICAgICAgLy8gTGFzdCBhZGRlZCBlbnRyeSB3aW5zLlxyXG4gICAgICAgIGlkcy5yZXZlcnNlKCk7XHJcbiAgICAgICAgaWRzLnNsaWNlKDAsIDEpLmZvckVhY2goKGlkKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgeyBjb250ZW50LCBtZXRhIH0gPSAoX2EgPSB0aGlzLnN0YXRlc1tpZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xyXG4gICAgICAgICAgICBjb250ZW50VG9BcHBseSA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIG1ldGFUb0FwcGx5ID0gbWV0YTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobWV0YVRvQXBwbHkgPT09IHVuZGVmaW5lZCB8fCBjb250ZW50VG9BcHBseSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbGllZFN0YXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAudG9nZ2xlKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuYXBwbGllZFN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudCkgPT09IGNvbnRlbnRUb0FwcGx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlckluc3RhbnRseSA9IHRoaXMudG9vbHRpcC5pc1Zpc2libGUoKTtcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLnNob3cobWV0YVRvQXBwbHksIHVuZGVmaW5lZCwgcmVuZGVySW5zdGFudGx5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zaG93KG1ldGFUb0FwcGx5LCBjb250ZW50VG9BcHBseSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwbGllZFN0YXRlID0geyBjb250ZW50OiBjb250ZW50VG9BcHBseSwgbWV0YTogbWV0YVRvQXBwbHkgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYWtlVG9vbHRpcE1ldGEoZXZlbnQsIGNhbnZhcywgZGF0dW0sIHdpbmRvdykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBjb25zdCB7IHBhZ2VYLCBwYWdlWSwgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHhPZmZzZXQ6IGRhdHVtLnNlcmllcy50b29sdGlwLnBvc2l0aW9uLnhPZmZzZXQsXHJcbiAgICAgICAgICAgIHlPZmZzZXQ6IGRhdHVtLnNlcmllcy50b29sdGlwLnBvc2l0aW9uLnlPZmZzZXQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBtZXRhID0ge1xyXG4gICAgICAgICAgICBwYWdlWCxcclxuICAgICAgICAgICAgcGFnZVksXHJcbiAgICAgICAgICAgIG9mZnNldFgsXHJcbiAgICAgICAgICAgIG9mZnNldFksXHJcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcclxuICAgICAgICAgICAgc2hvd0Fycm93OiBkYXR1bS5zZXJpZXMudG9vbHRpcC5zaG93QXJyb3csXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gT24gbGluZSBhbmQgc2NhdHRlciBzZXJpZXMsIHRoZSB0b29sdGlwIGNvdmVycyB0aGUgdG9wIG9mIGVycm9yYmFycyB3aGVuIHVzaW5nXHJcbiAgICAgICAgLy8gZGF0dW0ubWlkUG9pbnQuIFVzaW5nIGRhdHVtLnlCYXIudXBwZXJQb2ludCByZW5kZXJzIHRoZSB0b29sdGlwIGhpZ2hlciB1cC5cclxuICAgICAgICBjb25zdCByZWZQb2ludCA9IChfYiA9IChfYSA9IGRhdHVtLnlCYXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cHBlclBvaW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkYXR1bS5taWRQb2ludDtcclxuICAgICAgICBpZiAoZGF0dW0uc2VyaWVzLnRvb2x0aXAucG9zaXRpb24udHlwZSA9PT0gJ25vZGUnICYmIHJlZlBvaW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcmVmUG9pbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZGF0dW0uc2VyaWVzLmNvbnRlbnRHcm91cC5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWV0YSksIHsgcGFnZVg6IE1hdGgucm91bmQoY2FudmFzUmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFggKyBwb2ludC54KSwgcGFnZVk6IE1hdGgucm91bmQoY2FudmFzUmVjdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSArIHBvaW50LnkpLCBvZmZzZXRYOiBNYXRoLnJvdW5kKHBvaW50LngpLCBvZmZzZXRZOiBNYXRoLnJvdW5kKHBvaW50LnkpIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXRhLmVuYWJsZUludGVyYWN0aW9uID0gKF9kID0gKF9jID0gZGF0dW0uc2VyaWVzLnRvb2x0aXAuaW50ZXJhY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lbmFibGVkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gbWV0YTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogTWFuYWdlcyB0aGUgY3VycmVudCB6b29tIHN0YXRlIGZvciBhIGNoYXJ0LiBUcmFja3MgdGhlIHJlcXVlc3RlZCB6b29tIGZyb20gZGlzdGluY3QgZGVwZW5kZW50c1xyXG4gKiBhbmQgaGFuZGxlcyBjb25mbGljdGluZyB6b29tIHJlcXVlc3RzLlxyXG4gKi9cclxuY2xhc3MgWm9vbU1hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuYXhlcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQXhlcyhheGVzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRBeGVzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLmF4ZXMpKTtcclxuICAgICAgICBheGVzLmZvckVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgICAgICAgICByZW1vdmVkQXhlcy5kZWxldGUoYXhpcy5pZCk7XHJcbiAgICAgICAgICAgIChfYSA9IChfYiA9IHRoaXMuYXhlcylbX2MgPSBheGlzLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iW19jXSA9IG5ldyBBeGlzWm9vbU1hbmFnZXIoYXhpcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlbW92ZWRBeGVzLmZvckVhY2goKGF4aXNJZCkgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5heGVzW2F4aXNJZF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuaW5pdGlhbFpvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXdab29tKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlWm9vbSh0aGlzLmluaXRpYWxab29tLmNhbGxlcklkLCB0aGlzLmluaXRpYWxab29tLm5ld1pvb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRpYWxab29tID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSkge1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmF4ZXMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxab29tID0geyBjYWxsZXJJZCwgbmV3Wm9vbSB9O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5heGVzKS5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGF4aXMudXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSA9PT0gbnVsbCB8fCBuZXdab29tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdab29tW2F4aXMuZ2V0RGlyZWN0aW9uKCldKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVBeGlzWm9vbShjYWxsZXJJZCwgYXhpc0lkLCBuZXdab29tKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuYXhlc1theGlzSWRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSk7XHJcbiAgICAgICAgdGhpcy5hcHBseVN0YXRlcygpO1xyXG4gICAgfVxyXG4gICAgZ2V0Wm9vbSgpIHtcclxuICAgICAgICBsZXQgeDtcclxuICAgICAgICBsZXQgeTtcclxuICAgICAgICAvLyBUT0RPOiB0aGlzIG9ubHkgd29ya3Mgd2hlbiB0aGVyZSBpcyBhIHNpbmdsZSBheGlzIG9uIGVhY2ggZGlyZWN0aW9uIGFzIGl0IGdldHMgdGhlIGxhc3Qgb2YgZWFjaFxyXG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5heGVzKS5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChheGlzLmdldERpcmVjdGlvbigpID09PSBDaGFydEF4aXNEaXJlY3Rpb24uWCkge1xyXG4gICAgICAgICAgICAgICAgeCA9IGF4aXMuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGF4aXMuZ2V0RGlyZWN0aW9uKCkgPT09IENoYXJ0QXhpc0RpcmVjdGlvbi5ZKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gYXhpcy5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoeCB8fCB5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRBeGlzWm9vbShheGlzSWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuYXhlc1theGlzSWRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Wm9vbSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0QXhpc1pvb21zKCkge1xyXG4gICAgICAgIGNvbnN0IGF4ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtheGlzSWQsIGF4aXNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYXhlcykpIHtcclxuICAgICAgICAgICAgYXhlc1theGlzSWRdID0ge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBheGlzLmdldERpcmVjdGlvbigpLFxyXG4gICAgICAgICAgICAgICAgem9vbTogYXhpcy5nZXRab29tKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBheGVzO1xyXG4gICAgfVxyXG4gICAgYXBwbHlTdGF0ZXMoKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IE9iamVjdC52YWx1ZXModGhpcy5heGVzKVxyXG4gICAgICAgICAgICAubWFwKChheGlzKSA9PiBheGlzLmFwcGx5U3RhdGVzKCkpXHJcbiAgICAgICAgICAgIC5zb21lKEJvb2xlYW4pO1xyXG4gICAgICAgIGlmICghY2hhbmdlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgYXhlcyA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3QgW2F4aXNJZCwgYXhpc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5heGVzKSkge1xyXG4gICAgICAgICAgICBheGVzW2F4aXNJZF0gPSBheGlzLmdldFpvb20oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goJ3pvb20tY2hhbmdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdHlwZTogJ3pvb20tY2hhbmdlJyB9LCAoY3VycmVudFpvb20gIT09IG51bGwgJiYgY3VycmVudFpvb20gIT09IHZvaWQgMCA/IGN1cnJlbnRab29tIDoge30pKSwgeyBheGVzIH0pKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBBeGlzWm9vbU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXhpcykge1xyXG4gICAgICAgIHRoaXMuc3RhdGVzID0ge307XHJcbiAgICAgICAgdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICBjb25zdCBbbWluID0gMCwgbWF4ID0gMV0gPSBheGlzLnZpc2libGVSYW5nZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRab29tID0geyBtaW4sIG1heCB9O1xyXG4gICAgICAgIHRoaXMuc3RhdGVzWydfX2luaXRpYWxfXyddID0gdGhpcy5jdXJyZW50Wm9vbTtcclxuICAgIH1cclxuICAgIGdldERpcmVjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5heGlzLmRpcmVjdGlvbjtcclxuICAgIH1cclxuICAgIHVwZGF0ZVpvb20oY2FsbGVySWQsIG5ld1pvb20pIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5zdGF0ZXNbY2FsbGVySWRdO1xyXG4gICAgICAgIGlmIChuZXdab29tICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZXNbY2FsbGVySWRdID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3Wm9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Wm9vbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Wm9vbTtcclxuICAgIH1cclxuICAgIGFwcGx5U3RhdGVzKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgcHJldlpvb20gPSB0aGlzLmN1cnJlbnRab29tO1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBPYmplY3Qua2V5cyh0aGlzLnN0YXRlcylbT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFpvb20gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlc1tsYXN0XSk7XHJcbiAgICAgICAgcmV0dXJuIChwcmV2Wm9vbSA9PT0gbnVsbCB8fCBwcmV2Wm9vbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlpvb20ubWluKSAhPT0gKChfYSA9IHRoaXMuY3VycmVudFpvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5taW4pIHx8IChwcmV2Wm9vbSA9PT0gbnVsbCB8fCBwcmV2Wm9vbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlpvb20ubWF4KSAhPT0gKChfYiA9IHRoaXMuY3VycmVudFpvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXgpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIExheW91dFNlcnZpY2UgZXh0ZW5kcyBMaXN0ZW5lcnMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmxheW91dENvbXBsZXRlID0gJ2xheW91dC1jb21wbGV0ZSc7XHJcbiAgICB9XHJcbiAgICBhZGRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xheW91dFN0YWdlKGV2ZW50VHlwZSkgfHwgdGhpcy5pc0xheW91dENvbXBsZXRlKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5zdXBwb3J0ZWQgbGlzdGVuZXIgdHlwZTogJHtldmVudFR5cGV9YCk7XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaFBlcmZvcm1MYXlvdXQoc3RhZ2UsIGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTGF5b3V0U3RhZ2Uoc3RhZ2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExpc3RlbmVyc0J5VHlwZShzdGFnZSkucmVkdWNlKChyZXN1bHQsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5oYW5kbGVyKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5lcnJvck9uY2UoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN0eDtcclxuICAgIH1cclxuICAgIGRpc3BhdGNoTGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMubGF5b3V0Q29tcGxldGUsIGV2ZW50KTtcclxuICAgIH1cclxuICAgIGlzTGF5b3V0U3RhZ2UoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VHlwZSAhPT0gdGhpcy5sYXlvdXRDb21wbGV0ZTtcclxuICAgIH1cclxuICAgIGlzTGF5b3V0Q29tcGxldGUoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VHlwZSA9PT0gdGhpcy5sYXlvdXRDb21wbGV0ZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBncmlkTGF5b3V0KHsgb3JpZW50YXRpb24sIGJib3hlcywgbWF4SGVpZ2h0LCBtYXhXaWR0aCwgaXRlbVBhZGRpbmdZID0gMCwgaXRlbVBhZGRpbmdYID0gMCwgZm9yY2VSZXN1bHQgPSBmYWxzZSwgfSkge1xyXG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XHJcbiAgICBjb25zdCBwcmltYXJ5ID0ge1xyXG4gICAgICAgIG1heDogaG9yaXpvbnRhbCA/IG1heFdpZHRoIDogbWF4SGVpZ2h0LFxyXG4gICAgICAgIGZuOiBob3Jpem9udGFsID8gKGIpID0+IGIud2lkdGggOiAoYikgPT4gYi5oZWlnaHQsXHJcbiAgICAgICAgcGFkZGluZzogaG9yaXpvbnRhbCA/IGl0ZW1QYWRkaW5nWCA6IGl0ZW1QYWRkaW5nWSxcclxuICAgIH07XHJcbiAgICBjb25zdCBzZWNvbmRhcnkgPSB7XHJcbiAgICAgICAgbWF4OiAhaG9yaXpvbnRhbCA/IG1heFdpZHRoIDogbWF4SGVpZ2h0LFxyXG4gICAgICAgIGZuOiAhaG9yaXpvbnRhbCA/IChiKSA9PiBiLndpZHRoIDogKGIpID0+IGIuaGVpZ2h0LFxyXG4gICAgICAgIHBhZGRpbmc6ICFob3Jpem9udGFsID8gaXRlbVBhZGRpbmdYIDogaXRlbVBhZGRpbmdZLFxyXG4gICAgfTtcclxuICAgIGxldCBwcm9jZXNzZWRCQm94Q291bnQgPSAwO1xyXG4gICAgY29uc3QgcmF3UGFnZXMgPSBbXTtcclxuICAgIHdoaWxlIChwcm9jZXNzZWRCQm94Q291bnQgPCBiYm94ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWRCQm94ZXMgPSBiYm94ZXMuc2xpY2UocHJvY2Vzc2VkQkJveENvdW50KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzQkJveGVzKHVucHJvY2Vzc2VkQkJveGVzLCBwcm9jZXNzZWRCQm94Q291bnQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc2VkQkJveENvdW50ICs9IHJlc3VsdC5wcm9jZXNzZWRCQm94Q291bnQ7XHJcbiAgICAgICAgcmF3UGFnZXMucHVzaChyZXN1bHQucGFnZUluZGljZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1aWxkUGFnZXMocmF3UGFnZXMsIG9yaWVudGF0aW9uLCBiYm94ZXMsIGl0ZW1QYWRkaW5nWSwgaXRlbVBhZGRpbmdYKTtcclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzQkJveGVzKGJib3hlcywgaW5kZXhPZmZzZXQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpIHtcclxuICAgIC8vIElmIGNhbGN1bGF0ZVBhZ2UoKSBmYWlscyBvbiB0aGUgZmlyc3QgZ3Vlc3MsIHdlIGNvdWxkIHVzZSB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgZml0XHJcbiAgICAvLyBhcyBhIGdvb2QgZ3Vlc3MgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cclxuICAgIGNvbnN0IG1pbkd1ZXNzID0gMTtcclxuICAgIGxldCBzdGFydGluZ0d1ZXNzID0gZXN0aW1hdGVTdGFydGluZ0d1ZXNzKGJib3hlcywgcHJpbWFyeSk7XHJcbiAgICBpZiAoc3RhcnRpbmdHdWVzcyA8IG1pbkd1ZXNzKSB7XHJcbiAgICAgICAgaWYgKCFmb3JjZVJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMZWdlbmQgY29uc3RyYWludHMgdG9vIHNtYWxsISBEaXNwbGF5IGF0IGxlYXN0IG9uZSByb3cvY29sdW1uIGlmIGZvcmNlUmVzdWx0IGlzIHRydWVcclxuICAgICAgICBzdGFydGluZ0d1ZXNzID0gbWluR3Vlc3M7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBndWVzcyA9IHN0YXJ0aW5nR3Vlc3M7IGd1ZXNzID49IG1pbkd1ZXNzOyBndWVzcy0tKSB7XHJcbiAgICAgICAgY29uc3QgcGFnZUluZGljZXMgPSBjYWxjdWxhdGVQYWdlKGJib3hlcywgaW5kZXhPZmZzZXQsIGd1ZXNzLCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KTtcclxuICAgICAgICBpZiAocGFnZUluZGljZXMgPT0gbnVsbCAmJiBndWVzcyA8PSBtaW5HdWVzcykge1xyXG4gICAgICAgICAgICAvLyBDYW4ndCBsYXlvdXQhXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYWdlSW5kaWNlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEd1ZXNzIGFnYWluIVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYWdlSW5kaWNlcyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlUGFnZSgpIHN1Z2dlc3RlZCBhIGJldHRlciBndWVzcywgdXNlIHRoYXQgaWYgaXQncyBtb3JlIHRoYW4gbWluR3Vlc3MuXHJcbiAgICAgICAgICAgIGlmIChwYWdlSW5kaWNlcyA8PSBtaW5HdWVzcykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgbGF5b3V0IVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWVzcyA9IHBhZ2VJbmRpY2VzIDwgZ3Vlc3MgJiYgcGFnZUluZGljZXMgPiBtaW5HdWVzcyA/IHBhZ2VJbmRpY2VzIDogZ3Vlc3M7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9jZXNzZWRCQm94Q291bnQgPSBwYWdlSW5kaWNlcy5sZW5ndGggKiBwYWdlSW5kaWNlc1swXS5sZW5ndGg7IC8vIHRoaXMgaXMgYW4gZXN0aW1hdGUsIG5vdCBhbGwgcm93cy9jb2x1bW5zIHdpbGwgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcclxuICAgICAgICByZXR1cm4geyBwcm9jZXNzZWRCQm94Q291bnQsIHBhZ2VJbmRpY2VzIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUGFnZShiYm94ZXMsIGluZGV4T2Zmc2V0LCBwcmltYXJ5Q291bnQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgbGV0IHN1bVNlY29uZGFyeSA9IDA7XHJcbiAgICBsZXQgY3VycmVudE1heFNlY29uZGFyeSA9IDA7XHJcbiAgICBsZXQgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XHJcbiAgICBjb25zdCBtYXhQcmltYXJ5VmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBiYm94SW5kZXggPSAwOyBiYm94SW5kZXggPCBiYm94ZXMubGVuZ3RoOyBiYm94SW5kZXgrKykge1xyXG4gICAgICAgIGNvbnN0IHByaW1hcnlWYWx1ZUlkeCA9IChiYm94SW5kZXggKyBwcmltYXJ5Q291bnQpICUgcHJpbWFyeUNvdW50O1xyXG4gICAgICAgIGlmIChwcmltYXJ5VmFsdWVJZHggPT09IDApIHtcclxuICAgICAgICAgICAgc3VtU2Vjb25kYXJ5ICs9IGN1cnJlbnRNYXhTZWNvbmRhcnk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRNYXhTZWNvbmRhcnkgPSAwO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFByaW1hcnlJbmRpY2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRQcmltYXJ5SW5kaWNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByaW1hcnlWYWx1ZSA9IHByaW1hcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgcHJpbWFyeS5wYWRkaW5nO1xyXG4gICAgICAgIG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSA9IE1hdGgubWF4KChfYSA9IG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCwgcHJpbWFyeVZhbHVlKTtcclxuICAgICAgICBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gTWF0aC5tYXgoY3VycmVudE1heFNlY29uZGFyeSwgc2Vjb25kYXJ5LmZuKGJib3hlc1tiYm94SW5kZXhdKSArIHNlY29uZGFyeS5wYWRkaW5nKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50U2Vjb25kYXJ5RGltZW5zaW9uID0gc3VtU2Vjb25kYXJ5ICsgY3VycmVudE1heFNlY29uZGFyeTtcclxuICAgICAgICBjb25zdCByZXR1cm5SZXN1bHQgPSAhZm9yY2VSZXN1bHQgfHwgcmVzdWx0Lmxlbmd0aCA+IDA7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRTZWNvbmRhcnlEaW1lbnNpb24gPiBzZWNvbmRhcnkubWF4ICYmIHJldHVyblJlc3VsdCkge1xyXG4gICAgICAgICAgICAvLyBCcmVhY2hlZCBtYXggc2Vjb25kYXJ5IGRpbWVuc2lvbiBzaXplLCByZXR1cm4gaW5kaWNlcyBhY2N1bWxhdGVkIHNvIGZhciAoYnV0IG5vdCBpbi1wcm9ncmVzcyByb3cvY29sdW1uKS5cclxuICAgICAgICAgICAgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdW1QcmltYXJ5ID0gbWF4UHJpbWFyeVZhbHVlcy5yZWR1Y2UoKHN1bSwgbmV4dCkgPT4gc3VtICsgbmV4dCwgMCk7XHJcbiAgICAgICAgaWYgKHN1bVByaW1hcnkgPiBwcmltYXJ5Lm1heCAmJiAhZm9yY2VSZXN1bHQpIHtcclxuICAgICAgICAgICAgLy8gQnJlYWNoZWQgbWF4IG1haW4gZGltZW5zaW9uIHNpemUuXHJcbiAgICAgICAgICAgIGlmIChtYXhQcmltYXJ5VmFsdWVzLmxlbmd0aCA8IHByaW1hcnlDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmVlZGJhY2sgYXMgZ3Vlc3MgZm9yIG5leHQgaXRlcmF0aW9uIGlmIHdlJ3JlIG9uIHRoZSBmaXJzdCByb3VuZCBzdGlsbC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXhQcmltYXJ5VmFsdWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50UHJpbWFyeUluZGljZXMucHVzaChiYm94SW5kZXggKyBpbmRleE9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBpZiAoY3VycmVudFByaW1hcnlJbmRpY2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50UHJpbWFyeUluZGljZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0IDogdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkUGFnZXMocmF3UGFnZXMsIG9yaWVudGF0aW9uLCBiYm94ZXMsIGl0ZW1QYWRkaW5nWSwgaXRlbVBhZGRpbmdYKSB7XHJcbiAgICBsZXQgbWF4UGFnZVdpZHRoID0gMDtcclxuICAgIGxldCBtYXhQYWdlSGVpZ2h0ID0gMDtcclxuICAgIGNvbnN0IHBhZ2VzID0gcmF3UGFnZXMubWFwKChpbmRpY2VzKSA9PiB7XHJcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgaW5kaWNlcyA9IHRyYW5zcG9zZShpbmRpY2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuZEluZGV4ID0gMDtcclxuICAgICAgICBjb25zdCBjb2x1bW5zID0gaW5kaWNlcy5tYXAoKGNvbEluZGljZXMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29sQkJveGVzID0gY29sSW5kaWNlcy5tYXAoKGJib3hJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBNYXRoLm1heChiYm94SW5kZXgsIGVuZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYm94ZXNbYmJveEluZGV4XTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBjb2x1bW5IZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgY29sdW1uV2lkdGggPSAwO1xyXG4gICAgICAgICAgICBjb2xCQm94ZXMuZm9yRWFjaCgoYmJveCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uSGVpZ2h0ICs9IGJib3guaGVpZ2h0ICsgaXRlbVBhZGRpbmdZO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uV2lkdGggPSBNYXRoLm1heChjb2x1bW5XaWR0aCwgYmJveC53aWR0aCArIGl0ZW1QYWRkaW5nWCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlczogY29sSW5kaWNlcyxcclxuICAgICAgICAgICAgICAgIGJib3hlczogY29sQkJveGVzLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uSGVpZ2h0OiBNYXRoLmNlaWwoY29sdW1uSGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoOiBNYXRoLmNlaWwoY29sdW1uV2lkdGgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBwYWdlV2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBwYWdlSGVpZ2h0ID0gMDtcclxuICAgICAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xyXG4gICAgICAgICAgICBwYWdlV2lkdGggKz0gY29sdW1uLmNvbHVtbldpZHRoO1xyXG4gICAgICAgICAgICBwYWdlSGVpZ2h0ID0gTWF0aC5tYXgocGFnZUhlaWdodCwgY29sdW1uLmNvbHVtbkhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWF4UGFnZVdpZHRoID0gTWF0aC5tYXgocGFnZVdpZHRoLCBtYXhQYWdlV2lkdGgpO1xyXG4gICAgICAgIG1heFBhZ2VIZWlnaHQgPSBNYXRoLm1heChwYWdlSGVpZ2h0LCBtYXhQYWdlSGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2x1bW5zLFxyXG4gICAgICAgICAgICBzdGFydEluZGV4OiBpbmRpY2VzWzBdWzBdLFxyXG4gICAgICAgICAgICBlbmRJbmRleCxcclxuICAgICAgICAgICAgcGFnZVdpZHRoLFxyXG4gICAgICAgICAgICBwYWdlSGVpZ2h0LFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7IHBhZ2VzLCBtYXhQYWdlV2lkdGgsIG1heFBhZ2VIZWlnaHQgfTtcclxufVxyXG5mdW5jdGlvbiB0cmFuc3Bvc2UoZGF0YSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IF8gb2YgZGF0YVswXSkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKFtdKTtcclxuICAgIH1cclxuICAgIGRhdGEuZm9yRWFjaCgoaW5uZXJEYXRhLCBkYXRhSWR4KSA9PiB7XHJcbiAgICAgICAgaW5uZXJEYXRhLmZvckVhY2goKGl0ZW0sIGl0ZW1JZHgpID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0W2l0ZW1JZHhdW2RhdGFJZHhdID0gaXRlbTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBlc3RpbWF0ZVN0YXJ0aW5nR3Vlc3MoYmJveGVzLCBwcmltYXJ5KSB7XHJcbiAgICBjb25zdCBuID0gYmJveGVzLmxlbmd0aDtcclxuICAgIGxldCBwcmltYXJ5U3VtID0gMDtcclxuICAgIGZvciAobGV0IGJib3hJbmRleCA9IDA7IGJib3hJbmRleCA8IG47IGJib3hJbmRleCsrKSB7XHJcbiAgICAgICAgcHJpbWFyeVN1bSArPSBwcmltYXJ5LmZuKGJib3hlc1tiYm94SW5kZXhdKSArIHByaW1hcnkucGFkZGluZztcclxuICAgICAgICBpZiAocHJpbWFyeVN1bSA+IHByaW1hcnkubWF4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gbiAvIGJib3hJbmRleDtcclxuICAgICAgICAgICAgaWYgKHJhdGlvIDwgMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJib3hJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjtcclxufVxuXG5jbGFzcyBDcm9zcyBleHRlbmRzIE1hcmtlciB7XHJcbiAgICB1cGRhdGVQYXRoKCkge1xyXG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyA0LjI7XHJcbiAgICAgICAgc3VwZXIuYXBwbHlQYXRoKHMsIENyb3NzLm1vdmVzKTtcclxuICAgIH1cclxufVxyXG5Dcm9zcy5jbGFzc05hbWUgPSAnQ3Jvc3MnO1xyXG5Dcm9zcy5tb3ZlcyA9IFtcclxuICAgIHsgeDogLTEsIHk6IDAsIHQ6ICdtb3ZlJyB9LFxyXG4gICAgeyB4OiAtMSwgeTogLTEgfSxcclxuICAgIHsgeDogKzEsIHk6IC0xIH0sXHJcbiAgICB7IHg6ICsxLCB5OiArMSB9LFxyXG4gICAgeyB4OiArMSwgeTogLTEgfSxcclxuICAgIHsgeDogKzEsIHk6ICsxIH0sXHJcbiAgICB7IHg6IC0xLCB5OiArMSB9LFxyXG4gICAgeyB4OiArMSwgeTogKzEgfSxcclxuICAgIHsgeDogLTEsIHk6ICsxIH0sXHJcbiAgICB7IHg6IC0xLCB5OiAtMSB9LFxyXG4gICAgeyB4OiAtMSwgeTogKzEgfSxcclxuICAgIHsgeDogLTEsIHk6IC0xIH0sXHJcbl07XG5cbmNsYXNzIERpYW1vbmQgZXh0ZW5kcyBNYXJrZXIge1xyXG4gICAgdXBkYXRlUGF0aCgpIHtcclxuICAgICAgICBjb25zdCBzID0gdGhpcy5zaXplIC8gMjtcclxuICAgICAgICBzdXBlci5hcHBseVBhdGgocywgRGlhbW9uZC5tb3Zlcyk7XHJcbiAgICB9XHJcbn1cclxuRGlhbW9uZC5jbGFzc05hbWUgPSAnRGlhbW9uZCc7XHJcbkRpYW1vbmQubW92ZXMgPSBbXHJcbiAgICB7IHg6IDAsIHk6IC0xLCB0OiAnbW92ZScgfSxcclxuICAgIHsgeDogKzEsIHk6ICsxIH0sXHJcbiAgICB7IHg6IC0xLCB5OiArMSB9LFxyXG4gICAgeyB4OiAtMSwgeTogLTEgfSxcclxuICAgIHsgeDogKzEsIHk6IC0xIH0sXHJcbl07XG5cbmNsYXNzIEhlYXJ0IGV4dGVuZHMgTWFya2VyIHtcclxuICAgIHJhZChkZWdyZWUpIHtcclxuICAgICAgICByZXR1cm4gKGRlZ3JlZSAvIDE4MCkgKiBNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGF0aCgpIHtcclxuICAgICAgICBjb25zdCB7IHgsIHBhdGgsIHNpemUsIHJhZCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCByID0gc2l6ZSAvIDQ7XHJcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueSArIHIgLyAyO1xyXG4gICAgICAgIHBhdGguY2xlYXIoKTtcclxuICAgICAgICBwYXRoLmFyYyh4IC0gciwgeSAtIHIsIHIsIHJhZCgxMzApLCByYWQoMzMwKSk7XHJcbiAgICAgICAgcGF0aC5hcmMoeCArIHIsIHkgLSByLCByLCByYWQoMjIwKSwgcmFkKDUwKSk7XHJcbiAgICAgICAgcGF0aC5saW5lVG8oeCwgeSArIHIpO1xyXG4gICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICB9XHJcbn1cclxuSGVhcnQuY2xhc3NOYW1lID0gJ0hlYXJ0JztcblxuY2xhc3MgUGx1cyBleHRlbmRzIE1hcmtlciB7XHJcbiAgICB1cGRhdGVQYXRoKCkge1xyXG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyAzO1xyXG4gICAgICAgIHN1cGVyLmFwcGx5UGF0aChzLCBQbHVzLm1vdmVzKTtcclxuICAgIH1cclxufVxyXG5QbHVzLmNsYXNzTmFtZSA9ICdQbHVzJztcclxuUGx1cy5tb3ZlcyA9IFtcclxuICAgIHsgeDogLTAuNSwgeTogLTAuNSwgdDogJ21vdmUnIH0sXHJcbiAgICB7IHg6IDAsIHk6IC0xIH0sXHJcbiAgICB7IHg6ICsxLCB5OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6ICsxIH0sXHJcbiAgICB7IHg6ICsxLCB5OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6ICsxIH0sXHJcbiAgICB7IHg6IC0xLCB5OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6ICsxIH0sXHJcbiAgICB7IHg6IC0xLCB5OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6IC0xIH0sXHJcbiAgICB7IHg6IC0xLCB5OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6IC0xIH0sXHJcbl07XG5cbmNsYXNzIFNxdWFyZSBleHRlbmRzIE1hcmtlciB7XHJcbiAgICB1cGRhdGVQYXRoKCkge1xyXG4gICAgICAgIGNvbnN0IHsgcGF0aCwgeCwgeSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBocyA9IHRoaXMuc2l6ZSAvIDI7XHJcbiAgICAgICAgcGF0aC5jbGVhcigpO1xyXG4gICAgICAgIHBhdGgubW92ZVRvKHRoaXMuYWxpZ24oeCAtIGhzKSwgdGhpcy5hbGlnbih5IC0gaHMpKTtcclxuICAgICAgICBwYXRoLmxpbmVUbyh0aGlzLmFsaWduKHggKyBocyksIHRoaXMuYWxpZ24oeSAtIGhzKSk7XHJcbiAgICAgICAgcGF0aC5saW5lVG8odGhpcy5hbGlnbih4ICsgaHMpLCB0aGlzLmFsaWduKHkgKyBocykpO1xyXG4gICAgICAgIHBhdGgubGluZVRvKHRoaXMuYWxpZ24oeCAtIGhzKSwgdGhpcy5hbGlnbih5ICsgaHMpKTtcclxuICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG59XHJcblNxdWFyZS5jbGFzc05hbWUgPSAnU3F1YXJlJztcblxuY2xhc3MgVHJpYW5nbGUgZXh0ZW5kcyBNYXJrZXIge1xyXG4gICAgdXBkYXRlUGF0aCgpIHtcclxuICAgICAgICBjb25zdCBzID0gdGhpcy5zaXplICogMS4xO1xyXG4gICAgICAgIHN1cGVyLmFwcGx5UGF0aChzLCBUcmlhbmdsZS5tb3Zlcyk7XHJcbiAgICB9XHJcbn1cclxuVHJpYW5nbGUuY2xhc3NOYW1lID0gJ1RyaWFuZ2xlJztcclxuVHJpYW5nbGUubW92ZXMgPSBbXHJcbiAgICB7IHg6IDAsIHk6IC0wLjQ4LCB0OiAnbW92ZScgfSxcclxuICAgIHsgeDogMC41LCB5OiAwLjg3IH0sXHJcbiAgICB7IHg6IC0xLCB5OiAwIH0sXHJcbl07XG5cbmNvbnN0IE1BUktFUl9TSEFQRVMgPSB7XHJcbiAgICBjaXJjbGU6IENpcmNsZSxcclxuICAgIGNyb3NzOiBDcm9zcyxcclxuICAgIGRpYW1vbmQ6IERpYW1vbmQsXHJcbiAgICBoZWFydDogSGVhcnQsXHJcbiAgICBwbHVzOiBQbHVzLFxyXG4gICAgc3F1YXJlOiBTcXVhcmUsXHJcbiAgICB0cmlhbmdsZTogVHJpYW5nbGUsXHJcbn07XHJcbmNvbnN0IE1BUktFUl9TVVBQT1JURURfU0hBUEVTID0gT2JqZWN0LmtleXMoTUFSS0VSX1NIQVBFUyk7XHJcbmZ1bmN0aW9uIGlzTWFya2VyU2hhcGUoc2hhcGUpIHtcclxuICAgIHJldHVybiBNQVJLRVJfU1VQUE9SVEVEX1NIQVBFUy5pbmNsdWRlcyhzaGFwZSk7XHJcbn1cclxuLy8gVGhpcyBmdW5jdGlvbiBpcyBpbiBpdHMgb3duIGZpbGUgYmVjYXVzZSBwdXR0aW5nIGl0IGludG8gU2VyaWVzTWFya2VyIG1ha2VzIHRoZSBMZWdlbmRcclxuLy8gc3VkZGVubHkgYXdhcmUgb2YgdGhlIHNlcmllcyAoaXQncyBhbiBhZ25vc3RpYyBjb21wb25lbnQpLCBhbmQgcHV0dGluZyBpdCBpbnRvIE1hcmtlclxyXG4vLyBpbnRyb2R1Y2VzIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cclxuZnVuY3Rpb24gZ2V0TWFya2VyKHNoYXBlID0gU3F1YXJlKSB7XHJcbiAgICBpZiAoaXNNYXJrZXJTaGFwZShzaGFwZSkpIHtcclxuICAgICAgICByZXR1cm4gTUFSS0VSX1NIQVBFU1tzaGFwZV07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNoYXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFNxdWFyZTtcclxufVxuXG5jbGFzcyBNYXJrZXJMYWJlbCBleHRlbmRzIEdyb3VwIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKHsgbmFtZTogJ21hcmtlckxhYmVsR3JvdXAnIH0pO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgVGV4dCgpO1xyXG4gICAgICAgIHRoaXMuX21hcmtlciA9IG5ldyBTcXVhcmUoKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXJTaXplID0gMTU7XHJcbiAgICAgICAgdGhpcy5fc3BhY2luZyA9IDg7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsO1xyXG4gICAgICAgIGxhYmVsLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgIGxhYmVsLmZvbnRTaXplID0gMTI7XHJcbiAgICAgICAgbGFiZWwuZm9udEZhbWlseSA9ICdWZXJkYW5hLCBzYW5zLXNlcmlmJztcclxuICAgICAgICBsYWJlbC5maWxsID0gJ2JsYWNrJztcclxuICAgICAgICAvLyBGb3IgYmV0dGVyIGxvb2tpbmcgdmVydGljYWwgYWxpZ25tZW50IG9mIGxhYmVscyB0byBtYXJrZXJzLlxyXG4gICAgICAgIGxhYmVsLnkgPSBIZHBpQ2FudmFzLmhhcy50ZXh0TWV0cmljcyA/IDEgOiAwO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kKFt0aGlzLm1hcmtlciwgbGFiZWxdKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgc2V0IG1hcmtlcih2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXJrZXIgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5fbWFya2VyKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFya2VyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBtYXJrZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcjtcclxuICAgIH1cclxuICAgIHNldCBtYXJrZXJTaXplKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hcmtlclNpemUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlclNpemUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbWFya2VyU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2VyU2l6ZTtcclxuICAgIH1cclxuICAgIHNldCBzcGFjaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NwYWNpbmcgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwYWNpbmcgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgc3BhY2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3BhY2luZztcclxuICAgIH1cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLm1hcmtlcjtcclxuICAgICAgICBjb25zdCBtYXJrZXJTaXplID0gdGhpcy5tYXJrZXJTaXplO1xyXG4gICAgICAgIG1hcmtlci5zaXplID0gbWFya2VyU2l6ZTtcclxuICAgICAgICB0aGlzLmxhYmVsLnggPSBtYXJrZXJTaXplIC8gMiArIHRoaXMuc3BhY2luZztcclxuICAgIH1cclxuICAgIHJlbmRlcihyZW5kZXJDdHgpIHtcclxuICAgICAgICAvLyBDYW5ub3Qgb3ZlcnJpZGUgZmllbGQgR3JvdXAub3BhY2l0eSB3aXRoIGdldC9zZXQgcGFpciwgc29cclxuICAgICAgICAvLyBwcm9wYWdhdGUgb3BhY2l0eSBjaGFuZ2VzIGhlcmUuXHJcbiAgICAgICAgdGhpcy5tYXJrZXIub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICB0aGlzLmxhYmVsLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XHJcbiAgICB9XHJcbn1cclxuTWFya2VyTGFiZWwuY2xhc3NOYW1lID0gJ01hcmtlckxhYmVsJztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgnbGFiZWwnKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoJ2xhYmVsJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoJ2xhYmVsJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFByb3h5UHJvcGVydHlPbldyaXRlKCdsYWJlbCcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoJ2xhYmVsJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFByb3h5UHJvcGVydHlPbldyaXRlKCdsYWJlbCcsICdmaWxsJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgnbWFya2VyJywgJ2ZpbGwnKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJtYXJrZXJGaWxsXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoJ21hcmtlcicsICdzdHJva2UnKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJtYXJrZXJTdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgnbWFya2VyJywgJ3N0cm9rZVdpZHRoJyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwibWFya2VyU3Ryb2tlV2lkdGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgnbWFya2VyJywgJ2ZpbGxPcGFjaXR5JyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwibWFya2VyRmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgnbWFya2VyJywgJ3N0cm9rZU9wYWNpdHknKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJtYXJrZXJTdHJva2VPcGFjaXR5XCIsIHZvaWQgMCk7XG5cbmNsYXNzIFBhZ2luYXRpb25MYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvbG9yID0gJ2JsYWNrJztcclxuICAgICAgICB0aGlzLmZvbnRTdHlsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZvbnRXZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mb250U2l6ZSA9IDEyO1xyXG4gICAgICAgIHRoaXMuZm9udEZhbWlseSA9ICdWZXJkYW5hLCBzYW5zLXNlcmlmJztcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKENPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZPTlRfU1RZTEUpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRk9OVF9XRUlHSFQpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFNUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgdm9pZCAwKTtcclxuY2xhc3MgUGFnaW5hdGlvbk1hcmtlclN0eWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDE1O1xyXG4gICAgICAgIHRoaXMuZmlsbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCwgMSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCwgMSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUGFnaW5hdGlvbk1hcmtlclN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbmNsYXNzIFBhZ2luYXRpb25NYXJrZXIge1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IFRyaWFuZ2xlO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDE1O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElubmVyIHBhZGRpbmcgYmV0d2VlbiBhIHBhZ2luYXRpb24gYnV0dG9uIGFuZCB0aGUgbGFiZWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gODtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIEFjdGlvbk9uU2V0KHtcclxuICAgICAgICBjaGFuZ2VWYWx1ZSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Lm1hcmtlciA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQub25NYXJrZXJTaGFwZUNoYW5nZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwic2hhcGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBQYWdpbmF0aW9uTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xyXG5jbGFzcyBQYWdpbmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYXJ0VXBkYXRlQ2FsbGJhY2ssIHBhZ2VVcGRhdGVDYWxsYmFjaywgaW50ZXJhY3Rpb25NYW5hZ2VyLCBjdXJzb3JNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrID0gY2hhcnRVcGRhdGVDYWxsYmFjaztcclxuICAgICAgICB0aGlzLnBhZ2VVcGRhdGVDYWxsYmFjayA9IHBhZ2VVcGRhdGVDYWxsYmFjaztcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IGludGVyYWN0aW9uTWFuYWdlcjtcclxuICAgICAgICB0aGlzLmN1cnNvck1hbmFnZXIgPSBjdXJzb3JNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogJ3BhZ2luYXRpb24nIH0pO1xyXG4gICAgICAgIHRoaXMubGFiZWxOb2RlID0gbmV3IFRleHQoKTtcclxuICAgICAgICB0aGlzLm1hcmtlciA9IG5ldyBQYWdpbmF0aW9uTWFya2VyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlU3R5bGUgPSBuZXcgUGFnaW5hdGlvbk1hcmtlclN0eWxlKCk7XHJcbiAgICAgICAgdGhpcy5pbmFjdGl2ZVN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U3R5bGUgPSBuZXcgUGFnaW5hdGlvbk1hcmtlclN0eWxlKCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBQYWdpbmF0aW9uTGFiZWwoKTtcclxuICAgICAgICB0aGlzLnRvdGFsUGFnZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSAwO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25YID0gMDtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XHJcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCc7XHJcbiAgICAgICAgdGhpcy5fbmV4dEJ1dHRvbiA9IG5ldyBUcmlhbmdsZSgpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQnV0dG9uID0gbmV3IFRyaWFuZ2xlKCk7XHJcbiAgICAgICAgY29uc3QgeyBsYWJlbE5vZGUgfSA9IHRoaXM7XHJcbiAgICAgICAgbGFiZWxOb2RlLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgIGxhYmVsTm9kZS5mb250U2l6ZSA9IDEyO1xyXG4gICAgICAgIGxhYmVsTm9kZS5mb250RmFtaWx5ID0gJ1ZlcmRhbmEsIHNhbnMtc2VyaWYnO1xyXG4gICAgICAgIGxhYmVsTm9kZS5maWxsID0gJ2JsYWNrJztcclxuICAgICAgICBsYWJlbE5vZGUueSA9IEhkcGlDYW52YXMuaGFzLnRleHRNZXRyaWNzID8gMSA6IDA7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hcHBlbmQoW3RoaXMubmV4dEJ1dHRvbiwgdGhpcy5wcmV2aW91c0J1dHRvbiwgbGFiZWxOb2RlXSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB0aGlzLm9uUGFnaW5hdGlvbkNsaWNrKGV2ZW50KSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2hvdmVyJywgKGV2ZW50KSA9PiB0aGlzLm9uUGFnaW5hdGlvbk1vdXNlTW92ZShldmVudCkpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICB9XHJcbiAgICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVuYWJsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVHcm91cFZpc2liaWxpdHkoKSB7XHJcbiAgICAgICAgdGhpcy5ncm91cC52aXNpYmxlID0gdGhpcy5lbmFibGVkICYmIHRoaXMudmlzaWJsZTtcclxuICAgIH1cclxuICAgIHNldCBvcmllbnRhdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzoge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c0J1dHRvbi5yb3RhdGlvbiA9IC1NYXRoLlBJIC8gMjtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEJ1dHRvbi5yb3RhdGlvbiA9IE1hdGguUEkgLyAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAndmVydGljYWwnOlxyXG4gICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEJ1dHRvbi5yb3RhdGlvbiA9IE1hdGguUEk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IG5leHRCdXR0b24odmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fbmV4dEJ1dHRvbiAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVDaGlsZCh0aGlzLl9uZXh0QnV0dG9uKTtcclxuICAgICAgICAgICAgdGhpcy5fbmV4dEJ1dHRvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFwcGVuZENoaWxkKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbmV4dEJ1dHRvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dEJ1dHRvbjtcclxuICAgIH1cclxuICAgIHNldCBwcmV2aW91c0J1dHRvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0J1dHRvbiAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVDaGlsZCh0aGlzLl9wcmV2aW91c0J1dHRvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQnV0dG9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBwcmV2aW91c0J1dHRvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNCdXR0b247XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XHJcbiAgICAgICAgdGhpcy5lbmFibGVPckRpc2FibGVCdXR0b25zKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQb3NpdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWDtcclxuICAgICAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMudHJhbnNsYXRpb25ZO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTmV4dEJ1dHRvblBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMYWJlbFBvc2l0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHsgc2l6ZTogbWFya2VyU2l6ZSwgcGFkZGluZzogbWFya2VyUGFkZGluZyB9ID0gdGhpcy5tYXJrZXI7XHJcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uLnNpemUgPSBtYXJrZXJTaXplO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24uc2l6ZSA9IG1hcmtlclNpemU7XHJcbiAgICAgICAgdGhpcy5sYWJlbE5vZGUueCA9IG1hcmtlclNpemUgLyAyICsgbWFya2VyUGFkZGluZztcclxuICAgIH1cclxuICAgIHVwZGF0ZU5leHRCdXR0b25Qb3NpdGlvbigpIHtcclxuICAgICAgICBjb25zdCBsYWJlbEJCb3ggPSB0aGlzLmxhYmVsTm9kZS5jb21wdXRlQkJveCgpO1xyXG4gICAgICAgIHRoaXMubmV4dEJ1dHRvbi50cmFuc2xhdGlvblggPSBsYWJlbEJCb3gueCArIGxhYmVsQkJveC53aWR0aCArIHRoaXMubWFya2VyLnNpemUgLyAyICsgdGhpcy5tYXJrZXIucGFkZGluZztcclxuICAgIH1cclxuICAgIHVwZGF0ZUxhYmVsKCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3VycmVudFBhZ2UsIHRvdGFsUGFnZXM6IHBhZ2VzLCBsYWJlbE5vZGUsIGxhYmVsOiB7IGNvbG9yLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5IH0sIH0gPSB0aGlzO1xyXG4gICAgICAgIGxhYmVsTm9kZS50ZXh0ID0gYCR7Y3VycmVudFBhZ2UgKyAxfSAvICR7cGFnZXN9YDtcclxuICAgICAgICBsYWJlbE5vZGUuZmlsbCA9IGNvbG9yO1xyXG4gICAgICAgIGxhYmVsTm9kZS5mb250U3R5bGUgPSBmb250U3R5bGU7XHJcbiAgICAgICAgbGFiZWxOb2RlLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xyXG4gICAgICAgIGxhYmVsTm9kZS5mb250U2l6ZSA9IGZvbnRTaXplO1xyXG4gICAgICAgIGxhYmVsTm9kZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcclxuICAgIH1cclxuICAgIHVwZGF0ZU1hcmtlcnMoKSB7XHJcbiAgICAgICAgY29uc3QgeyBuZXh0QnV0dG9uLCBwcmV2aW91c0J1dHRvbiwgbmV4dEJ1dHRvbkRpc2FibGVkLCBwcmV2aW91c0J1dHRvbkRpc2FibGVkLCBhY3RpdmVTdHlsZSwgaW5hY3RpdmVTdHlsZSwgaGlnaGxpZ2h0U3R5bGUsIGhpZ2hsaWdodEFjdGl2ZSwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgYnV0dG9uU3R5bGUgPSAoYnV0dG9uLCBkaXNhYmxlZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmFjdGl2ZVN0eWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gaGlnaGxpZ2h0QWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0U3R5bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVN0eWxlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrZXIobmV4dEJ1dHRvbiwgYnV0dG9uU3R5bGUoJ25leHQnLCBuZXh0QnV0dG9uRGlzYWJsZWQpKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hcmtlcihwcmV2aW91c0J1dHRvbiwgYnV0dG9uU3R5bGUoJ3ByZXZpb3VzJywgcHJldmlvdXNCdXR0b25EaXNhYmxlZCkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyKG1hcmtlciwgc3R5bGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBzaXplIH0gPSB0aGlzLm1hcmtlcjtcclxuICAgICAgICBtYXJrZXIuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgbWFya2VyLmZpbGwgPSBzdHlsZS5maWxsO1xyXG4gICAgICAgIG1hcmtlci5maWxsT3BhY2l0eSA9IChfYSA9IHN0eWxlLmZpbGxPcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xyXG4gICAgICAgIG1hcmtlci5zdHJva2UgPSBzdHlsZS5zdHJva2U7XHJcbiAgICAgICAgbWFya2VyLnN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgbWFya2VyLnN0cm9rZU9wYWNpdHkgPSBzdHlsZS5zdHJva2VPcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgZW5hYmxlT3JEaXNhYmxlQnV0dG9ucygpIHtcclxuICAgICAgICBjb25zdCB7IGN1cnJlbnRQYWdlLCB0b3RhbFBhZ2VzIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHplcm9QYWdlc1RvRGlzcGxheSA9IHRvdGFsUGFnZXMgPT09IDA7XHJcbiAgICAgICAgY29uc3Qgb25MYXN0UGFnZSA9IGN1cnJlbnRQYWdlID09PSB0b3RhbFBhZ2VzIC0gMTtcclxuICAgICAgICBjb25zdCBvbkZpcnN0UGFnZSA9IGN1cnJlbnRQYWdlID09PSAwO1xyXG4gICAgICAgIHRoaXMubmV4dEJ1dHRvbkRpc2FibGVkID0gb25MYXN0UGFnZSB8fCB6ZXJvUGFnZXNUb0Rpc3BsYXk7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkID0gb25GaXJzdFBhZ2UgfHwgemVyb1BhZ2VzVG9EaXNwbGF5O1xyXG4gICAgfVxyXG4gICAgbmV4dEJ1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgJiYgdGhpcy5uZXh0QnV0dG9uLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICB9XHJcbiAgICBwcmV2aW91c0J1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkICYmIHRoaXMucHJldmlvdXNCdXR0b24uY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKTtcclxuICAgIH1cclxuICAgIG9uUGFnaW5hdGlvbkNsaWNrKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcclxuICAgICAgICBpZiAodGhpcy5uZXh0QnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xyXG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudFBhZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5vblBhZ2luYXRpb25DaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgIGV2ZW50LmNvbnN1bWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcmV2aW91c0J1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWNyZW1lbnRQYWdlKCk7XHJcbiAgICAgICAgICAgIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICBldmVudC5jb25zdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25QYWdpbmF0aW9uTW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcclxuICAgICAgICBpZiAodGhpcy5uZXh0QnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsICdwb2ludGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gJ25leHQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnByZXZpb3VzQnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsICdwb2ludGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gJ3ByZXZpb3VzJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcclxuICAgICAgICB0aGlzLmNoYXJ0VXBkYXRlQ2FsbGJhY2soQ2hhcnRVcGRhdGVUeXBlLlNDRU5FX1JFTkRFUik7XHJcbiAgICB9XHJcbiAgICBvblBhZ2luYXRpb25DaGFuZ2VkKCkge1xyXG4gICAgICAgIHRoaXMucGFnZVVwZGF0ZUNhbGxiYWNrKHRoaXMuY3VycmVudFBhZ2UpO1xyXG4gICAgfVxyXG4gICAgaW5jcmVtZW50UGFnZSgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gTWF0aC5taW4odGhpcy5jdXJyZW50UGFnZSArIDEsIHRoaXMudG90YWxQYWdlcyAtIDEpO1xyXG4gICAgfVxyXG4gICAgZGVjcmVtZW50UGFnZSgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gTWF0aC5tYXgodGhpcy5jdXJyZW50UGFnZSAtIDEsIDApO1xyXG4gICAgfVxyXG4gICAgb25NYXJrZXJTaGFwZUNoYW5nZSgpIHtcclxuICAgICAgICBjb25zdCBNYXJrZXIgPSBnZXRNYXJrZXIodGhpcy5tYXJrZXIuc2hhcGUgfHwgVHJpYW5nbGUpO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24gPSBuZXcgTWFya2VyKCk7XHJcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uID0gbmV3IE1hcmtlcigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XHJcbiAgICAgICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrKENoYXJ0VXBkYXRlVHlwZS5TQ0VORV9SRU5ERVIpO1xyXG4gICAgfVxyXG4gICAgYXR0YWNoUGFnaW5hdGlvbihub2RlKSB7XHJcbiAgICAgICAgbm9kZS5hcHBlbmQodGhpcy5ncm91cCk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cC5jb21wdXRlQkJveCgpO1xyXG4gICAgfVxyXG59XHJcblBhZ2luYXRpb24uY2xhc3NOYW1lID0gJ1BhZ2luYXRpb24nO1xuXG5jb25zdCBPUklFTlRBVElPTlMgPSBbJ2hvcml6b250YWwnLCAndmVydGljYWwnXTtcclxuY29uc3QgT1BUX09SSUVOVEFUSU9OID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHYsIGN0eCkgPT4gT1BUSU9OQUwodiwgY3R4LCAodikgPT4gT1JJRU5UQVRJT05TLmluY2x1ZGVzKHYpKSwgYGV4cGVjdGluZyBhbiBvcmllbnRhdGlvbiBrZXl3b3JkIHN1Y2ggYXMgJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdgKTtcclxuY2xhc3MgTGVnZW5kTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgdGhpcy5mb250U3R5bGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZm9udFNpemUgPSAxMjtcclxuICAgICAgICB0aGlzLmZvbnRGYW1pbHkgPSAnVmVyZGFuYSwgc2Fucy1zZXJpZic7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJtYXhMZW5ndGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZPTlRfU1RZTEUpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9GT05UX1dFSUdIVCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFNUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9GVU5DVElPTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgdm9pZCAwKTtcclxuY2xhc3MgTGVnZW5kTWFya2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDE1O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBtYXJrZXIgdHlwZSBpcyBzZXQsIHRoZSBsZWdlbmQgd2lsbCBhbHdheXMgdXNlIHRoYXQgbWFya2VyIHR5cGUgZm9yIGFsbCBpdHMgaXRlbXMsXHJcbiAgICAgICAgICogcmVnYXJkbGVzcyBvZiB0aGUgdHlwZSB0aGF0IGNvbWVzIGZyb20gdGhlIGBkYXRhYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9zaGFwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYWRkaW5nIGJldHdlZW4gdGhlIG1hcmtlciBhbmQgdGhlIGxhYmVsIHdpdGhpbiBlYWNoIGxlZ2VuZCBpdGVtLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDg7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHNldCBzaGFwZSh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLl9zaGFwZSA9IHZhbHVlO1xyXG4gICAgICAgIChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25NYXJrZXJTaGFwZUNoYW5nZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNoYXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFwZTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCB2b2lkIDApO1xyXG5jbGFzcyBMZWdlbmRJdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubWFya2VyID0gbmV3IExlZ2VuZE1hcmtlcigpO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgTGVnZW5kTGFiZWwoKTtcclxuICAgICAgICAvKiogVXNlZCB0byBjb25zdHJhaW4gdGhlIHdpZHRoIG9mIGxlZ2VuZCBpdGVtcy4gKi9cclxuICAgICAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsZWdlbmQgdXNlcyBncmlkIGxheW91dCBmb3IgaXRzIGl0ZW1zLCBvY2N1cHlpbmcgYXMgZmV3IGNvbHVtbnMgYXMgcG9zc2libGUgd2hlbiBwb3NpdGlvbmVkIHRvIGxlZnQgb3IgcmlnaHQsXHJcbiAgICAgICAgICogYW5kIGFzIGZldyByb3dzIGFzIHBvc3NpYmxlIHdoZW4gcG9zaXRpb25lZCB0byB0b3Agb3IgYm90dG9tLiBUaGlzIGNvbmZpZyBzcGVjaWZpZXMgdGhlIGFtb3VudCBvZiBob3Jpem9udGFsXHJcbiAgICAgICAgICogcGFkZGluZyBiZXR3ZWVuIGxlZ2VuZCBpdGVtcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhZGRpbmdYID0gMTY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxlZ2VuZCB1c2VzIGdyaWQgbGF5b3V0IGZvciBpdHMgaXRlbXMsIG9jY3VweWluZyBhcyBmZXcgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHBvc2l0aW9uZWQgdG8gbGVmdCBvciByaWdodCxcclxuICAgICAgICAgKiBhbmQgYXMgZmV3IHJvd3MgYXMgcG9zc2libGUgd2hlbiBwb3NpdGlvbmVkIHRvIHRvcCBvciBib3R0b20uIFRoaXMgY29uZmlnIHNwZWNpZmllcyB0aGUgYW1vdW50IG9mIHZlcnRpY2FsXHJcbiAgICAgICAgICogcGFkZGluZyBiZXR3ZWVuIGxlZ2VuZCBpdGVtcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhZGRpbmdZID0gODtcclxuICAgICAgICB0aGlzLnRvZ2dsZVNlcmllc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcInBhZGRpbmdYXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwicGFkZGluZ1lcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJ0b2dnbGVTZXJpZXNWaXNpYmxlXCIsIHZvaWQgMCk7XHJcbmNsYXNzIExlZ2VuZExpc3RlbmVycyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1DbGljayA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1Eb3VibGVDbGljayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9GVU5DVElPTiksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbl0sIExlZ2VuZExpc3RlbmVycy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUNsaWNrXCIsIHZvaWQgMCk7XHJcbmNsYXNzIExlZ2VuZCB7XHJcbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9XHJcbiAgICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVuYWJsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRPcmllbnRhdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdob3Jpem9udGFsJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCh7IG5hbWU6ICdsZWdlbmQnLCBsYXllcjogdHJ1ZSwgekluZGV4OiBMYXllcnMuTEVHRU5EX1pJTkRFWCB9KTtcclxuICAgICAgICB0aGlzLml0ZW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuZ3JvdXAsIE1hcmtlckxhYmVsKTtcclxuICAgICAgICB0aGlzLm9sZFNpemUgPSBbMCwgMF07XHJcbiAgICAgICAgdGhpcy5wYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubWF4UGFnZVNpemUgPSBbMCwgMF07XHJcbiAgICAgICAgLyoqIEl0ZW0gaW5kZXggdG8gdHJhY2sgb24gcmUtcGFnaW5hdGlvbiwgc28gY3VycmVudCBwYWdlIHVwZGF0ZXMgYXBwcm9wcmlhdGVseS4gKi9cclxuICAgICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gMDtcclxuICAgICAgICB0aGlzLml0ZW0gPSBuZXcgTGVnZW5kSXRlbSgpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExlZ2VuZExpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMudHJ1bmNhdGVkSXRlbXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAnYm90dG9tJztcclxuICAgICAgICAvKiogVXNlZCB0byBjb25zdHJhaW4gdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmQuICovXHJcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAvKiogVXNlZCB0byBjb25zdHJhaW4gdGhlIGhlaWdodCBvZiB0aGUgbGVnZW5kLiAqL1xyXG4gICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKiBSZXZlcnNlIHRoZSBkaXNwbGF5IG9yZGVyIG9mIGxlZ2VuZCBpdGVtcyBpZiBgdHJ1ZWAuICovXHJcbiAgICAgICAgdGhpcy5yZXZlcnNlT3JkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95Rm5zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3BhY2luZyBiZXR3ZWVuIHRoZSBsZWdlbmQgYW5kIHRoZSBlZGdlIG9mIHRoZSBjaGFydCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gMjA7XHJcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXJXaWR0aHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gWzAsIDBdO1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXRlbS5tYXJrZXIucGFyZW50ID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhZ2luYXRpb24gPSBuZXcgUGFnaW5hdGlvbigodHlwZSkgPT4gY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKHR5cGUpLCAocGFnZSkgPT4gdGhpcy51cGRhdGVQYWdlTnVtYmVyKHBhZ2UpLCBjdHguaW50ZXJhY3Rpb25NYW5hZ2VyLCBjdHguY3Vyc29yTWFuYWdlcik7XHJcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLmF0dGFjaFBhZ2luYXRpb24odGhpcy5ncm91cCk7XHJcbiAgICAgICAgdGhpcy5pdGVtLm1hcmtlci5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGJ5cGFzcyA9IHsgYnlwYXNzUGF1c2U6IFsnYW5pbWF0aW9uJ10gfTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChjdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB0aGlzLmNoZWNrTGVnZW5kQ2xpY2soZSksIGJ5cGFzcyksIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2RibGNsaWNrJywgKGUpID0+IHRoaXMuY2hlY2tMZWdlbmREb3VibGVDbGljayhlKSwgYnlwYXNzKSwgY3R4LmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcignaG92ZXInLCAoZSkgPT4gdGhpcy5oYW5kbGVMZWdlbmRNb3VzZU1vdmUoZSkpLCBjdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcignc3RhcnQtbGF5b3V0JywgKGUpID0+IHRoaXMucG9zaXRpb25MZWdlbmQoZS5zaHJpbmtSZWN0KSksICgpID0+IHRoaXMuZGV0YWNoTGVnZW5kKCkpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcclxuICAgIH1cclxuICAgIG9uTWFya2VyU2hhcGVDaGFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtU2VsZWN0aW9uLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5tYXJrRGlydHkodGhpcy5ncm91cCwgUmVkcmF3VHlwZS5NSU5PUik7XHJcbiAgICB9XHJcbiAgICBnZXRDaGFyYWN0ZXJXaWR0aHMoZm9udCkge1xyXG4gICAgICAgIGNvbnN0IHsgY2hhcmFjdGVyV2lkdGhzIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmIChjaGFyYWN0ZXJXaWR0aHMuaGFzKGZvbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFyYWN0ZXJXaWR0aHMuZ2V0KGZvbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdyA9IHtcclxuICAgICAgICAgICAgJy4uLic6IEhkcGlDYW52YXMuZ2V0VGV4dFNpemUoJy4uLicsIGZvbnQpLndpZHRoLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hhcmFjdGVyV2lkdGhzLnNldChmb250LCBjdyk7XHJcbiAgICAgICAgcmV0dXJuIGN3O1xyXG4gICAgfVxyXG4gICAgc2V0IHZpc2libGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVHcm91cFZpc2liaWxpdHkoKTtcclxuICAgIH1cclxuICAgIGdldCB2aXNpYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xyXG4gICAgICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiB0aGlzLnZpc2libGUgJiYgdGhpcy5kYXRhLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBhdHRhY2hMZWdlbmQobm9kZSkge1xyXG4gICAgICAgIG5vZGUuYXBwZW5kKHRoaXMuZ3JvdXApO1xyXG4gICAgfVxyXG4gICAgZGV0YWNoTGVnZW5kKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmdyb3VwLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKHRoaXMuZ3JvdXApO1xyXG4gICAgfVxyXG4gICAgZ2V0SXRlbUxhYmVsKGRhdHVtKSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHg6IHsgY2FsbGJhY2tDYWNoZSB9LCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IGZvcm1hdHRlciB9ID0gdGhpcy5pdGVtLmxhYmVsO1xyXG4gICAgICAgIGlmIChmb3JtYXR0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1JZDogZGF0dW0uaXRlbUlkLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdHVtLmxhYmVsLnRleHQsXHJcbiAgICAgICAgICAgICAgICBzZXJpZXNJZDogZGF0dW0uc2VyaWVzSWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0dW0ubGFiZWwudGV4dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1ldGhvZCBpcyBnaXZlbiB0aGUgZGVzaXJlZCBzaXplIG9mIHRoZSBsZWdlbmQsIHdoaWNoIG9ubHkgc2VydmVzIGFzIGEgaGludC5cclxuICAgICAqIFRoZSB2ZXJ0aWNhbGx5IG9yaWVudGVkIGxlZ2VuZCB3aWxsIHRha2UgYXMgbXVjaCBob3Jpem9udGFsIHNwYWNlIGFzIG5lZWRlZCwgYnV0IHdpbGxcclxuICAgICAqIHJlc3BlY3QgdGhlIGhlaWdodCBjb25zdHJhaW50cywgYW5kIHRoZSBob3Jpem9udGFsIGxlZ2VuZCB3aWxsIHRha2UgYXMgbXVjaCB2ZXJ0aWNhbFxyXG4gICAgICogc3BhY2UgYXMgbmVlZGVkIGluIGFuIGF0dGVtcHQgbm90IHRvIGV4Y2VlZCB0aGUgZ2l2ZW4gd2lkdGguXHJcbiAgICAgKiBBZnRlciB0aGUgbGF5b3V0IGlzIGRvbmUsIHRoZSB7QGxpbmsgc2l6ZX0gd2lsbCBjb250YWluIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbGVnZW5kLlxyXG4gICAgICogSWYgdGhlIGFjdHVhbCBzaXplIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgYWN0dWFsIHNpemUsIHRoZSBsZWdlbmQgd2lsbCBmaXJlXHJcbiAgICAgKiB0aGUgJ2xheW91dENoYW5nZScgZXZlbnQgdG8gY29tbXVuaWNhdGUgdGhhdCBhbm90aGVyIGxheW91dCBpcyBuZWVkZWQsIGFuZCB0aGUgYWJvdmVcclxuICAgICAqIHByb2Nlc3Mgc2hvdWxkIGJlIHJlcGVhdGVkLlxyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIHBlcmZvcm1MYXlvdXQod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IHsgcGFkZGluZ1gsIHBhZGRpbmdZLCBsYWJlbCwgbWF4V2lkdGgsIG1hcmtlcjogeyBzaXplOiBtYXJrZXJTaXplLCBwYWRkaW5nOiBtYXJrZXJQYWRkaW5nLCBzaGFwZTogbWFya2VyU2hhcGUgfSwgbGFiZWw6IHsgbWF4TGVuZ3RoID0gSW5maW5pdHksIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfSwgfSA9IHRoaXMuaXRlbTtcclxuICAgICAgICBjb25zdCBkYXRhID0gWy4uLnRoaXMuZGF0YV07XHJcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJzZU9yZGVyKSB7XHJcbiAgICAgICAgICAgIGRhdGEucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLml0ZW1TZWxlY3Rpb24udXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZSBzaXplIG9mIHRoZSBsZWdlbmQgaXRlbXMgYW5kIG1lYXN1cmUgdGhlbS5cclxuICAgICAgICBjb25zdCBiYm94ZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBmb250ID0gZ2V0Rm9udChsYWJlbCk7XHJcbiAgICAgICAgY29uc3QgaXRlbU1heFdpZHRoUGVyY2VudGFnZSA9IDAuODtcclxuICAgICAgICBjb25zdCBtYXhJdGVtV2lkdGggPSBtYXhXaWR0aCAhPT0gbnVsbCAmJiBtYXhXaWR0aCAhPT0gdm9pZCAwID8gbWF4V2lkdGggOiB3aWR0aCAqIGl0ZW1NYXhXaWR0aFBlcmNlbnRhZ2U7XHJcbiAgICAgICAgY29uc3QgcGFkZGVkTWFya2VyV2lkdGggPSBtYXJrZXJTaXplICsgbWFya2VyUGFkZGluZyArIHBhZGRpbmdYO1xyXG4gICAgICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBNYXJrZXIgPSBnZXRNYXJrZXIobWFya2VyU2hhcGUgIT09IG51bGwgJiYgbWFya2VyU2hhcGUgIT09IHZvaWQgMCA/IG1hcmtlclNoYXBlIDogZGF0dW0ubWFya2VyLnNoYXBlKTtcclxuICAgICAgICAgICAgaWYgKCEobWFya2VyTGFiZWwubWFya2VyICYmIG1hcmtlckxhYmVsLm1hcmtlciBpbnN0YW5jZW9mIE1hcmtlcikpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlckxhYmVsLm1hcmtlciA9IG5ldyBNYXJrZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXJrZXJMYWJlbC5tYXJrZXJTaXplID0gbWFya2VyU2l6ZTtcclxuICAgICAgICAgICAgbWFya2VyTGFiZWwuc3BhY2luZyA9IG1hcmtlclBhZGRpbmc7XHJcbiAgICAgICAgICAgIG1hcmtlckxhYmVsLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcclxuICAgICAgICAgICAgbWFya2VyTGFiZWwuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XHJcbiAgICAgICAgICAgIG1hcmtlckxhYmVsLmZvbnRTaXplID0gZm9udFNpemU7XHJcbiAgICAgICAgICAgIG1hcmtlckxhYmVsLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IChfYSA9IGRhdHVtLml0ZW1JZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0dW0uaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0SXRlbUxhYmVsKGRhdHVtKTtcclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IChsYWJlbFRleHQgIT09IG51bGwgJiYgbGFiZWxUZXh0ICE9PSB2b2lkIDAgPyBsYWJlbFRleHQgOiAnPHVua25vd24+JykucmVwbGFjZSgvXFxyP1xcbi9nLCAnICcpO1xyXG4gICAgICAgICAgICBtYXJrZXJMYWJlbC50ZXh0ID0gdGhpcy50cnVuY2F0ZSh0ZXh0LCBtYXhMZW5ndGgsIG1heEl0ZW1XaWR0aCwgcGFkZGVkTWFya2VyV2lkdGgsIGZvbnQsIGlkKTtcclxuICAgICAgICAgICAgYmJveGVzLnB1c2gobWFya2VyTGFiZWwuY29tcHV0ZUJCb3goKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heCgxLCB3aWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMSwgaGVpZ2h0KTtcclxuICAgICAgICBpZiAoIWlzRmluaXRlKHdpZHRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XHJcbiAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMub2xkU2l6ZTtcclxuICAgICAgICBzaXplWzBdID0gd2lkdGg7XHJcbiAgICAgICAgc2l6ZVsxXSA9IGhlaWdodDtcclxuICAgICAgICBpZiAoc2l6ZVswXSAhPT0gb2xkU2l6ZVswXSB8fCBzaXplWzFdICE9PSBvbGRTaXplWzFdKSB7XHJcbiAgICAgICAgICAgIG9sZFNpemVbMF0gPSBzaXplWzBdO1xyXG4gICAgICAgICAgICBvbGRTaXplWzFdID0gc2l6ZVsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBwYWdlcywgbWF4UGFnZUhlaWdodCwgbWF4UGFnZVdpZHRoIH0gPSB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oYmJveGVzLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnBhZ2VzID0gcGFnZXM7XHJcbiAgICAgICAgdGhpcy5tYXhQYWdlU2l6ZSA9IFttYXhQYWdlV2lkdGggLSBwYWRkaW5nWCwgbWF4UGFnZUhlaWdodCAtIHBhZGRpbmdZXTtcclxuICAgICAgICBjb25zdCBwYWdlTnVtYmVyID0gdGhpcy5wYWdpbmF0aW9uLmN1cnJlbnRQYWdlO1xyXG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnBhZ2VzW3BhZ2VOdW1iZXJdO1xyXG4gICAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8IDEgfHwgIXBhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAvLyBQb3NpdGlvbiBsZWdlbmQgaXRlbXNcclxuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyKTtcclxuICAgICAgICAvLyBVcGRhdGUgbGVnZW5kIGl0ZW0gcHJvcGVydGllcyB0aGF0IGRvbid0IGFmZmVjdCB0aGUgbGF5b3V0LlxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICB0cnVuY2F0ZSh0ZXh0LCBtYXhDaGFyTGVuZ3RoLCBtYXhJdGVtV2lkdGgsIHBhZGRlZE1hcmtlcldpZHRoLCBmb250LCBpZCkge1xyXG4gICAgICAgIGNvbnN0IGVsbGlwc2lzID0gYC4uLmA7XHJcbiAgICAgICAgY29uc3QgdGV4dENoYXJzID0gdGV4dC5zcGxpdCgnJyk7XHJcbiAgICAgICAgbGV0IGFkZEVsbGlwc2lzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gbWF4Q2hhckxlbmd0aCkge1xyXG4gICAgICAgICAgICB0ZXh0ID0gYCR7dGV4dC5zdWJzdHJpbmcoMCwgbWF4Q2hhckxlbmd0aCl9YDtcclxuICAgICAgICAgICAgYWRkRWxsaXBzaXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gTWF0aC5mbG9vcihwYWRkZWRNYXJrZXJXaWR0aCArIEhkcGlDYW52YXMuZ2V0VGV4dFNpemUodGV4dCwgZm9udCkud2lkdGgpO1xyXG4gICAgICAgIGlmIChsYWJlbFdpZHRoID4gbWF4SXRlbVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGxldCB0cnVuY2F0ZWRUZXh0ID0gJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcldpZHRocyA9IHRoaXMuZ2V0Q2hhcmFjdGVyV2lkdGhzKGZvbnQpO1xyXG4gICAgICAgICAgICBsZXQgY3VtdWxhdGl2ZVdpZHRoID0gcGFkZGVkTWFya2VyV2lkdGggKyBjaGFyYWN0ZXJXaWR0aHNbZWxsaXBzaXNdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgdGV4dENoYXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNoYXJhY3RlcldpZHRoc1tjaGFyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcldpZHRoc1tjaGFyXSA9IEhkcGlDYW52YXMuZ2V0VGV4dFNpemUoY2hhciwgZm9udCkud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdW11bGF0aXZlV2lkdGggKz0gY2hhcmFjdGVyV2lkdGhzW2NoYXJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1bXVsYXRpdmVXaWR0aCA+IG1heEl0ZW1XaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ1bmNhdGVkVGV4dCArPSBjaGFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHQgPSB0cnVuY2F0ZWRUZXh0O1xyXG4gICAgICAgICAgICBhZGRFbGxpcHNpcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRFbGxpcHNpcykge1xyXG4gICAgICAgICAgICB0ZXh0ICs9IGVsbGlwc2lzO1xyXG4gICAgICAgICAgICB0aGlzLnRydW5jYXRlZEl0ZW1zLmFkZChpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRydW5jYXRlZEl0ZW1zLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcclxuICAgICAgICBjb25zdCB0cmFja2luZ0luZGV4ID0gTWF0aC5taW4odGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCwgYmJveGVzLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWCA9IDA7XHJcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWSA9IDA7XHJcbiAgICAgICAgY29uc3QgeyBwYWdlcywgbWF4UGFnZUhlaWdodCwgbWF4UGFnZVdpZHRoLCBwYWdpbmF0aW9uQkJveCwgcGFnaW5hdGlvblZlcnRpY2FsIH0gPSB0aGlzLmNhbGN1bGF0ZVBhZ2luYXRpb24oYmJveGVzLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBuZXdDdXJyZW50UGFnZSA9IHBhZ2VzLmZpbmRJbmRleCgocCkgPT4gcC5lbmRJbmRleCA+PSB0cmFja2luZ0luZGV4KTtcclxuICAgICAgICB0aGlzLnBhZ2luYXRpb24uY3VycmVudFBhZ2UgPSBNYXRoLm1pbihNYXRoLm1heChuZXdDdXJyZW50UGFnZSwgMCksIHBhZ2VzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIGNvbnN0IHsgcGFkZGluZ1g6IGl0ZW1QYWRkaW5nWCwgcGFkZGluZ1k6IGl0ZW1QYWRkaW5nWSB9ID0gdGhpcy5pdGVtO1xyXG4gICAgICAgIGNvbnN0IHBhZ2luYXRpb25Db21wb25lbnRQYWRkaW5nID0gODtcclxuICAgICAgICBjb25zdCBsZWdlbmRJdGVtc1dpZHRoID0gbWF4UGFnZVdpZHRoIC0gaXRlbVBhZGRpbmdYO1xyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1zSGVpZ2h0ID0gbWF4UGFnZUhlaWdodCAtIGl0ZW1QYWRkaW5nWTtcclxuICAgICAgICBsZXQgcGFnaW5hdGlvblggPSAwO1xyXG4gICAgICAgIGxldCBwYWdpbmF0aW9uWSA9IC1wYWdpbmF0aW9uQkJveC55IC0gdGhpcy5pdGVtLm1hcmtlci5zaXplIC8gMjtcclxuICAgICAgICBpZiAocGFnaW5hdGlvblZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIHBhZ2luYXRpb25ZICs9IGxlZ2VuZEl0ZW1zSGVpZ2h0ICsgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYWdpbmF0aW9uWCArPSAtcGFnaW5hdGlvbkJCb3gueCArIGxlZ2VuZEl0ZW1zV2lkdGggKyBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZztcclxuICAgICAgICAgICAgcGFnaW5hdGlvblkgKz0gKGxlZ2VuZEl0ZW1zSGVpZ2h0IC0gcGFnaW5hdGlvbkJCb3guaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblggPSBwYWdpbmF0aW9uWDtcclxuICAgICAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25ZID0gcGFnaW5hdGlvblk7XHJcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGVNYXJrZXJzKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWF4UGFnZUhlaWdodCxcclxuICAgICAgICAgICAgbWF4UGFnZVdpZHRoLFxyXG4gICAgICAgICAgICBwYWdlcyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBjb25zdCB7IHBhZGRpbmdYOiBpdGVtUGFkZGluZ1gsIHBhZGRpbmdZOiBpdGVtUGFkZGluZ1kgfSA9IHRoaXMuaXRlbTtcclxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcclxuICAgICAgICBjb25zdCBwYWdpbmF0aW9uVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmNsdWRlcyh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICBsZXQgcGFnaW5hdGlvbkJCb3ggPSB0aGlzLnBhZ2luYXRpb24uY29tcHV0ZUJCb3goKTtcclxuICAgICAgICBsZXQgbGFzdFBhc3NQYWdpbmF0aW9uQkJveCA9IG5ldyBCQm94KDAsIDAsIDAsIDApO1xyXG4gICAgICAgIGxldCBwYWdlcyA9IFtdO1xyXG4gICAgICAgIGxldCBtYXhQYWdlV2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBtYXhQYWdlSGVpZ2h0ID0gMDtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHN0YWJsZU91dHB1dCA9IChsYXN0UGFzc1BhZ2luYXRpb25CQm94KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbGFzdFBhc3NQYWdpbmF0aW9uQkJveDtcclxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID09PSBwYWdpbmF0aW9uQkJveC53aWR0aCAmJiBoZWlnaHQgPT09IHBhZ2luYXRpb25CQm94LmhlaWdodDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGZvcmNlUmVzdWx0ID0gdGhpcy5tYXhXaWR0aCAhPT0gdW5kZWZpbmVkIHx8IHRoaXMubWF4SGVpZ2h0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoY291bnQrKyA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybigndW5hYmxlIHRvIGZpbmQgc3RhYmxlIGxlZ2VuZCBsYXlvdXQuJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYWdpbmF0aW9uQkJveCA9IGxhc3RQYXNzUGFnaW5hdGlvbkJCb3g7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gd2lkdGggLSAocGFnaW5hdGlvblZlcnRpY2FsID8gMCA6IHBhZ2luYXRpb25CQm94LndpZHRoKTtcclxuICAgICAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gaGVpZ2h0IC0gKHBhZ2luYXRpb25WZXJ0aWNhbCA/IHBhZ2luYXRpb25CQm94LmhlaWdodCA6IDApO1xyXG4gICAgICAgICAgICBjb25zdCBsYXlvdXQgPSBncmlkTGF5b3V0KHtcclxuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYmJveGVzLFxyXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgbWF4V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBpdGVtUGFkZGluZ1ksXHJcbiAgICAgICAgICAgICAgICBpdGVtUGFkZGluZ1gsXHJcbiAgICAgICAgICAgICAgICBmb3JjZVJlc3VsdCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHBhZ2VzID0gKF9hID0gbGF5b3V0ID09PSBudWxsIHx8IGxheW91dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0LnBhZ2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICAgICAgbWF4UGFnZVdpZHRoID0gKF9iID0gbGF5b3V0ID09PSBudWxsIHx8IGxheW91dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5b3V0Lm1heFBhZ2VXaWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICAgICAgbWF4UGFnZUhlaWdodCA9IChfYyA9IGxheW91dCA9PT0gbnVsbCB8fCBsYXlvdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dC5tYXhQYWdlSGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbFBhZ2VzID0gcGFnZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRpb24udmlzaWJsZSA9IHRvdGFsUGFnZXMgPiAxO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRpb24udG90YWxQYWdlcyA9IHRvdGFsUGFnZXM7XHJcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGUoKTtcclxuICAgICAgICAgICAgbGFzdFBhc3NQYWdpbmF0aW9uQkJveCA9IHRoaXMucGFnaW5hdGlvbi5jb21wdXRlQkJveCgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFnaW5hdGlvbi52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKCFzdGFibGVPdXRwdXQobGFzdFBhc3NQYWdpbmF0aW9uQkJveCkpO1xyXG4gICAgICAgIHJldHVybiB7IG1heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodCwgcGFnZXMsIHBhZ2luYXRpb25CQm94LCBwYWdpbmF0aW9uVmVydGljYWwgfTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyID0gMCkge1xyXG4gICAgICAgIGNvbnN0IHsgaXRlbTogeyBwYWRkaW5nWSB9LCBpdGVtU2VsZWN0aW9uLCBwYWdlcywgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHBhZ2VzLmxlbmd0aCA8IDEgfHwgIXBhZ2VzW3BhZ2VOdW1iZXJdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjb2x1bW5zLCBzdGFydEluZGV4OiB2aXNpYmxlU3RhcnQsIGVuZEluZGV4OiB2aXNpYmxlRW5kIH0gPSBwYWdlc1twYWdlTnVtYmVyXTtcclxuICAgICAgICAvLyBQb3NpdGlvbiBsZWdlbmQgaXRlbXMgdXNpbmcgdGhlIGxheW91dCBjb21wdXRlZCBhYm92ZS5cclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgcm93Q291bnQgPSBjb2x1bW5zWzBdLmluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmdldE9yaWVudGF0aW9uKCkgPT09ICdob3Jpem9udGFsJztcclxuICAgICAgICBjb25zdCBpdGVtSGVpZ2h0ID0gY29sdW1uc1swXS5iYm94ZXNbMF0uaGVpZ2h0ICsgcGFkZGluZ1k7XHJcbiAgICAgICAgY29uc3Qgcm93U3VtQ29sdW1uV2lkdGhzID0gW107XHJcbiAgICAgICAgaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgXywgaSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBpZiAoaSA8IHZpc2libGVTdGFydCB8fCBpID4gdmlzaWJsZUVuZCkge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyTGFiZWwudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IGkgLSB2aXNpYmxlU3RhcnQ7XHJcbiAgICAgICAgICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGxldCByb3dJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IHBhZ2VJbmRleCAlIGNvbHVtbkNvdW50O1xyXG4gICAgICAgICAgICAgICAgcm93SW5kZXggPSBNYXRoLmZsb29yKHBhZ2VJbmRleCAvIGNvbHVtbkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gTWF0aC5mbG9vcihwYWdlSW5kZXggLyByb3dDb3VudCk7XHJcbiAgICAgICAgICAgICAgICByb3dJbmRleCA9IHBhZ2VJbmRleCAlIHJvd0NvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hcmtlckxhYmVsLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2NvbHVtbkluZGV4XTtcclxuICAgICAgICAgICAgaWYgKCFjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5ID0gaXRlbUhlaWdodCAqIHJvd0luZGV4O1xyXG4gICAgICAgICAgICB4ID0gKF9hID0gcm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICAgICAgcm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA9ICgoX2IgPSByb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSArIGNvbHVtbi5jb2x1bW5XaWR0aDtcclxuICAgICAgICAgICAgLy8gUm91bmQgb2ZmIGZvciBwaXhlbCBncmlkIGFsaWdubWVudCB0byB3b3JrIHByb3Blcmx5LlxyXG4gICAgICAgICAgICBtYXJrZXJMYWJlbC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHgpO1xyXG4gICAgICAgICAgICBtYXJrZXJMYWJlbC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGFnZU51bWJlcihwYWdlTnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgeyBwYWdlcyB9ID0gdGhpcztcclxuICAgICAgICAvLyBUcmFjayBhbiBpdGVtIG9uIHRoZSBwYWdlIGluIHJlLXBhZ2luYXRpb24gY2FzZXMgKGUuZy4gcmVzaXplKS5cclxuICAgICAgICBjb25zdCB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSBwYWdlc1twYWdlTnVtYmVyXTtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBTdGF5IG9uIGZpcnN0IHBhZ2Ugb24gcGFnaW5hdGlvbiB1cGRhdGUuXHJcbiAgICAgICAgICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYWdlTnVtYmVyID09PSBwYWdlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIC8vIFN0YXkgb24gbGFzdCBwYWdlIG9uIHBhZ2luYXRpb24gdXBkYXRlLlxyXG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gZW5kSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUcmFjayB0aGUgbWlkZGxlIGl0ZW0gb24gdGhlIHBhZ2UpLlxyXG4gICAgICAgICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gTWF0aC5mbG9vcigoc3RhcnRJbmRleCArIGVuZEluZGV4KSAvIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZU1hcmtlcnMoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyKTtcclxuICAgICAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZShDaGFydFVwZGF0ZVR5cGUuU0NFTkVfUkVOREVSKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBjb25zdCB7IGxhYmVsOiB7IGNvbG9yIH0sIG1hcmtlcjogaXRlbU1hcmtlciwgfSA9IHRoaXMuaXRlbTtcclxuICAgICAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgbWFya2VyID0gZGF0dW0ubWFya2VyO1xyXG4gICAgICAgICAgICBtYXJrZXJMYWJlbC5tYXJrZXJGaWxsID0gbWFya2VyLmZpbGw7XHJcbiAgICAgICAgICAgIG1hcmtlckxhYmVsLm1hcmtlclN0cm9rZSA9IG1hcmtlci5zdHJva2U7XHJcbiAgICAgICAgICAgIG1hcmtlckxhYmVsLm1hcmtlclN0cm9rZVdpZHRoID0gKF9hID0gaXRlbU1hcmtlci5zdHJva2VXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTWF0aC5taW4oMiwgbWFya2VyLnN0cm9rZVdpZHRoKTtcclxuICAgICAgICAgICAgbWFya2VyTGFiZWwubWFya2VyRmlsbE9wYWNpdHkgPSBtYXJrZXIuZmlsbE9wYWNpdHk7XHJcbiAgICAgICAgICAgIG1hcmtlckxhYmVsLm1hcmtlclN0cm9rZU9wYWNpdHkgPSBtYXJrZXIuc3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgICAgbWFya2VyTGFiZWwub3BhY2l0eSA9IGRhdHVtLmVuYWJsZWQgPyAxIDogMC41O1xyXG4gICAgICAgICAgICBtYXJrZXJMYWJlbC5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RGF0dW1Gb3JQb2ludCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZUNoaWxkQkJveGVzID0gW107XHJcbiAgICAgICAgY29uc3QgY2xvc2VzdExlZnRUb3AgPSB7IGRpc3Q6IEluZmluaXR5LCBkYXR1bTogdW5kZWZpbmVkIH07XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmdyb3VwLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmICghY2hpbGQudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIE1hcmtlckxhYmVsKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEJCb3ggPSBjaGlsZC5jb21wdXRlQkJveCgpO1xyXG4gICAgICAgICAgICBjaGlsZEJCb3guZ3Jvdyh0aGlzLml0ZW0ucGFkZGluZ1ggLyAyLCAnaG9yaXpvbnRhbCcpO1xyXG4gICAgICAgICAgICBjaGlsZEJCb3guZ3Jvdyh0aGlzLml0ZW0ucGFkZGluZ1kgLyAyLCAndmVydGljYWwnKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkQkJveC5jb250YWluc1BvaW50KHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZGF0dW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGlzdFggPSB4IC0gY2hpbGRCQm94LnggLSB0aGlzLml0ZW0ucGFkZGluZ1ggLyAyO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0WSA9IHkgLSBjaGlsZEJCb3gueSAtIHRoaXMuaXRlbS5wYWRkaW5nWSAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnBvdyhkaXN0WCwgMikgKyBNYXRoLnBvdyhkaXN0WSwgMik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvVGhlTGVmdFRvcCA9IGRpc3RYID49IDAgJiYgZGlzdFkgPj0gMDtcclxuICAgICAgICAgICAgaWYgKHRvVGhlTGVmdFRvcCAmJiBkaXN0IDwgY2xvc2VzdExlZnRUb3AuZGlzdCkge1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdExlZnRUb3AuZGlzdCA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0TGVmdFRvcC5kYXR1bSA9IGNoaWxkLmRhdHVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZpc2libGVDaGlsZEJCb3hlcy5wdXNoKGNoaWxkQkJveCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhZ2VCQm94ID0gQkJveC5tZXJnZSh2aXNpYmxlQ2hpbGRCQm94ZXMpO1xyXG4gICAgICAgIGlmICghcGFnZUJCb3guY29udGFpbnNQb2ludCh4LCB5KSkge1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgaW4tYmV0d2VlbiBsZWdlbmQgaXRlbXMuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHJldHVybmluZyBjbG9zZXN0IG1hdGNoIHRvIHRoZSBsZWZ0L3VwLlxyXG4gICAgICAgIHJldHVybiBjbG9zZXN0TGVmdFRvcC5kYXR1bTtcclxuICAgIH1cclxuICAgIGNvbXB1dGVCQm94KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwLmNvbXB1dGVCQm94KCk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlUGFnZWRCQm94KCkge1xyXG4gICAgICAgIGNvbnN0IGFjdHVhbEJCb3ggPSB0aGlzLmdyb3VwLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdHVhbEJCb3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IFttYXhQYWdlV2lkdGgsIG1heFBhZ2VIZWlnaHRdID0gdGhpcy5tYXhQYWdlU2l6ZTtcclxuICAgICAgICBhY3R1YWxCQm94LmhlaWdodCA9IE1hdGgubWF4KG1heFBhZ2VIZWlnaHQsIGFjdHVhbEJCb3guaGVpZ2h0KTtcclxuICAgICAgICBhY3R1YWxCQm94LndpZHRoID0gTWF0aC5tYXgobWF4UGFnZVdpZHRoLCBhY3R1YWxCQm94LndpZHRoKTtcclxuICAgICAgICByZXR1cm4gYWN0dWFsQkJveDtcclxuICAgIH1cclxuICAgIGNoZWNrTGVnZW5kQ2xpY2soZXZlbnQpIHtcclxuICAgICAgICBjb25zdCB7IGxpc3RlbmVyczogeyBsZWdlbmRJdGVtQ2xpY2sgfSwgY3R4OiB7IGRhdGFTZXJ2aWNlLCBoaWdobGlnaHRNYW5hZ2VyIH0sIGl0ZW06IHsgdG9nZ2xlU2VyaWVzVmlzaWJsZSB9LCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEJCb3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRlckluc2lkZUxlZ2VuZCA9IHRoaXMuZ3JvdXAudmlzaWJsZSAmJiBsZWdlbmRCQm94LmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldERhdHVtRm9yUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgaWYgKCFwb2ludGVySW5zaWRlTGVnZW5kIHx8ICFkYXR1bSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgaWQsIGl0ZW1JZCwgZW5hYmxlZCB9ID0gZGF0dW07XHJcbiAgICAgICAgY29uc3QgY2hhcnRTZXJpZXMgPSBkYXRhU2VydmljZS5nZXRTZXJpZXMoKTtcclxuICAgICAgICBjb25zdCBzZXJpZXMgPSBjaGFydFNlcmllcy5maW5kKChzKSA9PiBzLmlkID09PSBpZCk7XHJcbiAgICAgICAgaWYgKCFzZXJpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudC5jb25zdW1lKCk7XHJcbiAgICAgICAgbGV0IG5ld0VuYWJsZWQgPSBlbmFibGVkO1xyXG4gICAgICAgIGlmICh0b2dnbGVTZXJpZXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIG5ld0VuYWJsZWQgPSAhZW5hYmxlZDtcclxuICAgICAgICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIubGVnZW5kSXRlbUNsaWNrKHNlcmllcywgaXRlbUlkLCBuZXdFbmFibGVkLCBkYXR1bS5sZWdlbmRJdGVtTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmV3RW5hYmxlZCkge1xyXG4gICAgICAgICAgICBoaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIHtcclxuICAgICAgICAgICAgICAgIHNlcmllcyxcclxuICAgICAgICAgICAgICAgIGl0ZW1JZCxcclxuICAgICAgICAgICAgICAgIGRhdHVtOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZShDaGFydFVwZGF0ZVR5cGUuUFJPQ0VTU19EQVRBLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xyXG4gICAgICAgIGxlZ2VuZEl0ZW1DbGljayA9PT0gbnVsbCB8fCBsZWdlbmRJdGVtQ2xpY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2VuZEl0ZW1DbGljayh7IHR5cGU6ICdjbGljaycsIGVuYWJsZWQ6IG5ld0VuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzSWQ6IHNlcmllcy5pZCB9KTtcclxuICAgIH1cclxuICAgIGNoZWNrTGVnZW5kRG91YmxlQ2xpY2soZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBsaXN0ZW5lcnM6IHsgbGVnZW5kSXRlbURvdWJsZUNsaWNrIH0sIGN0eDogeyBkYXRhU2VydmljZSB9LCBpdGVtOiB7IHRvZ2dsZVNlcmllc1Zpc2libGUgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcclxuICAgICAgICAvLyBJbnRlZ3JhdGVkIGNoYXJ0cyBkbyBub3QgaGFuZGxlIGRvdWJsZSBjbGljayBiZWhhdmlvdXIgY29ycmVjdGx5IGR1ZSB0byBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlXHJcbiAgICAgICAgLy8gY2hhcnQgYmVpbmcgY3JlYXRlZC4gU2VlIGh0dHBzOi8vYWctZ3JpZC5hdGxhc3NpYW4ubmV0L2Jyb3dzZS9SVEktMTM4MVxyXG4gICAgICAgIGlmICh0aGlzLmN0eC5tb2RlID09PSAnaW50ZWdyYXRlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZWdlbmRCQm94ID0gdGhpcy5jb21wdXRlQkJveCgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJbnNpZGVMZWdlbmQgPSB0aGlzLmdyb3VwLnZpc2libGUgJiYgbGVnZW5kQkJveC5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpO1xyXG4gICAgICAgIGNvbnN0IGRhdHVtID0gdGhpcy5nZXREYXR1bUZvclBvaW50KG9mZnNldFgsIG9mZnNldFkpO1xyXG4gICAgICAgIGlmICghcG9pbnRlckluc2lkZUxlZ2VuZCB8fCAhZGF0dW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGlkLCBpdGVtSWQsIHNlcmllc0lkIH0gPSBkYXR1bTtcclxuICAgICAgICBjb25zdCBjaGFydFNlcmllcyA9IGRhdGFTZXJ2aWNlLmdldFNlcmllcygpO1xyXG4gICAgICAgIGNvbnN0IHNlcmllcyA9IGNoYXJ0U2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGlkKTtcclxuICAgICAgICBpZiAoIXNlcmllcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50LmNvbnN1bWUoKTtcclxuICAgICAgICBpZiAodG9nZ2xlU2VyaWVzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBudW1WaXNpYmxlSXRlbXMgPSB7fTtcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kRGF0YSA9IGNoYXJ0U2VyaWVzLmZsYXRNYXAoKHNlcmllcykgPT4gc2VyaWVzLmdldExlZ2VuZERhdGEoJ2NhdGVnb3J5JykpO1xyXG4gICAgICAgICAgICBsZWdlbmREYXRhLmZvckVhY2goKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHZhciBfYjtcclxuICAgICAgICAgICAgICAgIChfYSA9IG51bVZpc2libGVJdGVtc1tfYiA9IGQuc2VyaWVzSWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAobnVtVmlzaWJsZUl0ZW1zW19iXSA9IDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bVZpc2libGVJdGVtc1tkLnNlcmllc0lkXSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgY2xpY2tlZEl0ZW0gPSBsZWdlbmREYXRhLmZpbmQoKGQpID0+IGQuaXRlbUlkID09PSBpdGVtSWQgJiYgZC5zZXJpZXNJZCA9PT0gc2VyaWVzSWQpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlci5sZWdlbmRJdGVtRG91YmxlQ2xpY2soc2VyaWVzLCBpdGVtSWQsIChfYSA9IGNsaWNrZWRJdGVtID09PSBudWxsIHx8IGNsaWNrZWRJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGlja2VkSXRlbS5lbmFibGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSwgbnVtVmlzaWJsZUl0ZW1zLCBjbGlja2VkSXRlbSA9PT0gbnVsbCB8fCBjbGlja2VkSXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xpY2tlZEl0ZW0ubGVnZW5kSXRlbU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZShDaGFydFVwZGF0ZVR5cGUuUFJPQ0VTU19EQVRBLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xyXG4gICAgICAgIGxlZ2VuZEl0ZW1Eb3VibGVDbGljayA9PT0gbnVsbCB8fCBsZWdlbmRJdGVtRG91YmxlQ2xpY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2VuZEl0ZW1Eb3VibGVDbGljayh7IHR5cGU6ICdkYmxjbGljaycsIGVuYWJsZWQ6IHRydWUsIGl0ZW1JZCwgc2VyaWVzSWQ6IHNlcmllcy5pZCB9KTtcclxuICAgIH1cclxuICAgIGhhbmRsZUxlZ2VuZE1vdXNlTW92ZShldmVudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW06IHsgdG9nZ2xlU2VyaWVzVmlzaWJsZSB9LCBsaXN0ZW5lcnMsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghZW5hYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEJCb3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgY29uc3QgeyBwYWdlWCwgcGFnZVksIG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJbnNpZGVMZWdlbmQgPSB0aGlzLmdyb3VwLnZpc2libGUgJiYgbGVnZW5kQkJveC5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpO1xyXG4gICAgICAgIGlmICghcG9pbnRlckluc2lkZUxlZ2VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJldmVudCBvdGhlciBoYW5kbGVycyBmcm9tIGNvbnN1bWluZyB0aGlzIGV2ZW50IGlmIGl0J3MgZ2VuZXJhdGVkIGluc2lkZSB0aGUgbGVnZW5kXHJcbiAgICAgICAgLy8gYm91bmRhcmllcy5cclxuICAgICAgICBldmVudC5jb25zdW1lKCk7XHJcbiAgICAgICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldERhdHVtRm9yUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRlck92ZXJMZWdlbmREYXR1bSA9IHBvaW50ZXJJbnNpZGVMZWdlbmQgJiYgZGF0dW0gIT09IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoIXBvaW50ZXJPdmVyTGVnZW5kRGF0dW0pIHtcclxuICAgICAgICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcmllcyA9IGRhdHVtID8gdGhpcy5jdHguZGF0YVNlcnZpY2UuZ2V0U2VyaWVzKCkuZmluZCgoc2VyaWVzKSA9PiBzZXJpZXMuaWQgPT09IChkYXR1bSA9PT0gbnVsbCB8fCBkYXR1bSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0dW0uaWQpKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoZGF0dW0gJiYgdGhpcy50cnVuY2F0ZWRJdGVtcy5oYXMoKF9hID0gZGF0dW0uaXRlbUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXR1bS5pZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCB7IHBhZ2VYLCBwYWdlWSwgb2Zmc2V0WCwgb2Zmc2V0WSwgZXZlbnQsIHNob3dBcnJvdzogZmFsc2UgfSwgdG9Ub29sdGlwSHRtbCh7IGNvbnRlbnQ6IHRoaXMuZ2V0SXRlbUxhYmVsKGRhdHVtKSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9nZ2xlU2VyaWVzVmlzaWJsZSB8fCBsaXN0ZW5lcnMubGVnZW5kSXRlbUNsaWNrICE9IG51bGwgfHwgbGlzdGVuZXJzLmxlZ2VuZEl0ZW1Eb3VibGVDbGljayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsICdwb2ludGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoZGF0dW0gPT09IG51bGwgfHwgZGF0dW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdHVtLmVuYWJsZWQpICYmIHNlcmllcykge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCB7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXMsXHJcbiAgICAgICAgICAgICAgICBpdGVtSWQ6IGRhdHVtID09PSBudWxsIHx8IGRhdHVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXR1bS5pdGVtSWQsXHJcbiAgICAgICAgICAgICAgICBkYXR1bTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvc2l0aW9uTGVnZW5kKHNocmlua1JlY3QpIHtcclxuICAgICAgICBjb25zdCBuZXdTaHJpbmtSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNocmlua1JlY3Q6IG5ld1Nocmlua1JlY3QgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW2xlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHRdID0gdGhpcy5jYWxjdWxhdGVMZWdlbmREaW1lbnNpb25zKHNocmlua1JlY3QpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25YID0gMDtcclxuICAgICAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSA9IDA7XHJcbiAgICAgICAgdGhpcy5wZXJmb3JtTGF5b3V0KGxlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IGxlZ2VuZEJCb3ggPSB0aGlzLmNvbXB1dGVQYWdlZEJCb3goKTtcclxuICAgICAgICBjb25zdCBjYWxjdWxhdGVUcmFuc2xhdGlvblBlcnBlbmRpY3VsYXJEaW1lbnNpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hyaW5rUmVjdC5oZWlnaHQgLSBsZWdlbmRCQm94LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNocmlua1JlY3Qud2lkdGggLSBsZWdlbmRCQm94LndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2xhdGlvblg7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2xhdGlvblk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25YID0gKHNocmlua1JlY3Qud2lkdGggLSBsZWdlbmRCQm94LndpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25ZID0gY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hyaW5rUmVjdC5zaHJpbmsobGVnZW5kQkJveC5oZWlnaHQsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uWCA9IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uWSA9IChzaHJpbmtSZWN0LmhlaWdodCAtIGxlZ2VuZEJCb3guaGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hyaW5rUmVjdC5zaHJpbmsobGVnZW5kQkJveC53aWR0aCwgdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUm91bmQgb2ZmIGZvciBwaXhlbCBncmlkIGFsaWdubWVudCB0byB3b3JrIHByb3Blcmx5LlxyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IoLWxlZ2VuZEJCb3gueCArIHNocmlua1JlY3QueCArIHRyYW5zbGF0aW9uWCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcigtbGVnZW5kQkJveC55ICsgc2hyaW5rUmVjdC55ICsgdHJhbnNsYXRpb25ZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSAmJiB0aGlzLmVuYWJsZWQgJiYgdGhpcy5kYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmRQYWRkaW5nID0gdGhpcy5zcGFjaW5nO1xyXG4gICAgICAgICAgICBuZXdTaHJpbmtSZWN0LnNocmluayhsZWdlbmRQYWRkaW5nLCB0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kUG9zaXRpb25lZEJCb3ggPSBsZWdlbmRCQm94LmNsb25lKCk7XHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uZWRCQm94LnggKz0gdGhpcy5ncm91cC50cmFuc2xhdGlvblg7XHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uZWRCQm94LnkgKz0gdGhpcy5ncm91cC50cmFuc2xhdGlvblk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnVwZGF0ZUV4Y2x1c2l2ZVJlY3QodGhpcy5pZCwgbGVnZW5kUG9zaXRpb25lZEJCb3gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlRXhjbHVzaXZlUmVjdCh0aGlzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2hyaW5rUmVjdDogbmV3U2hyaW5rUmVjdCB9O1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlTGVnZW5kRGltZW5zaW9ucyhzaHJpbmtSZWN0KSB7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzaHJpbmtSZWN0O1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgbWF4Q29lZmZpY2llbnQgPSAwLjU7XHJcbiAgICAgICAgY29uc3QgbWluSGVpZ2h0Q29lZmZpY2llbnQgPSAwLjI7XHJcbiAgICAgICAgY29uc3QgbWluV2lkdGhDb2VmZmljaWVudCA9IDAuMjU7XHJcbiAgICAgICAgbGV0IGxlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHQ7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAvLyBBIGhvcml6b250YWwgbGVnZW5kIHNob3VsZCB0YWtlIG1heGltdW0gYmV0d2VlbiAyMCB0byA1MCBwZXJjZW50IG9mIHRoZSBjaGFydCBoZWlnaHQgaWYgaGVpZ2h0IGlzIGxhcmdlciB0aGFuIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgbWF4aW11bSAyMCBwZXJjZW50IG9mIHRoZSBjaGFydCBoZWlnaHQgaWYgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiB3aWR0aC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodENvZWZmaWNpZW50ID0gYXNwZWN0UmF0aW8gPCAxXHJcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1pbihtYXhDb2VmZmljaWVudCwgbWluSGVpZ2h0Q29lZmZpY2llbnQgKiAoMSAvIGFzcGVjdFJhdGlvKSlcclxuICAgICAgICAgICAgICAgICAgICA6IG1pbkhlaWdodENvZWZmaWNpZW50O1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kV2lkdGggPSB0aGlzLm1heFdpZHRoID8gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgd2lkdGgpIDogd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRIZWlnaHQgPSB0aGlzLm1heEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucm91bmQoaGVpZ2h0ICogaGVpZ2h0Q29lZmZpY2llbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAvLyBBIHZlcnRpY2FsIGxlZ2VuZCBzaG91bGQgdGFrZSBtYXhpbXVtIGJldHdlZW4gMjUgdG8gNTAgcGVyY2VudCBvZiB0aGUgY2hhcnQgd2lkdGggaWYgd2lkdGggaXMgbGFyZ2VyIHRoYW4gaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgbWF4aW11bSAyNSBwZXJjZW50IG9mIHRoZSBjaGFydCB3aWR0aCBpZiB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gaGVpZ2h0LlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGhDb2VmZmljaWVudCA9IGFzcGVjdFJhdGlvID4gMSA/IE1hdGgubWluKG1heENvZWZmaWNpZW50LCBtaW5XaWR0aENvZWZmaWNpZW50ICogYXNwZWN0UmF0aW8pIDogbWluV2lkdGhDb2VmZmljaWVudDtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gdGhpcy5tYXhXaWR0aCA/IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHdpZHRoKSA6IE1hdGgucm91bmQod2lkdGggKiB3aWR0aENvZWZmaWNpZW50KTtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodCkgOiBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodF07XHJcbiAgICB9XHJcbn1cclxuTGVnZW5kLmNsYXNzTmFtZSA9ICdMZWdlbmQnO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJfZW5hYmxlZFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKFBPU0lUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwibWF4SGVpZ2h0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0JPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicmV2ZXJzZU9yZGVyXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX09SSUVOVEFUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgdm9pZCAwKTtcblxuY2xhc3MgT3ZlcmxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIHBhcmVudCwgZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgIH1cclxuICAgIHNob3cocmVjdCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtyZWN0Lnh9cHhgO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gYCR7cmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGA7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLnJlbmRlcmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgY29udGVudC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xyXG4gICAgICAgICAgICBjb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgY29udGVudC5zdHlsZS5tYXJnaW4gPSAnOHB4JztcclxuICAgICAgICAgICAgY29udGVudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XHJcbiAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUuZm9udCA9ICcxMnB4IFZlcmRhbmEsIHNhbnMtc2VyaWYnO1xyXG4gICAgICAgICAgICBjb250ZW50LmlubmVyVGV4dCA9IChfYSA9IHRoaXMudGV4dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ05vIGRhdGEgdG8gZGlzcGxheSc7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2IgPSB0aGlzLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hcHBlbmQoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBoaWRlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRlVOQ1RJT04pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG5dLCBPdmVybGF5LnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgT3ZlcmxheS5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuXG5jbGFzcyBDaGFydE92ZXJsYXlzIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMubm9EYXRhID0gbmV3IE92ZXJsYXkoJ2FnLWNoYXJ0LW5vLWRhdGEtb3ZlcmxheScsIHBhcmVudCwgcGFyZW50Lm93bmVyRG9jdW1lbnQpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OID0gMzA7XHJcbmNsYXNzIFNlcmllc0xheWVyTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihyb290R3JvdXApIHtcclxuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuc2VyaWVzID0ge307XHJcbiAgICAgICAgdGhpcy5leHBlY3RlZFNlcmllc0NvdW50ID0gMTtcclxuICAgICAgICB0aGlzLm1vZGUgPSAnbm9ybWFsJztcclxuICAgICAgICB0aGlzLnJvb3RHcm91cCA9IHJvb3RHcm91cDtcclxuICAgIH1cclxuICAgIHNldFNlcmllc0NvdW50KGNvdW50KSB7XHJcbiAgICAgICAgdGhpcy5leHBlY3RlZFNlcmllc0NvdW50ID0gY291bnQ7XHJcbiAgICB9XHJcbiAgICByZXF1ZXN0R3JvdXAoc2VyaWVzQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgX2MsIF9kO1xyXG4gICAgICAgIGNvbnN0IHsgaWQsIHR5cGUsIHJvb3RHcm91cDogc2VyaWVzUm9vdEdyb3VwLCBoaWdobGlnaHRHcm91cDogc2VyaWVzSGlnaGxpZ2h0R3JvdXAsIGFubm90YXRpb25Hcm91cDogc2VyaWVzQW5ub3RhdGlvbkdyb3VwLCBzZXJpZXNHcm91cGluZywgfSA9IHNlcmllc0NvbmZpZztcclxuICAgICAgICBjb25zdCB7IGdyb3VwSW5kZXggPSBpZCB9ID0gc2VyaWVzR3JvdXBpbmcgIT09IG51bGwgJiYgc2VyaWVzR3JvdXBpbmcgIT09IHZvaWQgMCA/IHNlcmllc0dyb3VwaW5nIDoge307XHJcbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2lkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gc2VyaWVzIGFscmVhZHkgaGFzIGFuIGFsbG9jYXRlZCBsYXllcjogJHt0aGlzLnNlcmllc1tpZF19YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlLWV2YWx1YXRlIG1vZGUgb25seSBvbiBmaXJzdCBzZXJpZXMgYWRkaXRpb24gLSB3ZSBjYW4ndCBzd2FwIHN0cmF0ZWd5IG1pZC1zZXR1cC5cclxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zZXJpZXMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGUgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RlZFNlcmllc0NvdW50ID49IFNFUklFU19USFJFU0hPTERfRk9SX0FHR1JFU1NJVkVfTEFZRVJfUkVEVUNUSU9OXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnYWdncmVzc2l2ZS1ncm91cGluZydcclxuICAgICAgICAgICAgICAgICAgICA6ICdub3JtYWwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2EgPSAoX2MgPSB0aGlzLmdyb3VwcylbdHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfY1t0eXBlXSA9IHt9KTtcclxuICAgICAgICBjb25zdCBsb29rdXBJbmRleCA9IHRoaXMubG9va3VwSWR4KGdyb3VwSW5kZXgpO1xyXG4gICAgICAgIGxldCBncm91cEluZm8gPSB0aGlzLmdyb3Vwc1t0eXBlXVtsb29rdXBJbmRleF07XHJcbiAgICAgICAgaWYgKCFncm91cEluZm8pIHtcclxuICAgICAgICAgICAgZ3JvdXBJbmZvID0gKF9iID0gKF9kID0gdGhpcy5ncm91cHNbdHlwZV0pW2xvb2t1cEluZGV4XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9kW2xvb2t1cEluZGV4XSA9IHtcclxuICAgICAgICAgICAgICAgIHNlcmllc0lkczogW10sXHJcbiAgICAgICAgICAgICAgICBncm91cDogdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1jb250ZW50YCxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IExheWVycy5TRVJJRVNfTEFZRVJfWklOREVYLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiBzZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcignZGF0YScpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0OiB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke3R5cGV9LWhpZ2hsaWdodGAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiBMYXllcnMuU0VSSUVTX0xBWUVSX1pJTkRFWCxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogc2VyaWVzQ29uZmlnLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoJ2hpZ2hsaWdodCcpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbjogdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1hbm5vdGF0aW9uYCxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IExheWVycy5TRVJJRVNfTEFZRVJfWklOREVYLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleFN1Yk9yZGVyOiBzZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcignYW5ub3RhdGlvbicpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXJpZXNbaWRdID0geyBsYXllclN0YXRlOiBncm91cEluZm8sIHNlcmllc0NvbmZpZyB9O1xyXG4gICAgICAgIGdyb3VwSW5mby5zZXJpZXNJZHMucHVzaChpZCk7XHJcbiAgICAgICAgZ3JvdXBJbmZvLmdyb3VwLmFwcGVuZENoaWxkKHNlcmllc1Jvb3RHcm91cCk7XHJcbiAgICAgICAgZ3JvdXBJbmZvLmhpZ2hsaWdodC5hcHBlbmRDaGlsZChzZXJpZXNIaWdobGlnaHRHcm91cCk7XHJcbiAgICAgICAgZ3JvdXBJbmZvLmFubm90YXRpb24uYXBwZW5kQ2hpbGQoc2VyaWVzQW5ub3RhdGlvbkdyb3VwKTtcclxuICAgICAgICByZXR1cm4gZ3JvdXBJbmZvLmdyb3VwO1xyXG4gICAgfVxyXG4gICAgY2hhbmdlR3JvdXAoc2VyaWVzQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IGlkLCBzZXJpZXNHcm91cGluZywgdHlwZSwgcm9vdEdyb3VwLCBoaWdobGlnaHRHcm91cCwgYW5ub3RhdGlvbkdyb3VwLCBvbGRHcm91cGluZyB9ID0gc2VyaWVzQ29uZmlnO1xyXG4gICAgICAgIGNvbnN0IHsgZ3JvdXBJbmRleCA9IGlkIH0gPSBzZXJpZXNHcm91cGluZyAhPT0gbnVsbCAmJiBzZXJpZXNHcm91cGluZyAhPT0gdm9pZCAwID8gc2VyaWVzR3JvdXBpbmcgOiB7fTtcclxuICAgICAgICBpZiAoKF9iID0gKF9hID0gdGhpcy5ncm91cHNbdHlwZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtncm91cEluZGV4XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlcmllc0lkcy5pbmNsdWRlcyhpZCkpIHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBpbiB0aGUgcmlnaHQgZ3JvdXAsIG5vdGhpbmcgdG8gZG8uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2lkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUdyb3VwKHsgaWQsIHNlcmllc0dyb3VwaW5nOiBvbGRHcm91cGluZywgdHlwZSwgcm9vdEdyb3VwLCBoaWdobGlnaHRHcm91cCwgYW5ub3RhdGlvbkdyb3VwIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcXVlc3RHcm91cChzZXJpZXNDb25maWcpO1xyXG4gICAgfVxyXG4gICAgcmVsZWFzZUdyb3VwKHNlcmllc0NvbmZpZykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICAgICAgY29uc3QgeyBpZCwgc2VyaWVzR3JvdXBpbmcsIHJvb3RHcm91cCwgaGlnaGxpZ2h0R3JvdXAsIGFubm90YXRpb25Hcm91cCwgdHlwZSB9ID0gc2VyaWVzQ29uZmlnO1xyXG4gICAgICAgIGNvbnN0IHsgZ3JvdXBJbmRleCA9IGlkIH0gPSBzZXJpZXNHcm91cGluZyAhPT0gbnVsbCAmJiBzZXJpZXNHcm91cGluZyAhPT0gdm9pZCAwID8gc2VyaWVzR3JvdXBpbmcgOiB7fTtcclxuICAgICAgICBpZiAodGhpcy5zZXJpZXNbaWRdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBzZXJpZXMgZG9lc24ndCBoYXZlIGFuIGFsbG9jYXRlZCBsYXllcjogJHtpZH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbG9va3VwSW5kZXggPSB0aGlzLmxvb2t1cElkeChncm91cEluZGV4KTtcclxuICAgICAgICBjb25zdCBncm91cEluZm8gPSAoX2IgPSAoX2EgPSB0aGlzLmdyb3Vwc1t0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2xvb2t1cEluZGV4XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKF9jID0gdGhpcy5zZXJpZXNbaWRdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGF5ZXJTdGF0ZTtcclxuICAgICAgICBpZiAoZ3JvdXBJbmZvKSB7XHJcbiAgICAgICAgICAgIGdyb3VwSW5mby5zZXJpZXNJZHMgPSBncm91cEluZm8uc2VyaWVzSWRzLmZpbHRlcigodikgPT4gdiAhPT0gaWQpO1xyXG4gICAgICAgICAgICBncm91cEluZm8uZ3JvdXAucmVtb3ZlQ2hpbGQocm9vdEdyb3VwKTtcclxuICAgICAgICAgICAgZ3JvdXBJbmZvLmhpZ2hsaWdodC5yZW1vdmVDaGlsZChoaWdobGlnaHRHcm91cCk7XHJcbiAgICAgICAgICAgIGdyb3VwSW5mby5hbm5vdGF0aW9uLnJlbW92ZUNoaWxkKGFubm90YXRpb25Hcm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoZ3JvdXBJbmZvID09PSBudWxsIHx8IGdyb3VwSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBJbmZvLnNlcmllc0lkcy5sZW5ndGgpID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIExhc3QgbWVtYmVyIG9mIHRoZSBsYXllciwgY2xlYW51cC5cclxuICAgICAgICAgICAgdGhpcy5yb290R3JvdXAucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5yb290R3JvdXAucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmhpZ2hsaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdEdyb3VwLnJlbW92ZUNoaWxkKGdyb3VwSW5mby5hbm5vdGF0aW9uKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW3R5cGVdW2xvb2t1cEluZGV4XTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW3R5cGVdW2lkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGdyb3VwSW5mbyA9PT0gbnVsbCB8fCBncm91cEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwSW5mby5zZXJpZXNJZHMubGVuZ3RoKSA+IDApIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHpJbmRleFN1Yk9yZGVyIHRvIGF2b2lkIGl0IGJlY29taW5nIHN0YWxlIGFzIHNlcmllcyBhcmUgcmVtb3ZlZCBhbmQgcmUtYWRkZWRcclxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2FtZSBncm91cEluZGV4LCBidXQgYXJlIG90aGVyd2lzZSB1bnJlbGF0ZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IGxlYWRTZXJpZXNDb25maWcgPSAoX2UgPSB0aGlzLnNlcmllc1soX2QgPSBncm91cEluZm8gPT09IG51bGwgfHwgZ3JvdXBJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cEluZm8uc2VyaWVzSWRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMF1dKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2VyaWVzQ29uZmlnO1xyXG4gICAgICAgICAgICBncm91cEluZm8uZ3JvdXAuekluZGV4U3ViT3JkZXIgPSBsZWFkU2VyaWVzQ29uZmlnID09PSBudWxsIHx8IGxlYWRTZXJpZXNDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYWRTZXJpZXNDb25maWcuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcignZGF0YScpO1xyXG4gICAgICAgICAgICBncm91cEluZm8uaGlnaGxpZ2h0LnpJbmRleFN1Yk9yZGVyID0gbGVhZFNlcmllc0NvbmZpZyA9PT0gbnVsbCB8fCBsZWFkU2VyaWVzQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWFkU2VyaWVzQ29uZmlnLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgICAgICBncm91cEluZm8uYW5ub3RhdGlvbi56SW5kZXhTdWJPcmRlciA9IGxlYWRTZXJpZXNDb25maWcgPT09IG51bGwgfHwgbGVhZFNlcmllc0NvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZFNlcmllc0NvbmZpZy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKCdhbm5vdGF0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNlcmllc1tpZF07XHJcbiAgICB9XHJcbiAgICBsb29rdXBJZHgoZ3JvdXBJbmRleCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdub3JtYWwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBncm91cEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGdyb3VwSW5kZXggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGdyb3VwSW5kZXggPSBOdW1iZXIoZ3JvdXBJbmRleC5zcGxpdCgnLScpLnNsaWNlKC0xKVswXSk7XHJcbiAgICAgICAgICAgIGlmICghZ3JvdXBJbmRleClcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heChNYXRoLm1pbihncm91cEluZGV4IC8gdGhpcy5leHBlY3RlZFNlcmllc0NvdW50LCAxKSwgMCkgKlxyXG4gICAgICAgICAgICBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTik7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXBzIG9mIE9iamVjdC52YWx1ZXModGhpcy5ncm91cHMpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ3JvdXBJbmZvIG9mIE9iamVjdC52YWx1ZXMoZ3JvdXBzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290R3JvdXAucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmdyb3VwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdEdyb3VwLnJlbW92ZUNoaWxkKGdyb3VwSW5mby5oaWdobGlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290R3JvdXAucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmFubm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0ge307XHJcbiAgICAgICAgdGhpcy5zZXJpZXMgPSB7fTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTZXJpZXNTdGF0ZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyU2VyaWVzKHsgaWQsIHNlcmllc0dyb3VwaW5nLCB2aXNpYmxlLCB0eXBlLCB9KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfYjtcclxuICAgICAgICBpZiAoIXNlcmllc0dyb3VwaW5nKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgKF9hID0gKF9iID0gdGhpcy5ncm91cHMpW3R5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2JbdHlwZV0gPSB7fSk7XHJcbiAgICAgICAgdGhpcy5ncm91cHNbdHlwZV1baWRdID0geyBncm91cGluZzogc2VyaWVzR3JvdXBpbmcsIHZpc2libGUgfTtcclxuICAgIH1cclxuICAgIGRlcmVnaXN0ZXJTZXJpZXMoeyBpZCwgdHlwZSB9KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBzW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXVtpZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdyb3Vwc1t0eXBlXSAmJiBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwc1t0eXBlXSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRWaXNpYmxlUGVlckdyb3VwSW5kZXgoeyB0eXBlLCBzZXJpZXNHcm91cGluZyB9KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXHJcbiAgICAgICAgICAgIHJldHVybiB7IHZpc2libGVHcm91cENvdW50OiAxLCBpbmRleDogMCB9O1xyXG4gICAgICAgIGNvbnN0IHZpc2libGVHcm91cHMgPSBbXHJcbiAgICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKChfYSA9IHRoaXMuZ3JvdXBzW3R5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBlbnRyeV0pID0+IGVudHJ5LnZpc2libGUpXHJcbiAgICAgICAgICAgICAgICAucmVkdWNlKChyZXN1bHQsIFtfLCBuZXh0XSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQobmV4dC5ncm91cGluZy5ncm91cEluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0sIG5ldyBTZXQoKSlcclxuICAgICAgICAgICAgICAgIC52YWx1ZXMoKSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZpc2libGVHcm91cHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZpc2libGVHcm91cENvdW50OiB2aXNpYmxlR3JvdXBzLmxlbmd0aCxcclxuICAgICAgICAgICAgaW5kZXg6IHZpc2libGVHcm91cHMuaW5kZXhPZihzZXJpZXNHcm91cGluZy5ncm91cEluZGV4KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEJhc2VMYXlvdXRQcm9jZXNzb3Ige1xyXG4gICAgY29uc3RydWN0b3IoY2hhcnRMaWtlLCBsYXlvdXRTZXJ2aWNlKSB7XHJcbiAgICAgICAgdGhpcy5jaGFydExpa2UgPSBjaGFydExpa2U7XHJcbiAgICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlID0gbGF5b3V0U2VydmljZTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nXHJcbiAgICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKCdsYXlvdXQtY29tcGxldGUnLCAoZSkgPT4gdGhpcy5sYXlvdXRDb21wbGV0ZShlKSksIHRoaXMubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcignc3RhcnQtbGF5b3V0JywgKGUpID0+IHRoaXMucG9zaXRpb25QYWRkaW5nKGUuc2hyaW5rUmVjdCkpLCB0aGlzLmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoJ3N0YXJ0LWxheW91dCcsIChlKSA9PiB0aGlzLnBvc2l0aW9uQ2FwdGlvbnMoZS5zaHJpbmtSZWN0KSkpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xyXG4gICAgfVxyXG4gICAgbGF5b3V0Q29tcGxldGUoeyBjbGlwU2VyaWVzLCBzZXJpZXM6IHsgcGFkZGVkUmVjdCB9IH0pIHtcclxuICAgICAgICBjb25zdCB7IHNlcmllc0FyZWEsIHNlcmllc1Jvb3QgfSA9IHRoaXMuY2hhcnRMaWtlO1xyXG4gICAgICAgIGlmIChzZXJpZXNBcmVhLmNsaXAgfHwgY2xpcFNlcmllcykge1xyXG4gICAgICAgICAgICBzZXJpZXNSb290LnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShwYWRkZWRSZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlcmllc1Jvb3Quc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zaXRpb25QYWRkaW5nKHNocmlua1JlY3QpIHtcclxuICAgICAgICBjb25zdCB7IHBhZGRpbmcgfSA9IHRoaXMuY2hhcnRMaWtlO1xyXG4gICAgICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcubGVmdCwgJ2xlZnQnKTtcclxuICAgICAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnRvcCwgJ3RvcCcpO1xyXG4gICAgICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcucmlnaHQsICdyaWdodCcpO1xyXG4gICAgICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcuYm90dG9tLCAnYm90dG9tJyk7XHJcbiAgICAgICAgcmV0dXJuIHsgc2hyaW5rUmVjdCB9O1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25DYXB0aW9ucyhzaHJpbmtSZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGNvbnN0IHsgdGl0bGUsIHN1YnRpdGxlLCBmb290bm90ZSB9ID0gdGhpcy5jaGFydExpa2U7XHJcbiAgICAgICAgY29uc3QgbmV3U2hyaW5rUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcclxuICAgICAgICBjb25zdCB1cGRhdGVDYXB0aW9uID0gKGNhcHRpb24pID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q2FwdGlvbkhlaWdodCA9IHNocmlua1JlY3QuaGVpZ2h0IC8gMTA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHRpb25MaW5lSGVpZ2h0ID0gKF9hID0gY2FwdGlvbi5saW5lSGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjYXB0aW9uLmZvbnRTaXplICogVGV4dC5kZWZhdWx0TGluZUhlaWdodFJhdGlvO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHNocmlua1JlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KGNhcHRpb25MaW5lSGVpZ2h0LCBkZWZhdWx0Q2FwdGlvbkhlaWdodCk7XHJcbiAgICAgICAgICAgIGNhcHRpb24uY29tcHV0ZVRleHRXcmFwKG1heFdpZHRoLCBtYXhIZWlnaHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25Ub3BBbmRTaHJpbmtCQm94ID0gKGNhcHRpb24sIHNwYWNpbmcpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFzZVkgPSBuZXdTaHJpbmtSZWN0Lnk7XHJcbiAgICAgICAgICAgIGNhcHRpb24ubm9kZS54ID0gbmV3U2hyaW5rUmVjdC54ICsgbmV3U2hyaW5rUmVjdC53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIGNhcHRpb24ubm9kZS55ID0gYmFzZVk7XHJcbiAgICAgICAgICAgIGNhcHRpb24ubm9kZS50ZXh0QmFzZWxpbmUgPSAndG9wJztcclxuICAgICAgICAgICAgdXBkYXRlQ2FwdGlvbihjYXB0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgYmJveCA9IGNhcHRpb24ubm9kZS5jb21wdXRlQkJveCgpO1xyXG4gICAgICAgICAgICAvLyBBcyB0aGUgYmJveCAoeCx5KSBlbmRzIHVwIGF0IGEgZGlmZmVyZW50IGxvY2F0aW9uIHRoYW4gc3BlY2lmaWVkIGFib3ZlLCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIHRha2UgaXQgaW50byBjb25zaWRlcmF0aW9uIHdoZW4gY2FsY3VsYXRpbmcgaG93IG11Y2ggc3BhY2UgbmVlZHMgdG8gYmUgcmVzZXJ2ZWQgdG9cclxuICAgICAgICAgICAgLy8gYWNjb21tb2RhdGUgdGhlIGNhcHRpb24uXHJcbiAgICAgICAgICAgIGNvbnN0IGJib3hIZWlnaHQgPSBNYXRoLmNlaWwoYmJveC55IC0gYmFzZVkgKyBiYm94LmhlaWdodCArIHNwYWNpbmcpO1xyXG4gICAgICAgICAgICBuZXdTaHJpbmtSZWN0LnNocmluayhiYm94SGVpZ2h0LCAndG9wJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkJvdHRvbUFuZFNocmlua0JCb3ggPSAoY2FwdGlvbiwgc3BhY2luZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlWSA9IG5ld1Nocmlua1JlY3QueSArIG5ld1Nocmlua1JlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjYXB0aW9uLm5vZGUueCA9IG5ld1Nocmlua1JlY3QueCArIG5ld1Nocmlua1JlY3Qud2lkdGggLyAyO1xyXG4gICAgICAgICAgICBjYXB0aW9uLm5vZGUueSA9IGJhc2VZO1xyXG4gICAgICAgICAgICBjYXB0aW9uLm5vZGUudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNhcHRpb24oY2FwdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSBjYXB0aW9uLm5vZGUuY29tcHV0ZUJCb3goKTtcclxuICAgICAgICAgICAgY29uc3QgYmJveEhlaWdodCA9IE1hdGguY2VpbChiYXNlWSAtIGJib3gueSArIHNwYWNpbmcpO1xyXG4gICAgICAgICAgICBuZXdTaHJpbmtSZWN0LnNocmluayhiYm94SGVpZ2h0LCAnYm90dG9tJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoc3VidGl0bGUpIHtcclxuICAgICAgICAgICAgc3VidGl0bGUubm9kZS52aXNpYmxlID0gKF9hID0gc3VidGl0bGUuZW5hYmxlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aXRsZSkge1xyXG4gICAgICAgICAgICB0aXRsZS5ub2RlLnZpc2libGUgPSB0aXRsZS5lbmFibGVkO1xyXG4gICAgICAgICAgICBpZiAodGl0bGUubm9kZS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VGl0bGVTcGFjaW5nID0gKHN1YnRpdGxlID09PSBudWxsIHx8IHN1YnRpdGxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJ0aXRsZS5ub2RlLnZpc2libGUpID8gQ2FwdGlvbi5TTUFMTF9QQURESU5HIDogQ2FwdGlvbi5MQVJHRV9QQURESU5HO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhY2luZyA9IChfYiA9IHRpdGxlLnNwYWNpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRUaXRsZVNwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRvcEFuZFNocmlua0JCb3godGl0bGUsIHNwYWNpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdWJ0aXRsZSAmJiBzdWJ0aXRsZS5ub2RlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgcG9zaXRpb25Ub3BBbmRTaHJpbmtCQm94KHN1YnRpdGxlLCAoX2MgPSBzdWJ0aXRsZS5zcGFjaW5nKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvb3Rub3RlKSB7XHJcbiAgICAgICAgICAgIGZvb3Rub3RlLm5vZGUudmlzaWJsZSA9IGZvb3Rub3RlLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgIGlmIChmb290bm90ZS5ub2RlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQm90dG9tQW5kU2hyaW5rQkJveChmb290bm90ZSwgKF9kID0gZm9vdG5vdGUuc3BhY2luZykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2hyaW5rUmVjdDogbmV3U2hyaW5rUmVjdCB9O1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFVwZGF0ZVNlcnZpY2UgZXh0ZW5kcyBMaXN0ZW5lcnMge1xyXG4gICAgY29uc3RydWN0b3IodXBkYXRlQ2FsbGJhY2spIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSB1cGRhdGVDYWxsYmFjaztcclxuICAgIH1cclxuICAgIHVwZGF0ZSh0eXBlID0gQ2hhcnRVcGRhdGVUeXBlLkZVTEwsIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2ggPSBmYWxzZSwgc2tpcEFuaW1hdGlvbnMgPSBmYWxzZSB9ID0ge30pIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHR5cGUsIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2gsIHNraXBBbmltYXRpb25zIH0pO1xyXG4gICAgfVxyXG4gICAgZGlzcGF0Y2hVcGRhdGVDb21wbGV0ZShtaW5SZWN0KSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSB7IHR5cGU6ICd1cGRhdGUtY29tcGxldGUnLCBtaW5SZWN0IH07XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlLWNvbXBsZXRlJywgZXZlbnQpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpc2VTcGVjaWFsT3ZlcnJpZGVzKG9wdHMpIHtcclxuICAgIGxldCBnbG9iYWxXaW5kb3c7XHJcbiAgICBpZiAob3B0cy53aW5kb3cgIT0gbnVsbCkge1xyXG4gICAgICAgIGdsb2JhbFdpbmRvdyA9IG9wdHMud2luZG93O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBnbG9iYWxXaW5kb3cgPSB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGdsb2JhbFdpbmRvdyA9IGdsb2JhbC53aW5kb3c7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIHVuYWJsZSB0byByZXNvbHZlIGdsb2JhbCB3aW5kb3cnKTtcclxuICAgIH1cclxuICAgIGxldCBnbG9iYWxEb2N1bWVudDtcclxuICAgIGlmIChvcHRzLmRvY3VtZW50ICE9IG51bGwpIHtcclxuICAgICAgICBnbG9iYWxEb2N1bWVudCA9IG9wdHMuZG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgZ2xvYmFsRG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgZ2xvYmFsRG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIHVuYWJsZSB0byByZXNvbHZlIGdsb2JhbCBkb2N1bWVudCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkb2N1bWVudDogZ2xvYmFsRG9jdW1lbnQsXHJcbiAgICAgICAgd2luZG93OiBnbG9iYWxXaW5kb3csXHJcbiAgICAgICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvOiBvcHRzLm92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyxcclxuICAgICAgICBzY2VuZU1vZGU6IG9wdHMuc2NlbmVNb2RlLFxyXG4gICAgfTtcclxufVxyXG5jbGFzcyBTZXJpZXNBcmVhIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2xpcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZygwKTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9CT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBTZXJpZXNBcmVhLnByb3RvdHlwZSwgXCJjbGlwXCIsIHZvaWQgMCk7XHJcbmNsYXNzIENoYXJ0IGV4dGVuZHMgT2JzZXJ2YWJsZSB7XHJcbiAgICBnZXRPcHRpb25zKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IHF1ZXVlZFVzZXJPcHRpb25zIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGxhc3RVcGRhdGVPcHRpb25zID0gKF9hID0gcXVldWVkVXNlck9wdGlvbnNbcXVldWVkVXNlck9wdGlvbnMubGVuZ3RoIC0gMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudXNlck9wdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIGpzb25NZXJnZShbbGFzdFVwZGF0ZU9wdGlvbnNdKTtcclxuICAgIH1cclxuICAgIGF1dG9TaXplQ2hhbmdlZCh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbGFzdEF1dG9TaXplKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZXNpemUodW5kZWZpbmVkLCB1bmRlZmluZWQsICdhdXRvU2l6ZSBvcHRpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcclxuICAgICAgICAgICAgc3R5bGUud2lkdGggPSAnYXV0byc7XHJcbiAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9ICdhdXRvJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRlc3Ryb3llZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVzdHJveWVkO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Ioc3BlY2lhbE92ZXJyaWRlcywgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2VkT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHRoaXMudXNlck9wdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLnF1ZXVlZFVzZXJPcHRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5zZXJpZXNSb290ID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tU2VyaWVzLXJvb3RgIH0pO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmV4dHJhRGVidWdTdGF0cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0QXV0b1NpemUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IG5ldyBQYWRkaW5nKDIwKTtcclxuICAgICAgICB0aGlzLnNlcmllc0FyZWEgPSBuZXcgU2VyaWVzQXJlYSgpO1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdWJ0aXRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZvb3Rub3RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubW9kZSA9ICdzdGFuZGFsb25lJztcclxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95Rm5zID0gW107XHJcbiAgICAgICAgdGhpcy5tb2R1bGVzID0ge307XHJcbiAgICAgICAgdGhpcy5sZWdlbmRNb2R1bGVzID0ge307XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JzID0gW107XHJcbiAgICAgICAgdGhpcy5sZWdlbmRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVR5cGUgPSBDaGFydFVwZGF0ZVR5cGUuTk9ORTtcclxuICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNdXRleCA9IG5ldyBNdXRleCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUmVxdWVzdG9ycyA9IHt9O1xyXG4gICAgICAgIHRoaXMucGVyZm9ybVVwZGF0ZVRyaWdnZXIgPSBkZWJvdW5jZWRDYWxsYmFjaygoeyBjb3VudCB9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTXV0ZXguYWNxdWlyZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVVwZGF0ZShjb3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0UGVyZm9ybVVwZGF0ZUVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmVycm9yKCd1cGRhdGUgZXJyb3InLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fYXhlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3NlcmllcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubGFzdEludGVyYWN0aW9uRXZlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5wb2ludGVyU2NoZWR1bGVyID0gZGVib3VuY2VkQW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0SW50ZXJhY3Rpb25FdmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyKHRoaXMubGFzdEludGVyYWN0aW9uRXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEludGVyYWN0aW9uRXZlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vblNlcmllc05vZGVDbGljayA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJpZXNOb2RlQ2xpY2tFdmVudCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQpLCB7IHR5cGU6ICdzZXJpZXNOb2RlQ2xpY2snIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VyaWVzTm9kZUNsaWNrRXZlbnQsICdzZXJpZXMnLCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBkaXNwbGF5IHRoZSBkZXByZWNhdGlvbiB3YXJuaW5nXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGV2ZW50LnNlcmllcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KHNlcmllc05vZGVDbGlja0V2ZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWVzTm9kZURvdWJsZUNsaWNrID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudCksIHsgdHlwZTogJ3Nlcmllc05vZGVEb3VibGVDbGljaycgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KHNlcmllc05vZGVEb3VibGVDbGljayk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNwZWNpYWxPdmVycmlkZXMgPSBpbml0aWFsaXNlU3BlY2lhbE92ZXJyaWRlcyhzcGVjaWFsT3ZlcnJpZGVzKTtcclxuICAgICAgICBjb25zdCB7IHdpbmRvdywgZG9jdW1lbnQgfSA9IHRoaXMuc3BlY2lhbE92ZXJyaWRlcztcclxuICAgICAgICBjb25zdCBzY2VuZSA9IHJlc291cmNlcyA9PT0gbnVsbCB8fCByZXNvdXJjZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc291cmNlcy5zY2VuZTtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gKF9hID0gcmVzb3VyY2VzID09PSBudWxsIHx8IHJlc291cmNlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzb3VyY2VzLmVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJlc291cmNlcyA9PT0gbnVsbCB8fCByZXNvdXJjZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc291cmNlcy5jb250YWluZXI7XHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBHcm91cCh7IG5hbWU6ICdyb290JyB9KTtcclxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBzY2VuZSBmcm9tIHJlbmRlcmluZyBjaGFydCBjb21wb25lbnRzIGluIGFuIGludmFsaWQgc3RhdGVcclxuICAgICAgICAvLyAoYmVmb3JlIGZpcnN0IGxheW91dCBpcyBwZXJmb3JtZWQpLlxyXG4gICAgICAgIHJvb3QudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHJvb3QuYXBwZW5kKHRoaXMuc2VyaWVzUm9vdCk7XHJcbiAgICAgICAgdGhpcy5heGlzR3JpZEdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogJ0F4ZXMtR3JpZHMnLCBsYXllcjogdHJ1ZSwgekluZGV4OiBMYXllcnMuQVhJU19HUklEX1pJTkRFWCB9KTtcclxuICAgICAgICByb290LmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyaWRHcm91cCk7XHJcbiAgICAgICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiAnQXhlcycsIGxheWVyOiB0cnVlLCB6SW5kZXg6IExheWVycy5BWElTX1pJTkRFWCB9KTtcclxuICAgICAgICByb290LmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWctY2hhcnQtd3JhcHBlcicpO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZSAhPT0gbnVsbCAmJiBzY2VuZSAhPT0gdm9pZCAwID8gc2NlbmUgOiBuZXcgU2NlbmUodGhpcy5zcGVjaWFsT3ZlcnJpZGVzKTtcclxuICAgICAgICB0aGlzLnNjZW5lLnJvb3QgPSByb290O1xyXG4gICAgICAgIHRoaXMuc2NlbmUuY29udGFpbmVyID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLmF1dG9TaXplID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNoYXJ0RXZlbnRNYW5hZ2VyID0gbmV3IENoYXJ0RXZlbnRNYW5hZ2VyKCk7XHJcbiAgICAgICAgdGhpcy5jdXJzb3JNYW5hZ2VyID0gbmV3IEN1cnNvck1hbmFnZXIoZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRNYW5hZ2VyID0gbmV3IEhpZ2hsaWdodE1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IG5ldyBJbnRlcmFjdGlvbk1hbmFnZXIoZWxlbWVudCwgZG9jdW1lbnQsIHdpbmRvdyk7XHJcbiAgICAgICAgdGhpcy56b29tTWFuYWdlciA9IG5ldyBab29tTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBuZXcgRGF0YVNlcnZpY2UoKCkgPT4gdGhpcy5zZXJpZXMpO1xyXG4gICAgICAgIHRoaXMubGF5b3V0U2VydmljZSA9IG5ldyBMYXlvdXRTZXJ2aWNlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTZXJ2aWNlID0gbmV3IFVwZGF0ZVNlcnZpY2UoKHR5cGUgPSBDaGFydFVwZGF0ZVR5cGUuRlVMTCwgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaCwgc2tpcEFuaW1hdGlvbnMgfSkgPT4gdGhpcy51cGRhdGUodHlwZSwgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaCwgc2tpcEFuaW1hdGlvbnMgfSkpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzU3RhdGVNYW5hZ2VyID0gbmV3IFNlcmllc1N0YXRlTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyID0gbmV3IFNlcmllc0xheWVyTWFuYWdlcih0aGlzLnNlcmllc1Jvb3QpO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDYWNoZSA9IG5ldyBDYWxsYmFja0NhY2hlKCk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIsIHRoaXMudXBkYXRlTXV0ZXgpO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5za2lwKCk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnBsYXkoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NvcnMgPSBbbmV3IEJhc2VMYXlvdXRQcm9jZXNzb3IodGhpcywgdGhpcy5sYXlvdXRTZXJ2aWNlKV07XHJcbiAgICAgICAgdGhpcy50b29sdGlwID0gbmV3IFRvb2x0aXAodGhpcy5zY2VuZS5jYW52YXMuZWxlbWVudCwgZG9jdW1lbnQsIHdpbmRvdywgZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwTWFuYWdlciA9IG5ldyBUb29sdGlwTWFuYWdlcih0aGlzLnRvb2x0aXAsIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gbmV3IENoYXJ0T3ZlcmxheXModGhpcy5lbGVtZW50KTtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodCA9IG5ldyBDaGFydEhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIFNpemVNb25pdG9yLm9ic2VydmUodGhpcy5lbGVtZW50LCAoc2l6ZSkgPT4gdGhpcy5yYXdSZXNpemUoc2l6ZSkpO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lGbnMucHVzaCh0aGlzLmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHRoaXMub25DbGljayhldmVudCkpLCB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcignZGJsY2xpY2snLCAoZXZlbnQpID0+IHRoaXMub25Eb3VibGVDbGljayhldmVudCkpLCB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcignaG92ZXInLCAoZXZlbnQpID0+IHRoaXMub25Nb3VzZU1vdmUoZXZlbnQpKSwgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2xlYXZlJywgKGV2ZW50KSA9PiB0aGlzLm9uTGVhdmUoZXZlbnQpKSwgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ3BhZ2UtbGVmdCcsICgpID0+IHRoaXMuZGVzdHJveSgpKSwgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ3doZWVsJywgKCkgPT4gdGhpcy5kaXNhYmxlUG9pbnRlcigpKSwgXHJcbiAgICAgICAgLy8gQmxvY2sgcmVkdW5kYW50IGFuZCBpbnRlcmZlcmluZyBhdHRlbXB0cyB0byB1cGRhdGUgdGhlIGhvdmVyZWQgZWxlbWVudCBkdXJpbmcgZHJhZ2dpbmcuXHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2RyYWctc3RhcnQnLCAoKSA9PiB0aGlzLmRpc2FibGVQb2ludGVyKCkpLCB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2FuaW1hdGlvbi1mcmFtZScsIChfKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKENoYXJ0VXBkYXRlVHlwZS5TQ0VORV9SRU5ERVIpO1xyXG4gICAgICAgIH0pLCB0aGlzLmhpZ2hsaWdodE1hbmFnZXIuYWRkTGlzdGVuZXIoJ2hpZ2hsaWdodC1jaGFuZ2UnLCAoZXZlbnQpID0+IHRoaXMuY2hhbmdlSGlnaGxpZ2h0RGF0dW0oZXZlbnQpKSwgdGhpcy56b29tTWFuYWdlci5hZGRMaXN0ZW5lcignem9vbS1jaGFuZ2UnLCAoXykgPT4gdGhpcy51cGRhdGUoQ2hhcnRVcGRhdGVUeXBlLlBST0NFU1NfREFUQSwgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSwgc2tpcEFuaW1hdGlvbnM6IHRydWUgfSkpKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IHRoaXMuYXR0YWNoTGVnZW5kKCdjYXRlZ29yeScsIExlZ2VuZCk7XHJcbiAgICB9XHJcbiAgICBhZGRNb2R1bGUobW9kdWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlc1ttb2R1bGUub3B0aW9uc0tleV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIG1vZHVsZSBhbHJlYWR5IGluaXRpYWxpc2VkOiAnICsgbW9kdWxlLm9wdGlvbnNLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2R1bGVJbnN0YW5jZSA9IG5ldyBtb2R1bGUuaW5zdGFuY2VDb25zdHJ1Y3Rvcih0aGlzLmdldE1vZHVsZUNvbnRleHQoKSk7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVzW21vZHVsZS5vcHRpb25zS2V5XSA9IHsgaW5zdGFuY2U6IG1vZHVsZUluc3RhbmNlIH07XHJcbiAgICAgICAgdGhpc1ttb2R1bGUub3B0aW9uc0tleV0gPSBtb2R1bGVJbnN0YW5jZTsgLy8gVE9ETyByZW1vdmVcclxuICAgIH1cclxuICAgIHJlbW92ZU1vZHVsZShtb2R1bGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5tb2R1bGVzW21vZHVsZS5vcHRpb25zS2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5tb2R1bGVzW21vZHVsZS5vcHRpb25zS2V5XTtcclxuICAgICAgICBkZWxldGUgdGhpc1ttb2R1bGUub3B0aW9uc0tleV07IC8vIFRPRE8gcmVtb3ZlXHJcbiAgICB9XHJcbiAgICBhdHRhY2hMZWdlbmQobGVnZW5kVHlwZSwgbGVnZW5kQ29uc3RydWN0b3IpIHtcclxuICAgICAgICBjb25zdCBsZWdlbmQgPSBuZXcgbGVnZW5kQ29uc3RydWN0b3IodGhpcy5nZXRNb2R1bGVDb250ZXh0KCkpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kcy5zZXQobGVnZW5kVHlwZSwgbGVnZW5kKTtcclxuICAgICAgICBsZWdlbmQuYXR0YWNoTGVnZW5kKHRoaXMuc2NlbmUucm9vdCk7XHJcbiAgICAgICAgcmV0dXJuIGxlZ2VuZDtcclxuICAgIH1cclxuICAgIGFkZExlZ2VuZE1vZHVsZShtb2R1bGUpIHtcclxuICAgICAgICBpZiAodGhpcy5tb2R1bGVzW21vZHVsZS5vcHRpb25zS2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQUcgQ2hhcnRzIC0gbW9kdWxlIGFscmVhZHkgaW5pdGlhbGlzZWQ6ICcgKyBtb2R1bGUub3B0aW9uc0tleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IHRoaXMuYXR0YWNoTGVnZW5kKG1vZHVsZS5pZGVudGlmaWVyLCBtb2R1bGUuaW5zdGFuY2VDb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVzW21vZHVsZS5vcHRpb25zS2V5XSA9IHsgaW5zdGFuY2U6IGxlZ2VuZCB9O1xyXG4gICAgICAgIHRoaXNbbW9kdWxlLm9wdGlvbnNLZXldID0gbGVnZW5kO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGVnZW5kTW9kdWxlKG1vZHVsZSkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kcy5kZWxldGUobW9kdWxlLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTW9kdWxlKG1vZHVsZSk7XHJcbiAgICB9XHJcbiAgICBpc01vZHVsZUVuYWJsZWQobW9kdWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxlc1ttb2R1bGUub3B0aW9uc0tleV0gIT0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldE1vZHVsZUNvbnRleHQoKSB7XHJcbiAgICAgICAgY29uc3QgeyBzY2VuZSwgYW5pbWF0aW9uTWFuYWdlciwgY2hhcnRFdmVudE1hbmFnZXIsIGN1cnNvck1hbmFnZXIsIGhpZ2hsaWdodE1hbmFnZXIsIGludGVyYWN0aW9uTWFuYWdlciwgdG9vbHRpcE1hbmFnZXIsIHpvb21NYW5hZ2VyLCBkYXRhU2VydmljZSwgbGF5b3V0U2VydmljZSwgdXBkYXRlU2VydmljZSwgc2VyaWVzU3RhdGVNYW5hZ2VyLCBzZXJpZXNMYXllck1hbmFnZXIsIG1vZGUsIGNhbGxiYWNrQ2FjaGUsIHNwZWNpYWxPdmVycmlkZXM6IHsgd2luZG93LCBkb2N1bWVudCB9LCB9ID0gdGhpcztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aW5kb3csXHJcbiAgICAgICAgICAgIGRvY3VtZW50LFxyXG4gICAgICAgICAgICBzY2VuZSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uTWFuYWdlcixcclxuICAgICAgICAgICAgY2hhcnRFdmVudE1hbmFnZXIsXHJcbiAgICAgICAgICAgIGN1cnNvck1hbmFnZXIsXHJcbiAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIsXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uTWFuYWdlcixcclxuICAgICAgICAgICAgdG9vbHRpcE1hbmFnZXIsXHJcbiAgICAgICAgICAgIHpvb21NYW5hZ2VyLFxyXG4gICAgICAgICAgICBkYXRhU2VydmljZSxcclxuICAgICAgICAgICAgbGF5b3V0U2VydmljZSxcclxuICAgICAgICAgICAgdXBkYXRlU2VydmljZSxcclxuICAgICAgICAgICAgbW9kZSxcclxuICAgICAgICAgICAgc2VyaWVzU3RhdGVNYW5hZ2VyLFxyXG4gICAgICAgICAgICBzZXJpZXNMYXllck1hbmFnZXIsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrQ2FjaGUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3kob3B0cykge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXM7XHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlVHlwZSA9IENoYXJ0VXBkYXRlVHlwZS5OT05FO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc29ycy5mb3JFYWNoKChwKSA9PiBwLmRlc3Ryb3koKSk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwTWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwLmRlc3Ryb3koKTtcclxuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMubGVnZW5kcykuZm9yRWFjaCgobGVnZW5kKSA9PiBsZWdlbmQuZGVzdHJveSgpKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZHMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXlzLm5vRGF0YS5oaWRlKCk7XHJcbiAgICAgICAgU2l6ZU1vbml0b3IudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25zS2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubW9kdWxlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVNb2R1bGUoeyBvcHRpb25zS2V5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnN0b3AoKTtcclxuICAgICAgICBpZiAoa2VlcFRyYW5zZmVyYWJsZVJlc291cmNlcykge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnN0cmlwKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciwgc2NlbmU6IHRoaXMuc2NlbmUsIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbW92ZUFsbFNlcmllcygpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYSkgPT4gYS5kZXN0cm95KCkpO1xyXG4gICAgICAgIHRoaXMuYXhlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDYWNoZS5pbnZhbGlkYXRlQ2FjaGUoKTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkaXNhYmxlUG9pbnRlcihoaWdobGlnaHRPbmx5ID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoIWhpZ2hsaWdodE9ubHkpIHtcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RJbnRlcmFjdGlvbkV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEludGVyYWN0aW9uRXZlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVxdWVzdEZhY3RvcnlVcGRhdGUoY2IpIHtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudCsrO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTXV0ZXguYWNxdWlyZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGNiKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50LS07XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBlcmZvcm1VcGRhdGVUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJmb3JtVXBkYXRlVHlwZTtcclxuICAgIH1cclxuICAgIGdldCBsYXN0UGVyZm9ybVVwZGF0ZUVycm9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0UGVyZm9ybVVwZGF0ZUVycm9yO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKHR5cGUgPSBDaGFydFVwZGF0ZVR5cGUuRlVMTCwgb3B0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlLCBza2lwQW5pbWF0aW9ucywgc2VyaWVzVG9VcGRhdGUgPSB0aGlzLnNlcmllcywgbmV3QW5pbWF0aW9uQmF0Y2gsIH0gPSBvcHRzICE9PSBudWxsICYmIG9wdHMgIT09IHZvaWQgMCA/IG9wdHMgOiB7fTtcclxuICAgICAgICBpZiAoZm9yY2VOb2RlRGF0YVJlZnJlc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiBzZXJpZXMubWFya05vZGVEYXRhRGlydHkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHNlcmllc1RvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUuYWRkKHNlcmllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChza2lwQW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3QW5pbWF0aW9uQmF0Y2gpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChEZWJ1Zy5jaGVjayh0cnVlKSkge1xyXG4gICAgICAgICAgICBsZXQgc3RhY2sgPSAoX2IgPSBuZXcgRXJyb3IoKS5zdGFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJzx1bmtub3duPic7XHJcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXFwoW14pXSovZywgJycpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnNbc3RhY2tdID0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPCB0aGlzLl9wZXJmb3JtVXBkYXRlVHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybVVwZGF0ZVRyaWdnZXIuc2NoZWR1bGUob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmJhY2tPZmZNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGVyZm9ybVVwZGF0ZShjb3VudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IF9wZXJmb3JtVXBkYXRlVHlwZTogcGVyZm9ybVVwZGF0ZVR5cGUsIGV4dHJhRGVidWdTdGF0cyB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWVzVG9VcGRhdGUgPSBbLi4udGhpcy5zZXJpZXNUb1VwZGF0ZV07XHJcbiAgICAgICAgICAgIC8vIENsZWFyIHN0YXRlIGltbWVkaWF0ZWx5IHNvIHRoYXQgc2lkZS1lZmZlY3RzIGNhbiBiZSBkZXRlY3RlZCBwcmlvciB0byBTQ0VORV9SRU5ERVIuXHJcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVUeXBlID0gQ2hhcnRVcGRhdGVUeXBlLk5PTkU7XHJcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUuY2xlYXIoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA9PT0gMCAmJiBwZXJmb3JtVXBkYXRlVHlwZSA8IENoYXJ0VXBkYXRlVHlwZS5TQ0VORV9SRU5ERVIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5zdGFydEJhdGNoKHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gc3RhcnQnLCBDaGFydFVwZGF0ZVR5cGVbcGVyZm9ybVVwZGF0ZVR5cGVdKTtcclxuICAgICAgICAgICAgY29uc3Qgc3BsaXRzID0geyBzdGFydDogcGVyZm9ybWFuY2Uubm93KCkgfTtcclxuICAgICAgICAgICAgc3dpdGNoIChwZXJmb3JtVXBkYXRlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDaGFydFVwZGF0ZVR5cGUuRlVMTDpcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2hhcnRVcGRhdGVUeXBlLlBST0NFU1NfREFUQTpcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnByb2Nlc3NEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlUG9pbnRlcih0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdHNbJ/Cfj60nXSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2hhcnRVcGRhdGVUeXBlLlBFUkZPUk1fTEFZT1VUOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoQ2hhcnRVcGRhdGVUeXBlLlBFUkZPUk1fTEFZT1VUKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrRmlyc3RBdXRvU2l6ZShzZXJpZXNUb1VwZGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucHJvY2Vzc0xheW91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0c1sn4oyWJ10gPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICBjYXNlIENoYXJ0VXBkYXRlVHlwZS5TRVJJRVNfVVBEQVRFOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoQ2hhcnRVcGRhdGVUeXBlLlNFUklFU19VUERBVEUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNlcmllc1JlY3QgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWVzVXBkYXRlcyA9IFsuLi5zZXJpZXNUb1VwZGF0ZV0ubWFwKChzZXJpZXMpID0+IHNlcmllcy51cGRhdGUoeyBzZXJpZXNSZWN0IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChzZXJpZXNVcGRhdGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdHNbJ/CfpJQnXSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2hhcnRVcGRhdGVUeXBlLlRPT0xUSVBfUkVDQUxDVUxBVElPTjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KENoYXJ0VXBkYXRlVHlwZS5UT09MVElQX1JFQ0FMQ1VMQVRJT04pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwTWV0YSA9IHRoaXMudG9vbHRpcE1hbmFnZXIuZ2V0VG9vbHRpcE1ldGEodGhpcy5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNIb3ZlcmVkID0gKChfYSA9IHRvb2x0aXBNZXRhID09PSBudWxsIHx8IHRvb2x0aXBNZXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b29sdGlwTWV0YS5ldmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnaG92ZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJmb3JtVXBkYXRlVHlwZSA8PSBDaGFydFVwZGF0ZVR5cGUuU0VSSUVTX1VQREFURSAmJiBpc0hvdmVyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyKHRvb2x0aXBNZXRhLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRzWyfihpYnXSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgQ2hhcnRVcGRhdGVUeXBlLlNDRU5FX1JFTkRFUjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KENoYXJ0VXBkYXRlVHlwZS5TQ0VORV9SRU5ERVIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBleHRyYURlYnVnU3RhdHNbJ3VwZGF0ZVNob3J0Y3V0Q291bnQnXSA9IHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNjZW5lLnJlbmRlcih7IGRlYnVnU3BsaXRUaW1lczogc3BsaXRzLCBleHRyYURlYnVnU3RhdHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYURlYnVnU3RhdHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICBjYXNlIENoYXJ0VXBkYXRlVHlwZS5OT05FOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaG9ydGN1dENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLmVuZEJhdGNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoVXBkYXRlQ29tcGxldGUodGhpcy5nZXRNaW5SZWN0KCkpO1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gZW5kJywge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbk1zOiBNYXRoLnJvdW5kKChlbmQgLSBzcGxpdHNbJ3N0YXJ0J10pICogMTAwKSAvIDEwMCxcclxuICAgICAgICAgICAgICAgIGNvdW50LFxyXG4gICAgICAgICAgICAgICAgcGVyZm9ybVVwZGF0ZVR5cGU6IENoYXJ0VXBkYXRlVHlwZVtwZXJmb3JtVXBkYXRlVHlwZV0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2hlY2tVcGRhdGVTaG9ydGN1dChjaGVja1VwZGF0ZVR5cGUpIHtcclxuICAgICAgICBjb25zdCBtYXhTaG9ydGN1dHMgPSAzO1xyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPiBtYXhTaG9ydGN1dHMpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLndhcm4oYGV4Y2VlZGVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzaW11bHRhbmVvdXMgdXBkYXRlcyAoJHttYXhTaG9ydGN1dHMgKyAxfSksIGRpc2NhcmRpbmcgY2hhbmdlcyBhbmQgcmVuZGVyaW5nYCwgdGhpcy51cGRhdGVSZXF1ZXN0b3JzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA8PSBjaGVja1VwZGF0ZVR5cGUpIHtcclxuICAgICAgICAgICAgLy8gQSBwcmV2aW91cyBzdGVwIG1vZGlmaWVkIHNlcmllcyBzdGF0ZSwgYW5kIHdlIG5lZWQgdG8gcmUtcnVuIHRoaXMgb3IgYW4gZWFybGllciBzdGVwIGJlZm9yZSByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY2hlY2tGaXJzdEF1dG9TaXplKHNlcmllc1RvVXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b1NpemUgJiYgIXRoaXMuX2xhc3RBdXRvU2l6ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuX3BlcmZvcm1VcGRhdGVOb1JlbmRlckNvdW50Kys7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhY2tPZmZNcyA9IChjb3VudCBeIDIpICogMTA7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8IDgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlc2NoZWR1bGUgaWYgY2FudmFzIHNpemUgaGFzbid0IGJlZW4gc2V0IHlldCB0byBhdm9pZCBhIHJhY2UuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShDaGFydFVwZGF0ZVR5cGUuUEVSRk9STV9MQVlPVVQsIHsgc2VyaWVzVG9VcGRhdGUsIGJhY2tPZmZNcyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ0NoYXJ0LmNoZWNrRmlyc3RBdXRvU2l6ZSgpIC0gYmFja2luZyBvZmYgdW50aWwgZmlyc3Qgc2l6ZSB1cGRhdGUnLCBiYWNrT2ZmTXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFmdGVyIHNldmVyYWwgZmFpbGVkIHBhc3NlcywgY29udGludWUgYW5kIGFjY2VwdCB0aGVyZSBtYXliZSBhIHJlZHVuZGFudFxyXG4gICAgICAgICAgICAvLyByZW5kZXIuIFNvbWV0aW1lcyB0aGlzIGNhc2UgaGFwcGVucyB3aGVuIHdlIGFscmVhZHkgaGF2ZSB0aGUgY29ycmVjdFxyXG4gICAgICAgICAgICAvLyB3aWR0aC9oZWlnaHQsIGFuZCB3ZSBlbmQgdXAgbmV2ZXIgcmVuZGVyaW5nIHRoZSBjaGFydCBpbiB0aGF0IHNjZW5hcmlvLlxyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdDaGFydC5jaGVja0ZpcnN0QXV0b1NpemUoKSAtIHRpbWVvdXQgZm9yIGZpcnN0IHNpemUgdXBkYXRlLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBzZXQgYXhlcyh2YWx1ZXMpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkQXhlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl9heGVzLmZvckVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgYXhpcy5kZXRhY2hBeGlzKHRoaXMuYXhpc0dyb3VwLCB0aGlzLmF4aXNHcmlkR3JvdXApO1xyXG4gICAgICAgICAgICByZW1vdmVkQXhlcy5hZGQoYXhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbWFrZSBsaW5rZWQgYXhlcyBnbyBhZnRlciB0aGUgcmVndWxhciBvbmVzIChzaW11bGF0ZXMgc3RhYmxlIHNvcnQgYnkgYGxpbmtlZFRvYCBwcm9wZXJ0eSlcclxuICAgICAgICB0aGlzLl9heGVzID0gdmFsdWVzLmZpbHRlcigoYSkgPT4gIWEubGlua2VkVG8pLmNvbmNhdCh2YWx1ZXMuZmlsdGVyKChhKSA9PiBhLmxpbmtlZFRvKSk7XHJcbiAgICAgICAgdGhpcy5fYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGF4aXMuYXR0YWNoQXhpcyh0aGlzLmF4aXNHcm91cCwgdGhpcy5heGlzR3JpZEdyb3VwKTtcclxuICAgICAgICAgICAgcmVtb3ZlZEF4ZXMuZGVsZXRlKGF4aXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuem9vbU1hbmFnZXIudXBkYXRlQXhlcyh0aGlzLl9heGVzKTtcclxuICAgICAgICByZW1vdmVkQXhlcy5mb3JFYWNoKChheGlzKSA9PiBheGlzLmRlc3Ryb3koKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgYXhlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXhlcztcclxuICAgIH1cclxuICAgIHNldCBzZXJpZXModmFsdWVzKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxTZXJpZXMoKTtcclxuICAgICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5zZXRTZXJpZXNDb3VudCh2YWx1ZXMubGVuZ3RoKTtcclxuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB0aGlzLmFkZFNlcmllcyhzZXJpZXMpKTtcclxuICAgIH1cclxuICAgIGdldCBzZXJpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmllcztcclxuICAgIH1cclxuICAgIGFkZFNlcmllcyhzZXJpZXMpIHtcclxuICAgICAgICBjb25zdCB7IHNlcmllczogYWxsU2VyaWVzIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNhbkFkZCA9IGFsbFNlcmllcy5pbmRleE9mKHNlcmllcykgPCAwO1xyXG4gICAgICAgIGlmIChjYW5BZGQpIHtcclxuICAgICAgICAgICAgYWxsU2VyaWVzLnB1c2goc2VyaWVzKTtcclxuICAgICAgICAgICAgaWYgKHNlcmllcy5yb290R3JvdXAucGFyZW50ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLnJlcXVlc3RHcm91cChzZXJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFNlcmllcyhzZXJpZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaW5pdFNlcmllcyhzZXJpZXMpIHtcclxuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXM7XHJcbiAgICAgICAgc2VyaWVzLmNoYXJ0ID0ge1xyXG4gICAgICAgICAgICBnZXQgbW9kZSgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydC5tb2RlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgc2VyaWVzUmVjdCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydC5zZXJpZXNSZWN0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwbGFjZUxhYmVscygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydC5wbGFjZUxhYmVscygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VyaWVzLnNldENoYXJ0RGF0YSh0aGlzLmRhdGEpO1xyXG4gICAgICAgIHRoaXMuYWRkU2VyaWVzTGlzdGVuZXJzKHNlcmllcyk7XHJcbiAgICAgICAgc2VyaWVzLmFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUFsbFNlcmllcygpIHtcclxuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ25vZGVDbGljaycsIHRoaXMub25TZXJpZXNOb2RlQ2xpY2spO1xyXG4gICAgICAgICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbm9kZURvdWJsZUNsaWNrJywgdGhpcy5vblNlcmllc05vZGVEb3VibGVDbGljayk7XHJcbiAgICAgICAgICAgIHNlcmllcy5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHNlcmllcy5jaGFydCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9zZXJpZXMgPSBbXTsgLy8gdXNpbmcgYF9zZXJpZXNgIGluc3RlYWQgb2YgYHNlcmllc2AgdG8gcHJldmVudCBpbmZpbml0ZSByZWN1cnNpb25cclxuICAgIH1cclxuICAgIGFkZFNlcmllc0xpc3RlbmVycyhzZXJpZXMpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKCdzZXJpZXNOb2RlQ2xpY2snKSkge1xyXG4gICAgICAgICAgICBzZXJpZXMuYWRkRXZlbnRMaXN0ZW5lcignbm9kZUNsaWNrJywgdGhpcy5vblNlcmllc05vZGVDbGljayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoJ3Nlcmllc05vZGVEb3VibGVDbGljaycpKSB7XHJcbiAgICAgICAgICAgIHNlcmllcy5hZGRFdmVudExpc3RlbmVyKCdub2RlRG91YmxlQ2xpY2snLCB0aGlzLm9uU2VyaWVzTm9kZURvdWJsZUNsaWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVBbGxTZXJpZXNMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKCdub2RlQ2xpY2snLCB0aGlzLm9uU2VyaWVzTm9kZUNsaWNrKTtcclxuICAgICAgICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ25vZGVEb3VibGVDbGljaycsIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2spO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFNlcmllc0xpc3RlbmVycyhzZXJpZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXNzaWduU2VyaWVzVG9BeGVzKCkge1xyXG4gICAgICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGF4aXMuYm91bmRTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmllc0F4aXMgPSBzLmF4ZXNbYXhpcy5kaXJlY3Rpb25dO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllc0F4aXMgPT09IGF4aXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXNzaWduQXhlc1RvU2VyaWVzKCkge1xyXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGhhcyB0byBydW4gYmVmb3JlIGBhc3NpZ25TZXJpZXNUb0F4ZXNgLlxyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvblRvQXhlc01hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gYXhpcy5kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkF4ZXMgPSAoKF9hID0gZGlyZWN0aW9uVG9BeGVzTWFwW2RpcmVjdGlvbl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChkaXJlY3Rpb25Ub0F4ZXNNYXBbZGlyZWN0aW9uXSA9IFtdKSk7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbkF4ZXMucHVzaChheGlzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgc2VyaWVzLmRpcmVjdGlvbnMuZm9yRWFjaCgoZGlyZWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BeGVzID0gZGlyZWN0aW9uVG9BeGVzTWFwW2RpcmVjdGlvbl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpcmVjdGlvbkF4ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoYG5vIGF2YWlsYWJsZSBheGlzIGZvciBkaXJlY3Rpb24gWyR7ZGlyZWN0aW9ufV07IGNoZWNrIHNlcmllcyBhbmQgYXhlcyBjb25maWd1cmF0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmllc0tleXMgPSBzZXJpZXMuZ2V0S2V5cyhkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QXhpcyA9IHRoaXMuZmluZE1hdGNoaW5nQXhpcyhkaXJlY3Rpb25BeGVzLCBzZXJpZXNLZXlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghbmV3QXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci53YXJuT25jZShgbm8gbWF0Y2hpbmcgYXhpcyBmb3IgZGlyZWN0aW9uIFske2RpcmVjdGlvbn1dIGFuZCBrZXlzIFske3Nlcmllc0tleXN9XTsgY2hlY2sgc2VyaWVzIGFuZCBheGVzIGNvbmZpZ3VyYXRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VyaWVzLmF4ZXNbZGlyZWN0aW9uXSA9IG5ld0F4aXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZmluZE1hdGNoaW5nQXhpcyhkaXJlY3Rpb25BeGVzLCBkaXJlY3Rpb25LZXlzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBheGlzIG9mIGRpcmVjdGlvbkF4ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgYXhpc0tleXMgPSBheGlzLmtleXM7XHJcbiAgICAgICAgICAgIGlmICghYXhpc0tleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWRpcmVjdGlvbktleXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGlyZWN0aW9uS2V5IG9mIGRpcmVjdGlvbktleXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChheGlzS2V5cy5pbmRleE9mKGRpcmVjdGlvbktleSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmF3UmVzaXplKHNpemUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2l6ZTtcclxuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGgpO1xyXG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0KTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0b1NpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW2F1dG9XaWR0aCA9IDAsIGF1dGhIZWlnaHQgPSAwXSA9IChfYSA9IHRoaXMuX2xhc3RBdXRvU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICAgICAgaWYgKGF1dG9XaWR0aCA9PT0gd2lkdGggJiYgYXV0aEhlaWdodCA9PT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGFzdEF1dG9TaXplID0gW3dpZHRoLCBoZWlnaHRdO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAnU2l6ZU1vbml0b3InKTtcclxuICAgIH1cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBzb3VyY2UpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgd2lkdGggIT09IG51bGwgJiYgd2lkdGggIT09IHZvaWQgMCA/IHdpZHRoIDogKHdpZHRoID0gKF9hID0gdGhpcy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuYXV0b1NpemUgPyAoX2IgPSB0aGlzLl9sYXN0QXV0b1NpemUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXSA6IHRoaXMuc2NlbmUuY2FudmFzLndpZHRoKSk7XHJcbiAgICAgICAgaGVpZ2h0ICE9PSBudWxsICYmIGhlaWdodCAhPT0gdm9pZCAwID8gaGVpZ2h0IDogKGhlaWdodCA9IChfYyA9IHRoaXMuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAodGhpcy5hdXRvU2l6ZSA/IChfZCA9IHRoaXMuX2xhc3RBdXRvU2l6ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kWzFdIDogdGhpcy5zY2VuZS5jYW52YXMuaGVpZ2h0KSk7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQ2hhcnQucmVzaXplKCkgZnJvbSAke3NvdXJjZX1gLCB7IHdpZHRoLCBoZWlnaHQsIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB9KTtcclxuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQgfHwgIU51bWJlci5pc0Zpbml0ZSh3aWR0aCkgfHwgIU51bWJlci5pc0Zpbml0ZShoZWlnaHQpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUucmVzaXplKHdpZHRoLCBoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZVBvaW50ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIGxldCBza2lwQW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9TaXplICYmIHRoaXMuX2ZpcnN0QXV0b1NpemUpIHtcclxuICAgICAgICAgICAgICAgIHNraXBBbmltYXRpb25zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJzdEF1dG9TaXplID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoQ2hhcnRVcGRhdGVUeXBlLlBFUkZPUk1fTEFZT1VULCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlLCBza2lwQW5pbWF0aW9ucyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy5jYW5IYXZlQXhlcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduQXhlc1RvU2VyaWVzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2lnblNlcmllc1RvQXhlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFDb250cm9sbGVyID0gbmV3IERhdGFDb250cm9sbGVyKHRoaXMubW9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc1Byb21pc2VzID0gdGhpcy5zZXJpZXMubWFwKChzKSA9PiBzLnByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSk7XHJcbiAgICAgICAgICAgIHlpZWxkIGRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoc2VyaWVzUHJvbWlzZXMpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZUxlZ2VuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGxhY2VMYWJlbHMoKSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZVNlcmllcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiB0aGlzLnNlcmllcykge1xyXG4gICAgICAgICAgICBpZiAoIXNlcmllcy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBzZXJpZXMuZ2V0TGFiZWxEYXRhKCk7XHJcbiAgICAgICAgICAgIGlmICghKGxhYmVsRGF0YSAmJiBpc1BvaW50TGFiZWxEYXR1bShsYWJlbERhdGFbMF0pKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0YS5wdXNoKGxhYmVsRGF0YSk7XHJcbiAgICAgICAgICAgIHZpc2libGVTZXJpZXMucHVzaChzZXJpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHNlcmllc1JlY3QgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gc2VyaWVzUmVjdCAmJiBkYXRhLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyBwbGFjZUxhYmVscyhkYXRhLCB7IHg6IDAsIHk6IDAsIHdpZHRoOiBzZXJpZXNSZWN0LndpZHRoLCBoZWlnaHQ6IHNlcmllc1JlY3QuaGVpZ2h0IH0pXHJcbiAgICAgICAgICAgIDogW107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobGFiZWxzLm1hcCgobCwgaSkgPT4gW3Zpc2libGVTZXJpZXNbaV0sIGxdKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMZWdlbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmRzLmZvckVhY2goKGxlZ2VuZCwgbGVnZW5kVHlwZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDYXRlZ29yeUxlZ2VuZERhdGEgPSAoZGF0YSkgPT4gZGF0YS5ldmVyeSgoZCkgPT4gZC5sZWdlbmRUeXBlID09PSAnY2F0ZWdvcnknKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZ2VuZERhdGEgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHMpID0+IHMuc2hvd0luTGVnZW5kKS5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2F0ZWdvcnlMZWdlbmREYXRhKGxlZ2VuZERhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhdGVnb3J5TGVnZW5kRGF0YShsZWdlbmREYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxlZ2VuZC5kYXRhID0gbGVnZW5kRGF0YTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZUNhdGVnb3J5TGVnZW5kRGF0YShsZWdlbmREYXRhKSB7XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgZWFjaCBzZXJpZXMgdGhhdCBzaGFyZXMgYSBsZWdlbmQgaXRlbSBsYWJlbCB1c2VzIHRoZSBzYW1lIGZpbGwgY29sb3VyXHJcbiAgICAgICAgY29uc3QgbGFiZWxNYXJrZXJGaWxscyA9IHt9O1xyXG4gICAgICAgIGxlZ2VuZERhdGEuZm9yRWFjaCgoZCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgdmFyIF9kLCBfZTtcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IChfYSA9IHRoaXMuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGQuc2VyaWVzSWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZTtcclxuICAgICAgICAgICAgaWYgKCFzZXJpZXNUeXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAoX2IgPSBsYWJlbE1hcmtlckZpbGxzW3Nlcmllc1R5cGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAobGFiZWxNYXJrZXJGaWxsc1tzZXJpZXNUeXBlXSA9IHt9KTtcclxuICAgICAgICAgICAgKF9jID0gKF9kID0gbGFiZWxNYXJrZXJGaWxsc1tzZXJpZXNUeXBlXSlbX2UgPSBkLmxhYmVsLnRleHRdKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2RbX2VdID0gbmV3IFNldCgpKTtcclxuICAgICAgICAgICAgaWYgKGQubWFya2VyLmZpbGwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbGFiZWxNYXJrZXJGaWxsc1tzZXJpZXNUeXBlXVtkLmxhYmVsLnRleHRdLmFkZChkLm1hcmtlci5maWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VyaWVzTWFya2VycyBvZiBPYmplY3QudmFsdWVzKGxhYmVsTWFya2VyRmlsbHMpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZpbGxzXSBvZiBPYmplY3QuZW50cmllcyhzZXJpZXNNYXJrZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGxzLnNpemUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGBsZWdlbmQgaXRlbSAnJHtuYW1lfScgaGFzIG11bHRpcGxlIGZpbGwgY29sb3JzLCB0aGlzIG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb2Nlc3NMYXlvdXQoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFJlY3QgPSB0aGlzLmFuaW1hdGlvblJlY3Q7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybUxheW91dCgpO1xyXG4gICAgICAgICAgICBpZiAob2xkUmVjdCAmJiAhKChfYSA9IHRoaXMuYW5pbWF0aW9uUmVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVxdWFscyhvbGRSZWN0KSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNraXAgYW5pbWF0aW9ucyBpZiB0aGUgbGF5b3V0IGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTm9EYXRhT3ZlcmxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdDaGFydC5wZXJmb3JtVXBkYXRlKCkgLSBzZXJpZXNSZWN0JywgdGhpcy5zZXJpZXNSZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBlcmZvcm1MYXlvdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUucm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5yb290LnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zY2VuZTtcclxuICAgICAgICAgICAgbGV0IGN0eCA9IHsgc2hyaW5rUmVjdDogbmV3IEJCb3goMCwgMCwgd2lkdGgsIGhlaWdodCkgfTtcclxuICAgICAgICAgICAgY3R4ID0gdGhpcy5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoUGVyZm9ybUxheW91dCgnc3RhcnQtbGF5b3V0JywgY3R4KTtcclxuICAgICAgICAgICAgY3R4ID0gdGhpcy5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoUGVyZm9ybUxheW91dCgnYmVmb3JlLXNlcmllcycsIGN0eCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdHguc2hyaW5rUmVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIHgveSBhcmUgbG9jYWwgY2FudmFzIGNvb3JkaW5hdGVzIGluIENTUyBwaXhlbHMsIG5vdCBhY3R1YWwgcGl4ZWxzXHJcbiAgICBwaWNrU2VyaWVzTm9kZShwb2ludCwgZXhhY3RNYXRjaE9ubHksIG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIC8vIERpc2FibGUgJ25lYXJlc3QgbWF0Y2gnIG9wdGlvbnMgaWYgbG9va2luZyBmb3IgZXhhY3QgbWF0Y2hlcyBvbmx5XHJcbiAgICAgICAgY29uc3QgcGlja01vZGVzID0gZXhhY3RNYXRjaE9ubHkgPyBbU2VyaWVzTm9kZVBpY2tNb2RlLkVYQUNUX1NIQVBFX01BVENIXSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggc2VyaWVzIGluIHJldmVyc2UsIGFzIGxhdGVyIGRlY2xhcmVkIHNlcmllcyBhcHBlYXJzIG9uIHRvcCBvZiBlYXJsaWVyXHJcbiAgICAgICAgLy8gZGVjbGFyZWQgc2VyaWVzLlxyXG4gICAgICAgIGNvbnN0IHJldmVyc2VTZXJpZXMgPSBbLi4udGhpcy5zZXJpZXNdLnJldmVyc2UoKTtcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHJldmVyc2VTZXJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSB8fCAhc2VyaWVzLnJvb3RHcm91cC52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IG1hdGNoLCBkaXN0YW5jZSB9ID0gKF9hID0gc2VyaWVzLnBpY2tOb2RlKHBvaW50LCBwaWNrTW9kZXMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcclxuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCBkaXN0YW5jZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKCFyZXN1bHQgfHwgcmVzdWx0LmRpc3RhbmNlID4gZGlzdGFuY2UpICYmIGRpc3RhbmNlIDw9IChtYXhEaXN0YW5jZSAhPT0gbnVsbCAmJiBtYXhEaXN0YW5jZSAhPT0gdm9pZCAwID8gbWF4RGlzdGFuY2UgOiBJbmZpbml0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgc2VyaWVzLCBkaXN0YW5jZSwgZGF0dW06IG1hdGNoIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV4dHJhRGVidWdTdGF0c1sncGlja1Nlcmllc05vZGUnXSA9IE1hdGgucm91bmQoKChfYiA9IHRoaXMuZXh0cmFEZWJ1Z1N0YXRzWydwaWNrU2VyaWVzTm9kZSddKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSArIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0SW50ZXJhY3Rpb25FdmVudCA9IGV2ZW50O1xyXG4gICAgICAgIHRoaXMucG9pbnRlclNjaGVkdWxlci5zY2hlZHVsZSgpO1xyXG4gICAgICAgIHRoaXMuZXh0cmFEZWJ1Z1N0YXRzWydtb3VzZVgnXSA9IGV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgdGhpcy5leHRyYURlYnVnU3RhdHNbJ21vdXNlWSddID0gZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICB0aGlzLnVwZGF0ZShDaGFydFVwZGF0ZVR5cGUuU0NFTkVfUkVOREVSKTtcclxuICAgIH1cclxuICAgIG9uTGVhdmUoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy50b29sdGlwLnBvaW50ZXJMZWZ0T250b1Rvb2x0aXAoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlUG9pbnRlcigpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlUG9pbnRlcihldmVudCkge1xyXG4gICAgICAgIGNvbnN0IHsgbGFzdFBpY2ssIGhvdmVyUmVjdCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xyXG4gICAgICAgIGNvbnN0IGRpc2FibGVQb2ludGVyID0gKGhpZ2hsaWdodE9ubHkgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGFzdFBpY2spIHtcclxuICAgICAgICAgICAgICAgIC8vIEN1cnNvciBtb3ZlZCBmcm9tIGEgbm9uLW1hcmtlciBub2RlIHRvIGVtcHR5IHNwYWNlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlUG9pbnRlcihoaWdobGlnaHRPbmx5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCEoaG92ZXJSZWN0ID09PSBudWxsIHx8IGhvdmVyUmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG92ZXJSZWN0LmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpKSB7XHJcbiAgICAgICAgICAgIGRpc2FibGVQb2ludGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSGFuZGxlIG5vZGUgaGlnaGxpZ2h0aW5nIGFuZCB0b29sdGlwIHRvZ2dsaW5nIHdoZW4gcG9pbnRlciB3aXRoaW4gYHRvb2x0aXAucmFuZ2VgXHJcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVG9vbHRpcChldmVudCwgZGlzYWJsZVBvaW50ZXIpO1xyXG4gICAgICAgIC8vIEhhbmRsZSBub2RlIGhpZ2hsaWdodGluZyBhbmQgbW91c2UgY3Vyc29yIHdoZW4gcG9pbnRlciB3aXRoaW5nIGBzZXJpZXNbXS5ub2RlQ2xpY2tSYW5nZWBcclxuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJOb2RlKGV2ZW50KTtcclxuICAgIH1cclxuICAgIGhhbmRsZVBvaW50ZXJUb29sdGlwKGV2ZW50LCBkaXNhYmxlUG9pbnRlcikge1xyXG4gICAgICAgIGNvbnN0IHsgbGFzdFBpY2ssIHRvb2x0aXAgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyByYW5nZSB9ID0gdG9vbHRpcDtcclxuICAgICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xyXG4gICAgICAgIGxldCBwaXhlbFJhbmdlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShyYW5nZSkpIHtcclxuICAgICAgICAgICAgcGl4ZWxSYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwaWNrID0gdGhpcy5waWNrU2VyaWVzTm9kZSh7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfSwgcmFuZ2UgPT09ICdleGFjdCcsIHBpeGVsUmFuZ2UpO1xyXG4gICAgICAgIGlmICghcGljaykge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodC5yYW5nZSA9PT0gJ3Rvb2x0aXAnKVxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZVBvaW50ZXIodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNOZXdEYXR1bSA9IHRoaXMuaGlnaGxpZ2h0LnJhbmdlID09PSAnbm9kZScgfHwgIWxhc3RQaWNrIHx8IGxhc3RQaWNrLmRhdHVtICE9PSBwaWNrLmRhdHVtO1xyXG4gICAgICAgIGxldCBodG1sO1xyXG4gICAgICAgIGlmIChpc05ld0RhdHVtKSB7XHJcbiAgICAgICAgICAgIGh0bWwgPSBwaWNrLnNlcmllcy5nZXRUb29sdGlwSHRtbChwaWNrLmRhdHVtKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0LnJhbmdlID09PSAndG9vbHRpcCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgcGljay5kYXR1bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGFzdFBpY2spIHtcclxuICAgICAgICAgICAgbGFzdFBpY2suZXZlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNQaXhlbFJhbmdlID0gcGl4ZWxSYW5nZSAhPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBFbmFibGVkID0gdGhpcy50b29sdGlwLmVuYWJsZWQgJiYgcGljay5zZXJpZXMudG9vbHRpcC5lbmFibGVkO1xyXG4gICAgICAgIGNvbnN0IGV4YWN0bHlNYXRjaGVkID0gcmFuZ2UgPT09ICdleGFjdCcgJiYgcGljay5kaXN0YW5jZSA9PT0gMDtcclxuICAgICAgICBjb25zdCByYW5nZU1hdGNoZWQgPSByYW5nZSA9PT0gJ25lYXJlc3QnIHx8IGlzUGl4ZWxSYW5nZSB8fCBleGFjdGx5TWF0Y2hlZDtcclxuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVUb29sdGlwID0gdG9vbHRpcEVuYWJsZWQgJiYgcmFuZ2VNYXRjaGVkICYmICghaXNOZXdEYXR1bSB8fCBodG1sICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIGNvbnN0IG1ldGEgPSBUb29sdGlwTWFuYWdlci5tYWtlVG9vbHRpcE1ldGEoZXZlbnQsIHRoaXMuc2NlbmUuY2FudmFzLCBwaWNrLmRhdHVtLCB0aGlzLnNwZWNpYWxPdmVycmlkZXMud2luZG93KTtcclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVG9vbHRpcCkge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBNYW5hZ2VyLnVwZGF0ZVRvb2x0aXAodGhpcy5pZCwgbWV0YSwgaHRtbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlUG9pbnRlck5vZGUoZXZlbnQpIHtcclxuICAgICAgICBjb25zdCBmb3VuZCA9IHRoaXMuY2hlY2tTZXJpZXNOb2RlUmFuZ2UoZXZlbnQsIChzZXJpZXMsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzZXJpZXMuaGFzRXZlbnRMaXN0ZW5lcignbm9kZUNsaWNrJykgfHwgc2VyaWVzLmhhc0V2ZW50TGlzdGVuZXIoJ25vZGVEb3VibGVDbGljaycpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKCdjaGFydCcsICdwb2ludGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0LnJhbmdlID09PSAnbm9kZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZGF0dW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKCdjaGFydCcpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHQucmFuZ2UgPT09ICdub2RlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQ2xpY2soZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGVja1Nlcmllc05vZGVDbGljayhldmVudCkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoQ2hhcnRVcGRhdGVUeXBlLlNFUklFU19VUERBVEUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KHtcclxuICAgICAgICAgICAgdHlwZTogJ2NsaWNrJyxcclxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LnNvdXJjZUV2ZW50LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25Eb3VibGVDbGljayhldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrU2VyaWVzTm9kZURvdWJsZUNsaWNrKGV2ZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShDaGFydFVwZGF0ZVR5cGUuU0VSSUVTX1VQREFURSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiAnZG91YmxlQ2xpY2snLFxyXG4gICAgICAgICAgICBldmVudDogZXZlbnQuc291cmNlRXZlbnQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjaGVja1Nlcmllc05vZGVDbGljayhldmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrU2VyaWVzTm9kZVJhbmdlKGV2ZW50LCAoc2VyaWVzLCBkYXR1bSkgPT4gc2VyaWVzLmZpcmVOb2RlQ2xpY2tFdmVudChldmVudC5zb3VyY2VFdmVudCwgZGF0dW0pKTtcclxuICAgIH1cclxuICAgIGNoZWNrU2VyaWVzTm9kZURvdWJsZUNsaWNrKGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTZXJpZXNOb2RlUmFuZ2UoZXZlbnQsIChzZXJpZXMsIGRhdHVtKSA9PiBzZXJpZXMuZmlyZU5vZGVEb3VibGVDbGlja0V2ZW50KGV2ZW50LnNvdXJjZUV2ZW50LCBkYXR1bSkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tTZXJpZXNOb2RlUmFuZ2UoZXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgbmVhcmVzdE5vZGUgPSB0aGlzLnBpY2tTZXJpZXNOb2RlKHsgeDogZXZlbnQub2Zmc2V0WCwgeTogZXZlbnQub2Zmc2V0WSB9LCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGF0dW0gPSBuZWFyZXN0Tm9kZSA9PT0gbnVsbCB8fCBuZWFyZXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmVhcmVzdE5vZGUuZGF0dW07XHJcbiAgICAgICAgY29uc3Qgbm9kZUNsaWNrUmFuZ2UgPSBkYXR1bSA9PT0gbnVsbCB8fCBkYXR1bSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0dW0uc2VyaWVzLm5vZGVDbGlja1JhbmdlO1xyXG4gICAgICAgIGxldCBwaXhlbFJhbmdlO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZUNsaWNrUmFuZ2UgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShub2RlQ2xpY2tSYW5nZSkpIHtcclxuICAgICAgICAgICAgcGl4ZWxSYW5nZSA9IG5vZGVDbGlja1JhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaW5kIHRoZSBub2RlIGlmIGV4YWN0bHkgbWF0Y2hlZCBhbmQgdXBkYXRlIHRoZSBoaWdobGlnaHQgcGlja2VkIG5vZGVcclxuICAgICAgICBsZXQgcGlja2VkTm9kZSA9IHRoaXMucGlja1Nlcmllc05vZGUoeyB4OiBldmVudC5vZmZzZXRYLCB5OiBldmVudC5vZmZzZXRZIH0sIHRydWUpO1xyXG4gICAgICAgIGlmIChwaWNrZWROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVQaWNrZWQodGhpcy5pZCwgcGlja2VkTm9kZS5kYXR1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlUGlja2VkKHRoaXMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBzaG91bGQgdHJpZ2dlciB0aGUgY2FsbGJhY2sgYmFzZWQgb24gbmVhcmVzdCBub2RlXHJcbiAgICAgICAgaWYgKGRhdHVtICYmIG5vZGVDbGlja1JhbmdlID09PSAnbmVhcmVzdCcpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soZGF0dW0uc2VyaWVzLCBkYXR1bSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZUNsaWNrUmFuZ2UgIT09ICdleGFjdCcpIHtcclxuICAgICAgICAgICAgcGlja2VkTm9kZSA9IHRoaXMucGlja1Nlcmllc05vZGUoeyB4OiBldmVudC5vZmZzZXRYLCB5OiBldmVudC5vZmZzZXRZIH0sIGZhbHNlLCBwaXhlbFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwaWNrZWROb2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gVGhlbiBpZiB3ZSd2ZSBwaWNrZWQgYSBub2RlIHdpdGhpbiB0aGUgcGl4ZWwgcmFuZ2UsIG9yIGV4YWN0bHksIHRyaWdnZXIgdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgY29uc3QgaXNQaXhlbFJhbmdlID0gcGl4ZWxSYW5nZSAhPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGV4YWN0bHlNYXRjaGVkID0gbm9kZUNsaWNrUmFuZ2UgPT09ICdleGFjdCcgJiYgcGlja2VkTm9kZS5kaXN0YW5jZSA9PT0gMDtcclxuICAgICAgICBpZiAoaXNQaXhlbFJhbmdlIHx8IGV4YWN0bHlNYXRjaGVkKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHBpY2tlZE5vZGUuc2VyaWVzLCBwaWNrZWROb2RlLmRhdHVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNoYW5nZUhpZ2hsaWdodERhdHVtKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBzZXJpZXNUb1VwZGF0ZSA9IG5ldyBTZXQoKTtcclxuICAgICAgICBjb25zdCB7IHNlcmllczogbmV3U2VyaWVzID0gdW5kZWZpbmVkLCBkYXR1bTogbmV3RGF0dW0gfSA9IChfYSA9IGV2ZW50LmN1cnJlbnRIaWdobGlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xyXG4gICAgICAgIGNvbnN0IHsgc2VyaWVzOiBsYXN0U2VyaWVzID0gdW5kZWZpbmVkLCBkYXR1bTogbGFzdERhdHVtIH0gPSAoX2IgPSBldmVudC5wcmV2aW91c0hpZ2hsaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XHJcbiAgICAgICAgaWYgKGxhc3RTZXJpZXMpIHtcclxuICAgICAgICAgICAgc2VyaWVzVG9VcGRhdGUuYWRkKGxhc3RTZXJpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3U2VyaWVzKSB7XHJcbiAgICAgICAgICAgIHNlcmllc1RvVXBkYXRlLmFkZChuZXdTZXJpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGp1c3QgY3Vyc29yIGlmIGEgc3BlY2lmaWMgZGF0dW0gaXMgaGlnaGxpZ2h0ZWQsIHJhdGhlciB0aGFuIGp1c3QgYSBzZXJpZXMuXHJcbiAgICAgICAgaWYgKChsYXN0U2VyaWVzID09PSBudWxsIHx8IGxhc3RTZXJpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RTZXJpZXMuY3Vyc29yKSAmJiBsYXN0RGF0dW0pIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihsYXN0U2VyaWVzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChuZXdTZXJpZXMgPT09IG51bGwgfHwgbmV3U2VyaWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdTZXJpZXMuY3Vyc29yKSAmJiBuZXdEYXR1bSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKG5ld1Nlcmllcy5pZCwgbmV3U2VyaWVzLmN1cnNvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdFBpY2sgPSBldmVudC5jdXJyZW50SGlnaGxpZ2h0ID8geyBkYXR1bTogZXZlbnQuY3VycmVudEhpZ2hsaWdodCB9IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZUFsbCA9IG5ld1NlcmllcyA9PSBudWxsIHx8IGxhc3RTZXJpZXMgPT0gbnVsbDtcclxuICAgICAgICBpZiAodXBkYXRlQWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKENoYXJ0VXBkYXRlVHlwZS5TRVJJRVNfVVBEQVRFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKENoYXJ0VXBkYXRlVHlwZS5TRVJJRVNfVVBEQVRFLCB7IHNlcmllc1RvVXBkYXRlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdhaXRGb3JVcGRhdGUodGltZW91dE1zID0gNTAwMCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIEF3YWl0IHVudGlsIGFueSBwZW5kaW5nIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdGhyb3VnaC5cclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlTXV0ZXgud2FpdEZvckNsZWFyQWNxdWlyZVF1ZXVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlcmZvcm1VcGRhdGVUeXBlICE9PSBDaGFydFVwZGF0ZVR5cGUuTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0TXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhaXRGb3JVcGRhdGUoKSB0aW1lb3V0IHJlYWNoZWQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBzbGVlcCg1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBd2FpdCB1bnRpbCBhbnkgcmVtYWluaW5nIHVwZGF0ZXMgYXJlIGZsdXNoZWQgdGhyb3VnaC5cclxuICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVNdXRleC53YWl0Rm9yQ2xlYXJBY3F1aXJlUXVldWUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGhhbmRsZU5vRGF0YU92ZXJsYXkoKSB7XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkRGlzcGxheU5vRGF0YU92ZXJsYXkgPSAhdGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy5oYXNEYXRhKCkpO1xyXG4gICAgICAgIGlmIChzaG91bGREaXNwbGF5Tm9EYXRhT3ZlcmxheSAmJiB0aGlzLnNlcmllc1JlY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5vdmVybGF5cy5ub0RhdGEuc2hvdyh0aGlzLnNlcmllc1JlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vdmVybGF5cy5ub0RhdGEuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE1pblJlY3QoKSB7XHJcbiAgICAgICAgY29uc3QgbWluUmVjdHMgPSB0aGlzLnNlcmllcy5tYXAoKHNlcmllcykgPT4gc2VyaWVzLmdldE1pblJlY3QoKSkuZmlsdGVyKChyZWN0KSA9PiByZWN0ICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIGlmICghbWluUmVjdHMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBuZXcgQkJveCgwLCAwLCBtaW5SZWN0cy5yZWR1Y2UoKG1heCwgcmVjdCkgPT4gTWF0aC5tYXgobWF4LCByZWN0LndpZHRoKSwgMCksIG1pblJlY3RzLnJlZHVjZSgobWF4LCByZWN0KSA9PiBNYXRoLm1heChtYXgsIHJlY3QuaGVpZ2h0KSwgMCkpO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgQWN0aW9uT25TZXQoe1xyXG4gICAgICAgIG5ld1ZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9sZFZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQ2hhcnQucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIEFjdGlvbk9uU2V0KHtcclxuICAgICAgICBuZXdWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXMuc2V0Q2hhcnREYXRhKHZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQ2hhcnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBBY3Rpb25PblNldCh7XHJcbiAgICAgICAgbmV3VmFsdWUodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUodmFsdWUsIHVuZGVmaW5lZCwgJ3dpZHRoIG9wdGlvbicpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIENoYXJ0LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIEFjdGlvbk9uU2V0KHtcclxuICAgICAgICBuZXdWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh1bmRlZmluZWQsIHZhbHVlLCAnaGVpZ2h0IG9wdGlvbicpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIENoYXJ0LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBBY3Rpb25PblNldCh7XHJcbiAgICAgICAgY2hhbmdlVmFsdWUodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hdXRvU2l6ZUNoYW5nZWQodmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQ2hhcnQucHJvdG90eXBlLCBcImF1dG9TaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgQWN0aW9uT25TZXQoe1xyXG4gICAgICAgIG5ld1ZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5zY2VuZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbGRWYWx1ZShvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc2NlbmUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKG9sZFZhbHVlLm5vZGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuXSwgQ2hhcnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgQWN0aW9uT25TZXQoe1xyXG4gICAgICAgIG5ld1ZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5zY2VuZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbGRWYWx1ZShvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc2NlbmUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKG9sZFZhbHVlLm5vZGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuXSwgQ2hhcnQucHJvdG90eXBlLCBcInN1YnRpdGxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgQWN0aW9uT25TZXQoe1xyXG4gICAgICAgIG5ld1ZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5zY2VuZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbGRWYWx1ZShvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc2NlbmUucm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKG9sZFZhbHVlLm5vZGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuXSwgQ2hhcnQucHJvdG90eXBlLCBcImZvb3Rub3RlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoU1RSSU5HX1VOSU9OKCdzdGFuZGFsb25lJywgJ2ludGVncmF0ZWQnKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBDaGFydC5wcm90b3R5cGUsIFwibW9kZVwiLCB2b2lkIDApO1xuXG52YXIgQXJjVHlwZTtcclxuKGZ1bmN0aW9uIChBcmNUeXBlKSB7XHJcbiAgICBBcmNUeXBlW0FyY1R5cGVbXCJPcGVuXCJdID0gMF0gPSBcIk9wZW5cIjtcclxuICAgIEFyY1R5cGVbQXJjVHlwZVtcIkNob3JkXCJdID0gMV0gPSBcIkNob3JkXCI7XHJcbiAgICBBcmNUeXBlW0FyY1R5cGVbXCJSb3VuZFwiXSA9IDJdID0gXCJSb3VuZFwiO1xyXG59KShBcmNUeXBlIHx8IChBcmNUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEVsbGlwdGljYWwgYXJjIG5vZGUuXHJcbiAqL1xyXG5jbGFzcyBBcmMgZXh0ZW5kcyBQYXRoIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJYID0gMDtcclxuICAgICAgICB0aGlzLmNlbnRlclkgPSAwO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gMTA7XHJcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcclxuICAgICAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgdGhpcy5jb3VudGVyQ2xvY2t3aXNlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgYXJjIHRvIHJlbmRlcjpcclxuICAgICAgICAgKiAtIHtAbGluayBBcmNUeXBlLk9wZW59IC0gZW5kIHBvaW50cyBvZiB0aGUgYXJjIHNlZ21lbnQgYXJlIG5vdCBjb25uZWN0ZWQgKGRlZmF1bHQpXHJcbiAgICAgICAgICogLSB7QGxpbmsgQXJjVHlwZS5DaG9yZH0gLSBlbmQgcG9pbnRzIG9mIHRoZSBhcmMgc2VnbWVudCBhcmUgY29ubmVjdGVkIGJ5IGEgbGluZSBzZWdtZW50XHJcbiAgICAgICAgICogLSB7QGxpbmsgQXJjVHlwZS5Sb3VuZH0gLSBlYWNoIG9mIHRoZSBlbmQgcG9pbnRzIG9mIHRoZSBhcmMgc2VnbWVudCBhcmUgY29ubmVjdGVkXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgY2VudGVyIG9mIHRoZSBhcmNcclxuICAgICAgICAgKiBBcmNzIHdpdGgge0BsaW5rIEFyY1R5cGUuT3Blbn0gZG8gbm90IHN1cHBvcnQgaGl0IHRlc3RpbmcsIGV2ZW4gaWYgdGhleSBoYXZlIHRoZWlyXHJcbiAgICAgICAgICoge0BsaW5rIFNoYXBlLmZpbGxTdHlsZX0gc2V0LCBiZWNhdXNlIHRoZXkgYXJlIG5vdCBjbG9zZWQgcGF0aHMuIEhpdCB0ZXN0aW5nIHN1cHBvcnRcclxuICAgICAgICAgKiB3b3VsZCByZXF1aXJlIHVzaW5nIHR3byBwYXRocyAtIG9uZSBmb3IgcmVuZGVyaW5nLCBhbm90aGVyIGZvciBoaXQgdGVzdGluZyAtIGFuZCB0aGVyZVxyXG4gICAgICAgICAqIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIGRvIHRoYXQsIHdoZW4gb25lIGNhbiBqdXN0IHVzZSB7QGxpbmsgQXJjVHlwZS5DaG9yZH1cclxuICAgICAgICAgKiB0byBjcmVhdGUgYSBjbG9zZWQgcGF0aC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBBcmNUeXBlLk9wZW47XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgZnVsbFBpZSgpIHtcclxuICAgICAgICByZXR1cm4gaXNFcXVhbChub3JtYWxpemVBbmdsZTM2MCh0aGlzLnN0YXJ0QW5nbGUpLCBub3JtYWxpemVBbmdsZTM2MCh0aGlzLmVuZEFuZ2xlKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQYXRoKCkge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgcGF0aC5jbGVhcigpOyAvLyBObyBuZWVkIHRvIHJlY3JlYXRlIHRoZSBQYXRoLCBjYW4gc2ltcGx5IGNsZWFyIHRoZSBleGlzdGluZyBvbmUuXHJcbiAgICAgICAgcGF0aC5hcmModGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIHRoaXMucmFkaXVzLCB0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUsIHRoaXMuY291bnRlckNsb2Nrd2lzZSk7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gQXJjVHlwZS5DaG9yZCkge1xyXG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IEFyY1R5cGUuUm91bmQgJiYgIXRoaXMuZnVsbFBpZSkge1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcHV0ZUJCb3goKSB7XHJcbiAgICAgICAgLy8gT25seSB3b3JrcyB3aXRoIGZ1bGwgYXJjcyAoY2lyY2xlcykgYW5kIHVudHJhbnNmb3JtZWQgZWxsaXBzZXMuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCQm94KHRoaXMuY2VudGVyWCAtIHRoaXMucmFkaXVzLCB0aGlzLmNlbnRlclkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xyXG4gICAgfVxyXG4gICAgaXNQb2ludEluUGF0aCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgIT09IEFyY1R5cGUuT3BlbiAmJlxyXG4gICAgICAgICAgICBiYm94LmNvbnRhaW5zUG9pbnQocG9pbnQueCwgcG9pbnQueSkgJiZcclxuICAgICAgICAgICAgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgocG9pbnQueCwgcG9pbnQueSkpO1xyXG4gICAgfVxyXG59XHJcbkFyYy5jbGFzc05hbWUgPSAnQXJjJztcclxuQXJjLmRlZmF1bHRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBTaGFwZS5kZWZhdWx0U3R5bGVzLCB7XHJcbiAgICBsaW5lV2lkdGg6IDEsXHJcbiAgICBmaWxsU3R5bGU6IG51bGwsXHJcbn0pO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQXJjLnByb3RvdHlwZSwgXCJjZW50ZXJYXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBcmMucHJvdG90eXBlLCBcImNlbnRlcllcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIEFyYy5wcm90b3R5cGUsIFwicmFkaXVzXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBcmMucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIEFyYy5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBBcmMucHJvdG90eXBlLCBcImNvdW50ZXJDbG9ja3dpc2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIEFyYy5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuXG5jb25zdCBjb252ZXJ0Q29sb3JTdHJpbmdUb0hzbGEgPSAodikgPT4ge1xyXG4gICAgY29uc3QgY29sb3IgPSBDb2xvci5mcm9tU3RyaW5nKHYpO1xyXG4gICAgY29uc3QgW2gsIHMsIGxdID0gQ29sb3IuUkdCdG9IU0woY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XHJcbiAgICByZXR1cm4geyBoLCBzLCBsLCBhOiBjb2xvci5hIH07XHJcbn07XHJcbmNvbnN0IGludGVycG9sYXRlSHNsYSA9ICh4LCB5LCBkKSA9PiB7XHJcbiAgICBkID0gTWF0aC5taW4oTWF0aC5tYXgoZCwgMCksIDEpO1xyXG4gICAgbGV0IGg7XHJcbiAgICBsZXQgcztcclxuICAgIGlmIChOdW1iZXIuaXNOYU4oeC5oKSAmJiBOdW1iZXIuaXNOYU4oeS5oKSkge1xyXG4gICAgICAgIGggPSAwO1xyXG4gICAgICAgIHMgPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoTnVtYmVyLmlzTmFOKHguaCkpIHtcclxuICAgICAgICBoID0geS5oO1xyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChOdW1iZXIuaXNOYU4oeS5oKSkge1xyXG4gICAgICAgIGggPSB4Lmg7XHJcbiAgICAgICAgcyA9IHgucztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHhIID0geC5oO1xyXG4gICAgICAgIGxldCB5SCA9IHkuaDtcclxuICAgICAgICBjb25zdCBkZWx0YUggPSB5LmggLSB4Lmg7XHJcbiAgICAgICAgaWYgKGRlbHRhSCA+IDE4MCkge1xyXG4gICAgICAgICAgICB5SCAtPSAzNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhSCA8IC0xODApIHtcclxuICAgICAgICAgICAgeUggKz0gMzYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoID0geEggKiAoMSAtIGQpICsgeUggKiBkO1xyXG4gICAgICAgIHMgPSB4LnMgKiAoMSAtIGQpICsgeS5zICogZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGwgPSB4LmwgKiAoMSAtIGQpICsgeS5sICogZDtcclxuICAgIGNvbnN0IGEgPSB4LmEgKiAoMSAtIGQpICsgeS5hICogZDtcclxuICAgIHJldHVybiBDb2xvci5mcm9tSFNMKGgsIHMsIGwsIGEpO1xyXG59O1xyXG5jbGFzcyBDb2xvclNjYWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gWzAsIDFdO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSBbJ3JlZCcsICdibHVlJ107XHJcbiAgICAgICAgdGhpcy5wYXJzZWRSYW5nZSA9IHRoaXMucmFuZ2UubWFwKGNvbnZlcnRDb2xvclN0cmluZ1RvSHNsYSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgY29uc3QgeyBkb21haW4sIHJhbmdlIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmIChkb21haW4ubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoJ2Bjb2xvckRvbWFpbmAgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXMuJyk7XHJcbiAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaCgwLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkb21haW4ubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkb21haW5bMF0gKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRvbWFpbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gZG9tYWluW2kgLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgYiA9IGRvbWFpbltpXTtcclxuICAgICAgICAgICAgaWYgKGEgPj0gYikge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKCdgY29sb3JEb21haW5gIHZhbHVlcyBzaG91bGQgYmUgc3VwcGxpZWQgaW4gYXNjZW5kaW5nIG9yZGVyLicpO1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPCBkb21haW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSByYW5nZS5sZW5ndGg7IGkgPCBkb21haW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlLnB1c2gocmFuZ2UubGVuZ3RoID4gMCA/IHJhbmdlWzBdIDogJ2JsYWNrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJzZWRSYW5nZSA9IHRoaXMucmFuZ2UubWFwKGNvbnZlcnRDb2xvclN0cmluZ1RvSHNsYSk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0KHgpIHtcclxuICAgICAgICBjb25zdCB7IGRvbWFpbiwgcmFuZ2UsIHBhcnNlZFJhbmdlIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGQwID0gZG9tYWluWzBdO1xyXG4gICAgICAgIGNvbnN0IGQxID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcclxuICAgICAgICBjb25zdCByMCA9IHJhbmdlWzBdO1xyXG4gICAgICAgIGNvbnN0IHIxID0gcmFuZ2VbcmFuZ2UubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKHggPD0gZDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHIwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA+PSBkMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpbmRleDtcclxuICAgICAgICBsZXQgcTtcclxuICAgICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gKHggLSBkMCkgLyAoZDEgLSBkMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gKHJhbmdlLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBpbmRleCA9IHJhbmdlLmxlbmd0aCA8PSAyID8gMCA6IE1hdGgubWluKE1hdGguZmxvb3IodCAqIChyYW5nZS5sZW5ndGggLSAxKSksIHJhbmdlLmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICBxID0gKHQgLSBpbmRleCAqIHN0ZXApIC8gc3RlcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRvbWFpbi5sZW5ndGggLSAyOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA8IGRvbWFpbltpbmRleCArIDFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYSA9IGRvbWFpbltpbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSBkb21haW5baW5kZXggKyAxXTtcclxuICAgICAgICAgICAgcSA9ICh4IC0gYSkgLyAoYiAtIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjMCA9IHBhcnNlZFJhbmdlW2luZGV4XTtcclxuICAgICAgICBjb25zdCBjMSA9IHBhcnNlZFJhbmdlW2luZGV4ICsgMV07XHJcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlSHNsYShjMCwgYzEsIHEpLnRvUmdiYVN0cmluZygpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIExpbmVhckdyYWRpZW50RmlsbCBleHRlbmRzIFNoYXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAndG8tcmlnaHQnO1xyXG4gICAgICAgIHRoaXMuc3RvcHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGdldCBtYXNrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xyXG4gICAgfVxyXG4gICAgc2V0IG1hc2sobmV3TWFzaykge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLl9tYXNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5ld01hc2sgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKG5ld01hc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tYXNrID0gbmV3TWFzaztcclxuICAgIH1cclxuICAgIGlzUG9pbnRJblBhdGgoeCwgeSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMubWFzaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUG9pbnRJblBhdGgoeCwgeSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZUJCb3goKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm1hc2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21wdXRlQkJveCgpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHJlbmRlckN0eCkge1xyXG4gICAgICAgIGNvbnN0IHsgbWFzaywgc3RvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIGRldmljZVBpeGVsUmF0aW8gfSA9IHJlbmRlckN0eDtcclxuICAgICAgICBjb25zdCBwaXhlbExlbmd0aCA9IDEgLyBkZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgIGNvbnN0IG1hc2tCYm94ID0gbWFzayA9PT0gbnVsbCB8fCBtYXNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXNrLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcclxuICAgICAgICBpZiAobWFzayA9PSBudWxsIHx8IHN0b3BzID09IG51bGwgfHwgbWFza0Jib3ggPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChtYXNrLmRpcnR5UGF0aCkge1xyXG4gICAgICAgICAgICBtYXNrLnVwZGF0ZVBhdGgoKTtcclxuICAgICAgICAgICAgbWFzay5kaXJ0eVBhdGggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgbWFzay5wYXRoLmRyYXcoY3R4KTtcclxuICAgICAgICBjdHguY2xpcCgpO1xyXG4gICAgICAgIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIGNvbnN0IHgwID0gTWF0aC5mbG9vcihtYXNrQmJveC54KTtcclxuICAgICAgICBjb25zdCB4MSA9IE1hdGguY2VpbChtYXNrQmJveC54ICsgbWFza0Jib3gud2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IHkwID0gTWF0aC5mbG9vcihtYXNrQmJveC55KTtcclxuICAgICAgICBjb25zdCB5MSA9IE1hdGguY2VpbChtYXNrQmJveC55ICsgbWFza0Jib3guaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBjb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcclxuICAgICAgICBjb25zdCBbaTAsIGkxXSA9IHRoaXMuZGlyZWN0aW9uID09PSAndG8tcmlnaHQnID8gW3gwLCB4MV0gOiBbeTAsIHkxXTtcclxuICAgICAgICBjb2xvclNjYWxlLmRvbWFpbiA9IHN0b3BzLm1hcCgoXywgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGkwICsgKChpMSAtIGkwKSAqIGluZGV4KSAvIChzdG9wcy5sZW5ndGggLSAxKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb2xvclNjYWxlLnJhbmdlID0gc3RvcHM7XHJcbiAgICAgICAgY29sb3JTY2FsZS51cGRhdGUoKTtcclxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd0by1yaWdodCcpIHtcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0geTEgLSB5MDtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IHgwOyB4IDw9IHgxOyB4ICs9IHBpeGVsTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JTY2FsZS5jb252ZXJ0KHgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHkwLCBwaXhlbExlbmd0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB4MSAtIHgwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0geTA7IHkgPD0geTE7IHkgKz0gcGl4ZWxMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvclNjYWxlLmNvbnZlcnQoeSk7XHJcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeDAsIHksIHdpZHRoLCBwaXhlbExlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgTGluZWFyR3JhZGllbnRGaWxsLnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NQUpPUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgTGluZWFyR3JhZGllbnRGaWxsLnByb3RvdHlwZSwgXCJzdG9wc1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG5dLCBMaW5lYXJHcmFkaWVudEZpbGwucHJvdG90eXBlLCBcIl9tYXNrXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFJlY3QgZXh0ZW5kcyBQYXRoIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5ib3JkZXJQYXRoID0gbmV3IFBhdGgyRCgpO1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB0aGlzLndpZHRoID0gMTA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgYHRydWVgLCB0aGUgcmVjdCBpcyBhbGlnbmVkIHRvIHRoZSBwaXhlbCBncmlkIGZvciBjcmlzcCBsb29raW5nIGxpbmVzLlxyXG4gICAgICAgICAqIEFuaW1hdGVkIHJlY3RzIG1heSBub3QgbG9vayBuaWNlIHdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgZm9yIGV4YW1wbGVcclxuICAgICAgICAgKiB3aGVuIGEgcmVjdCBpcyB0cmFuc2xhdGVkIGJ5IGEgc3ViLXBpeGVsIHZhbHVlIG9uIGVhY2ggZnJhbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jcmlzcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZVBhdGhTdHJva2VXaWR0aCA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RpdmVTdHJva2VXaWR0aCA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiB0aGUgcmVjdGFuZ2xlJ3Mgd2lkdGggb3IgaGVpZ2h0IGlzIGxlc3MgdGhhbiBhIHBpeGVsXHJcbiAgICAgICAgICogYW5kIGNyaXNwIG1vZGUgaXMgb24sIHRoZSByZWN0YW5nbGUgd2lsbCBzdGlsbCBmaXQgaW50byB0aGUgcGl4ZWwsXHJcbiAgICAgICAgICogYnV0IHdpbGwgYmUgbGVzcyBvcGFxdWUgdG8gbWFrZSBhbiBlZmZlY3Qgb2YgaG9sZGluZyBsZXNzIHNwYWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSAxO1xyXG4gICAgfVxyXG4gICAgaXNEaXJ0eVBhdGgoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggIT09IHRoaXMuc3Ryb2tlV2lkdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhISh0aGlzLnBhdGguaXNEaXJ0eSgpIHx8IHRoaXMuYm9yZGVyUGF0aC5pc0RpcnR5KCkgfHwgKChfYSA9IHRoaXMuY2xpcFBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0RpcnR5KCkpKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBhdGgoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgY29uc3QgeyBwYXRoLCBib3JkZXJQYXRoLCBjcmlzcCB9ID0gdGhpcztcclxuICAgICAgICBsZXQgeyB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLCBzdHJva2VXaWR0aCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gKF9iID0gKF9hID0gdGhpcy5sYXllck1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW52YXMucGl4ZWxSYXRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICBjb25zdCBwaXhlbFNpemUgPSAxIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICBsZXQgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHBhdGguY2xlYXIoeyB0cmFja0NoYW5nZXM6IHRydWUgfSk7XHJcbiAgICAgICAgYm9yZGVyUGF0aC5jbGVhcih7IHRyYWNrQ2hhbmdlczogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoY3Jpc3ApIHtcclxuICAgICAgICAgICAgaWYgKHcgPD0gcGl4ZWxTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSAqPSB3IC8gcGl4ZWxTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoIDw9IHBpeGVsU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgKj0gaCAvIHBpeGVsU2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3ID0gdGhpcy5hbGlnbih4LCB3KTtcclxuICAgICAgICAgICAgaCA9IHRoaXMuYWxpZ24oeSwgaCk7XHJcbiAgICAgICAgICAgIHggPSB0aGlzLmFsaWduKHgpO1xyXG4gICAgICAgICAgICB5ID0gdGhpcy5hbGlnbih5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGlmICh3IDwgcGl4ZWxTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUb28gbmFycm93LCBkcmF3IGEgdmVydGljYWwgc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBseCA9IHggKyBwaXhlbFNpemUgLyAyO1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyUGF0aC5tb3ZlVG8obHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyUGF0aC5saW5lVG8obHgsIHkgKyBoKTtcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gcGl4ZWxTaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoIDwgcGl4ZWxTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUb28gbmFycm93LCBkcmF3IGEgaG9yaXpvbnRhbCBzdHJva2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGx5ID0geSArIHBpeGVsU2l6ZSAvIDI7XHJcbiAgICAgICAgICAgICAgICBib3JkZXJQYXRoLm1vdmVUbyh4LCBseSk7XHJcbiAgICAgICAgICAgICAgICBib3JkZXJQYXRoLmxpbmVUbyh4ICsgdywgbHkpO1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBwaXhlbFNpemU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cm9rZVdpZHRoIDwgdyAmJiBzdHJva2VXaWR0aCA8IGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHggKz0gaGFsZlN0cm9rZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgeSArPSBoYWxmU3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB3IC09IHN0cm9rZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgaCAtPSBzdHJva2VXaWR0aDtcclxuICAgICAgICAgICAgICAgIC8vIENsaXBwaW5nIG5vdCBuZWVkZWQgaW4gdGhpcyBjYXNlOyBmaWxsIHRvIGNlbnRlciBvZiBzdHJva2UuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcGF0aC5yZWN0KHgsIHksIHcsIGgpO1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyUGF0aC5yZWN0KHgsIHksIHcsIGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgZmlsbCBhbmQganVzdCByZW5kZXIgdGhlIHN0cm9rZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSAoX2MgPSB0aGlzLmJvcmRlckNsaXBQYXRoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgUGF0aDJEKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoLmNsZWFyKHsgdHJhY2tDaGFuZ2VzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aC5yZWN0KHgsIHksIHcsIGgpO1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyUGF0aC5yZWN0KHgsIHksIHcsIGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBib3JkZXJQYXRoIG5lZWRlZCwgYW5kIHRodXMgbm8gY2xpcFBhdGggbmVlZGVkIGVpdGhlci4gRmlsbCB0byBmdWxsIGV4dGVudCBvZlxyXG4gICAgICAgICAgICAvLyBSZWN0LlxyXG4gICAgICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBwYXRoLnJlY3QoeCwgeSwgdywgaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWZmZWN0aXZlU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcclxuICAgICAgICB0aGlzLm1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ID0gbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgaXNQb2ludEluUGF0aCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgcmV0dXJuIGJib3guY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KTtcclxuICAgIH1cclxuICAgIGFwcGx5RmlsbEFscGhhKGN0eCkge1xyXG4gICAgICAgIGNvbnN0IHsgZmlsbE9wYWNpdHksIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5LCBvcGFjaXR5IH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYSAqIG9wYWNpdHkgKiBmaWxsT3BhY2l0eSAqIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgcmVuZGVyU3Ryb2tlKGN0eCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3Ryb2tlLCBlZmZlY3RpdmVTdHJva2VXaWR0aCwgYm9yZGVyUGF0aCwgYm9yZGVyQ2xpcFBhdGgsIG9wYWNpdHksIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5IH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGJvcmRlckFjdGl2ZSA9ICEhc3Ryb2tlICYmICEhZWZmZWN0aXZlU3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgaWYgKGJvcmRlckFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgbGluZUNhcCwgbGluZUpvaW4gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChib3JkZXJDbGlwUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc3Ryb2tlV2lkdGggaXMgbGFyZ2VyIHRoYW4gd2lkdGggb3IgaGVpZ2h0LCBzbyB1c2UgY2xpcHBpbmcgdG8gcmVuZGVyIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHNpbXBsZXN0IHdheSB0byBhY2hpZXZlIHRoZSBjb3JyZWN0IHJlbmRlcmluZyBkdWUgdG8gbnVhbmNlcyB3aXRoIH4wXHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aC9oZWlnaHQgbGluZXMgaW4gQ2FudmFzIG9wZXJhdGlvbnMuXHJcbiAgICAgICAgICAgICAgICBib3JkZXJDbGlwUGF0aC5kcmF3KGN0eCk7XHJcbiAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvcmRlclBhdGguZHJhdyhjdHgpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcclxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGEgKiBvcGFjaXR5ICogc3Ryb2tlT3BhY2l0eSAqIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5O1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gZWZmZWN0aXZlU3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGluZURhc2hPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsaW5lQ2FwKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmVKb2luKSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5SZWN0LmNsYXNzTmFtZSA9ICdSZWN0JztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFJlY3QucHJvdG90eXBlLCBcInhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFJlY3QucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFJlY3QucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFJlY3QucHJvdG90eXBlLCBcInJhZGl1c1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbl0sIFJlY3QucHJvdG90eXBlLCBcImNyaXNwXCIsIHZvaWQgMCk7XG5cbmNsYXNzIEltYWdlIGV4dGVuZHMgTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VJbWFnZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuc291cmNlSW1hZ2UgPSBzb3VyY2VJbWFnZTtcclxuICAgIH1cclxuICAgIHJlbmRlcihyZW5kZXJDdHgpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT09IFJlZHJhd1R5cGUuTk9ORSAmJiAhZm9yY2VSZW5kZXIpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXRzKVxyXG4gICAgICAgICAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkKys7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy5tYXRyaXgudG9Db250ZXh0KGN0eCk7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLnNvdXJjZUltYWdlO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCB0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwieFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgSW1hZ2UucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NQUpPUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgSW1hZ2UucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgSW1hZ2UucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcblxuY29uc3QgbW90aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmcm9tVG9Nb3Rpb24kMSksIHJlc2V0TW90aW9uJDEpO1xuXG52YXIgaW50ZWdyYXRlZENoYXJ0c1NjZW5lID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBtb3Rpb246IG1vdGlvbixcbiAgICBDYXB0aW9uOiBDYXB0aW9uLFxuICAgIERyb3BTaGFkb3c6IERyb3BTaGFkb3csXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIFNjZW5lOiBTY2VuZSxcbiAgICBOb2RlOiBOb2RlLFxuICAgIGdldCBQb2ludGVyRXZlbnRzICgpIHsgcmV0dXJuIFBvaW50ZXJFdmVudHM7IH0sXG4gICAgZ2V0IFJlZHJhd1R5cGUgKCkgeyByZXR1cm4gUmVkcmF3VHlwZTsgfSxcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbjogU2NlbmVDaGFuZ2VEZXRlY3Rpb24sXG4gICAgU2VsZWN0aW9uOiBTZWxlY3Rpb24sXG4gICAgQXJjOiBBcmMsXG4gICAgTGluZTogTGluZSxcbiAgICBMaW5lYXJHcmFkaWVudEZpbGw6IExpbmVhckdyYWRpZW50RmlsbCxcbiAgICBQYXRoOiBQYXRoLFxuICAgIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbjogU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uLFxuICAgIFJlY3Q6IFJlY3QsXG4gICAgU2VjdG9yOiBTZWN0b3IsXG4gICAgU2hhcGU6IFNoYXBlLFxuICAgIFRleHQ6IFRleHQsXG4gICAgZ2V0Rm9udDogZ2V0Rm9udCxcbiAgICBDb250aW51b3VzU2NhbGU6IENvbnRpbnVvdXNTY2FsZSxcbiAgICBCYW5kU2NhbGU6IEJhbmRTY2FsZSxcbiAgICBMaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG4gICAgdG9SYWRpYW5zOiB0b1JhZGlhbnMsXG4gICAgTGFiZWw6IExhYmVsLFxuICAgIE1hcmtlcjogTWFya2VyLFxuICAgIGdldE1hcmtlcjogZ2V0TWFya2VyLFxuICAgIENpcmNsZTogQ2lyY2xlLFxuICAgIERpYW1vbmQ6IERpYW1vbmQsXG4gICAgU3F1YXJlOiBTcXVhcmUsXG4gICAgVHJpYW5nbGU6IFRyaWFuZ2xlLFxuICAgIFRvb2x0aXA6IFRvb2x0aXAsXG4gICAgdG9Ub29sdGlwSHRtbDogdG9Ub29sdGlwSHRtbCxcbiAgICBCQm94OiBCQm94LFxuICAgIG5lYXJlc3RTcXVhcmVkOiBuZWFyZXN0U3F1YXJlZCxcbiAgICBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyOiBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyLFxuICAgIEhkcGlDYW52YXM6IEhkcGlDYW52YXMsXG4gICAgSW1hZ2U6IEltYWdlLFxuICAgIFBhdGgyRDogUGF0aDJELFxuICAgIGVhc2luZzogZWFzaW5nXG59KTtcblxuY29uc3QgREVGQVVMVF9ESVJFQ1RJT05fS0VZUyA9IHtcclxuICAgIFtDaGFydEF4aXNEaXJlY3Rpb24uWF06IFsneEtleSddLFxyXG4gICAgW0NoYXJ0QXhpc0RpcmVjdGlvbi5ZXTogWyd5S2V5J10sXHJcbn07XHJcbmNvbnN0IERFRkFVTFRfRElSRUNUSU9OX05BTUVTID0ge1xyXG4gICAgW0NoYXJ0QXhpc0RpcmVjdGlvbi5YXTogWyd4TmFtZSddLFxyXG4gICAgW0NoYXJ0QXhpc0RpcmVjdGlvbi5ZXTogWyd5TmFtZSddLFxyXG59O1xyXG5jbGFzcyBDYXJ0ZXNpYW5TZXJpZXNOb2RlQ2xpY2tFdmVudCBleHRlbmRzIFNlcmllc05vZGVDbGlja0V2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XHJcbiAgICAgICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xyXG4gICAgICAgIHRoaXMueEtleSA9IHNlcmllcy54S2V5O1xyXG4gICAgICAgIHRoaXMueUtleSA9IHNlcmllcy55S2V5O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENhcnRlc2lhblNlcmllcyBleHRlbmRzIERhdGFNb2RlbFNlcmllcyB7XHJcbiAgICBnZXQgY29udGV4dE5vZGVEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Tm9kZURhdGEuc2xpY2UoKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKF9hKSB7XHJcbiAgICAgICAgdmFyIHsgcGF0aHNQZXJTZXJpZXMgPSAxLCBoYXNNYXJrZXJzID0gZmFsc2UsIGhhc0hpZ2hsaWdodGVkTGFiZWxzID0gZmFsc2UsIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQgPSBbXSwgZGlyZWN0aW9uS2V5cyA9IERFRkFVTFRfRElSRUNUSU9OX0tFWVMsIGRpcmVjdGlvbk5hbWVzID0gREVGQVVMVF9ESVJFQ1RJT05fTkFNRVMsIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb24gPSB0cnVlLCBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUsIGFuaW1hdGlvblJlc2V0Rm5zIH0gPSBfYSwgb3RoZXJPcHRzID0gX19yZXN0KF9hLCBbXCJwYXRoc1BlclNlcmllc1wiLCBcImhhc01hcmtlcnNcIiwgXCJoYXNIaWdobGlnaHRlZExhYmVsc1wiLCBcInBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXRcIiwgXCJkaXJlY3Rpb25LZXlzXCIsIFwiZGlyZWN0aW9uTmFtZXNcIiwgXCJkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uXCIsIFwibWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cIiwgXCJhbmltYXRpb25SZXNldEZuc1wiXSk7XHJcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IGRpcmVjdGlvbktleXMsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbk5hbWVzLCB1c2VTZXJpZXNHcm91cExheWVyOiB0cnVlLCBjYW5IYXZlQXhlczogdHJ1ZSB9LCBvdGhlck9wdHMpKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1OYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHROb2RlRGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuTm9kZUNsaWNrRXZlbnQgPSBDYXJ0ZXNpYW5TZXJpZXNOb2RlQ2xpY2tFdmVudDtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5oaWdobGlnaHROb2RlLCAoKSA9PiB0aGlzLm9wdHMuaGFzTWFya2VycyA/IHRoaXMubWFya2VyRmFjdG9yeSgpIDogdGhpcy5ub2RlRmFjdG9yeSgpKTtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmhpZ2hsaWdodExhYmVsLCBUZXh0KTtcclxuICAgICAgICB0aGlzLmFubm90YXRpb25TZWxlY3Rpb25zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuc3ViR3JvdXBzID0gW107XHJcbiAgICAgICAgdGhpcy5zdWJHcm91cElkID0gMDtcclxuICAgICAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5vcHRzID0ge1xyXG4gICAgICAgICAgICBwYXRoc1BlclNlcmllcyxcclxuICAgICAgICAgICAgaGFzTWFya2VycyxcclxuICAgICAgICAgICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHMsXHJcbiAgICAgICAgICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbktleXMsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbk5hbWVzLFxyXG4gICAgICAgICAgICBhbmltYXRpb25SZXNldEZucyxcclxuICAgICAgICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbixcclxuICAgICAgICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb24sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZSgnZW1wdHknLCB7XHJcbiAgICAgICAgICAgIGVtcHR5OiB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdyZWFkeScsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlYWR5OiB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhOiAnd2FpdGluZycsXHJcbiAgICAgICAgICAgICAgICBjbGVhcjogJ2NsZWFyaW5nJyxcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFya2VyczogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhkYXRhKSxcclxuICAgICAgICAgICAgICAgIHJlc2l6ZTogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3YWl0aW5nOiB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdyZWFkeScsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xlYXJpbmc6IHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ2VtcHR5JyxcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSk7XHJcbiAgICB9XHJcbiAgICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKCdsZWdlbmQtaXRlbS1jbGljaycsIChldmVudCkgPT4gdGhpcy5vbkxlZ2VuZEl0ZW1DbGljayhldmVudCkpO1xyXG4gICAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKCdsZWdlbmQtaXRlbS1kb3VibGUtY2xpY2snLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHROb2RlRGF0YS5zcGxpY2UoMCwgdGhpcy5fY29udGV4dE5vZGVEYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5zdWJHcm91cHMuc3BsaWNlKDAsIHRoaXMuc3ViR3JvdXBzLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmlzaWJsZSwgX2NvbnRleHROb2RlRGF0YTogcHJldmlvdXNDb250ZXh0RGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBzZXJpZXMgfSA9IChfYiA9IChfYSA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRBY3RpdmVIaWdobGlnaHQoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0hpZ2hsaWdodGVkID0gc2VyaWVzID8gc2VyaWVzID09PSB0aGlzIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBjb25zdCByZXNpemUgPSB0aGlzLmNoZWNrUmVzaXplKHNlcmllc1JlY3QpO1xyXG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRJdGVtcyA9IHlpZWxkIHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uKHNlcmllc0hpZ2hsaWdodGVkKTtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVTZWxlY3Rpb25zKHZpc2libGUpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZU5vZGVzKGhpZ2hsaWdodEl0ZW1zLCBzZXJpZXNIaWdobGlnaHRlZCwgdmlzaWJsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCwgcHJldmlvdXNDb250ZXh0RGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChyZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbigncmVzaXplJywgYW5pbWF0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKCd1cGRhdGUnLCBhbmltYXRpb25EYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNlbGVjdGlvbnMoYW55U2VyaWVzSXRlbUVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIWFueVNlcmllc0l0ZW1FbmFibGVkICYmIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoICYmICF0aGlzLmlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVEYXRhUmVmcmVzaCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYENhcnRlc2lhblNlcmllcy51cGRhdGVTZWxlY3Rpb25zKCkgLSBjYWxsaW5nIGNyZWF0ZU5vZGVEYXRhKCkgZm9yYCwgdGhpcy5pZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0Tm9kZURhdGEgPSB5aWVsZCB0aGlzLmNyZWF0ZU5vZGVEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25WYWxpZCA9IHRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dE5vZGVEYXRhLmZvckVhY2goKG5vZGVEYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IG5vZGVEYXRhLmFuaW1hdGlvblZhbGlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAobm9kZURhdGEuYW5pbWF0aW9uVmFsaWQgPSBhbmltYXRpb25WYWxpZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlU2VyaWVzR3JvdXBzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhTW9kZWwgIT09IHVuZGVmaW5lZCAmJiBwcm9jZXNzZWREYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdkYXRhLXVwZGF0ZScsIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRoaXMuc3ViR3JvdXBzLm1hcCgoZywgaSkgPT4gdGhpcy51cGRhdGVTZXJpZXNHcm91cFNlbGVjdGlvbnMoZywgaSkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNlcmllc0dyb3VwU2VsZWN0aW9ucyhzdWJHcm91cCwgc2VyaWVzSWR4LCBzZXJpZXNIaWdobGlnaHRlZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBtYXJrZXJTZWxlY3Rpb24sIHBhdGhzIH0gPSBzdWJHcm91cDtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dERhdGEgPSB0aGlzLl9jb250ZXh0Tm9kZURhdGFbc2VyaWVzSWR4XTtcclxuICAgICAgICAgICAgY29uc3QgeyBub2RlRGF0YSwgbGFiZWxEYXRhLCBpdGVtSWQgfSA9IGNvbnRleHREYXRhO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZVBhdGhzKHsgc2VyaWVzSGlnaGxpZ2h0ZWQsIGl0ZW1JZCwgY29udGV4dERhdGEsIHBhdGhzLCBzZXJpZXNJZHggfSk7XHJcbiAgICAgICAgICAgIHN1Ykdyb3VwLmRhdHVtU2VsZWN0aW9uID0geWllbGQgdGhpcy51cGRhdGVEYXR1bVNlbGVjdGlvbih7IG5vZGVEYXRhLCBkYXR1bVNlbGVjdGlvbiwgc2VyaWVzSWR4IH0pO1xyXG4gICAgICAgICAgICBzdWJHcm91cC5sYWJlbFNlbGVjdGlvbiA9IHlpZWxkIHRoaXMudXBkYXRlTGFiZWxTZWxlY3Rpb24oeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uLCBzZXJpZXNJZHggfSk7XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXJTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHN1Ykdyb3VwLm1hcmtlclNlbGVjdGlvbiA9IHlpZWxkIHRoaXMudXBkYXRlTWFya2VyU2VsZWN0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSWR4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1hcmtlckZhY3RvcnkoKSB7XHJcbiAgICAgICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoKTtcclxuICAgICAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTZXJpZXNHcm91cHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEsIGNvbnRlbnRHcm91cCwgc3ViR3JvdXBzLCBvcHRzOiB7IHBhdGhzUGVyU2VyaWVzLCBoYXNNYXJrZXJzLCBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uLCBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbiB9LCB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGNvbnRleHROb2RlRGF0YS5sZW5ndGggPT09IHN1Ykdyb3Vwcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29udGV4dE5vZGVEYXRhLmxlbmd0aCA8IHN1Ykdyb3Vwcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHN1Ykdyb3Vwcy5zcGxpY2UoY29udGV4dE5vZGVEYXRhLmxlbmd0aCkuZm9yRWFjaCgoeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCwgbGFiZWxHcm91cCwgcGF0aHMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHcm91cC5yZW1vdmVDaGlsZChkYXRhTm9kZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdyb3VwLnJlbW92ZUNoaWxkKG1hcmtlckdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdyb3VwLnJlbW92ZUNoaWxkKGxhYmVsR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdyb3VwLnJlbW92ZUNoaWxkKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsR3JvdXBzID0gY29udGV4dE5vZGVEYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKHRvdGFsR3JvdXBzID4gc3ViR3JvdXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1Ykdyb3VwSWQgPSB0aGlzLnN1Ykdyb3VwSWQrKztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFOb2RlR3JvdXAgPSBuZXcgR3JvdXAoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1zdWIke3N1Ykdyb3VwSWR9LWRhdGFOb2Rlc2AsXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiBMYXllcnMuU0VSSUVTX0xBWUVSX1pJTkRFWCxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKCdkYXRhJywgc3ViR3JvdXBJZCksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlckdyb3VwID0gaGFzTWFya2Vyc1xyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEdyb3VwKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLXN1YiR7dGhpcy5zdWJHcm91cElkKyt9LW1hcmtlcnNgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiBMYXllcnMuU0VSSUVTX0xBWUVSX1pJTkRFWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcignbWFya2VyJywgc3ViR3JvdXBJZCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsR3JvdXAgPSBuZXcgR3JvdXAoe1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1zdWIke3RoaXMuc3ViR3JvdXBJZCsrfS1sYWJlbHNgLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogTGF5ZXJzLlNFUklFU19MQUJFTF9aSU5ERVgsXHJcbiAgICAgICAgICAgICAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcignbGFiZWxzJywgc3ViR3JvdXBJZCksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChkYXRhTm9kZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChsYWJlbEdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChtYXJrZXJHcm91cCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdGhzUGVyU2VyaWVzOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aHNbaW5kZXhdID0gbmV3IFBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoc1tpbmRleF0uekluZGV4ID0gTGF5ZXJzLlNFUklFU19MQVlFUl9aSU5ERVg7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aHNbaW5kZXhdLnpJbmRleFN1Yk9yZGVyID0gdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKCdwYXRocycsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQocGF0aHNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN1Ykdyb3Vwcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRocyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZUdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsR3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTZWxlY3Rpb246IFNlbGVjdGlvbi5zZWxlY3QobGFiZWxHcm91cCwgVGV4dCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0dW1TZWxlY3Rpb246IFNlbGVjdGlvbi5zZWxlY3QoZGF0YU5vZGVHcm91cCwgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLCBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXJTZWxlY3Rpb246IG1hcmtlckdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gU2VsZWN0aW9uLnNlbGVjdChtYXJrZXJHcm91cCwgKCkgPT4gdGhpcy5tYXJrZXJGYWN0b3J5KCksIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUsIHN1YkluZGV4ID0gMCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUsIHN1YkluZGV4KTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3BhdGhzJykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoT2Zmc2V0ID0gKF9hID0gdGhpcy5vcHRzLnBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXRbc3ViSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBzdXBlckZuID0gcmVzdWx0WzBdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1cGVyRm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9ICgpID0+ICtzdXBlckZuKCkgKyBwYXRoT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gK3N1cGVyRm4gKyBwYXRoT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVOb2RlcyhoaWdobGlnaHRlZEl0ZW1zLCBzZXJpZXNIaWdobGlnaHRlZCwgYW55U2VyaWVzSXRlbUVuYWJsZWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBoaWdobGlnaHRTZWxlY3Rpb24sIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLCBvcHRzOiB7IGhhc01hcmtlcnMsIGhhc0hpZ2hsaWdodGVkTGFiZWxzIH0sIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgKChfYSA9IHRoaXMuX2NvbnRleHROb2RlRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwICYmIGFueVNlcmllc0l0ZW1FbmFibGVkO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3RHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnZpc2libGUgPSAoYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlKSAmJiAhIXNlcmllc0hpZ2hsaWdodGVkO1xyXG4gICAgICAgICAgICBjb25zdCBzdWJHcm91cE9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcclxuICAgICAgICAgICAgaWYgKGhhc01hcmtlcnMpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlTWFya2VyTm9kZXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbjogaGlnaGxpZ2h0U2VsZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzSGlnaGxpZ2h0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0lkeDogLTEsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbignaGlnaGxpZ2h0TWFya2VycycsIGhpZ2hsaWdodFNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZURhdHVtTm9kZXMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdHVtU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgaXNIaWdobGlnaHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSWR4OiAtMSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKCdoaWdobGlnaHQnLCBoaWdobGlnaHRTZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNIaWdobGlnaHRlZExhYmVscykge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVMYWJlbE5vZGVzKHsgbGFiZWxTZWxlY3Rpb246IGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLCBzZXJpZXNJZHg6IC0xIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRoaXMuc3ViR3JvdXBzLm1hcCgoc3ViR3JvdXAsIHNlcmllc0lkeCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCwgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBtYXJrZXJTZWxlY3Rpb24sIHBhdGhzLCBsYWJlbEdyb3VwLCB9ID0gc3ViR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGl0ZW1JZCB9ID0gdGhpcy5jb250ZXh0Tm9kZURhdGFbc2VyaWVzSWR4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1Ykdyb3VwVmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgICAgICBkYXRhTm9kZUdyb3VwLm9wYWNpdHkgPSBzdWJHcm91cE9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBkYXRhTm9kZUdyb3VwLnZpc2libGUgPSBhbmltYXRpb25FbmFibGVkIHx8IHN1Ykdyb3VwVmlzaWJsZTtcclxuICAgICAgICAgICAgICAgIGxhYmVsR3JvdXAudmlzaWJsZSA9IHN1Ykdyb3VwVmlzaWJsZTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckdyb3VwLm9wYWNpdHkgPSBzdWJHcm91cE9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyR3JvdXAuekluZGV4ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU5vZGVHcm91cC56SW5kZXggPj0gTGF5ZXJzLlNFUklFU19MQVlFUl9aSU5ERVhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YU5vZGVHcm91cC56SW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YU5vZGVHcm91cC56SW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckdyb3VwLnZpc2libGUgPSBzdWJHcm91cFZpc2libGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsR3JvdXAub3BhY2l0eSA9IHN1Ykdyb3VwT3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlUGF0aE5vZGVzKHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNIaWdobGlnaHRlZCxcclxuICAgICAgICAgICAgICAgICAgICBpdGVtSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSWR4LFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHN1Ykdyb3VwT3BhY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBzdWJHcm91cFZpc2libGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRW5hYmxlZCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhTm9kZUdyb3VwLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZURhdHVtTm9kZXMoeyBkYXR1bVNlbGVjdGlvbiwgaGlnaGxpZ2h0ZWRJdGVtcywgaXNIaWdobGlnaHQ6IGZhbHNlLCBzZXJpZXNJZHggfSk7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZUxhYmVsTm9kZXMoeyBsYWJlbFNlbGVjdGlvbiwgc2VyaWVzSWR4IH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc01hcmtlcnMgJiYgbWFya2VyU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVNYXJrZXJOb2Rlcyh7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGZhbHNlLCBzZXJpZXNJZHggfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdobGlnaHRMYWJlbERhdGEobGFiZWxEYXRhLCBoaWdobGlnaHRlZEl0ZW0pIHtcclxuICAgICAgICBjb25zdCBsYWJlbEl0ZW0gPSBsYWJlbERhdGEuZmluZCgobGQpID0+IGxkLmRhdHVtID09PSBoaWdobGlnaHRlZEl0ZW0uZGF0dW0gJiYgbGQuaXRlbUlkID09PSBoaWdobGlnaHRlZEl0ZW0uaXRlbUlkKTtcclxuICAgICAgICByZXR1cm4gbGFiZWxJdGVtID8gW2xhYmVsSXRlbV0gOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdobGlnaHREYXRhKF9ub2RlRGF0YSwgaGlnaGxpZ2h0ZWRJdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkSXRlbSA/IFtoaWdobGlnaHRlZEl0ZW1dIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uKHNlcmllc0hpZ2hsaWdodGVkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaGlnaGxpZ2h0U2VsZWN0aW9uLCBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbiwgX2NvbnRleHROb2RlRGF0YTogY29udGV4dE5vZGVEYXRhIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gKF9hID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEFjdGl2ZUhpZ2hsaWdodCgpO1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc2VyaWVzSGlnaGxpZ2h0ZWQgJiYgKGhpZ2hsaWdodGVkRGF0dW0gPT09IG51bGwgfHwgaGlnaGxpZ2h0ZWREYXR1bSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGlnaGxpZ2h0ZWREYXR1bS5kYXR1bSkgPyBoaWdobGlnaHRlZERhdHVtIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBsZXQgbGFiZWxJdGVtcztcclxuICAgICAgICAgICAgbGV0IGhpZ2hsaWdodEl0ZW1zO1xyXG4gICAgICAgICAgICBpZiAoaXRlbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbHNFbmFibGVkID0gdGhpcy5pc0xhYmVsRW5hYmxlZCgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGxhYmVsRGF0YSwgbm9kZURhdGEgfSBvZiBjb250ZXh0Tm9kZURhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRJdGVtcyA9IHRoaXMuZ2V0SGlnaGxpZ2h0RGF0YShub2RlRGF0YSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxJdGVtcyA9IGxhYmVsc0VuYWJsZWQgPyB0aGlzLmdldEhpZ2hsaWdodExhYmVsRGF0YShsYWJlbERhdGEsIGl0ZW0pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWxhYmVsc0VuYWJsZWQgfHwgbGFiZWxJdGVtcyAhPSBudWxsKSAmJiBoaWdobGlnaHRJdGVtcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IHlpZWxkIHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uSXRlbSh7XHJcbiAgICAgICAgICAgICAgICBpdGVtczogaGlnaGxpZ2h0SXRlbXMsXHJcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0geWllbGQgdGhpcy51cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25MYWJlbCh7XHJcbiAgICAgICAgICAgICAgICBpdGVtczogbGFiZWxJdGVtcyxcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodEl0ZW1zO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGlja05vZGVFeGFjdFNoYXBlKHBvaW50KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xyXG4gICAgICAgIGNvbnN0IHsgb3B0czogeyBoYXNNYXJrZXJzIH0sIH0gPSB0aGlzO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCB9IG9mIHRoaXMuc3ViR3JvdXBzKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IGRhdGFOb2RlR3JvdXAucGlja05vZGUoeCwgeSk7XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2ggJiYgaGFzTWFya2Vycykge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXJrZXJHcm91cCA9PT0gbnVsbCB8fCBtYXJrZXJHcm91cCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyR3JvdXAucGlja05vZGUoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kIG9mIHRoaXMubW9kdWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdHVtIH0gPSAoX2EgPSBtb2QucGlja05vZGVFeGFjdChwb2ludCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdHVtICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXR1bSwgZGlzdGFuY2U6IDAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xyXG4gICAgICAgIGNvbnN0IHsgYXhlcywgcm9vdEdyb3VwLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5YXTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldO1xyXG4gICAgICAgIGNvbnN0IGhpdFBvaW50ID0gcm9vdEdyb3VwLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xyXG4gICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBjbG9zZXN0RGF0dW07XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGNvbnRleHROb2RlRGF0YSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIGNvbnRleHQubm9kZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9pbnQ6IHsgeDogZGF0dW1YID0gTmFOLCB5OiBkYXR1bVkgPSBOYU4gfSA9IHt9IH0gPSBkYXR1bTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihkYXR1bVgpIHx8IGlzTmFOKGRhdHVtWSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5SYW5nZSA9ICh4QXhpcyA9PT0gbnVsbCB8fCB4QXhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogeEF4aXMuaW5SYW5nZShkYXR1bVgpKSAmJiAoeUF4aXMgPT09IG51bGwgfHwgeUF4aXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHlBeGlzLmluUmFuZ2UoZGF0dW1ZKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1c2UgTWF0aC5zcXJ0KCkgc2luY2UgeCA8IHkgaW1wbGllcyBNYXRoLnNxcnQoeCkgPCBNYXRoLnNxcnQoeSkgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgPiAxXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGgubWF4KE1hdGgucG93KChoaXRQb2ludC54IC0gZGF0dW1YKSwgMikgKyBNYXRoLnBvdygoaGl0UG9pbnQueSAtIGRhdHVtWSksIDIpLCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGF0dW0gPSBkYXR1bTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IG1vZCBvZiB0aGlzLm1vZHVsZU1hcCkge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RQaWNrID0gbW9kLnBpY2tOb2RlTmVhcmVzdChwb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChtb2RQaWNrICE9PSB1bmRlZmluZWQgJiYgbW9kUGljay5kaXN0YW5jZVNxdWFyZWQgPCBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZDtcclxuICAgICAgICAgICAgICAgIGNsb3Nlc3REYXR1bSA9IG1vZFBpY2suZGF0dW07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xvc2VzdERhdHVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKSAtICgoX2IgPSAoX2EgPSBjbG9zZXN0RGF0dW0ucG9pbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdHVtOiBjbG9zZXN0RGF0dW0sIGRpc3RhbmNlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGlja05vZGVNYWluQXhpc0ZpcnN0KHBvaW50LCByZXF1aXJlQ2F0ZWdvcnlBeGlzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xyXG4gICAgICAgIGNvbnN0IHsgYXhlcywgcm9vdEdyb3VwLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5YXTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldO1xyXG4gICAgICAgIC8vIFByZWZlciB0byBzdGFydCBzZWFyY2ggd2l0aCBhbnkgYXZhaWxhYmxlIGNhdGVnb3J5IGF4aXMuXHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9ucyA9IFt4QXhpcywgeUF4aXNdXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGEpID0+IGEgaW5zdGFuY2VvZiBDYXRlZ29yeUF4aXMpXHJcbiAgICAgICAgICAgIC5tYXAoKGEpID0+IGEuZGlyZWN0aW9uKTtcclxuICAgICAgICBpZiAocmVxdWlyZUNhdGVnb3J5QXhpcyAmJiBkaXJlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERlZmF1bHQgdG8gWC1heGlzIHVubGVzcyB3ZSBmb3VuZCBhIHN1aXRhYmxlIGNhdGVnb3J5IGF4aXMuXHJcbiAgICAgICAgY29uc3QgW3ByaW1hcnlEaXJlY3Rpb24gPSBDaGFydEF4aXNEaXJlY3Rpb24uWF0gPSBkaXJlY3Rpb25zO1xyXG4gICAgICAgIGNvbnN0IGhpdFBvaW50ID0gcm9vdEdyb3VwLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xyXG4gICAgICAgIGNvbnN0IGhpdFBvaW50Q29vcmRzID0gcHJpbWFyeURpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlggPyBbaGl0UG9pbnQueCwgaGl0UG9pbnQueV0gOiBbaGl0UG9pbnQueSwgaGl0UG9pbnQueF07XHJcbiAgICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSBbSW5maW5pdHksIEluZmluaXR5XTtcclxuICAgICAgICBsZXQgY2xvc2VzdERhdHVtO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGV4dCBvZiBjb250ZXh0Tm9kZURhdGEpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBkYXR1bSBvZiBjb250ZXh0Lm5vZGVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvaW50OiB7IHg6IGRhdHVtWCA9IE5hTiwgeTogZGF0dW1ZID0gTmFOIH0gPSB7fSB9ID0gZGF0dW07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGF0dW1YKSB8fCBpc05hTihkYXR1bVkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luUmFuZ2UgPSAoeEF4aXMgPT09IG51bGwgfHwgeEF4aXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHhBeGlzLmluUmFuZ2UoZGF0dW1YKSkgJiYgKHlBeGlzID09PSBudWxsIHx8IHlBeGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB5QXhpcy5pblJhbmdlKGRhdHVtWSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0luUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcHJpbWFyeURpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlggPyBbZGF0dW1YLCBkYXR1bVldIDogW2RhdHVtWSwgZGF0dW1YXTtcclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGlzdGFuY2VzIGZyb20gbW9zdCBzaWduaWZpY2FudCBkaW1lbnNpb24gdG8gbGVhc3QuXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3TWluRGlzdGFuY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmFicyhwb2ludFtpXSAtIGhpdFBvaW50Q29vcmRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA+IG1pbkRpc3RhbmNlW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01pbkRpc3RhbmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlW2ldID0gZGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UuZmlsbChJbmZpbml0eSwgaSArIDEsIG1pbkRpc3RhbmNlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld01pbkRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERhdHVtID0gZGF0dW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsb3Nlc3REYXR1bSkge1xyXG4gICAgICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCA9IE1hdGgubWF4KE1hdGgucG93KG1pbkRpc3RhbmNlWzBdLCAyKSArIE1hdGgucG93KG1pbkRpc3RhbmNlWzFdLCAyKSAtICgoX2IgPSAoX2EgPSBjbG9zZXN0RGF0dW0ucG9pbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSwgMCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kIG9mIHRoaXMubW9kdWxlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RQaWNrID0gbW9kLnBpY2tOb2RlTWFpbkF4aXNGaXJzdChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kUGljayAhPT0gdW5kZWZpbmVkICYmIG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkIDwgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REYXR1bSA9IG1vZFBpY2suZGF0dW07XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCA9IG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRhdHVtOiBjbG9zZXN0RGF0dW0sIGRpc3RhbmNlOiBNYXRoLnNxcnQoY2xvc2VzdERpc3RhbmNlU3F1YXJlZCkgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkxlZ2VuZEl0ZW1DbGljayhldmVudCkge1xyXG4gICAgICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMsIGxlZ2VuZEl0ZW1OYW1lIH0gPSBldmVudDtcclxuICAgICAgICBjb25zdCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUgPSB0aGlzLmxlZ2VuZEl0ZW1OYW1lICE9IG51bGwgJiYgdGhpcy5sZWdlbmRJdGVtTmFtZSA9PT0gbGVnZW5kSXRlbU5hbWU7XHJcbiAgICAgICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCB8fCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpIHtcclxuICAgICAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBudW1WaXNpYmxlSXRlbXMsIGxlZ2VuZEl0ZW1OYW1lIH0gPSBldmVudDtcclxuICAgICAgICBjb25zdCB0b3RhbFZpc2libGVJdGVtcyA9IE9iamVjdC52YWx1ZXMobnVtVmlzaWJsZUl0ZW1zKS5yZWR1Y2UoKHAsIHYpID0+IHAgKyB2LCAwKTtcclxuICAgICAgICBjb25zdCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUgPSB0aGlzLmxlZ2VuZEl0ZW1OYW1lICE9IG51bGwgJiYgdGhpcy5sZWdlbmRJdGVtTmFtZSA9PT0gbGVnZW5kSXRlbU5hbWU7XHJcbiAgICAgICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCB8fCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUpIHtcclxuICAgICAgICAgICAgLy8gRG91YmxlLWNsaWNrZWQgaXRlbSBzaG91bGQgYWx3YXlzIGJlY29tZSB2aXNpYmxlLlxyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZW5hYmxlZCAmJiB0b3RhbFZpc2libGVJdGVtcyA9PT0gMSkge1xyXG4gICAgICAgICAgICAvLyBPdGhlciBpdGVtcyBzaG91bGQgYmVjb21lIHZpc2libGUgaWYgdGhlcmUgaXMgb25seSBvbmUgZXhpc3RpbmcgdmlzaWJsZSBpdGVtLlxyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERpc2FibGUgb3RoZXIgaXRlbXMgaWYgbm90IGV4YWN0bHkgb25lIGVuYWJsZWQuXHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IHRvIGFsbG93IG1vcmUgc29waGlzdGljYXRlZCBkaXJ0eSBzZWxlY3Rpb24gZGV0ZWN0aW9uLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldExhYmVsRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBzaG91bGRGbGlwWFkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYW55IGFkamFjZW50IHR3byBub2Rlcy4gVGhlIGF4ZXMgYXJlIHRyZWF0ZWQgaW5kZXBlbmRlbnRseSwgc28gdGhpc1xyXG4gICAgICogbWF5IG5vdCByZXByZXNlbnQgdGhlIHNhbWUgdHdvIHBvaW50cyBmb3IgYm90aCBkaXJlY3Rpb25zLiBUaGUgZGltZW5zaW9ucyByZXByZXNlbnQgdGhlIGdyZWF0ZXN0IGRpc3RhbmNlXHJcbiAgICAgKiBiZXR3ZWVuIGFueSB0d28gYWRqYWNlbnQgbm9kZXMuXHJcbiAgICAgKi9cclxuICAgIGdldE1pblJlY3QoKSB7XHJcbiAgICAgICAgY29uc3QgW2NvbnRleHRdID0gdGhpcy5fY29udGV4dE5vZGVEYXRhO1xyXG4gICAgICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0Lm5vZGVEYXRhLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjb250ZXh0Lm5vZGVEYXRhXHJcbiAgICAgICAgICAgIC5tYXAoKHsgbWlkUG9pbnQgfSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBtaWRQb2ludCA9PT0gbnVsbCB8fCBtaWRQb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWlkUG9pbnQueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDsgfSlcclxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxyXG4gICAgICAgICAgICAucmVkdWNlKChtYXgsIHgsIGksIGFycmF5KSA9PiAoaSA+IDAgPyBNYXRoLm1heChtYXgsIHggLSBhcnJheVtpIC0gMV0pIDogbWF4KSwgMCk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGV4dC5ub2RlRGF0YVxyXG4gICAgICAgICAgICAubWFwKCh7IG1pZFBvaW50IH0pID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gbWlkUG9pbnQgPT09IG51bGwgfHwgbWlkUG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pZFBvaW50LnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7IH0pXHJcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYilcclxuICAgICAgICAgICAgLnJlZHVjZSgobWF4LCB5LCBpLCBhcnJheSkgPT4gKGkgPiAwID8gTWF0aC5tYXgobWF4LCB5IC0gYXJyYXlbaSAtIDFdKSA6IG1heCksIDApO1xyXG4gICAgICAgIHJldHVybiBuZXcgQkJveCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkl0ZW0ob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0czogeyBoYXNNYXJrZXJzIH0sIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGl0ZW1zLCBoaWdobGlnaHRTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVEYXRhID0gaXRlbXMgIT09IG51bGwgJiYgaXRlbXMgIT09IHZvaWQgMCA/IGl0ZW1zIDogW107XHJcbiAgICAgICAgICAgIGlmIChoYXNNYXJrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJTZWxlY3Rpb24gPSBoaWdobGlnaHRTZWxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVNYXJrZXJTZWxlY3Rpb24oeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uLCBzZXJpZXNJZHg6IC0xIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRGF0dW1TZWxlY3Rpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdHVtU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSWR4OiAtMSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25MYWJlbChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBpdGVtcywgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGl0ZW1zICE9PSBudWxsICYmIGl0ZW1zICE9PSB2b2lkIDAgPyBpdGVtcyA6IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVMYWJlbFNlbGVjdGlvbih7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb246IGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLCBzZXJpZXNJZHg6IC0xIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IGZvciBzdWItY2xhc3Nlcy5cclxuICAgICAgICAgICAgcmV0dXJuIG9wdHMuZGF0dW1TZWxlY3Rpb247XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVEYXR1bU5vZGVzKF9vcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgcG9pbnQgZm9yIHN1Yi1jbGFzc2VzLlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBPdmVycmlkZSBwb2ludCBmb3Igc3ViLWNsYXNzZXMuXHJcbiAgICAgICAgICAgIHJldHVybiBvcHRzLm1hcmtlclNlbGVjdGlvbjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZU1hcmtlck5vZGVzKF9vcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgcG9pbnQgZm9yIHN1Yi1jbGFzc2VzLlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGF0aHMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IGZvciBzdWItY2xhc3Nlcy5cclxuICAgICAgICAgICAgb3B0cy5wYXRocy5mb3JFYWNoKChwKSA9PiAocC52aXNpYmxlID0gZmFsc2UpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBhdGhOb2RlcyhvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBwYXRocywgb3BhY2l0eSwgdmlzaWJsZSB9ID0gb3B0cztcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgcGF0aC52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVzZXRBbGxBbmltYXRpb24oZGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgeyBwYXRoLCBkYXR1bSwgbGFiZWwsIG1hcmtlciB9ID0gKF9iID0gKF9hID0gdGhpcy5vcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYW5pbWF0aW9uUmVzZXRGbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xyXG4gICAgICAgIC8vIFN0b3AgYW55IHJ1bm5pbmcgYW5pbWF0aW9ucyBieSBwcmVmaXggY29udmVudGlvbi5cclxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XHJcbiAgICAgICAgaWYgKHBhdGgpIHtcclxuICAgICAgICAgICAgZGF0YS5wYXRocy5mb3JFYWNoKChwYXRocykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzZXRNb3Rpb24ocGF0aHMsIHBhdGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdHVtKSB7XHJcbiAgICAgICAgICAgIHJlc2V0TW90aW9uKGRhdGEuZGF0dW1TZWxlY3Rpb25zLCBkYXR1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICByZXNldE1vdGlvbihkYXRhLmxhYmVsU2VsZWN0aW9ucywgbGFiZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWFya2VyKSB7XHJcbiAgICAgICAgICAgIHJlc2V0TW90aW9uKGRhdGEubWFya2VyU2VsZWN0aW9ucywgbWFya2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGEuY29udGV4dERhdGEuc29tZSgoZCkgPT4gZC5hbmltYXRpb25WYWxpZCA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcclxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcclxuICAgICAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IGRhdHVtIH0gPSAoX2IgPSAoX2EgPSB0aGlzLm9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbmltYXRpb25SZXNldEZucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XHJcbiAgICAgICAgaWYgKGRhdHVtKSB7XHJcbiAgICAgICAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgZGF0dW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgeyBtYXJrZXIgfSA9IChfYiA9IChfYSA9IHRoaXMub3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaW1hdGlvblJlc2V0Rm5zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcclxuICAgICAgICBpZiAobWFya2VyKSB7XHJcbiAgICAgICAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgbWFya2VyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhbmltYXRlUmVhZHlSZXNpemUoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XHJcbiAgICB9XHJcbiAgICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcclxuICAgIH1cclxuICAgIGFuaW1hdGlvblRyYW5zaXRpb25DbGVhcigpIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oJ2NsZWFyJywgdGhpcy5nZXRBbmltYXRpb25EYXRhKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0QW5pbWF0aW9uRGF0YShzZXJpZXNSZWN0LCBwcmV2aW91c0NvbnRleHREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHtcclxuICAgICAgICAgICAgZGF0dW1TZWxlY3Rpb25zOiB0aGlzLnN1Ykdyb3Vwcy5tYXAoKHsgZGF0dW1TZWxlY3Rpb24gfSkgPT4gZGF0dW1TZWxlY3Rpb24pLFxyXG4gICAgICAgICAgICBtYXJrZXJTZWxlY3Rpb25zOiB0aGlzLnN1Ykdyb3Vwc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoeyBtYXJrZXJTZWxlY3Rpb24gfSkgPT4gbWFya2VyU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKCh7IG1hcmtlclNlbGVjdGlvbiB9KSA9PiBtYXJrZXJTZWxlY3Rpb24pLFxyXG4gICAgICAgICAgICBsYWJlbFNlbGVjdGlvbnM6IHRoaXMuc3ViR3JvdXBzLm1hcCgoeyBsYWJlbFNlbGVjdGlvbiB9KSA9PiBsYWJlbFNlbGVjdGlvbiksXHJcbiAgICAgICAgICAgIGFubm90YXRpb25TZWxlY3Rpb25zOiBbLi4udGhpcy5hbm5vdGF0aW9uU2VsZWN0aW9uc10sXHJcbiAgICAgICAgICAgIGNvbnRleHREYXRhOiB0aGlzLl9jb250ZXh0Tm9kZURhdGEsXHJcbiAgICAgICAgICAgIHByZXZpb3VzQ29udGV4dERhdGEsXHJcbiAgICAgICAgICAgIHBhdGhzOiB0aGlzLnN1Ykdyb3Vwcy5tYXAoKHsgcGF0aHMgfSkgPT4gcGF0aHMpLFxyXG4gICAgICAgICAgICBzZXJpZXNSZWN0LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkRhdGE7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVTY2FsaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGFkZFNjYWxlID0gKGRpcmVjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBheGlzID0gdGhpcy5heGVzW2RpcmVjdGlvbl07XHJcbiAgICAgICAgICAgIGlmICghYXhpcylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKGF4aXMuc2NhbGUgaW5zdGFuY2VvZiBMb2dTY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZSwgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2RpcmVjdGlvbl0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xvZycsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udmVydDogKGRvbWFpbikgPT4gYXhpcy5zY2FsZS5jb252ZXJ0KGRvbWFpbiksXHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBbZG9tYWluWzBdLCBkb21haW5bMV1dLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbcmFuZ2VbMF0sIHJhbmdlWzFdXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXhpcy5zY2FsZSBpbnN0YW5jZW9mIENvbnRpbnVvdXNTY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZSB9ID0gYXhpcy5zY2FsZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGF4aXMuc2NhbGUuZ2V0RG9tYWluKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbZGlyZWN0aW9uXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29udGludW91cycsXHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBbZG9tYWluWzBdLCBkb21haW5bMV1dLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbcmFuZ2VbMF0sIHJhbmdlWzFdXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXhpcy5zY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb21haW4gfSA9IGF4aXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbZGlyZWN0aW9uXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbixcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogZG9tYWluLm1hcCgoZCkgPT4gYXhpcy5zY2FsZS5jb252ZXJ0KGQpKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGFkZFNjYWxlKENoYXJ0QXhpc0RpcmVjdGlvbi5YKTtcclxuICAgICAgICBhZGRTY2FsZShDaGFydEF4aXNEaXJlY3Rpb24uWSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQ2FydGVzaWFuU2VyaWVzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtTmFtZVwiLCB2b2lkIDApO1xuXG5jb25zdCBkaXJlY3Rpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuY2xhc3MgQ2FydGVzaWFuQ2hhcnQgZXh0ZW5kcyBDaGFydCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcGVjaWFsT3ZlcnJpZGVzLCByZXNvdXJjZXMpIHtcclxuICAgICAgICBzdXBlcihzcGVjaWFsT3ZlcnJpZGVzLCByZXNvdXJjZXMpO1xyXG4gICAgICAgIC8qKiBJbnRlZ3JhdGVkIENoYXJ0cyBmZWF0dXJlIHN0YXRlIC0gbm90IHVzZWQgaW4gU3RhbmRhbG9uZSBDaGFydHMuICovXHJcbiAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2xhc3RBeGlzV2lkdGhzID0ge1xyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9sYXN0VmlzaWJpbGl0eSA9IHtcclxuICAgICAgICAgICAgY3Jvc3NMaW5lczogdHJ1ZSxcclxuICAgICAgICAgICAgc2VyaWVzOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwZXJmb3JtTGF5b3V0KCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBwZXJmb3JtTGF5b3V0OiB7IGdldDogKCkgPT4gc3VwZXIucGVyZm9ybUxheW91dCB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hyaW5rUmVjdCA9IHlpZWxkIF9zdXBlci5wZXJmb3JtTGF5b3V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uUmVjdCwgc2VyaWVzUmVjdCwgdmlzaWJpbGl0eSwgY2xpcFNlcmllcyB9ID0gdGhpcy51cGRhdGVBeGVzKHNocmlua1JlY3QpO1xyXG4gICAgICAgICAgICB0aGlzLnNlcmllc1Jvb3QudmlzaWJsZSA9IHZpc2liaWxpdHkuc2VyaWVzO1xyXG4gICAgICAgICAgICB0aGlzLnNlcmllc1JlY3QgPSBzZXJpZXNSZWN0O1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBhbmltYXRpb25SZWN0O1xyXG4gICAgICAgICAgICB0aGlzLnNlcmllc1Jvb3QudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihzZXJpZXNSZWN0LngpO1xyXG4gICAgICAgICAgICB0aGlzLnNlcmllc1Jvb3QudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcihzZXJpZXNSZWN0LnkpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHNlcmllc0FyZWE6IHsgcGFkZGluZyB9LCB9ID0gdGhpcztcclxuICAgICAgICAgICAgLy8gUmVjcmVhdGUgcGFkZGluZyBvYmplY3QgdG8gcHJldmVudCBpc3N1ZXMgd2l0aCBnZXR0ZXJzIGluIGBCQm94LnNocmluaygpYFxyXG4gICAgICAgICAgICBjb25zdCBzZXJpZXNQYWRkZWRSZWN0ID0gc2VyaWVzUmVjdC5jbG9uZSgpLmdyb3coe1xyXG4gICAgICAgICAgICAgICAgdG9wOiBwYWRkaW5nLnRvcCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYWRkaW5nLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiBwYWRkaW5nLmJvdHRvbSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHBhZGRpbmcubGVmdCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaG92ZXJSZWN0ID0gc2VyaWVzUGFkZGVkUmVjdDtcclxuICAgICAgICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoTGF5b3V0Q29tcGxldGUoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xheW91dC1jb21wbGV0ZScsXHJcbiAgICAgICAgICAgICAgICBjaGFydDogeyB3aWR0aDogdGhpcy5zY2VuZS53aWR0aCwgaGVpZ2h0OiB0aGlzLnNjZW5lLmhlaWdodCB9LFxyXG4gICAgICAgICAgICAgICAgY2xpcFNlcmllcyxcclxuICAgICAgICAgICAgICAgIHNlcmllczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Q6IHNlcmllc1JlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGVkUmVjdDogc2VyaWVzUGFkZGVkUmVjdCxcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmlsaXR5LnNlcmllcyxcclxuICAgICAgICAgICAgICAgICAgICBzaG91bGRGbGlwWFk6IHRoaXMuc2hvdWxkRmxpcFhZKCksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXhlczogdGhpcy5heGVzLm1hcCgoYXhpcykgPT4gKE9iamVjdC5hc3NpZ24oeyBpZDogYXhpcy5pZCB9LCBheGlzLmdldExheW91dFN0YXRlKCkpKSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hyaW5rUmVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUF4ZXMoaW5wdXRTaHJpbmtSZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBnb29kIGFwcHJveGltYXRpb24gZnJvbSB0aGUgbGFzdCB1cGRhdGUgLSB0aGlzIHNob3VsZCBtZWFuIHRoYXQgaW4gbWFueSByZXNpemVcclxuICAgICAgICAvLyBjYXNlcyB0aGF0IG9ubHkgYSBzaW5nbGUgcGFzcyBpcyBuZWVkZWQgXFxvLy5cclxuICAgICAgICBjb25zdCBheGlzV2lkdGhzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fbGFzdEF4aXNXaWR0aHMpO1xyXG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9sYXN0VmlzaWJpbGl0eSk7XHJcbiAgICAgICAgLy8gQ2xlYW4gYW55IHBvc2l0aW9ucyB3aGljaCBhcmVuJ3QgdmFsaWQgd2l0aCB0aGUgY3VycmVudCBheGlzIHN0YXR1cyAob3RoZXJ3aXNlIHdlIGVuZCB1cFxyXG4gICAgICAgIC8vIG5ldmVyIGJlaW5nIGFibGUgdG8gZmluZCBhIHN0YWJsZSByZXN1bHQpLlxyXG4gICAgICAgIGNvbnN0IGxpdmVBeGlzV2lkdGhzID0gbmV3IFNldCh0aGlzLl9heGVzLm1hcCgoYSkgPT4gYS5wb3NpdGlvbikpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgT2JqZWN0LmtleXMoYXhpc1dpZHRocykpIHtcclxuICAgICAgICAgICAgaWYgKCFsaXZlQXhpc1dpZHRocy5oYXMocG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgYXhpc1dpZHRoc1twb3NpdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhYmxlT3V0cHV0cyA9IChvdGhlckF4aXNXaWR0aHMsIG90aGVyVmlzaWJpbGl0eSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbmV3IGF4aXMgcG9zaXRpb25zLlxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob3RoZXJBeGlzV2lkdGhzKS5zb21lKChrKSA9PiBheGlzV2lkdGhzW2tdID09IG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh2aXNpYmlsaXR5LmNyb3NzTGluZXMgPT09IG90aGVyVmlzaWJpbGl0eS5jcm9zc0xpbmVzICYmXHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5LnNlcmllcyA9PT0gb3RoZXJWaXNpYmlsaXR5LnNlcmllcyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGF4aXMgcG9zaXRpb25zIGFuZCBlcXVhbGl0eS5cclxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGF4aXNXaWR0aHMpLmV2ZXJ5KChbcCwgd10pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlclcgPSBvdGhlckF4aXNXaWR0aHNbcF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcgIT0gbnVsbCB8fCBvdGhlclcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdyA9PT0gb3RoZXJXO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNlaWxWYWx1ZXMgPSAocmVjb3JkcykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocmVjb3JkcykucmVkdWNlKChvdXQsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIE1hdGguYWJzKHZhbHVlKSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9IHZhbHVlICE9IG51bGwgPyBNYXRoLmNlaWwodmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBJdGVyYXRpdmVseSB0cnkgdG8gcmVzb2x2ZSBheGlzIHdpZHRocyAtIHNpbmNlIFggYXhpcyB3aWR0aCBhZmZlY3RzIFkgYXhpcyByYW5nZSxcclxuICAgICAgICAvLyBhbmQgdmljZS12ZXJzYSwgd2UgbmVlZCB0byBpdGVyYXRpdmVseSB0cnkgYW5kIGZpbmQgYSBmaXQgZm9yIHRoZSBheGVzIGFuZCB0aGVpclxyXG4gICAgICAgIC8vIHRpY2tzL2xhYmVscy5cclxuICAgICAgICBsZXQgbGFzdFBhc3NBeGlzV2lkdGhzID0ge307XHJcbiAgICAgICAgbGV0IGxhc3RQYXNzVmlzaWJpbGl0eSA9IHt9O1xyXG4gICAgICAgIGxldCBjbGlwU2VyaWVzID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHNlcmllc1JlY3QgPSAoX2EgPSB0aGlzLnNlcmllc1JlY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9uZSgpO1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IHByaW1hcnlUaWNrQ291bnRzID0ge307XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF4aXNXaWR0aHMsIGxhc3RQYXNzQXhpc1dpZHRocyk7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odmlzaWJpbGl0eSwgbGFzdFBhc3NWaXNpYmlsaXR5KTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy51cGRhdGVBeGVzUGFzcyhheGlzV2lkdGhzLCBpbnB1dFNocmlua1JlY3QuY2xvbmUoKSwgc2VyaWVzUmVjdCk7XHJcbiAgICAgICAgICAgIGxhc3RQYXNzQXhpc1dpZHRocyA9IGNlaWxWYWx1ZXMocmVzdWx0LmF4aXNXaWR0aHMpO1xyXG4gICAgICAgICAgICBsYXN0UGFzc1Zpc2liaWxpdHkgPSByZXN1bHQudmlzaWJpbGl0eTtcclxuICAgICAgICAgICAgY2xpcFNlcmllcyA9IHJlc3VsdC5jbGlwU2VyaWVzO1xyXG4gICAgICAgICAgICBzZXJpZXNSZWN0ID0gcmVzdWx0LnNlcmllc1JlY3Q7XHJcbiAgICAgICAgICAgIHByaW1hcnlUaWNrQ291bnRzID0gcmVzdWx0LnByaW1hcnlUaWNrQ291bnRzO1xyXG4gICAgICAgICAgICBpZiAoY291bnQrKyA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybigndW5hYmxlIHRvIGZpbmQgc3RhYmxlIGF4aXMgbGF5b3V0LicpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICghc3RhYmxlT3V0cHV0cyhsYXN0UGFzc0F4aXNXaWR0aHMsIGxhc3RQYXNzVmlzaWJpbGl0eSkpO1xyXG4gICAgICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSBheGlzO1xyXG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5VGlja0NvdW50ID0gcHJpbWFyeVRpY2tDb3VudHNbZGlyZWN0aW9uXTtcclxuICAgICAgICAgICAgYXhpcy51cGRhdGUocHJpbWFyeVRpY2tDb3VudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY2xpcFJlY3RQYWRkaW5nID0gNTtcclxuICAgICAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdmlzaWJpbGl0eSBvZiBjcm9zc2xpbmVzXHJcbiAgICAgICAgICAgIGF4aXMuc2V0Q3Jvc3NMaW5lc1Zpc2libGUodmlzaWJpbGl0eS5jcm9zc0xpbmVzKTtcclxuICAgICAgICAgICAgaWYgKCFzZXJpZXNSZWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXhpcy5jbGlwR3JpZChzZXJpZXNSZWN0LngsIHNlcmllc1JlY3QueSwgc2VyaWVzUmVjdC53aWR0aCArIGNsaXBSZWN0UGFkZGluZywgc2VyaWVzUmVjdC5oZWlnaHQgKyBjbGlwUmVjdFBhZGRpbmcpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGF4aXMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuY2xpcFRpY2tMaW5lcyhpbnB1dFNocmlua1JlY3QueCwgc2VyaWVzUmVjdC55LCBpbnB1dFNocmlua1JlY3Qud2lkdGggKyBjbGlwUmVjdFBhZGRpbmcsIHNlcmllc1JlY3QuaGVpZ2h0ICsgY2xpcFJlY3RQYWRkaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuY2xpcFRpY2tMaW5lcyhzZXJpZXNSZWN0LngsIGlucHV0U2hyaW5rUmVjdC55LCBzZXJpZXNSZWN0LndpZHRoICsgY2xpcFJlY3RQYWRkaW5nLCBpbnB1dFNocmlua1JlY3QuaGVpZ2h0ICsgY2xpcFJlY3RQYWRkaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xhc3RBeGlzV2lkdGhzID0gYXhpc1dpZHRocztcclxuICAgICAgICB0aGlzLl9sYXN0VmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XHJcbiAgICAgICAgcmV0dXJuIHsgc2VyaWVzUmVjdCwgYW5pbWF0aW9uUmVjdDogaW5wdXRTaHJpbmtSZWN0LCB2aXNpYmlsaXR5LCBjbGlwU2VyaWVzIH07XHJcbiAgICB9XHJcbiAgICB1cGRhdGVBeGVzUGFzcyhheGlzV2lkdGhzLCBib3VuZHMsIGxhc3RQYXNzU2VyaWVzUmVjdCkge1xyXG4gICAgICAgIGNvbnN0IHsgYXhlcyB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB2aXNpdGVkID0ge307XHJcbiAgICAgICAgY29uc3QgbmV3QXhpc1dpZHRocyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSB7XHJcbiAgICAgICAgICAgIHNlcmllczogdHJ1ZSxcclxuICAgICAgICAgICAgY3Jvc3NMaW5lczogdHJ1ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBjbGlwU2VyaWVzID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgcHJpbWFyeVRpY2tDb3VudHMgPSB7fTtcclxuICAgICAgICBjb25zdCBwYWRkZWRCb3VuZHMgPSB0aGlzLmFwcGx5U2VyaWVzUGFkZGluZyhib3VuZHMpO1xyXG4gICAgICAgIGNvbnN0IGNyb3NzTGluZVBhZGRpbmcgPSBsYXN0UGFzc1Nlcmllc1JlY3QgPyB0aGlzLmJ1aWxkQ3Jvc3NMaW5lUGFkZGluZyhheGlzV2lkdGhzKSA6IHt9O1xyXG4gICAgICAgIGNvbnN0IGF4aXNCb3VuZCA9IHRoaXMuYnVpbGRBeGlzQm91bmQocGFkZGVkQm91bmRzLCBheGlzV2lkdGhzLCBjcm9zc0xpbmVQYWRkaW5nLCB2aXNpYmlsaXR5KTtcclxuICAgICAgICBjb25zdCBzZXJpZXNSZWN0ID0gdGhpcy5idWlsZFNlcmllc1JlY3QoYXhpc0JvdW5kLCBheGlzV2lkdGhzKTtcclxuICAgICAgICAvLyBTZXQgdGhlIG51bWJlciBvZiB0aWNrcyBmb3IgY29udGludW91cyBheGVzIGJhc2VkIG9uIHRoZSBhdmFpbGFibGUgcmFuZ2VcclxuICAgICAgICAvLyBiZWZvcmUgdXBkYXRpbmcgdGhlIGF4aXMgZG9tYWluIHZpYSBgdGhpcy51cGRhdGVBeGVzKClgIGFzIHRoZSB0aWNrIGNvdW50IGhhcyBhbiBlZmZlY3Qgb24gdGhlIGNhbGN1bGF0ZWQgYG5pY2VgIGRvbWFpbiBleHRlbnRcclxuICAgICAgICBheGVzLmZvckVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiA9ICdsZWZ0JyB9ID0gYXhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBjbGlwU2VyaWVzOiBuZXdDbGlwU2VyaWVzLCBheGlzVGhpY2tuZXNzLCBheGlzT2Zmc2V0LCB9ID0gdGhpcy5jYWxjdWxhdGVBeGlzRGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgICAgICBheGlzLFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzUmVjdCxcclxuICAgICAgICAgICAgICAgIHBhZGRlZEJvdW5kcyxcclxuICAgICAgICAgICAgICAgIGF4aXNXaWR0aHMsXHJcbiAgICAgICAgICAgICAgICBuZXdBeGlzV2lkdGhzLFxyXG4gICAgICAgICAgICAgICAgcHJpbWFyeVRpY2tDb3VudHMsXHJcbiAgICAgICAgICAgICAgICBjbGlwU2VyaWVzLFxyXG4gICAgICAgICAgICAgICAgYWRkSW50ZXJBeGlzUGFkZGluZzogKChfYSA9IHZpc2l0ZWRbcG9zaXRpb25dKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSA+IDAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2aXNpdGVkW3Bvc2l0aW9uXSA9ICgoX2IgPSB2aXNpdGVkW3Bvc2l0aW9uXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKyAxO1xyXG4gICAgICAgICAgICBjbGlwU2VyaWVzID0gY2xpcFNlcmllcyB8fCBuZXdDbGlwU2VyaWVzO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQXhpcyh7XHJcbiAgICAgICAgICAgICAgICBheGlzLFxyXG4gICAgICAgICAgICAgICAgYXhpc0JvdW5kLFxyXG4gICAgICAgICAgICAgICAgYXhpc09mZnNldCxcclxuICAgICAgICAgICAgICAgIGF4aXNUaGlja25lc3MsXHJcbiAgICAgICAgICAgICAgICBheGlzV2lkdGhzLFxyXG4gICAgICAgICAgICAgICAgcHJpbWFyeVRpY2tDb3VudHMsXHJcbiAgICAgICAgICAgICAgICBzZXJpZXNSZWN0LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4geyBjbGlwU2VyaWVzLCBzZXJpZXNSZWN0LCBheGlzV2lkdGhzOiBuZXdBeGlzV2lkdGhzLCB2aXNpYmlsaXR5LCBwcmltYXJ5VGlja0NvdW50cyB9O1xyXG4gICAgfVxyXG4gICAgYnVpbGRDcm9zc0xpbmVQYWRkaW5nKGF4aXNXaWR0aHMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY3Jvc3NMaW5lUGFkZGluZyA9IHt9O1xyXG4gICAgICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChheGlzLmNyb3NzTGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGF4aXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjcm9zc0xpbmUuY2FsY3VsYXRlUGFkZGluZyhjcm9zc0xpbmVQYWRkaW5nKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gUmVkdWNlIGNyb3NzLWxpbmUgcGFkZGluZyB0byBhY2NvdW50IGZvciBvdmVybGFwIHdpdGggYXhlcy5cclxuICAgICAgICBmb3IgKGNvbnN0IFtzaWRlLCBwYWRkaW5nID0gMF0gb2YgT2JqZWN0LmVudHJpZXMoY3Jvc3NMaW5lUGFkZGluZykpIHtcclxuICAgICAgICAgICAgY3Jvc3NMaW5lUGFkZGluZ1tzaWRlXSA9IE1hdGgubWF4KHBhZGRpbmcgLSAoKF9hID0gYXhpc1dpZHRoc1tzaWRlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCksIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3Jvc3NMaW5lUGFkZGluZztcclxuICAgIH1cclxuICAgIGFwcGx5U2VyaWVzUGFkZGluZyhib3VuZHMpIHtcclxuICAgICAgICBjb25zdCBwYWRkZWRSZWN0ID0gYm91bmRzLmNsb25lKCk7XHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRBeGVzID0gdGhpcy5heGVzLnNsaWNlKCkucmV2ZXJzZSgpO1xyXG4gICAgICAgIGRpcmVjdGlvbnMuZm9yRWFjaCgoZGlyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnNlcmllc0FyZWEucGFkZGluZ1tkaXJdO1xyXG4gICAgICAgICAgICBjb25zdCBheGlzID0gcmV2ZXJzZWRBeGVzLmZpbmQoKGF4aXMpID0+IGF4aXMucG9zaXRpb24gPT09IGRpcik7XHJcbiAgICAgICAgICAgIGlmIChheGlzKSB7XHJcbiAgICAgICAgICAgICAgICBheGlzLnNlcmllc0FyZWFQYWRkaW5nID0gcGFkZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhZGRlZFJlY3Quc2hyaW5rKHBhZGRpbmcsIGRpcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGFkZGVkUmVjdDtcclxuICAgIH1cclxuICAgIGJ1aWxkQXhpc0JvdW5kKGJvdW5kcywgYXhpc1dpZHRocywgY3Jvc3NMaW5lUGFkZGluZywgdmlzaWJpbGl0eSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBib3VuZHMuY2xvbmUoKTtcclxuICAgICAgICBjb25zdCB7IHRvcCA9IDAsIHJpZ2h0ID0gMCwgYm90dG9tID0gMCwgbGVmdCA9IDAgfSA9IGNyb3NzTGluZVBhZGRpbmc7XHJcbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbFBhZGRpbmcgPSBsZWZ0ICsgcmlnaHQ7XHJcbiAgICAgICAgY29uc3QgdmVydGljYWxQYWRkaW5nID0gdG9wICsgYm90dG9tO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSAoKF9hID0gYXhpc1dpZHRocy5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSArICgoX2IgPSBheGlzV2lkdGhzLnJpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSArIGhvcml6b250YWxQYWRkaW5nO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gKChfYyA9IGF4aXNXaWR0aHMudG9wKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSArICgoX2QgPSBheGlzV2lkdGhzLmJvdHRvbSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCkgKyB2ZXJ0aWNhbFBhZGRpbmc7XHJcbiAgICAgICAgaWYgKHJlc3VsdC53aWR0aCA8PSB0b3RhbFdpZHRoIHx8IHJlc3VsdC5oZWlnaHQgPD0gdG90YWxIZWlnaHQpIHtcclxuICAgICAgICAgICAgLy8gTm90IGVub3VnaCBzcGFjZSBmb3IgY3Jvc3NMaW5lcyBhbmQgc2VyaWVzXHJcbiAgICAgICAgICAgIHZpc2liaWxpdHkuY3Jvc3NMaW5lcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2aXNpYmlsaXR5LnNlcmllcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQueCArPSBsZWZ0O1xyXG4gICAgICAgIHJlc3VsdC55ICs9IHRvcDtcclxuICAgICAgICByZXN1bHQud2lkdGggLT0gaG9yaXpvbnRhbFBhZGRpbmc7XHJcbiAgICAgICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0aWNhbFBhZGRpbmc7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGJ1aWxkU2VyaWVzUmVjdChheGlzQm91bmQsIGF4aXNXaWR0aHMpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBheGlzQm91bmQuY2xvbmUoKTtcclxuICAgICAgICBjb25zdCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9ID0gYXhpc1dpZHRocztcclxuICAgICAgICByZXN1bHQueCArPSBsZWZ0ICE9PSBudWxsICYmIGxlZnQgIT09IHZvaWQgMCA/IGxlZnQgOiAwO1xyXG4gICAgICAgIHJlc3VsdC55ICs9IHRvcCAhPT0gbnVsbCAmJiB0b3AgIT09IHZvaWQgMCA/IHRvcCA6IDA7XHJcbiAgICAgICAgcmVzdWx0LndpZHRoIC09IChsZWZ0ICE9PSBudWxsICYmIGxlZnQgIT09IHZvaWQgMCA/IGxlZnQgOiAwKSArIChyaWdodCAhPT0gbnVsbCAmJiByaWdodCAhPT0gdm9pZCAwID8gcmlnaHQgOiAwKTtcclxuICAgICAgICByZXN1bHQuaGVpZ2h0IC09ICh0b3AgIT09IG51bGwgJiYgdG9wICE9PSB2b2lkIDAgPyB0b3AgOiAwKSArIChib3R0b20gIT09IG51bGwgJiYgYm90dG9tICE9PSB2b2lkIDAgPyBib3R0b20gOiAwKTtcclxuICAgICAgICAvLyBXaWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBub3QgYmUgbmVnYXRpdmUuXHJcbiAgICAgICAgcmVzdWx0LndpZHRoID0gTWF0aC5tYXgoMCwgcmVzdWx0LndpZHRoKTtcclxuICAgICAgICByZXN1bHQuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcmVzdWx0LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNsYW1wVG9PdXRzaWRlU2VyaWVzUmVjdChzZXJpZXNSZWN0LCB2YWx1ZSwgZGltZW5zaW9uLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHNlcmllc1JlY3Q7XHJcbiAgICAgICAgY29uc3QgY2xhbXBCb3VuZHMgPSBbeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0XTtcclxuICAgICAgICBjb25zdCBmbiA9IGRpcmVjdGlvbiA9PT0gMSA/IE1hdGgubWluIDogTWF0aC5tYXg7XHJcbiAgICAgICAgY29uc3QgY29tcGFyZVRvID0gY2xhbXBCb3VuZHNbKGRpbWVuc2lvbiA9PT0gJ3gnID8gMCA6IDEpICsgKGRpcmVjdGlvbiA9PT0gMSA/IDAgOiAyKV07XHJcbiAgICAgICAgcmV0dXJuIGZuKHZhbHVlLCBjb21wYXJlVG8pO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlQXhpc0RpbWVuc2lvbnMob3B0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICAgICAgY29uc3QgeyBheGlzLCBzZXJpZXNSZWN0LCBwYWRkZWRCb3VuZHMsIGF4aXNXaWR0aHMsIG5ld0F4aXNXaWR0aHMsIHByaW1hcnlUaWNrQ291bnRzLCBhZGRJbnRlckF4aXNQYWRkaW5nIH0gPSBvcHRzO1xyXG4gICAgICAgIGxldCB7IGNsaXBTZXJpZXMgfSA9IG9wdHM7XHJcbiAgICAgICAgY29uc3QgeyBwb3NpdGlvbiA9ICdsZWZ0JywgZGlyZWN0aW9uIH0gPSBheGlzO1xyXG4gICAgICAgIGNvbnN0IGF4aXNMZWZ0UmlnaHRSYW5nZSA9IChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChheGlzIGluc3RhbmNlb2YgQ2F0ZWdvcnlBeGlzIHx8IGF4aXMgaW5zdGFuY2VvZiBHcm91cGVkQ2F0ZWdvcnlBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIHNlcmllc1JlY3QuaGVpZ2h0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW3Nlcmllc1JlY3QuaGVpZ2h0LCAwXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGF4aXNPZmZzZXQgPSAoX2EgPSBuZXdBeGlzV2lkdGhzW3Bvc2l0aW9uXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICBheGlzLnJhbmdlID0gWzAsIHNlcmllc1JlY3Qud2lkdGhdO1xyXG4gICAgICAgICAgICAgICAgYXhpcy5ncmlkTGVuZ3RoID0gc2VyaWVzUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIGF4aXMucmFuZ2UgPSBheGlzTGVmdFJpZ2h0UmFuZ2UoYXhpcyk7XHJcbiAgICAgICAgICAgICAgICBheGlzLmdyaWRMZW5ndGggPSBzZXJpZXNSZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLnpvb21NYW5hZ2VyLmdldEF4aXNab29tKGF4aXMuaWQpO1xyXG4gICAgICAgIGNvbnN0IHsgbWluID0gMCwgbWF4ID0gMSB9ID0gem9vbSAhPT0gbnVsbCAmJiB6b29tICE9PSB2b2lkIDAgPyB6b29tIDoge307XHJcbiAgICAgICAgYXhpcy52aXNpYmxlUmFuZ2UgPSBbbWluLCBtYXhdO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlQ2xpcHBlZCA9IGF4aXMuZGF0YURvbWFpbi5jbGlwcGVkIHx8IGF4aXMudmlzaWJsZVJhbmdlWzBdID4gMCB8fCBheGlzLnZpc2libGVSYW5nZVsxXSA8IDE7XHJcbiAgICAgICAgY2xpcFNlcmllcyB8fCAoY2xpcFNlcmllcyA9IHJhbmdlQ2xpcHBlZCk7XHJcbiAgICAgICAgbGV0IHByaW1hcnlUaWNrQ291bnQgPSBheGlzLm5pY2UgPyBwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHBhZGRlZEJvdW5kc0NvZWZmaWNpZW50ID0gMC4zO1xyXG4gICAgICAgIGlmIChheGlzLnRoaWNrbmVzcyAhPSBudWxsICYmIGF4aXMudGhpY2tuZXNzID4gMCkge1xyXG4gICAgICAgICAgICBheGlzLm1heFRoaWNrbmVzcyA9IGF4aXMudGhpY2tuZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IENoYXJ0QXhpc0RpcmVjdGlvbi5ZKSB7XHJcbiAgICAgICAgICAgIGF4aXMubWF4VGhpY2tuZXNzID0gcGFkZGVkQm91bmRzLndpZHRoICogcGFkZGVkQm91bmRzQ29lZmZpY2llbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBheGlzLm1heFRoaWNrbmVzcyA9IHBhZGRlZEJvdW5kcy5oZWlnaHQgKiBwYWRkZWRCb3VuZHNDb2VmZmljaWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gYXhpcy5jYWxjdWxhdGVMYXlvdXQocHJpbWFyeVRpY2tDb3VudCk7XHJcbiAgICAgICAgcHJpbWFyeVRpY2tDb3VudCA9IGxheW91dC5wcmltYXJ5VGlja0NvdW50O1xyXG4gICAgICAgIHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gPSAoX2IgPSBwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwcmltYXJ5VGlja0NvdW50O1xyXG4gICAgICAgIGxldCBheGlzVGhpY2tuZXNzID0gMDtcclxuICAgICAgICBpZiAoYXhpcy50aGlja25lc3MgIT0gbnVsbCAmJiBheGlzLnRoaWNrbmVzcyA+IDApIHtcclxuICAgICAgICAgICAgYXhpc1RoaWNrbmVzcyA9IGF4aXMudGhpY2tuZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgeyBiYm94IH0gPSBsYXlvdXQ7XHJcbiAgICAgICAgICAgIGF4aXNUaGlja25lc3MgPSBkaXJlY3Rpb24gPT09IENoYXJ0QXhpc0RpcmVjdGlvbi5YID8gYmJveC5oZWlnaHQgOiBiYm94LndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IgbXVsdGlwbGUgYXhlcyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gYW5kIHBvc2l0aW9uLCBhcHBseSBwYWRkaW5nIGF0IHRoZSB0b3Agb2YgZWFjaCBpbm5lciBheGlzIChpLmUuIGJldHdlZW4gYXhlcykuXHJcbiAgICAgICAgY29uc3QgYXhpc1BhZGRpbmcgPSAxNTtcclxuICAgICAgICBpZiAoYWRkSW50ZXJBeGlzUGFkZGluZykge1xyXG4gICAgICAgICAgICBheGlzVGhpY2tuZXNzICs9IGF4aXNQYWRkaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBheGlzVGhpY2tuZXNzID0gTWF0aC5jZWlsKGF4aXNUaGlja25lc3MpO1xyXG4gICAgICAgIG5ld0F4aXNXaWR0aHNbcG9zaXRpb25dID0gKChfYyA9IG5ld0F4aXNXaWR0aHNbcG9zaXRpb25dKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSArIGF4aXNUaGlja25lc3M7XHJcbiAgICAgICAgYXhpcy5ncmlkUGFkZGluZyA9ICgoX2QgPSBheGlzV2lkdGhzW3Bvc2l0aW9uXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCkgLSAoKF9lID0gbmV3QXhpc1dpZHRoc1twb3NpdGlvbl0pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDApO1xyXG4gICAgICAgIHJldHVybiB7IGNsaXBTZXJpZXMsIGF4aXNUaGlja25lc3MsIGF4aXNPZmZzZXQsIHByaW1hcnlUaWNrQ291bnQgfTtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uQXhpcyhvcHRzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGNvbnN0IHsgYXhpcywgYXhpc0JvdW5kLCBheGlzV2lkdGhzLCBzZXJpZXNSZWN0LCBheGlzT2Zmc2V0LCBheGlzVGhpY2tuZXNzIH0gPSBvcHRzO1xyXG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24gfSA9IGF4aXM7XHJcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgYXhpcy50cmFuc2xhdGlvbi54ID0gYXhpc0JvdW5kLnggKyAoKF9hID0gYXhpc1dpZHRocy5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcclxuICAgICAgICAgICAgICAgIGF4aXMudHJhbnNsYXRpb24ueSA9IHRoaXMuY2xhbXBUb091dHNpZGVTZXJpZXNSZWN0KHNlcmllc1JlY3QsIGF4aXNCb3VuZC55ICsgMSArIGF4aXNPZmZzZXQgKyBheGlzVGhpY2tuZXNzLCAneScsIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICBheGlzLnRyYW5zbGF0aW9uLnggPSBheGlzQm91bmQueCArICgoX2IgPSBheGlzV2lkdGhzLmxlZnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xyXG4gICAgICAgICAgICAgICAgYXhpcy50cmFuc2xhdGlvbi55ID0gdGhpcy5jbGFtcFRvT3V0c2lkZVNlcmllc1JlY3Qoc2VyaWVzUmVjdCwgYXhpc0JvdW5kLnkgKyBheGlzQm91bmQuaGVpZ2h0ICsgMSAtIGF4aXNUaGlja25lc3MgLSBheGlzT2Zmc2V0LCAneScsIC0xKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIGF4aXMudHJhbnNsYXRpb24ueSA9IGF4aXNCb3VuZC55ICsgKChfYyA9IGF4aXNXaWR0aHMudG9wKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKTtcclxuICAgICAgICAgICAgICAgIGF4aXMudHJhbnNsYXRpb24ueCA9IHRoaXMuY2xhbXBUb091dHNpZGVTZXJpZXNSZWN0KHNlcmllc1JlY3QsIGF4aXNCb3VuZC54ICsgYXhpc09mZnNldCArIGF4aXNUaGlja25lc3MsICd4JywgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgYXhpcy50cmFuc2xhdGlvbi55ID0gYXhpc0JvdW5kLnkgKyAoKF9kID0gYXhpc1dpZHRocy50b3ApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApO1xyXG4gICAgICAgICAgICAgICAgYXhpcy50cmFuc2xhdGlvbi54ID0gdGhpcy5jbGFtcFRvT3V0c2lkZVNlcmllc1JlY3Qoc2VyaWVzUmVjdCwgYXhpc0JvdW5kLnggKyBheGlzQm91bmQud2lkdGggLSBheGlzVGhpY2tuZXNzIC0gYXhpc09mZnNldCwgJ3gnLCAtMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXhpcy51cGRhdGVQb3NpdGlvbih7IHJvdGF0aW9uOiB0b1JhZGlhbnMoYXhpcy5yb3RhdGlvbiksIHNpZGVGbGFnOiBheGlzLmxhYmVsLmdldFNpZGVGbGFnKCkgfSk7XHJcbiAgICB9XHJcbiAgICBzaG91bGRGbGlwWFkoKSB7XHJcbiAgICAgICAgLy8gT25seSBmbGlwIHRoZSB4eSBheGVzIGlmIGFsbCB0aGUgc2VyaWVzIGFncmVlIG9uIGZsaXBwaW5nXHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnNlcmllcy5zb21lKChzZXJpZXMpID0+ICEoc2VyaWVzIGluc3RhbmNlb2YgQ2FydGVzaWFuU2VyaWVzICYmIHNlcmllcy5zaG91bGRGbGlwWFkoKSkpO1xyXG4gICAgfVxyXG59XHJcbkNhcnRlc2lhbkNoYXJ0LmNsYXNzTmFtZSA9ICdDYXJ0ZXNpYW5DaGFydCc7XHJcbkNhcnRlc2lhbkNoYXJ0LnR5cGUgPSAnY2FydGVzaWFuJztcblxuLyoqXHJcbiAqIFByb3h5IGNsYXNzLCB0byBhbGxvdyBsaWJyYXJ5IHVzZXJzIHRvIGtlZXAgYSBzdGFibGUgcmVmZXJlbmNlIHRvIHRoZWlyIGNoYXJ0LCBldmVuIGlmIHdlIG5lZWRcclxuICogdG8gc3dpdGNoIGNvbmNyZXRlIGNsYXNzIChlLmcuIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gQ2FydGVzaWFuQ2hhcnQgdnMuIFBvbGFyQ2hhcnQpLlxyXG4gKi9cclxuY2xhc3MgQWdDaGFydEluc3RhbmNlUHJveHkge1xyXG4gICAgc3RhdGljIGlzSW5zdGFuY2UoeCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFnQ2hhcnRJbnN0YW5jZVByb3h5KSB7XHJcbiAgICAgICAgICAgIC8vIFNpbXBsZSBjYXNlLlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgoX2EgPSB4LmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdBZ0NoYXJ0SW5zdGFuY2VQcm94eScgJiYgeC5jaGFydCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIGluc3RhbmNlb2YgY2FuIGZhaWwgaWYgbWl4aW5nIGJ1bmRsZXMgKGUuZy4gZ3JpZCBhbGwtbW9kdWxlcyB2cy4gc3RhbmRhbG9uZSkuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geC5jaGFydCAhPSBudWxsICYmIHRoaXMudmFsaWRhdGVJbXBsZW1lbnRhdGlvbih4KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB2YWxpZGF0ZUltcGxlbWVudGF0aW9uKHgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0UHJvcHMgPSBbJ2dldE9wdGlvbnMnLCAnZGVzdHJveSddO1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZVByb3BzID0gT2JqZWN0LmtleXMoKF9iID0gKF9hID0geC5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3RvdHlwZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pO1xyXG4gICAgICAgIHJldHVybiBjaGFydFByb3BzLmV2ZXJ5KChwcm9wKSA9PiBzaWduYXR1cmVQcm9wcy5pbmNsdWRlcyhwcm9wKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFydCkge1xyXG4gICAgICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0T3B0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmNoYXJ0LmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOaWNlU2Vjb25kYXJ5QXhpcyhkb21haW4sIHByaW1hcnlUaWNrQ291bnQpIHtcclxuICAgIC8vIE1ha2Ugc2Vjb25kYXJ5IGF4aXMgZG9tYWluIG5pY2UgdXNpbmcgc3RyaWN0IHRpY2sgY291bnQsIG1hdGNoaW5nIHRoZSB0aWNrIGNvdW50IGZyb20gdGhlIHByaW1hcnkgYXhpcy5cclxuICAgIC8vIFRoaXMgaXMgdG8gbWFrZSB0aGUgc2Vjb25kYXJ5IGF4aXMgZ3JpZCBsaW5lcy8gdGljayBwb3NpdGlvbnMgYWxpZ24gd2l0aCB0aGUgb25lcyBmcm9tIHRoZSBwcmltYXJ5IGF4aXMuXHJcbiAgICBsZXQgc3RhcnQgPSBNYXRoLmZsb29yKGRvbWFpblswXSk7XHJcbiAgICBsZXQgc3RvcCA9IGRvbWFpblsxXTtcclxuICAgIHN0YXJ0ID0gY2FsY3VsYXRlTmljZVN0YXJ0KHN0YXJ0LCBzdG9wLCBwcmltYXJ5VGlja0NvdW50KTtcclxuICAgIGNvbnN0IHN0ZXAgPSBnZXRUaWNrU3RlcChzdGFydCwgc3RvcCwgcHJpbWFyeVRpY2tDb3VudCk7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHByaW1hcnlUaWNrQ291bnQgLSAxO1xyXG4gICAgc3RvcCA9IHN0YXJ0ICsgc2VnbWVudHMgKiBzdGVwO1xyXG4gICAgY29uc3QgZCA9IFtzdGFydCwgc3RvcF07XHJcbiAgICBjb25zdCB0aWNrcyA9IGdldFRpY2tzKHN0YXJ0LCBzdGVwLCBwcmltYXJ5VGlja0NvdW50KTtcclxuICAgIHJldHVybiBbZCwgdGlja3NdO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZU5pY2VTdGFydChhLCBiLCBjb3VudCkge1xyXG4gICAgY29uc3QgcmF3U3RlcCA9IE1hdGguYWJzKGIgLSBhKSAvIChjb3VudCAtIDEpO1xyXG4gICAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAocmF3U3RlcCkpO1xyXG4gICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKGEgLyBtYWduaXR1ZGUpICogbWFnbml0dWRlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRpY2tzKHN0YXJ0LCBzdGVwLCBjb3VudCkge1xyXG4gICAgLy8gcG93ZXIgb2YgdGhlIHN0ZXAgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgc3RlcCBpcyBhIGZyYWN0aW9uIChiZXR3ZWVuIDAgYW5kIDEpXHJcbiAgICBjb25zdCBzdGVwUG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoc3RlcCkpO1xyXG4gICAgY29uc3QgZnJhY3Rpb25EaWdpdHMgPSBzdGVwID4gMCAmJiBzdGVwIDwgMSA/IE1hdGguYWJzKHN0ZXBQb3dlcikgOiAwO1xyXG4gICAgY29uc3QgZiA9IE1hdGgucG93KDEwLCBmcmFjdGlvbkRpZ2l0cyk7XHJcbiAgICBjb25zdCB0aWNrcyA9IG5ldyBOdW1lcmljVGlja3MoZnJhY3Rpb25EaWdpdHMpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdGljayA9IHN0YXJ0ICsgc3RlcCAqIGk7XHJcbiAgICAgICAgdGlja3NbaV0gPSBNYXRoLnJvdW5kKHRpY2sgKiBmKSAvIGY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGlja3M7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IGNvdW50IC0gMTtcclxuICAgIGNvbnN0IHJhd1N0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIHNlZ21lbnRzO1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZU5leHROaWNlU3RlcChyYXdTdGVwKTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVOZXh0TmljZVN0ZXAocmF3U3RlcCkge1xyXG4gICAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAocmF3U3RlcCkpO1xyXG4gICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcclxuICAgIC8vIE1ha2Ugb3JkZXIgMVxyXG4gICAgY29uc3Qgc3RlcCA9IChyYXdTdGVwIC8gbWFnbml0dWRlKSAqIDEwO1xyXG4gICAgaWYgKHN0ZXAgPiAwICYmIHN0ZXAgPD0gMSkge1xyXG4gICAgICAgIHJldHVybiBtYWduaXR1ZGUgLyAxMDtcclxuICAgIH1cclxuICAgIGlmIChzdGVwID4gMSAmJiBzdGVwIDw9IDIpIHtcclxuICAgICAgICByZXR1cm4gKDIgKiBtYWduaXR1ZGUpIC8gMTA7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RlcCA+IDEgJiYgc3RlcCA8PSA1KSB7XHJcbiAgICAgICAgcmV0dXJuICg1ICogbWFnbml0dWRlKSAvIDEwO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0ZXAgPiA1ICYmIHN0ZXAgPD0gMTApIHtcclxuICAgICAgICByZXR1cm4gKDEwICogbWFnbml0dWRlKSAvIDEwO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0ZXAgPiAxMCAmJiBzdGVwIDw9IDIwKSB7XHJcbiAgICAgICAgcmV0dXJuICgyMCAqIG1hZ25pdHVkZSkgLyAxMDtcclxuICAgIH1cclxuICAgIGlmIChzdGVwID4gMjAgJiYgc3RlcCA8PSA0MCkge1xyXG4gICAgICAgIHJldHVybiAoNDAgKiBtYWduaXR1ZGUpIC8gMTA7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RlcCA+IDQwICYmIHN0ZXAgPD0gNTApIHtcclxuICAgICAgICByZXR1cm4gKDUwICogbWFnbml0dWRlKSAvIDEwO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0ZXAgPiA1MCAmJiBzdGVwIDw9IDEwMCkge1xyXG4gICAgICAgIHJldHVybiAoMTAwICogbWFnbml0dWRlKSAvIDEwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0ZXA7XHJcbn1cblxuY2xhc3MgTnVtYmVyQXhpc1RpY2sgZXh0ZW5kcyBBeGlzVGljayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubWF4U3BhY2luZyA9IE5hTjtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOKDEpLCBHUkVBVEVSX1RIQU4oJ21pblNwYWNpbmcnKSkpLFxyXG4gICAgRGVmYXVsdChOYU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTnVtYmVyQXhpc1RpY2sucHJvdG90eXBlLCBcIm1heFNwYWNpbmdcIiwgdm9pZCAwKTtcclxuY2xhc3MgTnVtYmVyQXhpcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xyXG4gICAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpKSB7XHJcbiAgICAgICAgc3VwZXIobW9kdWxlQ3R4LCBzY2FsZSk7XHJcbiAgICAgICAgdGhpcy5taW4gPSBOYU47XHJcbiAgICAgICAgdGhpcy5tYXggPSBOYU47XHJcbiAgICB9XHJcbiAgICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcclxuICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgZXh0ZW50LCBjbGlwcGVkIH0gPSBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KTtcclxuICAgICAgICByZXR1cm4geyBkb21haW46IGV4dGVudCwgY2xpcHBlZCB9O1xyXG4gICAgfVxyXG4gICAgZm9ybWF0RGF0dW0oZGF0dW0pIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdHVtID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0dW0udG9GaXhlZCgyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIExvZ2dlci53YXJuT25jZSgnZGF0YSBjb250YWlucyBEYXRlIG9iamVjdHMgd2hpY2ggYXJlIGJlaW5nIHBsb3R0ZWQgYWdhaW5zdCBhIG51bWJlciBheGlzLCBwbGVhc2Ugb25seSB1c2UgYSBudW1iZXIgYXhpcyBmb3IgbnVtYmVycy4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhkYXR1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlVGljaygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE51bWJlckF4aXNUaWNrKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTZWNvbmRhcnlBeGlzVGlja3MocHJpbWFyeVRpY2tDb3VudCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGFEb21haW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIGRhdGFEb21haW4gbm90IGNhbGN1bGF0ZWQsIGNhbm5vdCBwZXJmb3JtIHRpY2sgY2FsY3VsYXRpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGFEb21haW4uZG9tYWluLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIGNvbnN0IFtkLCB0aWNrc10gPSBjYWxjdWxhdGVOaWNlU2Vjb25kYXJ5QXhpcyh0aGlzLmRhdGFEb21haW4uZG9tYWluLCBwcmltYXJ5VGlja0NvdW50ICE9PSBudWxsICYmIHByaW1hcnlUaWNrQ291bnQgIT09IHZvaWQgMCA/IHByaW1hcnlUaWNrQ291bnQgOiAwKTtcclxuICAgICAgICB0aGlzLnNjYWxlLm5pY2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjYWxlLmRvbWFpbiA9IGQ7XHJcbiAgICAgICAgdGhpcy5zY2FsZS51cGRhdGUoKTtcclxuICAgICAgICByZXR1cm4gdGlja3M7XHJcbiAgICB9XHJcbn1cclxuTnVtYmVyQXhpcy5jbGFzc05hbWUgPSAnTnVtYmVyQXhpcyc7XHJcbk51bWJlckF4aXMudHlwZSA9ICdudW1iZXInO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOKCksIExFU1NfVEhBTignbWF4JykpKSxcclxuICAgIERlZmF1bHQoTmFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIE51bWJlckF4aXMucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOKCksIEdSRUFURVJfVEhBTignbWluJykpKSxcclxuICAgIERlZmF1bHQoTmFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIE51bWJlckF4aXMucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuXG5mdW5jdGlvbiBOT05fWkVST19OVU1CRVIoKSB7XHJcbiAgICAvLyBDYW5ub3QgYmUgMFxyXG4gICAgY29uc3QgbWVzc2FnZSA9IGBleHBlY3RpbmcgYSBub24temVybyBOdW1iZXJgO1xyXG4gICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgJiYgdiAhPT0gMCwgbWVzc2FnZSk7XHJcbn1cclxuY2xhc3MgTG9nQXhpcyBleHRlbmRzIE51bWJlckF4aXMge1xyXG4gICAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XHJcbiAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IGV4dGVudCwgY2xpcHBlZCB9ID0gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCk7XHJcbiAgICAgICAgY29uc3QgaXNJbnZlcnRlZCA9IGV4dGVudFswXSA+IGV4dGVudFsxXTtcclxuICAgICAgICBjb25zdCBjcm9zc2VzWmVybyA9IGV4dGVudFswXSA8IDAgJiYgZXh0ZW50WzFdID4gMDtcclxuICAgICAgICBjb25zdCBoYXNaZXJvRXh0ZW50ID0gZXh0ZW50WzBdID09PSAwICYmIGV4dGVudFsxXSA9PT0gMDtcclxuICAgICAgICBjb25zdCBpbnZhbGlkRG9tYWluID0gaXNJbnZlcnRlZCB8fCBjcm9zc2VzWmVybyB8fCBoYXNaZXJvRXh0ZW50O1xyXG4gICAgICAgIGlmIChpbnZhbGlkRG9tYWluKSB7XHJcbiAgICAgICAgICAgIGQgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGNyb3NzZXNaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybihgdGhlIGRhdGEgZG9tYWluIGNyb3NzZXMgemVybywgdGhlIGNoYXJ0IGRhdGEgY2Fubm90IGJlIHJlbmRlcmVkLiBTZWUgbG9nIGF4aXMgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNaZXJvRXh0ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIud2FybihgdGhlIGRhdGEgZG9tYWluIGhhcyAwIGV4dGVudCwgbm8gZGF0YSBpcyByZW5kZXJlZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXh0ZW50WzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGV4dGVudFswXSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRlbnRbMV0gPT09IDApIHtcclxuICAgICAgICAgICAgZXh0ZW50WzFdID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGRvbWFpbjogZXh0ZW50LCBjbGlwcGVkIH07XHJcbiAgICB9XHJcbiAgICBzZXQgYmFzZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2NhbGUuYmFzZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJhc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUuYmFzZTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xyXG4gICAgICAgIHN1cGVyKG1vZHVsZUN0eCwgbmV3IExvZ1NjYWxlKCkpO1xyXG4gICAgICAgIHRoaXMubWluID0gTmFOO1xyXG4gICAgICAgIHRoaXMubWF4ID0gTmFOO1xyXG4gICAgfVxyXG59XHJcbkxvZ0F4aXMuY2xhc3NOYW1lID0gJ0xvZ0F4aXMnO1xyXG5Mb2dBeGlzLnR5cGUgPSAnbG9nJztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShBTkQoTlVNQkVSX09SX05BTigpLCBMRVNTX1RIQU4oJ21heCcpLCBOT05fWkVST19OVU1CRVIoKSkpLFxyXG4gICAgRGVmYXVsdChOYU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTG9nQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4oKSwgR1JFQVRFUl9USEFOKCdtaW4nKSwgTk9OX1pFUk9fTlVNQkVSKCkpKSxcclxuICAgIERlZmF1bHQoTmFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExvZ0F4aXMucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuXG5jbGFzcyBUaW1lQXhpc1RpY2sgZXh0ZW5kcyBBeGlzVGljayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubWF4U3BhY2luZyA9IE5hTjtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOKDEpLCBHUkVBVEVSX1RIQU4oJ21pblNwYWNpbmcnKSkpLFxyXG4gICAgRGVmYXVsdChOYU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgVGltZUF4aXNUaWNrLnByb3RvdHlwZSwgXCJtYXhTcGFjaW5nXCIsIHZvaWQgMCk7XHJcbmNsYXNzIFRpbWVBeGlzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcclxuICAgICAgICBzdXBlcihtb2R1bGVDdHgsIG5ldyBUaW1lU2NhbGUoKSk7XHJcbiAgICAgICAgdGhpcy5kYXR1bUZvcm1hdCA9ICclbS8lZC8leSwgJUg6JU06JVMnO1xyXG4gICAgICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHsgc2NhbGUgfSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoU2NhbGUoKTtcclxuICAgICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gc2NhbGUudGlja0Zvcm1hdCh7XHJcbiAgICAgICAgICAgIHNwZWNpZmllcjogdGhpcy5kYXR1bUZvcm1hdCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBsZXQgeyBtaW4sIG1heCB9ID0gdGhpcztcclxuICAgICAgICBsZXQgY2xpcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWluID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBtaW4gPSBuZXcgRGF0ZShtaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG1heCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgbWF4ID0gbmV3IERhdGUobWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGQubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICBkID0gKChfYSA9IGV4dGVudChkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogWzAsIDEwMDBdKS5tYXAoKHgpID0+IG5ldyBEYXRlKHgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pbiBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgY2xpcHBlZCB8fCAoY2xpcHBlZCA9IG1pbiA+IGRbMF0pO1xyXG4gICAgICAgICAgICBkID0gW21pbiwgZFsxXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXggaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtYXggPCBkWzFdKTtcclxuICAgICAgICAgICAgZCA9IFtkWzBdLCBtYXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZFswXSA+IGRbMV0pIHtcclxuICAgICAgICAgICAgZCA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBkb21haW46IGQsIGNsaXBwZWQgfTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVRpY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lQXhpc1RpY2soKTtcclxuICAgIH1cclxuICAgIG9uTGFiZWxGb3JtYXRDaGFuZ2UodGlja3MsIGZvcm1hdCkge1xyXG4gICAgICAgIGlmIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgc3VwZXIub25MYWJlbEZvcm1hdENoYW5nZSh0aWNrcywgZm9ybWF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZvciB0aW1lIGF4aXMgbGFiZWxzIHRvIGxvb2sgbmljZSwgZXZlbiBpZiBkYXRlIGZvcm1hdCB3YXNuJ3Qgc2V0LlxyXG4gICAgICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gdGhpcy5zY2FsZS50aWNrRm9ybWF0KHsgdGlja3MgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9ybWF0RGF0dW0oZGF0dW0pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMubW9kdWxlQ3R4LmNhbGxiYWNrQ2FjaGUuY2FsbCh0aGlzLmRhdHVtRm9ybWF0dGVyLCBkYXR1bSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFN0cmluZyhkYXR1bSk7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVQYWRkaW5nKF9taW4sIF9tYXgpIHtcclxuICAgICAgICAvLyBudW1iZXJzIGluIGRvbWFpbiBjb3JyZXNwb25kIHRvIFVuaXggdGltZXN0YW1wc1xyXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZXhwYW5kIGRvbWFpbiBieSAxIGluIGZvcndhcmQgZGlyZWN0aW9uXHJcbiAgICAgICAgcmV0dXJuIFswLCAxXTtcclxuICAgIH1cclxufVxyXG5UaW1lQXhpcy5jbGFzc05hbWUgPSAnVGltZUF4aXMnO1xyXG5UaW1lQXhpcy50eXBlID0gJ3RpbWUnO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEFORChPUFRfREFURV9PUl9EQVRFVElNRV9NUywgTEVTU19USEFOKCdtYXgnKSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgVGltZUF4aXMucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEFORChPUFRfREFURV9PUl9EQVRFVElNRV9NUywgR1JFQVRFUl9USEFOKCdtaW4nKSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgVGltZUF4aXMucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuXG5jb25zdCBBWElTX0NPTlNUUlVDVE9SUyA9IHtcclxuICAgIFtOdW1iZXJBeGlzLnR5cGVdOiBOdW1iZXJBeGlzLFxyXG4gICAgW0NhdGVnb3J5QXhpcy50eXBlXTogQ2F0ZWdvcnlBeGlzLFxyXG4gICAgW1RpbWVBeGlzLnR5cGVdOiBUaW1lQXhpcyxcclxuICAgIFtHcm91cGVkQ2F0ZWdvcnlBeGlzLnR5cGVdOiBHcm91cGVkQ2F0ZWdvcnlBeGlzLFxyXG4gICAgW0xvZ0F4aXMudHlwZV06IExvZ0F4aXMsXHJcbn07XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQXhpcyhheGlzVHlwZSwgY3Rvcikge1xyXG4gICAgQVhJU19DT05TVFJVQ1RPUlNbYXhpc1R5cGVdID0gY3RvcjtcclxufVxyXG5mdW5jdGlvbiBnZXRBeGlzKGF4aXNUeXBlLCBtb2R1bGVDdHgpIHtcclxuICAgIGNvbnN0IGF4aXNDb25zdHJ1Y3RvciA9IEFYSVNfQ09OU1RSVUNUT1JTW2F4aXNUeXBlXTtcclxuICAgIGlmIChheGlzQ29uc3RydWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGF4aXNDb25zdHJ1Y3Rvcihtb2R1bGVDdHgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSB1bmtub3duIGF4aXMgdHlwZTogJHtheGlzVHlwZX1gKTtcclxufVxyXG5jb25zdCBBWElTX1RZUEVTID0ge1xyXG4gICAgaGFzKGF4aXNUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBWElTX0NPTlNUUlVDVE9SUywgYXhpc1R5cGUpO1xyXG4gICAgfSxcclxuICAgIGdldCBheGVzVHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKEFYSVNfQ09OU1RSVUNUT1JTKTtcclxuICAgIH0sXHJcbn07XHJcbmNvbnN0IEFYSVNfVEhFTUVfVEVNUExBVEVTID0ge307XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQXhpc1RoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIHRoZW1lKSB7XHJcbiAgICBBWElTX1RIRU1FX1RFTVBMQVRFU1theGlzVHlwZV0gPSB0aGVtZTtcclxufVxyXG5mdW5jdGlvbiBnZXRBeGlzVGhlbWVUZW1wbGF0ZShheGlzVHlwZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChfYSA9IEFYSVNfVEhFTUVfVEVNUExBVEVTW2F4aXNUeXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XHJcbn1cblxuY29uc3QgRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTID0gW1xyXG4gICAgeyB0eXBlOiAncm9vdCcsIG9wdGlvbnNLZXk6ICdhbmltYXRpb24nLCBjaGFydFR5cGVzOiBbJ2NhcnRlc2lhbicsICdwb2xhcicsICdoaWVyYXJjaHknXSB9LFxyXG4gICAge1xyXG4gICAgICAgIHR5cGU6ICdyb290JyxcclxuICAgICAgICBvcHRpb25zS2V5OiAnYmFja2dyb3VuZCcsXHJcbiAgICAgICAgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nLCAncG9sYXInLCAnaGllcmFyY2h5J10sXHJcbiAgICAgICAgb3B0aW9uc0lubmVyS2V5OiAnaW1hZ2UnLFxyXG4gICAgfSxcclxuICAgIHsgdHlwZTogJ3Jvb3QnLCBvcHRpb25zS2V5OiAnY29udGV4dE1lbnUnLCBjaGFydFR5cGVzOiBbJ2NhcnRlc2lhbicsICdwb2xhcicsICdoaWVyYXJjaHknXSB9LFxyXG4gICAgeyB0eXBlOiAncm9vdCcsIG9wdGlvbnNLZXk6ICd6b29tJywgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nXSB9LFxyXG4gICAge1xyXG4gICAgICAgIHR5cGU6ICdsZWdlbmQnLFxyXG4gICAgICAgIG9wdGlvbnNLZXk6ICdncmFkaWVudExlZ2VuZCcsXHJcbiAgICAgICAgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nLCAncG9sYXInLCAnaGllcmFyY2h5J10sXHJcbiAgICAgICAgaWRlbnRpZmllcjogJ2dyYWRpZW50JyxcclxuICAgIH0sXHJcbiAgICB7IHR5cGU6ICdheGlzJywgb3B0aW9uc0tleTogJ2F4ZXNbXScsIGNoYXJ0VHlwZXM6IFsncG9sYXInXSwgaWRlbnRpZmllcjogJ2FuZ2xlLWNhdGVnb3J5JyB9LFxyXG4gICAgeyB0eXBlOiAnYXhpcycsIG9wdGlvbnNLZXk6ICdheGVzW10nLCBjaGFydFR5cGVzOiBbJ3BvbGFyJ10sIGlkZW50aWZpZXI6ICdhbmdsZS1udW1iZXInIH0sXHJcbiAgICB7IHR5cGU6ICdheGlzJywgb3B0aW9uc0tleTogJ2F4ZXNbXScsIGNoYXJ0VHlwZXM6IFsncG9sYXInXSwgaWRlbnRpZmllcjogJ3JhZGl1cy1jYXRlZ29yeScgfSxcclxuICAgIHsgdHlwZTogJ2F4aXMnLCBvcHRpb25zS2V5OiAnYXhlc1tdJywgY2hhcnRUeXBlczogWydwb2xhciddLCBpZGVudGlmaWVyOiAncmFkaXVzLW51bWJlcicgfSxcclxuICAgIHsgdHlwZTogJ2F4aXMtb3B0aW9uJywgb3B0aW9uc0tleTogJ2Nyb3NzaGFpcicsIGNoYXJ0VHlwZXM6IFsnY2FydGVzaWFuJ10gfSxcclxuICAgIHsgdHlwZTogJ3NlcmllcycsIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsIGNoYXJ0VHlwZXM6IFsnY2FydGVzaWFuJ10sIGlkZW50aWZpZXI6ICdib3gtcGxvdCcgfSxcclxuICAgIHsgdHlwZTogJ3NlcmllcycsIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsIGNoYXJ0VHlwZXM6IFsnY2FydGVzaWFuJ10sIGlkZW50aWZpZXI6ICdidWxsZXQnIH0sXHJcbiAgICB7IHR5cGU6ICdzZXJpZXMnLCBvcHRpb25zS2V5OiAnc2VyaWVzW10nLCBjaGFydFR5cGVzOiBbJ2NhcnRlc2lhbiddLCBpZGVudGlmaWVyOiAnaGVhdG1hcCcgfSxcclxuICAgIHsgdHlwZTogJ3NlcmllcycsIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsIGNoYXJ0VHlwZXM6IFsncG9sYXInXSwgaWRlbnRpZmllcjogJ25pZ2h0aW5nYWxlJyB9LFxyXG4gICAgeyB0eXBlOiAnc2VyaWVzJywgb3B0aW9uc0tleTogJ3Nlcmllc1tdJywgY2hhcnRUeXBlczogWydwb2xhciddLCBpZGVudGlmaWVyOiAncmFkYXItYXJlYScgfSxcclxuICAgIHsgdHlwZTogJ3NlcmllcycsIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsIGNoYXJ0VHlwZXM6IFsncG9sYXInXSwgaWRlbnRpZmllcjogJ3JhZGFyLWxpbmUnIH0sXHJcbiAgICB7IHR5cGU6ICdzZXJpZXMnLCBvcHRpb25zS2V5OiAnc2VyaWVzW10nLCBjaGFydFR5cGVzOiBbJ3BvbGFyJ10sIGlkZW50aWZpZXI6ICdyYWRpYWwtYmFyJyB9LFxyXG4gICAgeyB0eXBlOiAnc2VyaWVzJywgb3B0aW9uc0tleTogJ3Nlcmllc1tdJywgY2hhcnRUeXBlczogWydwb2xhciddLCBpZGVudGlmaWVyOiAncmFkaWFsLWNvbHVtbicgfSxcclxuICAgIHsgdHlwZTogJ3NlcmllcycsIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsIGNoYXJ0VHlwZXM6IFsnY2FydGVzaWFuJ10sIGlkZW50aWZpZXI6ICdyYW5nZS1hcmVhJyB9LFxyXG4gICAgeyB0eXBlOiAnc2VyaWVzJywgb3B0aW9uc0tleTogJ3Nlcmllc1tdJywgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nXSwgaWRlbnRpZmllcjogJ3JhbmdlLWJhcicgfSxcclxuICAgIHsgdHlwZTogJ3NlcmllcycsIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsIGNoYXJ0VHlwZXM6IFsnaGllcmFyY2h5J10sIGlkZW50aWZpZXI6ICdzdW5idXJzdCcgfSxcclxuICAgIHsgdHlwZTogJ3NlcmllcycsIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsIGNoYXJ0VHlwZXM6IFsnaGllcmFyY2h5J10sIGlkZW50aWZpZXI6ICd0cmVlbWFwJyB9LFxyXG4gICAgeyB0eXBlOiAnc2VyaWVzJywgb3B0aW9uc0tleTogJ3Nlcmllc1tdJywgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nXSwgaWRlbnRpZmllcjogJ3dhdGVyZmFsbCcgfSxcclxuICAgIHsgdHlwZTogJ3Nlcmllcy1vcHRpb24nLCBvcHRpb25zS2V5OiAnZXJyb3JCYXInLCBjaGFydFR5cGVzOiBbJ2NhcnRlc2lhbiddLCBpZGVudGlmaWVyOiAnZXJyb3ItYmFycycgfSxcclxuXTtcclxuZnVuY3Rpb24gaXNFbnRlcnByaXNlU2VyaWVzVHlwZSh0eXBlKSB7XHJcbiAgICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLnNvbWUoKHMpID0+IHMudHlwZSA9PT0gJ3NlcmllcycgJiYgcy5pZGVudGlmaWVyID09PSB0eXBlKTtcclxufVxyXG5mdW5jdGlvbiBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyh0eXBlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gJ3NlcmllcycgJiYgcy5pZGVudGlmaWVyID09PSB0eXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoYXJ0VHlwZXM7XHJcbn1cclxuZnVuY3Rpb24gaXNFbnRlcnByaXNlU2VyaWVzVHlwZUxvYWRlZCh0eXBlKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuICgoX2IgPSAoX2EgPSBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmluZCgocykgPT4gcy50eXBlID09PSAnc2VyaWVzJyAmJiBzLmlkZW50aWZpZXIgPT09IHR5cGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlQ291bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApID4gMDtcclxufVxyXG5mdW5jdGlvbiBpc0VudGVycHJpc2VDYXJ0ZXNpYW4oc2VyaWVzVHlwZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgdHlwZSA9IChfYSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgodikgPT4gdiA9PT0gJ2NhcnRlc2lhbicpO1xyXG4gICAgcmV0dXJuIHR5cGUgPT09ICdjYXJ0ZXNpYW4nO1xyXG59XHJcbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVBvbGFyKHNlcmllc1R5cGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHR5cGUgPSAoX2EgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKHYpID0+IHYgPT09ICdwb2xhcicpO1xyXG4gICAgcmV0dXJuIHR5cGUgPT09ICdwb2xhcic7XHJcbn1cclxuZnVuY3Rpb24gaXNFbnRlcnByaXNlSGllcmFyY2h5KHNlcmllc1R5cGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHR5cGUgPSAoX2EgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKHYpID0+IHYgPT09ICdoaWVyYXJjaHknKTtcclxuICAgIHJldHVybiB0eXBlID09PSAnaGllcmFyY2h5JztcclxufVxyXG5mdW5jdGlvbiB2ZXJpZnlJZk1vZHVsZUV4cGVjdGVkKG1vZHVsZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKG1vZHVsZS5wYWNrYWdlVHlwZSAhPT0gJ2VudGVycHJpc2UnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWd1cmF0aW9uIGVycm9yLCBvbmx5IGVudGVycHJpc2UgbW9kdWxlcyBuZWVkIHZlcmlmaWNhdGlvbi4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0dWIgPSBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmluZCgocykgPT4ge1xyXG4gICAgICAgIHJldHVybiAocy50eXBlID09PSBtb2R1bGUudHlwZSAmJlxyXG4gICAgICAgICAgICBzLm9wdGlvbnNLZXkgPT09IG1vZHVsZS5vcHRpb25zS2V5ICYmXHJcbiAgICAgICAgICAgIHMuaWRlbnRpZmllciA9PT0gbW9kdWxlLmlkZW50aWZpZXIgJiZcclxuICAgICAgICAgICAgbW9kdWxlLmNoYXJ0VHlwZXMuZXZlcnkoKHQpID0+IHMuY2hhcnRUeXBlcy5pbmNsdWRlcyh0KSkpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoc3R1Yikge1xyXG4gICAgICAgIChfYSA9IHN0dWIudXNlQ291bnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChzdHViLnVzZUNvdW50ID0gMCk7XHJcbiAgICAgICAgc3R1Yi51c2VDb3VudCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0dWIgIT0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBnZXRVbnVzZWRFeHBlY3RlZE1vZHVsZXMoKSB7XHJcbiAgICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbHRlcigoeyB1c2VDb3VudCB9KSA9PiB1c2VDb3VudCA9PSBudWxsIHx8IHVzZUNvdW50ID09PSAwKTtcclxufVxuXG5jb25zdCBMRUdFTkRfS0VZUyA9IHtcclxuICAgIGNhdGVnb3J5OiAnbGVnZW5kJyxcclxufTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJMZWdlbmQodHlwZSwga2V5LCBjdHIsIHRoZW1lKSB7XHJcbiAgICBMRUdFTkRfS0VZU1t0eXBlXSA9IGtleTtcclxuICAgIExFR0VORF9USEVNRV9URU1QTEFURVNba2V5XSA9IHRoZW1lO1xyXG59XHJcbmNvbnN0IExFR0VORF9USEVNRV9URU1QTEFURVMgPSB7fTtcclxuZnVuY3Rpb24gZ2V0TGVnZW5kVGhlbWVUZW1wbGF0ZXMoKSB7XHJcbiAgICByZXR1cm4gTEVHRU5EX1RIRU1FX1RFTVBMQVRFUztcclxufVxyXG5mdW5jdGlvbiBnZXRMZWdlbmRLZXlzKCkge1xyXG4gICAgcmV0dXJuIExFR0VORF9LRVlTO1xyXG59XG5cbmNsYXNzIEJhY2tncm91bmQgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xyXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbmV3IEdyb3VwKHsgbmFtZTogJ2JhY2tncm91bmQnLCB6SW5kZXg6IExheWVycy5TRVJJRVNfQkFDS0dST1VORF9aSU5ERVggfSk7XHJcbiAgICAgICAgdGhpcy5yZWN0Tm9kZSA9IG5ldyBSZWN0KCk7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmZpbGwgPSAnd2hpdGUnO1xyXG4gICAgICAgIC8vIHBsYWNlaG9sZGVyIGZvciBlbnRlcnByaXNlIG1vZHVsZVxyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMucmVjdE5vZGUpO1xyXG4gICAgICAgIChfYSA9IGN0eC5zY2VuZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCgoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGN0eC5zY2VuZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTsgfSwgY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoJ2xheW91dC1jb21wbGV0ZScsIChlKSA9PiB0aGlzLm9uTGF5b3V0Q29tcGxldGUoZSkpKTtcclxuICAgIH1cclxuICAgIG9uTGF5b3V0Q29tcGxldGUoZSkge1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZS5jaGFydDtcclxuICAgICAgICB0aGlzLnJlY3ROb2RlLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5yZWN0Tm9kZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIFByb3h5UHJvcGVydHlPbldyaXRlKCdub2RlJywgJ3Zpc2libGUnKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0NPTE9SX1NUUklORyksXHJcbiAgICBQcm94eVByb3BlcnR5T25Xcml0ZSgncmVjdE5vZGUnLCAnZmlsbCcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xuXG5jb25zdCBCYWNrZ3JvdW5kTW9kdWxlID0ge1xyXG4gICAgdHlwZTogJ3Jvb3QnLFxyXG4gICAgb3B0aW9uc0tleTogJ2JhY2tncm91bmQnLFxyXG4gICAgcGFja2FnZVR5cGU6ICdjb21tdW5pdHknLFxyXG4gICAgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nLCAncG9sYXInLCAnaGllcmFyY2h5J10sXHJcbiAgICBpbnN0YW5jZUNvbnN0cnVjdG9yOiBCYWNrZ3JvdW5kLFxyXG59O1xuXG5jbGFzcyBOYXZpZ2F0b3JIYW5kbGUge1xyXG4gICAgc2V0IGZpbGwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnJoLmZpbGwgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBmaWxsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJoLmZpbGw7XHJcbiAgICB9XHJcbiAgICBzZXQgc3Ryb2tlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5yaC5zdHJva2UgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBzdHJva2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmguc3Ryb2tlO1xyXG4gICAgfVxyXG4gICAgc2V0IHN0cm9rZVdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5yaC5zdHJva2VXaWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0cm9rZVdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJoLnN0cm9rZVdpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5yaC53aWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJoLndpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucmguaGVpZ2h0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJoLmhlaWdodDtcclxuICAgIH1cclxuICAgIHNldCBncmlwTGluZUdhcCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucmguZ3JpcExpbmVHYXAgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBncmlwTGluZUdhcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaC5ncmlwTGluZUdhcDtcclxuICAgIH1cclxuICAgIHNldCBncmlwTGluZUxlbmd0aCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucmguZ3JpcExpbmVMZW5ndGggPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBncmlwTGluZUxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaC5ncmlwTGluZUxlbmd0aDtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKHJhbmdlSGFuZGxlKSB7XHJcbiAgICAgICAgdGhpcy5yaCA9IHJhbmdlSGFuZGxlO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIE5hdmlnYXRvck1hc2sge1xyXG4gICAgc2V0IGZpbGwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnJtLmZpbGwgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBmaWxsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJtLmZpbGw7XHJcbiAgICB9XHJcbiAgICBzZXQgc3Ryb2tlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ybS5zdHJva2UgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBzdHJva2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm0uc3Ryb2tlO1xyXG4gICAgfVxyXG4gICAgc2V0IHN0cm9rZVdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ybS5zdHJva2VXaWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0cm9rZVdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJtLnN0cm9rZVdpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGZpbGxPcGFjaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ybS5maWxsT3BhY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZpbGxPcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJtLmZpbGxPcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3IocmFuZ2VNYXNrKSB7XHJcbiAgICAgICAgdGhpcy5ybSA9IHJhbmdlTWFzaztcclxuICAgIH1cclxufVxuXG5jbGFzcyBSYW5nZUhhbmRsZSBleHRlbmRzIFBhdGgge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9maWxsID0gJyNmMmYyZjInO1xyXG4gICAgICAgIHRoaXMuX3N0cm9rZSA9ICcjOTk5OTk5JztcclxuICAgICAgICB0aGlzLl9zdHJva2VXaWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5fbGluZUNhcCA9ICdzcXVhcmUnO1xyXG4gICAgICAgIHRoaXMuX2NlbnRlclggPSAwO1xyXG4gICAgICAgIHRoaXMuX2NlbnRlclkgPSAwO1xyXG4gICAgICAgIC8vIFVzZSBhbiBldmVuIG51bWJlciBmb3IgYmV0dGVyIGxvb2tpbmcgcmVzdWx0cy5cclxuICAgICAgICB0aGlzLl93aWR0aCA9IDg7XHJcbiAgICAgICAgLy8gVXNlIGFuIGV2ZW4gbnVtYmVyIGZvciBiZXR0ZXIgbG9va2luZyByZXN1bHRzLlxyXG4gICAgICAgIHRoaXMuX2dyaXBMaW5lR2FwID0gMjtcclxuICAgICAgICAvLyBVc2UgYW4gZXZlbiBudW1iZXIgZm9yIGJldHRlciBsb29raW5nIHJlc3VsdHMuXHJcbiAgICAgICAgdGhpcy5fZ3JpcExpbmVMZW5ndGggPSA4O1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IDE2O1xyXG4gICAgfVxyXG4gICAgc2V0IGNlbnRlclgodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2VudGVyWCAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2VudGVyWCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGNlbnRlclgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlclg7XHJcbiAgICB9XHJcbiAgICBzZXQgY2VudGVyWSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jZW50ZXJZICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jZW50ZXJZID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyWSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2VudGVyWTtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl93aWR0aCAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICBzZXQgZ3JpcExpbmVHYXAodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZ3JpcExpbmVHYXAgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyaXBMaW5lR2FwID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZ3JpcExpbmVHYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyaXBMaW5lR2FwO1xyXG4gICAgfVxyXG4gICAgc2V0IGdyaXBMaW5lTGVuZ3RoKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyaXBMaW5lTGVuZ3RoICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmlwTGluZUxlbmd0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGdyaXBMaW5lTGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncmlwTGluZUxlbmd0aDtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5faGVpZ2h0ICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIGNvbXB1dGVCQm94KCkge1xyXG4gICAgICAgIGNvbnN0IHsgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB4ID0gY2VudGVyWCAtIHdpZHRoIC8gMjtcclxuICAgICAgICBjb25zdCB5ID0gY2VudGVyWSAtIGhlaWdodCAvIDI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgaXNQb2ludEluUGF0aCh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xyXG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICAgICAgcmV0dXJuIGJib3guY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBhdGgoKSB7XHJcbiAgICAgICAgY29uc3QgeyBwYXRoLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xyXG4gICAgICAgIHBhdGguY2xlYXIoKTtcclxuICAgICAgICBjb25zdCB4ID0gY2VudGVyWCAtIHdpZHRoIC8gMjtcclxuICAgICAgICBjb25zdCB5ID0gY2VudGVyWSAtIGhlaWdodCAvIDI7XHJcbiAgICAgICAgY29uc3QgYXggPSB0aGlzLmFsaWduKHgpO1xyXG4gICAgICAgIGNvbnN0IGF5ID0gdGhpcy5hbGlnbih5KTtcclxuICAgICAgICBjb25zdCBheHcgPSBheCArIHRoaXMuYWxpZ24oeCwgd2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IGF5aCA9IGF5ICsgdGhpcy5hbGlnbih5LCBoZWlnaHQpO1xyXG4gICAgICAgIC8vIEhhbmRsZS5cclxuICAgICAgICBwYXRoLm1vdmVUbyhheCwgYXkpO1xyXG4gICAgICAgIHBhdGgubGluZVRvKGF4dywgYXkpO1xyXG4gICAgICAgIHBhdGgubGluZVRvKGF4dywgYXloKTtcclxuICAgICAgICBwYXRoLmxpbmVUbyhheCwgYXloKTtcclxuICAgICAgICBwYXRoLmxpbmVUbyhheCwgYXkpO1xyXG4gICAgICAgIC8vIEdyaXAgbGluZXMuXHJcbiAgICAgICAgY29uc3QgZHggPSB0aGlzLmdyaXBMaW5lR2FwIC8gMjtcclxuICAgICAgICBjb25zdCBkeSA9IHRoaXMuZ3JpcExpbmVMZW5ndGggLyAyO1xyXG4gICAgICAgIHBhdGgubW92ZVRvKHRoaXMuYWxpZ24oY2VudGVyWCAtIGR4KSwgdGhpcy5hbGlnbihjZW50ZXJZIC0gZHkpKTtcclxuICAgICAgICBwYXRoLmxpbmVUbyh0aGlzLmFsaWduKGNlbnRlclggLSBkeCksIHRoaXMuYWxpZ24oY2VudGVyWSArIGR5KSk7XHJcbiAgICAgICAgcGF0aC5tb3ZlVG8odGhpcy5hbGlnbihjZW50ZXJYICsgZHgpLCB0aGlzLmFsaWduKGNlbnRlclkgLSBkeSkpO1xyXG4gICAgICAgIHBhdGgubGluZVRvKHRoaXMuYWxpZ24oY2VudGVyWCArIGR4KSwgdGhpcy5hbGlnbihjZW50ZXJZICsgZHkpKTtcclxuICAgIH1cclxufVxyXG5SYW5nZUhhbmRsZS5jbGFzc05hbWUgPSAnUmFuZ2VIYW5kbGUnO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKENPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiX2ZpbGxcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcIl9zdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiX3N0cm9rZVdpZHRoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTElORV9DQVApLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcIl9saW5lQ2FwXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcIl93aWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJfZ3JpcExpbmVHYXBcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwiX2dyaXBMaW5lTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcIl9oZWlnaHRcIiwgdm9pZCAwKTtcblxuZnVuY3Rpb24gbWFya0RpcnR5T25DaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICBpZiAobmV3VmFsdWUgIT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFJhbmdlTWFzayBleHRlbmRzIFBhdGgge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDIwMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDMwO1xyXG4gICAgICAgIHRoaXMubWluUmFuZ2UgPSAwLjA1O1xyXG4gICAgICAgIHRoaXMuX21pbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fbWF4ID0gMTtcclxuICAgIH1cclxuICAgIHNldCBtaW4odmFsdWUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgdGhpcy5tYXggLSB0aGlzLm1pblJhbmdlKTtcclxuICAgICAgICBpZiAodGhpcy5fbWluICE9PSB2YWx1ZSAmJiAhaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5UGF0aCA9IHRydWU7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMub25SYW5nZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG1pbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heCh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YWx1ZSA9IGNsYW1wKHRoaXMubWluICsgdGhpcy5taW5SYW5nZSwgdmFsdWUsIDEpO1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXggIT09IHZhbHVlICYmICFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5vblJhbmdlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKSB7XHJcbiAgICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW4sIG1heCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBtaW5YID0geCArIHdpZHRoICogbWluO1xyXG4gICAgICAgIGNvbnN0IG1heFggPSB4ICsgd2lkdGggKiBtYXg7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCQm94KG1pblgsIHksIG1heFggLSBtaW5YLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGF0aCgpIHtcclxuICAgICAgICBjb25zdCB7IHBhdGgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbiwgbWF4IH0gPSB0aGlzO1xyXG4gICAgICAgIHBhdGguY2xlYXIoKTtcclxuICAgICAgICBjb25zdCBheCA9IHRoaXMuYWxpZ24oeCk7XHJcbiAgICAgICAgY29uc3QgYXkgPSB0aGlzLmFsaWduKHkpO1xyXG4gICAgICAgIGNvbnN0IGF4dyA9IGF4ICsgdGhpcy5hbGlnbih4LCB3aWR0aCk7XHJcbiAgICAgICAgY29uc3QgYXloID0gYXkgKyB0aGlzLmFsaWduKHksIGhlaWdodCk7XHJcbiAgICAgICAgLy8gV2hvbGUgcmFuZ2UuXHJcbiAgICAgICAgcGF0aC5tb3ZlVG8oYXgsIGF5KTtcclxuICAgICAgICBwYXRoLmxpbmVUbyhheHcsIGF5KTtcclxuICAgICAgICBwYXRoLmxpbmVUbyhheHcsIGF5aCk7XHJcbiAgICAgICAgcGF0aC5saW5lVG8oYXgsIGF5aCk7XHJcbiAgICAgICAgcGF0aC5saW5lVG8oYXgsIGF5KTtcclxuICAgICAgICBjb25zdCBtaW5YID0gdGhpcy5hbGlnbih4ICsgd2lkdGggKiBtaW4pO1xyXG4gICAgICAgIGNvbnN0IG1heFggPSB0aGlzLmFsaWduKHggKyB3aWR0aCAqIG1heCk7XHJcbiAgICAgICAgLy8gVmlzaWJsZSByYW5nZS5cclxuICAgICAgICBwYXRoLm1vdmVUbyhtaW5YLCBheSk7XHJcbiAgICAgICAgcGF0aC5saW5lVG8obWluWCwgYXloKTtcclxuICAgICAgICBwYXRoLmxpbmVUbyhtYXhYLCBheWgpO1xyXG4gICAgICAgIHBhdGgubGluZVRvKG1heFgsIGF5KTtcclxuICAgICAgICBwYXRoLmxpbmVUbyhtaW5YLCBheSk7XHJcbiAgICB9XHJcbn1cclxuUmFuZ2VNYXNrLmNsYXNzTmFtZSA9ICdSYW5nZU1hc2snO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIEFjdGlvbk9uU2V0KHsgY2hhbmdlVmFsdWU6IG1hcmtEaXJ0eU9uQ2hhbmdlIH0pLFxyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgUmFuZ2VNYXNrLnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgQWN0aW9uT25TZXQoeyBjaGFuZ2VWYWx1ZTogbWFya0RpcnR5T25DaGFuZ2UgfSksXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBSYW5nZU1hc2sucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBBY3Rpb25PblNldCh7IGNoYW5nZVZhbHVlOiBtYXJrRGlydHlPbkNoYW5nZSB9KSxcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFJhbmdlTWFzay5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBBY3Rpb25PblNldCh7IGNoYW5nZVZhbHVlOiBtYXJrRGlydHlPbkNoYW5nZSB9KSxcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDApKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIFJhbmdlTWFzay5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBSYW5nZU1hc2sucHJvdG90eXBlLCBcIl9taW5cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFJhbmdlTWFzay5wcm90b3R5cGUsIFwiX21heFwiLCB2b2lkIDApO1xuXG5jbGFzcyBSYW5nZVNlbGVjdG9yIGV4dGVuZHMgR3JvdXAge1xyXG4gICAgc2V0IHgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm1hc2sueCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcygpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFzay54O1xyXG4gICAgfVxyXG4gICAgc2V0IHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm1hc2sueSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcygpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFzay55O1xyXG4gICAgfVxyXG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5tYXNrLndpZHRoID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVzKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFzay53aWR0aDtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm1hc2suaGVpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVzKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hc2suaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0IG1pbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubWFzay5taW4gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBtaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFzay5taW47XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5tYXNrLm1heCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXNrLm1heDtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKHsgbmFtZTogJ3JhbmdlU2VsZWN0b3JHcm91cCcgfSk7XHJcbiAgICAgICAgdGhpcy5taW5IYW5kbGUgPSBuZXcgUmFuZ2VIYW5kbGUoKTtcclxuICAgICAgICB0aGlzLm1heEhhbmRsZSA9IG5ldyBSYW5nZUhhbmRsZSgpO1xyXG4gICAgICAgIHRoaXMubWFzayA9ICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluLCBtYXggfSA9IFJhbmdlU2VsZWN0b3IuZGVmYXVsdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBuZXcgUmFuZ2VNYXNrKCk7XHJcbiAgICAgICAgICAgIG1hc2sueCA9IHg7XHJcbiAgICAgICAgICAgIG1hc2sueSA9IHk7XHJcbiAgICAgICAgICAgIG1hc2sud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgbWFzay5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIG1hc2subWluID0gbWluO1xyXG4gICAgICAgICAgICBtYXNrLm1heCA9IG1heDtcclxuICAgICAgICAgICAgY29uc3QgeyBtaW5IYW5kbGUsIG1heEhhbmRsZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgbWluSGFuZGxlLmNlbnRlclggPSB4O1xyXG4gICAgICAgICAgICBtYXhIYW5kbGUuY2VudGVyWCA9IHggKyB3aWR0aDtcclxuICAgICAgICAgICAgbWluSGFuZGxlLmNlbnRlclkgPSBtYXhIYW5kbGUuY2VudGVyWSA9IHkgKyBoZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZChbbWFzaywgbWluSGFuZGxlLCBtYXhIYW5kbGVdKTtcclxuICAgICAgICAgICAgbWFzay5vblJhbmdlQ2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVzKCk7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm9uUmFuZ2VDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbWFzaztcclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHRoaXMuX3ggPSBSYW5nZVNlbGVjdG9yLmRlZmF1bHRzLng7XHJcbiAgICAgICAgdGhpcy5feSA9IFJhbmdlU2VsZWN0b3IuZGVmYXVsdHMueTtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IFJhbmdlU2VsZWN0b3IuZGVmYXVsdHMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gUmFuZ2VTZWxlY3Rvci5kZWZhdWx0cy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fbWluID0gUmFuZ2VTZWxlY3Rvci5kZWZhdWx0cy5taW47XHJcbiAgICAgICAgdGhpcy5fbWF4ID0gUmFuZ2VTZWxlY3Rvci5kZWZhdWx0cy5tYXg7XHJcbiAgICAgICAgdGhpcy5pc0NvbnRhaW5lck5vZGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSGFuZGxlcygpIHtcclxuICAgICAgICBjb25zdCB7IG1pbkhhbmRsZSwgbWF4SGFuZGxlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtYXNrIH0gPSB0aGlzO1xyXG4gICAgICAgIG1pbkhhbmRsZS5jZW50ZXJYID0geCArIHdpZHRoICogbWFzay5taW47XHJcbiAgICAgICAgbWF4SGFuZGxlLmNlbnRlclggPSB4ICsgd2lkdGggKiBtYXNrLm1heDtcclxuICAgICAgICBtaW5IYW5kbGUuY2VudGVyWSA9IG1heEhhbmRsZS5jZW50ZXJZID0geSArIGhlaWdodCAvIDI7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlQkJveCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXNrLmNvbXB1dGVCQm94KCk7XHJcbiAgICB9XHJcbiAgICBjb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIocmVuZGVyQ3R4KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09PSBSZWRyYXdUeXBlLk5PTkUgJiYgIWZvcmNlUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0cylcclxuICAgICAgICAgICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCsrO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xyXG4gICAgICAgIHRoaXMubWF0cml4LnRvQ29udGV4dChjdHgpO1xyXG4gICAgICAgIGNvbnN0IHsgbWFzaywgbWluSGFuZGxlLCBtYXhIYW5kbGUgfSA9IHRoaXM7XHJcbiAgICAgICAgW21hc2ssIG1pbkhhbmRsZSwgbWF4SGFuZGxlXS5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQudmlzaWJsZSAmJiAoZm9yY2VSZW5kZXIgfHwgY2hpbGQuZGlydHkgPiBSZWRyYXdUeXBlLk5PTkUpKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQucmVuZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVuZGVyQ3R4KSwgeyBjdHgsIGZvcmNlUmVuZGVyIH0pKTtcclxuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1hcmtDbGVhbih7IGZvcmNlOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmIChzdGF0cylcclxuICAgICAgICAgICAgc3RhdHMubm9kZXNSZW5kZXJlZCsrO1xyXG4gICAgfVxyXG59XHJcblJhbmdlU2VsZWN0b3IuY2xhc3NOYW1lID0gJ1JhbmdlJztcclxuUmFuZ2VTZWxlY3Rvci5kZWZhdWx0cyA9IHtcclxuICAgIHg6IDAsXHJcbiAgICB5OiAwLFxyXG4gICAgd2lkdGg6IDIwMCxcclxuICAgIGhlaWdodDogMzAsXHJcbiAgICBtaW46IDAsXHJcbiAgICBtYXg6IDEsXHJcbn07XG5cbmNsYXNzIE5hdmlnYXRvciBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XHJcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnJzLndpZHRoID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnMud2lkdGg7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ycy5oZWlnaHQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0IG1pbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucnMubWluID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgbWluKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJzLm1pbjtcclxuICAgIH1cclxuICAgIHNldCBtYXgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnJzLm1heCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ycy5tYXg7XHJcbiAgICB9XHJcbiAgICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVHcm91cFZpc2liaWxpdHkoKSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiB0aGlzLnZpc2libGU7XHJcbiAgICAgICAgdGhpcy5ycy52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICBpZiAodmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKCduYXZpZ2F0b3InLCB7XHJcbiAgICAgICAgICAgICAgICB4OiB7IG1pbjogdGhpcy5ycy5taW4sIG1heDogdGhpcy5ycy5tYXggfSxcclxuICAgICAgICAgICAgICAgIHk6IHsgbWluOiAwLCBtYXg6IDEgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKCduYXZpZ2F0b3InKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLnJzID0gbmV3IFJhbmdlU2VsZWN0b3IoKTtcclxuICAgICAgICAvLyBXcmFwcGVycyB0byBhbGxvdyBvcHRpb24gYXBwbGljYXRpb24gdG8gdGhlIHNjZW5lIGdyYXBoIG5vZGVzLlxyXG4gICAgICAgIHRoaXMubWFzayA9IG5ldyBOYXZpZ2F0b3JNYXNrKHRoaXMucnMubWFzayk7XHJcbiAgICAgICAgdGhpcy5taW5IYW5kbGUgPSBuZXcgTmF2aWdhdG9ySGFuZGxlKHRoaXMucnMubWluSGFuZGxlKTtcclxuICAgICAgICB0aGlzLm1heEhhbmRsZSA9IG5ldyBOYXZpZ2F0b3JIYW5kbGUodGhpcy5ycy5tYXhIYW5kbGUpO1xyXG4gICAgICAgIHRoaXMubWluSGFuZGxlRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1heEhhbmRsZURyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wYW5IYW5kbGVPZmZzZXQgPSBOYU47XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSAxMDtcclxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJzLm9uUmFuZ2VDaGFuZ2UgPSAoKSA9PiBjdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbSgnbmF2aWdhdG9yJywge1xyXG4gICAgICAgICAgICB4OiB7IG1pbjogdGhpcy5ycy5taW4sIG1heDogdGhpcy5ycy5tYXggfSxcclxuICAgICAgICAgICAgeTogeyBtaW46IDAsIG1heDogMSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIChfYSA9IGN0eC5zY2VuZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ2hpbGQodGhpcy5ycyk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25PcHRzID0geyBieXBhc3NQYXVzZTogWydhbmltYXRpb24nXSB9O1xyXG4gICAgICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2RyYWctc3RhcnQnLCAoZXZlbnQpID0+IHRoaXMub25EcmFnU3RhcnQoZXZlbnQpLCBpbnRlcmFjdGlvbk9wdHMpLCBjdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKCdkcmFnJywgKGV2ZW50KSA9PiB0aGlzLm9uRHJhZyhldmVudCksIGludGVyYWN0aW9uT3B0cyksIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2hvdmVyJywgKGV2ZW50KSA9PiB0aGlzLm9uRHJhZyhldmVudCksIGludGVyYWN0aW9uT3B0cyksIGN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoJ2RyYWctZW5kJywgKCkgPT4gdGhpcy5vbkRyYWdTdG9wKCksIGludGVyYWN0aW9uT3B0cyksIGN0eC5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKCdiZWZvcmUtc2VyaWVzJywgKGV2ZW50KSA9PiB0aGlzLmxheW91dChldmVudCkpLCBjdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcignbGF5b3V0LWNvbXBsZXRlJywgKGV2ZW50KSA9PiB0aGlzLmxheW91dENvbXBsZXRlKGV2ZW50KSksICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gY3R4LnNjZW5lLnJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZCh0aGlzLnJzKTsgfSwgKCkgPT4gdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbSgnbmF2aWdhdG9yJykpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XHJcbiAgICB9XHJcbiAgICBsYXlvdXQoeyBzaHJpbmtSZWN0IH0pIHtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRvclRvdGFsSGVpZ2h0ID0gdGhpcy5ycy5oZWlnaHQgKyB0aGlzLm1hcmdpbjtcclxuICAgICAgICAgICAgc2hyaW5rUmVjdC5zaHJpbmsobmF2aWdhdG9yVG90YWxIZWlnaHQsICdib3R0b20nKTtcclxuICAgICAgICAgICAgdGhpcy5ycy55ID0gc2hyaW5rUmVjdC55ICsgc2hyaW5rUmVjdC5oZWlnaHQgKyB0aGlzLm1hcmdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2hyaW5rUmVjdCB9O1xyXG4gICAgfVxyXG4gICAgbGF5b3V0Q29tcGxldGUoeyBzZXJpZXM6IHsgcmVjdCwgdmlzaWJsZSB9IH0pIHtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkICYmIHZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5ycy54ID0gcmVjdC54O1xyXG4gICAgICAgICAgICB0aGlzLnJzLndpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgIH1cclxuICAgIG9uRHJhZ1N0YXJ0KG9mZnNldCkge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBvZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeyBycyB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IG1pbkhhbmRsZSwgbWF4SGFuZGxlLCB4LCB3aWR0aCwgbWluIH0gPSBycztcclxuICAgICAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSBycy5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpO1xyXG4gICAgICAgIGlmICghKHRoaXMubWluSGFuZGxlRHJhZ2dpbmcgfHwgdGhpcy5tYXhIYW5kbGVEcmFnZ2luZykpIHtcclxuICAgICAgICAgICAgaWYgKG1pbkhhbmRsZS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbkhhbmRsZURyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtYXhIYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhIYW5kbGVEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmlzaWJsZVJhbmdlLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFuSGFuZGxlT2Zmc2V0ID0gKG9mZnNldFggLSB4KSAvIHdpZHRoIC0gbWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EcmFnKG9mZnNldCkge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBycywgcGFuSGFuZGxlT2Zmc2V0IH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluSGFuZGxlLCBtYXhIYW5kbGUgfSA9IHJzO1xyXG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gb2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IG1pblggPSB4ICsgd2lkdGggKiBycy5taW47XHJcbiAgICAgICAgY29uc3QgbWF4WCA9IHggKyB3aWR0aCAqIHJzLm1heDtcclxuICAgICAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSBuZXcgQkJveChtaW5YLCB5LCBtYXhYIC0gbWluWCwgaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBnZXRSYXRpbyA9ICgpID0+IE1hdGgubWluKE1hdGgubWF4KChvZmZzZXRYIC0geCkgLyB3aWR0aCwgMCksIDEpO1xyXG4gICAgICAgIGlmIChtaW5IYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSB8fCBtYXhIYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcignbmF2aWdhdG9yJywgJ2V3LXJlc2l6ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2aXNpYmxlUmFuZ2UuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcignbmF2aWdhdG9yJywgJ2dyYWInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKCduYXZpZ2F0b3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWluSGFuZGxlRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgcnMubWluID0gZ2V0UmF0aW8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5tYXhIYW5kbGVEcmFnZ2luZykge1xyXG4gICAgICAgICAgICBycy5tYXggPSBnZXRSYXRpbygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaXNOYU4ocGFuSGFuZGxlT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzcGFuID0gcnMubWF4IC0gcnMubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihnZXRSYXRpbygpIC0gcGFuSGFuZGxlT2Zmc2V0LCAxIC0gc3Bhbik7XHJcbiAgICAgICAgICAgIGlmIChtaW4gPD0gcnMubWluKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwYW4gbGVmdFxyXG4gICAgICAgICAgICAgICAgcnMubWluID0gbWluO1xyXG4gICAgICAgICAgICAgICAgcnMubWF4ID0gcnMubWluICsgc3BhbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHBhbiByaWdodFxyXG4gICAgICAgICAgICAgICAgcnMubWF4ID0gbWluICsgc3BhbjtcclxuICAgICAgICAgICAgICAgIHJzLm1pbiA9IHJzLm1heCAtIHNwYW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRyYWdTdG9wKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcEhhbmRsZURyYWdnaW5nKCk7XHJcbiAgICB9XHJcbiAgICBzdG9wSGFuZGxlRHJhZ2dpbmcoKSB7XHJcbiAgICAgICAgdGhpcy5taW5IYW5kbGVEcmFnZ2luZyA9IHRoaXMubWF4SGFuZGxlRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBhbkhhbmRsZU9mZnNldCA9IE5hTjtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIEFjdGlvbk9uU2V0KHtcclxuICAgICAgICBjaGFuZ2VWYWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcblxuY29uc3QgTmF2aWdhdG9yTW9kdWxlID0ge1xyXG4gICAgdHlwZTogJ3Jvb3QnLFxyXG4gICAgb3B0aW9uc0tleTogJ25hdmlnYXRvcicsXHJcbiAgICBwYWNrYWdlVHlwZTogJ2NvbW11bml0eScsXHJcbiAgICBjaGFydFR5cGVzOiBbJ2NhcnRlc2lhbiddLFxyXG4gICAgaW5zdGFuY2VDb25zdHJ1Y3RvcjogTmF2aWdhdG9yLFxyXG4gICAgdGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIG5hdmlnYXRvcjoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICAgICAgbWFzazoge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyM5OTk5OTknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzk5OTk5OScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1pbkhhbmRsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmMmYyZjInLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzk5OTk5OScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA4LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNixcclxuICAgICAgICAgICAgICAgIGdyaXBMaW5lR2FwOiAyLFxyXG4gICAgICAgICAgICAgICAgZ3JpcExpbmVMZW5ndGg6IDgsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1heEhhbmRsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmMmYyZjInLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzk5OTk5OScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA4LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNixcclxuICAgICAgICAgICAgICAgIGdyaXBMaW5lR2FwOiAyLFxyXG4gICAgICAgICAgICAgICAgZ3JpcExpbmVMZW5ndGg6IDgsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbn07XG5cbmNvbnN0IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5ID0gKHsgdGFrZUNvbG9ycyB9KSA9PiB7XHJcbiAgICBjb25zdCB7IGZpbGxzOiBbZmlsbF0sIHN0cm9rZXM6IFtzdHJva2VdLCB9ID0gdGFrZUNvbG9ycygxKTtcclxuICAgIHJldHVybiB7IGZpbGwsIHN0cm9rZSB9O1xyXG59O1xyXG5jb25zdCBtYXJrZXJQYWxldHRlRmFjdG9yeSA9IChwYXJhbXMpID0+IHtcclxuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlIH0gPSBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeShwYXJhbXMpO1xyXG4gICAgcmV0dXJuIHsgbWFya2VyOiB7IGZpbGwsIHN0cm9rZSB9IH07XHJcbn07XG5cbmNvbnN0IEZPTlRfU0laRSA9IHtcclxuICAgIFNNQUxMOiAxMixcclxuICAgIE1FRElVTTogMTMsXHJcbiAgICBMQVJHRTogMTcsXHJcbn07XHJcbmNvbnN0IEJPTEQgPSAnYm9sZCc7XHJcbmNvbnN0IE5PUk1BTCA9ICdub3JtYWwnO1xyXG5jb25zdCBCT1RUT00gPSAnYm90dG9tJztcclxuY29uc3QgTEVGVCA9ICdsZWZ0JztcclxuY29uc3QgVE9QID0gJ3RvcCc7XHJcbmNvbnN0IENBUlRFU0lBTl9BWElTX1BPU0lUSU9OUyA9IHtcclxuICAgIEJPVFRPTSxcclxuICAgIExFRlQsXHJcbiAgICBUT1AsXHJcbn07XHJcbmNvbnN0IENBVEVHT1JZID0gJ2NhdGVnb3J5JztcclxuY29uc3QgTlVNQkVSID0gJ251bWJlcic7XHJcbmNvbnN0IFRJTUUgPSAndGltZSc7XHJcbmNvbnN0IExPRyA9ICdsb2cnO1xyXG5jb25zdCBDQVJURVNJQU5fQVhJU19UWVBFUyA9IHtcclxuICAgIENBVEVHT1JZLFxyXG4gICAgTlVNQkVSLFxyXG4gICAgVElNRSxcclxuICAgIExPRyxcclxufTtcclxuY29uc3QgQU5HTEVfQ0FURUdPUlkgPSAnYW5nbGUtY2F0ZWdvcnknO1xyXG5jb25zdCBBTkdMRV9OVU1CRVIgPSAnYW5nbGUtbnVtYmVyJztcclxuY29uc3QgUkFESVVTX0NBVEVHT1JZID0gJ3JhZGl1cy1jYXRlZ29yeSc7XHJcbmNvbnN0IFJBRElVU19OVU1CRVIgPSAncmFkaXVzLW51bWJlcic7XHJcbmNvbnN0IFBPTEFSX0FYSVNfVFlQRVMgPSB7XHJcbiAgICBBTkdMRV9DQVRFR09SWSxcclxuICAgIEFOR0xFX05VTUJFUixcclxuICAgIFJBRElVU19DQVRFR09SWSxcclxuICAgIFJBRElVU19OVU1CRVIsXHJcbn07XHJcbmNvbnN0IENJUkNMRSA9ICdjaXJjbGUnO1xuXG5jb25zdCBUWVBFUyA9IHt9O1xyXG5jb25zdCBERUZBVUxUUyA9IHt9O1xyXG5jb25zdCBDSEFSVF9UWVBFUyA9IHtcclxuICAgIGhhcyhzZXJpZXNUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChUWVBFUywgc2VyaWVzVHlwZSk7XHJcbiAgICB9LFxyXG4gICAgaXNDYXJ0ZXNpYW4oc2VyaWVzVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBUWVBFU1tzZXJpZXNUeXBlXSA9PT0gJ2NhcnRlc2lhbic7XHJcbiAgICB9LFxyXG4gICAgaXNQb2xhcihzZXJpZXNUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIFRZUEVTW3Nlcmllc1R5cGVdID09PSAncG9sYXInO1xyXG4gICAgfSxcclxuICAgIGlzSGllcmFyY2h5KHNlcmllc1R5cGUpIHtcclxuICAgICAgICByZXR1cm4gVFlQRVNbc2VyaWVzVHlwZV0gPT09ICdoaWVyYXJjaHknO1xyXG4gICAgfSxcclxuICAgIGdldCBzZXJpZXNUeXBlcygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoVFlQRVMpO1xyXG4gICAgfSxcclxuICAgIGdldCBjYXJ0ZXNpYW5UeXBlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNDYXJ0ZXNpYW4odCkpO1xyXG4gICAgfSxcclxuICAgIGdldCBwb2xhclR5cGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc1BvbGFyKHQpKTtcclxuICAgIH0sXHJcbiAgICBnZXQgaGllcmFyY2h5VHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzSGllcmFyY2h5KHQpKTtcclxuICAgIH0sXHJcbn07XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhcnRTZXJpZXNUeXBlKHNlcmllc1R5cGUsIGNoYXJ0VHlwZSkge1xyXG4gICAgVFlQRVNbc2VyaWVzVHlwZV0gPSBjaGFydFR5cGU7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJDaGFydERlZmF1bHRzKGNoYXJ0VHlwZSwgZGVmYXVsdHMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIERFRkFVTFRTW2NoYXJ0VHlwZV0gPSBqc29uTWVyZ2UoWyhfYSA9IERFRkFVTFRTW2NoYXJ0VHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCBkZWZhdWx0c10pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENoYXJ0RGVmYXVsdHMoY2hhcnRUeXBlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gREVGQVVMVFNbY2hhcnRUeXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2hhcnRUeXBlKHNlcmllc1R5cGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoX2EgPSBUWVBFU1tzZXJpZXNUeXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3Vua25vd24nO1xyXG59XG5cbmZ1bmN0aW9uIG9wdGlvbnNUeXBlKGlucHV0KSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICByZXR1cm4gKF9kID0gKF9hID0gaW5wdXQudHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gaW5wdXQuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnbGluZSc7XHJcbn1cclxuZnVuY3Rpb24gaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhpbnB1dCkge1xyXG4gICAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcclxuICAgIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChzcGVjaWZpZWRUeXBlID09PSAnY2FydGVzaWFuJykge1xyXG4gICAgICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENIQVJUX1RZUEVTLmlzQ2FydGVzaWFuKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZUNhcnRlc2lhbihzcGVjaWZpZWRUeXBlKTtcclxufVxyXG5mdW5jdGlvbiBpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKGlucHV0KSB7XHJcbiAgICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xyXG4gICAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChzcGVjaWZpZWRUeXBlID09PSAnaGllcmFyY2h5Jykge1xyXG4gICAgICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENIQVJUX1RZUEVTLmlzSGllcmFyY2h5KHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZUhpZXJhcmNoeShzcGVjaWZpZWRUeXBlKTtcclxufVxyXG5mdW5jdGlvbiBpc0FnUG9sYXJDaGFydE9wdGlvbnMoaW5wdXQpIHtcclxuICAgIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XHJcbiAgICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNwZWNpZmllZFR5cGUgPT09ICdwb2xhcicpIHtcclxuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBDSEFSVF9UWVBFUy5pc1BvbGFyKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZVBvbGFyKHNwZWNpZmllZFR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2VyaWVzT3B0aW9uVHlwZShpbnB1dCkge1xyXG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ0hBUlRfVFlQRVMuaGFzKGlucHV0KTtcclxufVxyXG5mdW5jdGlvbiBpc0F4aXNPcHRpb25UeXBlKGlucHV0KSB7XHJcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBBWElTX1RZUEVTLmhhcyhpbnB1dCk7XHJcbn1cblxuY29uc3QgREVGQVVMVF9DQVJURVNJQU5fQ0hBUlRfT1ZFUlJJREVTID0ge1xyXG4gICAgYXhlczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogQ0FSVEVTSUFOX0FYSVNfVFlQRVMuTlVNQkVSLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogQ0FSVEVTSUFOX0FYSVNfUE9TSVRJT05TLkxFRlQsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IENBUlRFU0lBTl9BWElTX1RZUEVTLkNBVEVHT1JZLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogQ0FSVEVTSUFOX0FYSVNfUE9TSVRJT05TLkJPVFRPTSxcclxuICAgICAgICB9LFxyXG4gICAgXSxcclxufTtcclxuZnVuY3Rpb24gc3dhcEF4ZXMob3B0cykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKCFpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCBbYXhpczAsIGF4aXMxXSA9IChfYSA9IG9wdHMuYXhlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBheGVzOiBbXHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXhpczApLCB7IHBvc2l0aW9uOiBheGlzMS5wb3NpdGlvbiB9KSxcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBheGlzMSksIHsgcG9zaXRpb246IGF4aXMwLnBvc2l0aW9uIH0pLFxyXG4gICAgICAgIF0gfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZUNvbmZsaWN0cyhvcHRzKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBjb25zdCBjb25mbGljdE92ZXJyaWRlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBbc291cmNlLCBjb25mbGljdHNdIG9mIE1PRFVMRV9DT05GTElDVFMuZW50cmllcygpKSB7XHJcbiAgICAgICAgaWYgKG9wdHNbc291cmNlXSA9PSBudWxsIHx8ICFjb25mbGljdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2EgPSBjb25mbGljdE92ZXJyaWRlc1tzb3VyY2VdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY29uZmxpY3RPdmVycmlkZXNbc291cmNlXSA9IHt9KTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbmZsaWN0IG9mIGNvbmZsaWN0cykge1xyXG4gICAgICAgICAgICBpZiAoKChfYiA9IG9wdHNbc291cmNlXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVuYWJsZWQpICYmICgoX2MgPSBvcHRzW2NvbmZsaWN0XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVuYWJsZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSBbJHtzb3VyY2V9XSBtb2R1bGUgY2FuIG5vdCBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUgYXMgWyR7Y29uZmxpY3R9XSwgaXQgd2lsbCBiZSBkaXNhYmxlZC5gKTtcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0T3ZlcnJpZGVzW3NvdXJjZV0uZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmxpY3RPdmVycmlkZXNbc291cmNlXS5lbmFibGVkID0gKF9kID0gb3B0c1tzb3VyY2VdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZW5hYmxlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjb25mbGljdE92ZXJyaWRlcztcclxufVxuXG5jb25zdCBFWFRFTkRTX0NIQVJUX0RFRkFVTFRTID0gU3ltYm9sKCdleHRlbmRzLWNoYXJ0LWRlZmF1bHRzJyk7XHJcbmNvbnN0IEVYVEVORFNfTEVHRU5EX0RFRkFVTFRTID0gU3ltYm9sKCdleHRlbmRzLWxlZ2VuZC1kZWZhdWx0cycpO1xyXG5jb25zdCBFWFRFTkRTX0xFR0VORF9JVEVNX0RFRkFVTFRTID0gU3ltYm9sKCdleHRlbmRzLWxlZ2VuZC1pdGVtLWRlZmF1bHRzJyk7XHJcbmNvbnN0IEVYVEVORFNfTEVHRU5EX0lURU1fTUFSS0VSX0RFRkFVTFRTID0gU3ltYm9sKCdleHRlbmRzLWxlZ2VuZC1pdGVtLW1hcmtlci1kZWZhdWx0cycpO1xyXG5jb25zdCBFWFRFTkRTX0FYRVNfREVGQVVMVFMgPSBTeW1ib2woJ2V4dGVuZHMtYXhlcy1kZWZhdWx0cycpO1xyXG5jb25zdCBFWFRFTkRTX0FYRVNfTEFCRUxfREVGQVVMVFMgPSBTeW1ib2woJ2V4dGVuZHMtYXhlcy1sYWJlbC1kZWZhdWx0cycpO1xyXG5jb25zdCBFWFRFTkRTX0FYRVNfTElORV9ERUZBVUxUUyA9IFN5bWJvbCgnZXh0ZW5kcy1heGVzLWxpbmUtZGVmYXVsdHMnKTtcclxuY29uc3QgRVhURU5EU19BWEVTX1RJQ0tfREVGQVVMVFMgPSBTeW1ib2woJ2V4dGVuZHMtYXhlcy10aWNrLWRlZmF1bHRzJyk7XHJcbmNvbnN0IEVYVEVORFNfQVhFU19HUklEX0xJTkVfREVGQVVMVFMgPSBTeW1ib2woJ2V4dGVuZHMtYXhlcy1ncmlkLWxpbmUtZGVmYXVsdHMnKTtcclxuY29uc3QgRVhURU5EU19TRVJJRVNfREVGQVVMVFMgPSBTeW1ib2woJ2V4dGVuZHMtc2VyaWVzLWRlZmF1bHRzJyk7XHJcbmNvbnN0IEVYVEVORFNfQ0FSVEVTSUFOX01BUktFUl9ERUZBVUxUUyA9IFN5bWJvbCgnZXh0ZW5kcy1jYXJ0ZXNpYW4tbWFya2VyLWRlZmF1bHRzJyk7XHJcbmNvbnN0IE9WRVJSSURFX1NFUklFU19MQUJFTF9ERUZBVUxUUyA9IFN5bWJvbCgnb3ZlcnJpZGUtc2VyaWVzLWxhYmVsLWRlZmF1bHRzJyk7XHJcbmNvbnN0IERFRkFVTFRfRk9OVF9GQU1JTFkgPSBTeW1ib2woJ2RlZmF1bHQtZm9udCcpO1xyXG5jb25zdCBERUZBVUxUX0xBQkVMX0NPTE9VUiA9IFN5bWJvbCgnZGVmYXVsdC1sYWJlbC1jb2xvdXInKTtcclxuY29uc3QgREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVIgPSBTeW1ib2woJ2RlZmF1bHQtaW52ZXJ0ZWQtbGFiZWwtY29sb3VyJyk7XHJcbmNvbnN0IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIgPSBTeW1ib2woJ2RlZmF1bHQtaW5zaWRlLXNlcmllcy1sYWJlbC1jb2xvdXInKTtcclxuY29uc3QgREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIgPSBTeW1ib2woJ2RlZmF1bHQtbXV0ZWQtbGFiZWwtY29sb3VyJyk7XHJcbmNvbnN0IERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiA9IFN5bWJvbCgnZGVmYXVsdC1heGlzLWdyaWQtY29sb3VyJyk7XHJcbmNvbnN0IERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUiA9IFN5bWJvbCgnZGVmYXVsdC1heGlzLWxpbmUtY29sb3VyJyk7XHJcbmNvbnN0IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSID0gU3ltYm9sKCdkZWZhdWx0LWNyb3NzLWxpbmVzLWNvbG91cicpO1xyXG5jb25zdCBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSID0gU3ltYm9sKCdkZWZhdWx0LWJhY2tncm91bmQtY29sb3VyJyk7XHJcbmNvbnN0IERFRkFVTFRfU0hBRE9XX0NPTE9VUiA9IFN5bWJvbCgnZGVmYXVsdC1zaGFkb3ctY29sb3VyJyk7XHJcbmNvbnN0IERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19QT1NJVElWRV9DT0xPVVJTID0gU3ltYm9sKCdkZWZhdWx0LXdhdGVyZmFsbC1zZXJpZXMtcG9zaXRpdmUtY29sb3JzJyk7XHJcbmNvbnN0IERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19ORUdBVElWRV9DT0xPVVJTID0gU3ltYm9sKCdkZWZhdWx0LXdhdGVyZmFsbC1zZXJpZXMtbmVnYXRpdmUtY29sb3JzJyk7XHJcbmNvbnN0IERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19UT1RBTF9DT0xPVVJTID0gU3ltYm9sKCdkZWZhdWx0LXdhdGVyZmFsbC1zZXJpZXMtdG90YWwtY29sb3JzJyk7XHJcbmNvbnN0IERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19DT05ORUNUT1JfTElORV9TVFJPS0UgPSBTeW1ib2woJ2RlZmF1bHQtd2F0ZXJmYWxsLXNlcmllcy1jb25uZWN0b3ItbGluZS1zdHJva2UnKTtcclxuY29uc3QgREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFID0gU3ltYm9sKCdkZWZhdWx0LXBvbGFyLXNlcmllcy1zdHJva2UnKTtcclxuY29uc3QgREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSA9IFN5bWJvbCgnZGVmYXVsdC1kaXZlcmdpbmctc2VyaWVzLWNvbG91ci1yYW5nZScpO1xyXG5jb25zdCBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUyA9IFN5bWJvbCgnZGVmYXVsdC1oaWVyYXJjaHktZmlsbHMnKTtcclxuY29uc3QgREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUyA9IFN5bWJvbCgnZGVmYXVsdC1oaWVyYXJjaHktc3Ryb2tlcycpO1xuXG4vKipcclxuICogSW1wbGVtZW50cyBhIHBlci1wYXRoIFwidG8vZnJvbVwiIGFuaW1hdGlvbi5cclxuICpcclxuICogQHBhcmFtIGlkIHByZWZpeCBmb3IgYWxsIGFuaW1hdGlvbiBpZHMgZ2VuZXJhdGVkIGJ5IHRoaXMgY2FsbFxyXG4gKiBAcGFyYW0gYW5pbWF0aW9uTWFuYWdlciB1c2VkIHRvIHNjaGVkdWxlIGdlbmVyYXRlZCBhbmltYXRpb25zXHJcbiAqIEBwYXJhbSBwYXRocyBjb250YWlucyBwYXRocyB0byBiZSBhbmltYXRlZFxyXG4gKiBAcGFyYW0gaW50ZXJtZWRpYXRlRm4gY2FsbGJhY2sgdG8gdXBkYXRlIHBhdGhcclxuICogQHBhcmFtIGV4dHJhT3B0cyBvcHRpb25hbCBhZGRpdGlvbmFsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gQW5pbWF0aW9uTWFuYWdlciNhbmltYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aE1vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgcGF0aHMsIGZucykge1xyXG4gICAgY29uc3QgeyBkZWZhdWx0RHVyYXRpb24gfSA9IGFuaW1hdGlvbk1hbmFnZXI7XHJcbiAgICBjb25zdCB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSA9IGZucztcclxuICAgIGNvbnN0IGFuaW1hdGUgPSAocGhhc2UsIHBhdGgsIHVwZGF0ZUZuKSA9PiB7XHJcbiAgICAgICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcclxuICAgICAgICAgICAgaWQ6IGAke2dyb3VwSWR9XyR7c3ViSWR9XyR7cGF0aC5pZH1fJHtwaGFzZX1gLFxyXG4gICAgICAgICAgICBncm91cElkLFxyXG4gICAgICAgICAgICBmcm9tOiAwLFxyXG4gICAgICAgICAgICB0bzogMSxcclxuICAgICAgICAgICAgZWFzZTogZWFzZU91dCxcclxuICAgICAgICAgICAgb25VcGRhdGUocmF0aW8sIHByZUluaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVJbml0ICYmIHBoYXNlICE9PSAncmVtb3ZlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgcGF0aC5wYXRoLmNsZWFyKHsgdHJhY2tDaGFuZ2VzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRm4ocmF0aW8sIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcGF0aC5jaGVja1BhdGhEaXJ0eSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblN0b3AoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGhhc2UgIT09ICdhZGRlZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgcGF0aC5wYXRoLmNsZWFyKHsgdHJhY2tDaGFuZ2VzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRm4oMSwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICBwYXRoLmNoZWNrUGF0aERpcnR5KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBGUk9NX1RPX01JWElOU1twaGFzZV0uYW5pbWF0aW9uRHVyYXRpb24gKiBkZWZhdWx0RHVyYXRpb24sXHJcbiAgICAgICAgICAgIGRlbGF5OiBGUk9NX1RPX01JWElOU1twaGFzZV0uYW5pbWF0aW9uRGVsYXkgKiBkZWZhdWx0RHVyYXRpb24sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XHJcbiAgICAgICAgaWYgKCFhbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdGUoJ3JlbW92ZWQnLCBwYXRoLCByZW1vdmVQaGFzZUZuKTtcclxuICAgICAgICAgICAgYW5pbWF0ZSgndXBkYXRlZCcsIHBhdGgsIHVwZGF0ZVBoYXNlRm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbmltYXRlKCdhZGRlZCcsIHBhdGgsIGFkZFBoYXNlRm4pO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IE1BUktFUl9TSEFQRSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiBpc01hcmtlclNoYXBlKHYpIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih2KSA9PT0gTWFya2VyLCBgZXhwZWN0aW5nIGEgbWFya2VyIHNoYXBlIGtleXdvcmQgc3VjaCBhcyAnY2lyY2xlJywgJ2RpYW1vbmQnIG9yICdzcXVhcmUnIG9yIGFuIG9iamVjdCBleHRlbmRpbmcgdGhlIE1hcmtlciBjbGFzc2ApO1xyXG5jbGFzcyBTZXJpZXNNYXJrZXIgZXh0ZW5kcyBDaGFuZ2VEZXRlY3RhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAvKiogT25lIG9mIHRoZSBwcmVkZWZpbmVkIG1hcmtlciBuYW1lcywgb3IgYSBtYXJrZXIgY29uc3RydWN0b3IgZnVuY3Rpb24gKGZvciB1c2VyLWRlZmluZWQgbWFya2VycykuICovXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IENpcmNsZTtcclxuICAgICAgICB0aGlzLnNpemUgPSA2O1xyXG4gICAgICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XHJcbiAgICB9XHJcbiAgICBnZXRTdHlsZSgpIHtcclxuICAgICAgICBjb25zdCB7IHNpemUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH0gPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB7IHNpemUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH07XHJcbiAgICB9XHJcbiAgICBnZXREaWFtZXRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplICsgdGhpcy5zdHJva2VXaWR0aDtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKEJPT0xFQU4pLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShNQVJLRVJfU0hBUEUpLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInNoYXBlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwLCAxKSksXHJcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogUmVkcmF3VHlwZS5NQUpPUiB9KSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKDApKSxcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCwgMSkpLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfRlVOQ1RJT04pLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZm9ybWF0dGVyXCIsIHZvaWQgMCk7XG5cbmZ1bmN0aW9uIG1hcmtlckZhZGVJbkFuaW1hdGlvbih7IGlkIH0sIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHN0YXR1cyA9ICd1bmtub3duJykge1xyXG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgRlJPTV9UT19NSVhJTlNbc3RhdHVzXSk7XHJcbiAgICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsICdtYXJrZXJzJywgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9ucywgeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9LCBwYXJhbXMpO1xyXG4gICAgbWFya2VyU2VsZWN0aW9ucy5mb3JFYWNoKChzKSA9PiBzLmNsZWFudXAoKSk7XHJcbn1cclxuZnVuY3Rpb24gbWFya2VyU2NhbGVJbkFuaW1hdGlvbih7IGlkIH0sIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMpIHtcclxuICAgIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgJ21hcmtlcnMnLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb25zLCB7IHNjYWxpbmdYOiAwLCBzY2FsaW5nWTogMCB9LCB7IHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9KTtcclxuICAgIG1hcmtlclNlbGVjdGlvbnMuZm9yRWFjaCgocykgPT4gcy5jbGVhbnVwKCkpO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbih7IGlkIH0sIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHNlcmllc1dpZHRoKSB7XHJcbiAgICAvLyBJbXByb3ZlcyBjb25zaXN0ZW5jeSB3aXRoIG1hdGNoaW5nIHBhcmFsbGVsIGFuaW1hdGlvbnMuXHJcbiAgICBjb25zdCB0d2Vha0ZhY3RvciA9IDAuMTtcclxuICAgIGNvbnN0IGZyb21GbiA9IChfLCBkYXR1bSkgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgeCA9IChfYiA9IChfYSA9IGRhdHVtLm1pZFBvaW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogc2VyaWVzV2lkdGg7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGEgZGVsYXkgdGhhdCBkZXBlbmRzIG9uIHRoZSBYIHBvc2l0aW9uIG9mIHRoZSBkYXR1bSwgc28gdGhhdCBub2RlcyBhcHBlYXJcclxuICAgICAgICAvLyBncmFkdWFsbHkgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBVc2UgZWFzZUluT3V0IHRvIG1hdGNoIGFueSBwYXJhbGxlbCBzd2lwZSBhbmltYXRpb25zLlxyXG4gICAgICAgIGNvbnN0IGRlbGF5UmF0aW8gPSBlYXNlSW5PdXQoeCAvIHNlcmllc1dpZHRoKSAtIHR3ZWFrRmFjdG9yO1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5tYXgoTWF0aC5taW4oZGVsYXlSYXRpbywgMSksIDApO1xyXG4gICAgICAgIHJldHVybiB7IHNjYWxpbmdYOiAwLCBzY2FsaW5nWTogMCwgYW5pbWF0aW9uRGVsYXk6IGRlbGF5LCBhbmltYXRpb25EdXJhdGlvbjogUVVJQ0tfVFJBTlNJVElPTiB9O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHRvRm4gPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHsgc2NhbGluZ1g6IDEsIHNjYWxpbmdZOiAxIH07XHJcbiAgICB9O1xyXG4gICAgZnJvbVRvTW90aW9uKGlkLCAnbWFya2VycycsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHsgZnJvbUZuLCB0b0ZuIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0TWFya2VyRm4oX25vZGUpIHtcclxuICAgIHJldHVybiB7IG9wYWNpdHk6IDEsIHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0TWFya2VyUG9zaXRpb25Gbihfbm9kZSwgZGF0dW0pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHJhbnNsYXRpb25YOiAoX2IgPSAoX2EgPSBkYXR1bS5wb2ludCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLngpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE5hTixcclxuICAgICAgICB0cmFuc2xhdGlvblk6IChfZCA9IChfYyA9IGRhdHVtLnBvaW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogTmFOLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlTWFya2VyQW5pbWF0aW9uKHBhaXJNYXAsIHBhcmVudFN0YXR1cykge1xyXG4gICAgY29uc3QgcmVhZEZpcnN0UGFpciA9ICh4VmFsdWUsIHR5cGUpID0+IHtcclxuICAgICAgICBjb25zdCB2YWwgPSBwYWlyTWFwW3R5cGVdW3hWYWx1ZV07XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFswXSA6IHZhbDtcclxuICAgIH07XHJcbiAgICBjb25zdCBtYXJrZXJTdGF0dXMgPSAoZGF0dW0pID0+IHtcclxuICAgICAgICBjb25zdCB7IHhWYWx1ZSB9ID0gZGF0dW07XHJcbiAgICAgICAgaWYgKHBhaXJNYXAubW92ZWRbeFZhbHVlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBwb2ludDogcmVhZEZpcnN0UGFpcih4VmFsdWUsICdtb3ZlZCcpLCBzdGF0dXM6ICd1cGRhdGVkJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYWlyTWFwLnJlbW92ZWRbeFZhbHVlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBwb2ludDogcmVhZEZpcnN0UGFpcih4VmFsdWUsICdyZW1vdmVkJyksIHN0YXR1czogJ3JlbW92ZWQnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhaXJNYXAuYWRkZWRbeFZhbHVlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBwb2ludDogcmVhZEZpcnN0UGFpcih4VmFsdWUsICdhZGRlZCcpLCBzdGF0dXM6ICdhZGRlZCcgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAndW5rbm93bicgfTtcclxuICAgIH07XHJcbiAgICBjb25zdCBmcm9tRm4gPSAobWFya2VyLCBkYXR1bSkgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBwb2ludCB9ID0gbWFya2VyU3RhdHVzKGRhdHVtKTtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAndW5rbm93bicpXHJcbiAgICAgICAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAgfTtcclxuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oeyB0cmFuc2xhdGlvblg6IChfYiA9IChfYSA9IHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludC5mcm9tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbWFya2VyLnRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZOiAoX2QgPSAoX2MgPSBwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnQuZnJvbSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG1hcmtlci50cmFuc2xhdGlvblksIG9wYWNpdHk6IG1hcmtlci5vcGFjaXR5IH0sIEZST01fVE9fTUlYSU5TW3N0YXR1c10pO1xyXG4gICAgICAgIGlmIChwYXJlbnRTdGF0dXMgPT09ICdhZGRlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIHsgb3BhY2l0eTogMCwgdHJhbnNsYXRpb25YOiAoX2UgPSBwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnQudG8pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS54LCB0cmFuc2xhdGlvblk6IChfZiA9IHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludC50bykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnkgfSksIEZST01fVE9fTUlYSU5TWydhZGRlZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2FkZGVkJykge1xyXG4gICAgICAgICAgICBkZWZhdWx0cy5vcGFjaXR5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHRvRm4gPSAoX21hcmtlciwgZGF0dW0pID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBwb2ludCB9ID0gbWFya2VyU3RhdHVzKGRhdHVtKTtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAndW5rbm93bicpXHJcbiAgICAgICAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAgfTtcclxuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oeyB0cmFuc2xhdGlvblg6IGRhdHVtLnBvaW50LngsIHRyYW5zbGF0aW9uWTogZGF0dW0ucG9pbnQueSwgb3BhY2l0eTogMSB9LCBGUk9NX1RPX01JWElOU1tzdGF0dXNdKTtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAncmVtb3ZlZCcgfHwgcGFyZW50U3RhdHVzID09PSAncmVtb3ZlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyksIHsgdHJhbnNsYXRpb25YOiAoX2EgPSBwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnQudG8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS54LCB0cmFuc2xhdGlvblk6IChfYiA9IHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2ludC50bykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnksIG9wYWNpdHk6IDAgfSksIEZST01fVE9fTUlYSU5TWydyZW1vdmVkJ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHsgZnJvbUZuLCB0b0ZuIH07XHJcbn1cblxuZnVuY3Rpb24gbWluTWF4KG5vZGVEYXRhKSB7XHJcbiAgICByZXR1cm4gbm9kZURhdGEucmVkdWNlKCh7IG1pbiwgbWF4IH0sIG5vZGUpID0+IHtcclxuICAgICAgICBpZiAobWluID09IG51bGwgfHwgbWluLnBvaW50LnggPiBub2RlLnBvaW50LngpIHtcclxuICAgICAgICAgICAgbWluID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heCA9PSBudWxsIHx8IG1heC5wb2ludC54IDwgbm9kZS5wb2ludC54KSB7XHJcbiAgICAgICAgICAgIG1heCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IG1pbiwgbWF4IH07XHJcbiAgICB9LCB7fSk7XHJcbn1cclxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uT25MaW5lKGEsIGIsIHRhcmdldFgpIHtcclxuICAgIGNvbnN0IG0gPSAoYi55IC0gYS55KSAvIChiLnggLSBhLngpO1xyXG4gICAgLy8gRmluZCBhIHBvaW50IGEgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUgZnJvbSBgYWAgYW5kIGBiYFxyXG4gICAgY29uc3QgeSA9ICh0YXJnZXRYIC0gYS54KSAqIG0gKyBhLnk7XHJcbiAgICByZXR1cm4geyB4OiB0YXJnZXRYLCB5IH07XHJcbn1cclxuZnVuY3Rpb24gYmFja2ZpbGxQYXRoUG9pbnQocmVzdWx0cywgcHJvY2Vzcywgc2tpcCwgcHJvY2Vzc0ZuKSB7XHJcbiAgICBsZXQgcHJldk1hcmtlcklkeCA9IC0xLCBuZXh0TWFya2VySWR4ID0gMDtcclxuICAgIGNvbnN0IHRvUHJvY2VzcyA9IFtdO1xyXG4gICAgd2hpbGUgKG5leHRNYXJrZXJJZHggPCByZXN1bHRzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChyZXN1bHRzW25leHRNYXJrZXJJZHhdLmNoYW5nZSA9PT0gcHJvY2Vzcykge1xyXG4gICAgICAgICAgICB0b1Byb2Nlc3MucHVzaChyZXN1bHRzW25leHRNYXJrZXJJZHhdKTtcclxuICAgICAgICAgICAgbmV4dE1hcmtlcklkeCsrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdHNbbmV4dE1hcmtlcklkeF0uY2hhbmdlID09PSBza2lwKSB7XHJcbiAgICAgICAgICAgIG5leHRNYXJrZXJJZHgrKztcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b1Byb2Nlc3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzRm4odG9Qcm9jZXNzLCBwcmV2TWFya2VySWR4LCBuZXh0TWFya2VySWR4KTtcclxuICAgICAgICAgICAgdG9Qcm9jZXNzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZNYXJrZXJJZHggPSBuZXh0TWFya2VySWR4O1xyXG4gICAgICAgIG5leHRNYXJrZXJJZHgrKztcclxuICAgIH1cclxuICAgIGlmICh0b1Byb2Nlc3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHByb2Nlc3NGbih0b1Byb2Nlc3MsIHByZXZNYXJrZXJJZHgsIG5leHRNYXJrZXJJZHgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJhY2tmaWxsUGF0aFBvaW50RGF0YShyZXN1bHQsIHNwbGl0TW9kZSkge1xyXG4gICAgYmFja2ZpbGxQYXRoUG9pbnQocmVzdWx0LCAnb3V0JywgJ2luJywgKHRvUHJvY2Vzcywgc0lkeCwgZUlkeCkgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHNJZHggPT09IC0xICYmIHJlc3VsdFtlSWR4XSkge1xyXG4gICAgICAgICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gKGQudG8gPSByZXN1bHRbZUlkeF0uZnJvbSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlSWR4ID09PSByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzSWR4XSkge1xyXG4gICAgICAgICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gKGQudG8gPSByZXN1bHRbc0lkeF0uZnJvbSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzcGxpdE1vZGUgPT09ICdpbnRlcnNlY3QnICYmICgoX2EgPSByZXN1bHRbc0lkeF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAmJiAoKF9iID0gcmVzdWx0W2VJZHhdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZnJvbSkpIHtcclxuICAgICAgICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IChkLnRvID0gaW50ZXJzZWN0aW9uT25MaW5lKHJlc3VsdFtzSWR4XS5mcm9tLCByZXN1bHRbZUlkeF0uZnJvbSwgZC5mcm9tLngpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gKGQudG8gPSBkLmZyb20pKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGJhY2tmaWxsUGF0aFBvaW50KHJlc3VsdCwgJ2luJywgJ291dCcsICh0b1Byb2Nlc3MsIHNJZHgsIGVJZHgpID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmIChzSWR4ID09PSAtMSAmJiByZXN1bHRbZUlkeF0pIHtcclxuICAgICAgICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IChkLmZyb20gPSByZXN1bHRbZUlkeF0udG8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZUlkeCA9PT0gcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc0lkeF0pIHtcclxuICAgICAgICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IChkLmZyb20gPSByZXN1bHRbc0lkeF0udG8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3BsaXRNb2RlID09PSAnaW50ZXJzZWN0JyAmJiAoKF9hID0gcmVzdWx0W3NJZHhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG8pICYmICgoX2IgPSByZXN1bHRbZUlkeF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50bykpIHtcclxuICAgICAgICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IChkLmZyb20gPSBpbnRlcnNlY3Rpb25PbkxpbmUocmVzdWx0W3NJZHhdLnRvLCByZXN1bHRbZUlkeF0udG8sIGQudG8ueCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiAoZC5mcm9tID0gZC50bykpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvaW50KGZyb20sIHRvLCByYXRpbykge1xyXG4gICAgY29uc3QgeDEgPSBpc05hTihmcm9tLngpID8gdG8ueCA6IGZyb20ueDtcclxuICAgIGNvbnN0IHkxID0gaXNOYU4oZnJvbS55KSA/IHRvLnkgOiBmcm9tLnk7XHJcbiAgICBjb25zdCB4ZCA9IHRvLnggLSBmcm9tLng7XHJcbiAgICBjb25zdCB5ZCA9IHRvLnkgLSBmcm9tLnk7XHJcbiAgICBjb25zdCB4ciA9IGlzTmFOKHhkKSA/IDAgOiB4ZCAqIHJhdGlvO1xyXG4gICAgY29uc3QgeXIgPSBpc05hTih5ZCkgPyAwIDogeWQgKiByYXRpbztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogeDEgKyB4cixcclxuICAgICAgICB5OiB5MSArIHlyLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJQYXJ0aWFsUGF0aChwYWlyRGF0YSwgcmF0aW9zLCBwYXRoKSB7XHJcbiAgICBjb25zdCB7IHBhdGg6IGxpbmVQYXRoIH0gPSBwYXRoO1xyXG4gICAgbGV0IHByZXZpb3VzVG87XHJcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgcGFpckRhdGEpIHtcclxuICAgICAgICBjb25zdCByYXRpbyA9IHJhdGlvc1tkYXRhLmNoYW5nZV07XHJcbiAgICAgICAgaWYgKHJhdGlvID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IGRhdGE7XHJcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCB8fCB0byA9PSBudWxsKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGNhbGN1bGF0ZVBvaW50KGZyb20sIHRvLCByYXRpbyk7XHJcbiAgICAgICAgaWYgKGRhdGEubW92ZVRvID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBsaW5lUGF0aC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEubW92ZVRvID09PSB0cnVlIHx8ICFwcmV2aW91c1RvKSB7XHJcbiAgICAgICAgICAgIGxpbmVQYXRoLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNUbykge1xyXG4gICAgICAgICAgICBjb25zdCBtb3ZlVG9SYXRpbyA9IGRhdGEubW92ZVRvID09PSAnaW4nID8gcmF0aW8gOiAxIC0gcmF0aW87XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeDogbWlkUG9pbnRYLCB5OiBtaWRQb2ludFkgfSA9IGNhbGN1bGF0ZVBvaW50KHByZXZpb3VzVG8sIHsgeCwgeSB9LCBtb3ZlVG9SYXRpbyk7XHJcbiAgICAgICAgICAgIGxpbmVQYXRoLmxpbmVUbyhtaWRQb2ludFgsIG1pZFBvaW50WSk7XHJcbiAgICAgICAgICAgIGxpbmVQYXRoLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNUbyA9IHsgeCwgeSB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGhTd2lwZUluQW5pbWF0aW9uKHsgaWQgfSwgYW5pbWF0aW9uTWFuYWdlciwgcGF0aHMpIHtcclxuICAgIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgJ3BhdGhfcHJvcGVydGllcycsIGFuaW1hdGlvbk1hbmFnZXIsIHBhdGhzLCB7IGNsaXBTY2FsaW5nWDogMCB9LCB7IGNsaXBTY2FsaW5nWDogMSB9LCB7XHJcbiAgICAgICAgc3RhcnQ6IHsgY2xpcE1vZGU6ICdub3JtYWwnIH0sXHJcbiAgICAgICAgZmluaXNoOiB7IGNsaXBNb2RlOiB1bmRlZmluZWQgfSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhGYWRlSW5BbmltYXRpb24oeyBpZCB9LCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uKSB7XHJcbiAgICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb24sIHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSwgTEFCRUxfUEhBU0UpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhGYWRlT3V0QW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbikge1xyXG4gICAgc3RhdGljRnJvbVRvTW90aW9uKGlkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uLCB7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0sIExBQkVMX1BIQVNFKTtcclxufVxyXG5mdW5jdGlvbiBidWlsZFJlc2V0UGF0aEZuKG9wdHMpIHtcclxuICAgIHJldHVybiAoX25vZGUpID0+IHtcclxuICAgICAgICByZXR1cm4geyBvcGFjaXR5OiBvcHRzLmdldE9wYWNpdHkoKSwgY2xpcFNjYWxpbmdYOiAxLCBjbGlwTW9kZTogdW5kZWZpbmVkIH07XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIHNjYWxlKHZhbCwgc2NhbGluZykge1xyXG4gICAgaWYgKCFzY2FsaW5nKVxyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgIHZhbCA9IHZhbC5nZXRUaW1lKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2NhbGluZy50eXBlID09PSAnY29udGludW91cycgJiYgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBjb25zdCBkb21haW5SYXRpbyA9ICh2YWwgLSBzY2FsaW5nLmRvbWFpblswXSkgLyAoc2NhbGluZy5kb21haW5bMV0gLSBzY2FsaW5nLmRvbWFpblswXSk7XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpblJhdGlvICogKHNjYWxpbmcucmFuZ2VbMV0gLSBzY2FsaW5nLnJhbmdlWzBdKSArIHNjYWxpbmcucmFuZ2VbMF07XHJcbiAgICB9XHJcbiAgICBpZiAoc2NhbGluZy50eXBlID09PSAnbG9nJyAmJiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBzY2FsaW5nLmNvbnZlcnQodmFsKTtcclxuICAgIH1cclxuICAgIC8vIENhdGVnb3J5IGF4aXMgY2FzZS5cclxuICAgIGNvbnN0IG1hdGNoaW5nSW5kZXggPSBzY2FsaW5nLmRvbWFpbi5maW5kSW5kZXgoKGQpID0+IGQgPT09IHZhbCk7XHJcbiAgICBpZiAobWF0Y2hpbmdJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxpbmcucmFuZ2VbbWF0Y2hpbmdJbmRleF07XHJcbiAgICB9XHJcbiAgICAvLyBXZSBmYWlsZWQgdG8gY29udmVydCB1c2luZyB0aGUgc2NhbGUuXHJcbiAgICByZXR1cm4gTmFOO1xyXG59XHJcbmZ1bmN0aW9uIGNsb3NlTWF0Y2goYSwgYikge1xyXG4gICAgY29uc3QgYW4gPSBOdW1iZXIoYSk7XHJcbiAgICBjb25zdCBibiA9IE51bWJlcihiKTtcclxuICAgIGlmICghaXNOYU4oYW4pICYmICFpc05hTihibikpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYm4gLSBhbikgPCAwLjI1O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlTW92ZVRvKGZyb20gPSBmYWxzZSwgdG8gPSBmYWxzZSkge1xyXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgICAgcmV0dXJuICEhZnJvbTtcclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tID8gJ2luJyA6ICdvdXQnO1xyXG59XHJcbmZ1bmN0aW9uIHBhaXJDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhLCBvcHRzID0ge30pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIGNvbnN0IHsgYmFja2ZpbGxTcGxpdE1vZGUgPSAnaW50ZXJzZWN0JyB9ID0gb3B0cztcclxuICAgIGNvbnN0IHRvTmV3U2NhbGUgPSAob2xkRGF0dW0pID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHNjYWxlKChfYSA9IG9sZERhdHVtLnhWYWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTmFOLCBuZXdEYXRhLnNjYWxlcy54KSxcclxuICAgICAgICAgICAgeTogc2NhbGUoKF9iID0gb2xkRGF0dW0ueVZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBOYU4sIG5ld0RhdGEuc2NhbGVzLnkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdG9PbGRTY2FsZSA9IChuZXdEYXR1bSkgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogc2NhbGUoKF9hID0gbmV3RGF0dW0ueFZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBOYU4sIG9sZERhdGEuc2NhbGVzLngpLFxyXG4gICAgICAgICAgICB5OiBzY2FsZSgoX2IgPSBuZXdEYXR1bS55VmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE5hTiwgb2xkRGF0YS5zY2FsZXMueSksXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGNvbnN0IHJlc3VsdE1hcCA9IHtcclxuICAgICAgICBhZGRlZDoge30sXHJcbiAgICAgICAgbW92ZWQ6IHt9LFxyXG4gICAgICAgIHJlbW92ZWQ6IHt9LFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhaXJVcCA9IChmcm9tLCB0bywgeFZhbHVlLCBjaGFuZ2UgPSAnbW92ZScpID0+IHtcclxuICAgICAgICBpZiAoZnJvbSAmJiAoaXNOYU4oZnJvbS5wb2ludC54KSB8fCBpc05hTihmcm9tLnBvaW50LnkpKSkge1xyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvICd0bycgcG9zaXRpb24gaWYgJ2Zyb20nIGlzIGludmFsaWQuXHJcbiAgICAgICAgICAgIGZyb20gPSB0bztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0UG9pbnQgPSB7XHJcbiAgICAgICAgICAgIGZyb206IGZyb20gPT09IG51bGwgfHwgZnJvbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJvbS5wb2ludCxcclxuICAgICAgICAgICAgdG86IHRvID09PSBudWxsIHx8IHRvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0by5wb2ludCxcclxuICAgICAgICAgICAgbW92ZVRvOiBjYWxjdWxhdGVNb3ZlVG8oZnJvbSA9PT0gbnVsbCB8fCBmcm9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcm9tLnBvaW50Lm1vdmVUbywgdG8gPT09IG51bGwgfHwgdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvLnBvaW50Lm1vdmVUbyksXHJcbiAgICAgICAgICAgIGNoYW5nZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjaGFuZ2UgPT09ICdtb3ZlJykge1xyXG4gICAgICAgICAgICByZXN1bHRNYXAubW92ZWRbeFZhbHVlXSA9IHJlc3VsdFBvaW50O1xyXG4gICAgICAgICAgICBvbGRJZHgrKztcclxuICAgICAgICAgICAgbmV3SWR4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZSA9PT0gJ2luJykge1xyXG4gICAgICAgICAgICByZXN1bHRNYXAuYWRkZWRbeFZhbHVlXSA9IHJlc3VsdFBvaW50O1xyXG4gICAgICAgICAgICBuZXdJZHgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlID09PSAnb3V0Jykge1xyXG4gICAgICAgICAgICByZXN1bHRNYXAucmVtb3ZlZFt4VmFsdWVdID0gcmVzdWx0UG9pbnQ7XHJcbiAgICAgICAgICAgIG9sZElkeCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaChyZXN1bHRQb2ludCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgeyBtaW46IG1pbkZyb21Ob2RlLCBtYXg6IG1heEZyb21Ob2RlIH0gPSBtaW5NYXgob2xkRGF0YS5ub2RlRGF0YSk7XHJcbiAgICBjb25zdCB7IG1pbjogbWluVG9Ob2RlLCBtYXg6IG1heFRvTm9kZSB9ID0gbWluTWF4KG5ld0RhdGEubm9kZURhdGEpO1xyXG4gICAgbGV0IG9sZElkeCA9IDA7XHJcbiAgICBsZXQgbmV3SWR4ID0gMDtcclxuICAgIHdoaWxlIChvbGRJZHggPCBvbGREYXRhLm5vZGVEYXRhLmxlbmd0aCB8fCBuZXdJZHggPCBuZXdEYXRhLm5vZGVEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSBvbGREYXRhLm5vZGVEYXRhW29sZElkeF07XHJcbiAgICAgICAgY29uc3QgdG8gPSBuZXdEYXRhLm5vZGVEYXRhW25ld0lkeF07XHJcbiAgICAgICAgY29uc3QgZnJvbVNoaWZ0ZWQgPSBmcm9tID8gdG9OZXdTY2FsZShmcm9tKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCB0b1Vuc2hpZnRlZCA9IHRvID8gdG9PbGRTY2FsZSh0bykgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgTkEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGZyb21TaGlmdGVkICYmIGNsb3NlTWF0Y2goZnJvbVNoaWZ0ZWQueCwgdG8gPT09IG51bGwgfHwgdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvLnBvaW50LngpKSB7XHJcbiAgICAgICAgICAgIHBhaXJVcChmcm9tLCB0bywgdG8ueFZhbHVlLCAnbW92ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmcm9tU2hpZnRlZCAmJiBmcm9tU2hpZnRlZC54IDwgKChfYSA9IG1pblRvTm9kZSA9PT0gbnVsbCB8fCBtaW5Ub05vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1pblRvTm9kZS5wb2ludC54KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtSW5maW5pdHkpKSB7XHJcbiAgICAgICAgICAgIHBhaXJVcChmcm9tLCBOQSwgZnJvbS54VmFsdWUsICdvdXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJvbVNoaWZ0ZWQgJiYgZnJvbVNoaWZ0ZWQueCA+ICgoX2IgPSBtYXhUb05vZGUgPT09IG51bGwgfHwgbWF4VG9Ob2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhUb05vZGUucG9pbnQueCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogSW5maW5pdHkpKSB7XHJcbiAgICAgICAgICAgIHBhaXJVcChmcm9tLCBOQSwgZnJvbS54VmFsdWUsICdvdXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG9VbnNoaWZ0ZWQgJiYgdG9VbnNoaWZ0ZWQueCA8ICgoX2MgPSBtaW5Gcm9tTm9kZSA9PT0gbnVsbCB8fCBtaW5Gcm9tTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluRnJvbU5vZGUucG9pbnQueCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogLUluZmluaXR5KSkge1xyXG4gICAgICAgICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsICdpbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b1Vuc2hpZnRlZCAmJiB0b1Vuc2hpZnRlZC54ID4gKChfZCA9IG1heEZyb21Ob2RlID09PSBudWxsIHx8IG1heEZyb21Ob2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXhGcm9tTm9kZS5wb2ludC54KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBJbmZpbml0eSkpIHtcclxuICAgICAgICAgICAgcGFpclVwKE5BLCB0bywgdG8ueFZhbHVlLCAnaW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJvbVNoaWZ0ZWQgJiYgZnJvbVNoaWZ0ZWQueCA8ICh0byA9PT0gbnVsbCB8fCB0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogdG8ucG9pbnQueCkpIHtcclxuICAgICAgICAgICAgcGFpclVwKGZyb20sIE5BLCBmcm9tLnhWYWx1ZSwgJ291dCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b1Vuc2hpZnRlZCAmJiB0b1Vuc2hpZnRlZC54IDwgKGZyb20gPT09IG51bGwgfHwgZnJvbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJvbS5wb2ludC54KSkge1xyXG4gICAgICAgICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsICdpbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmcm9tKSB7XHJcbiAgICAgICAgICAgIHBhaXJVcChmcm9tLCBOQSwgZnJvbS54VmFsdWUsICdvdXQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG8pIHtcclxuICAgICAgICAgICAgcGFpclVwKE5BLCB0bywgdG8ueFZhbHVlLCAnaW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHByb2Nlc3MgcG9pbnRzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYmFja2ZpbGxQYXRoUG9pbnREYXRhKHJlc3VsdCwgYmFja2ZpbGxTcGxpdE1vZGUpO1xyXG4gICAgcmV0dXJuIHsgcmVzdWx0LCByZXN1bHRNYXAgfTtcclxufVxyXG5mdW5jdGlvbiBwYWlyQ2F0ZWdvcnlEYXRhKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYsIG9wdHMgPSB7fSkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBjb25zdCB7IGJhY2tmaWxsU3BsaXRNb2RlID0gJ2ludGVyc2VjdCcsIG11bHRpRGF0dW0gPSBmYWxzZSB9ID0gb3B0cztcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgY29uc3QgcmVzdWx0TWFwU2luZ2xlID0ge1xyXG4gICAgICAgIGFkZGVkOiB7fSxcclxuICAgICAgICBtb3ZlZDoge30sXHJcbiAgICAgICAgcmVtb3ZlZDoge30sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzdWx0TWFwTXVsdGkgPSB7XHJcbiAgICAgICAgYWRkZWQ6IHt9LFxyXG4gICAgICAgIG1vdmVkOiB7fSxcclxuICAgICAgICByZW1vdmVkOiB7fSxcclxuICAgIH07XHJcbiAgICBsZXQgcHJldmlvdXNSZXN1bHRQb2ludCA9IHVuZGVmaW5lZDtcclxuICAgIGxldCBwcmV2aW91c1hWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGFkZFRvUmVzdWx0TWFwID0gKHhWYWx1ZSwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfYjtcclxuICAgICAgICBjb25zdCB0eXBlID0gcmVzdWx0LmNoYW5nZSA9PT0gJ21vdmUnID8gJ21vdmVkJyA6IHJlc3VsdC5jaGFuZ2UgPT09ICdpbicgPyAnYWRkZWQnIDogJ3JlbW92ZWQnO1xyXG4gICAgICAgIGlmIChtdWx0aURhdHVtKSB7XHJcbiAgICAgICAgICAgIChfYSA9IChfYiA9IHJlc3VsdE1hcE11bHRpW3R5cGVdKVt4VmFsdWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2JbeFZhbHVlXSA9IFtdKTtcclxuICAgICAgICAgICAgcmVzdWx0TWFwTXVsdGlbdHlwZV1beFZhbHVlXS5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHRNYXBTaW5nbGVbdHlwZV1beFZhbHVlXSA9IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldmlvdXNSZXN1bHRQb2ludCA9IHJlc3VsdDtcclxuICAgICAgICBwcmV2aW91c1hWYWx1ZSA9IHhWYWx1ZTtcclxuICAgIH07XHJcbiAgICBsZXQgb2xkSW5kZXggPSAwO1xyXG4gICAgbGV0IG5ld0luZGV4ID0gMDtcclxuICAgIGxldCBpc1hVbm9yZGVyZWQgPSBmYWxzZTtcclxuICAgIHdoaWxlIChvbGRJbmRleCA8IG9sZERhdGEubm9kZURhdGEubGVuZ3RoIHx8IG5ld0luZGV4IDwgbmV3RGF0YS5ub2RlRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBiZWZvcmUgPSBvbGREYXRhLm5vZGVEYXRhW29sZEluZGV4XTtcclxuICAgICAgICBjb25zdCBhZnRlciA9IG5ld0RhdGEubm9kZURhdGFbbmV3SW5kZXhdO1xyXG4gICAgICAgIGxldCByZXN1bHRQb2ludDtcclxuICAgICAgICBpZiAoKGJlZm9yZSA9PT0gbnVsbCB8fCBiZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJlZm9yZS54VmFsdWUpID09PSAoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLnhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0UG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2U6ICdtb3ZlJyxcclxuICAgICAgICAgICAgICAgIG1vdmVUbzogY2FsY3VsYXRlTW92ZVRvKChfYSA9IGJlZm9yZS5wb2ludC5tb3ZlVG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLCBhZnRlci5wb2ludC5tb3ZlVG8pLFxyXG4gICAgICAgICAgICAgICAgZnJvbTogYmVmb3JlLnBvaW50LFxyXG4gICAgICAgICAgICAgICAgdG86IGFmdGVyLnBvaW50LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhZGRUb1Jlc3VsdE1hcChiZWZvcmUueFZhbHVlLCByZXN1bHRQb2ludCk7XHJcbiAgICAgICAgICAgIG9sZEluZGV4Kys7XHJcbiAgICAgICAgICAgIG5ld0luZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpZmYucmVtb3ZlZC5pbmRleE9mKGJlZm9yZSA9PT0gbnVsbCB8fCBiZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJlZm9yZS54VmFsdWUpID49IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0UG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2U6ICdvdXQnLFxyXG4gICAgICAgICAgICAgICAgbW92ZVRvOiAoX2IgPSBiZWZvcmUucG9pbnQubW92ZVRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGZyb206IGJlZm9yZS5wb2ludCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYWRkVG9SZXN1bHRNYXAoYmVmb3JlLnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xyXG4gICAgICAgICAgICBvbGRJbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaWZmLmFkZGVkLmluZGV4T2YoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLnhWYWx1ZSkgPj0gMCkge1xyXG4gICAgICAgICAgICByZXN1bHRQb2ludCA9IHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZTogJ2luJyxcclxuICAgICAgICAgICAgICAgIG1vdmVUbzogKF9jID0gYWZ0ZXIucG9pbnQubW92ZVRvKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHRvOiBhZnRlci5wb2ludCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYWRkVG9SZXN1bHRNYXAoYWZ0ZXIueFZhbHVlLCByZXN1bHRQb2ludCk7XHJcbiAgICAgICAgICAgIG5ld0luZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG11bHRpRGF0dW0gJiYgcHJldmlvdXNSZXN1bHRQb2ludCAmJiBwcmV2aW91c1hWYWx1ZSA9PT0gKGJlZm9yZSA9PT0gbnVsbCB8fCBiZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJlZm9yZS54VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFBvaW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJldmlvdXNSZXN1bHRQb2ludCk7XHJcbiAgICAgICAgICAgIGFkZFRvUmVzdWx0TWFwKGJlZm9yZS54VmFsdWUsIHJlc3VsdFBvaW50KTtcclxuICAgICAgICAgICAgb2xkSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobXVsdGlEYXR1bSAmJiBwcmV2aW91c1Jlc3VsdFBvaW50ICYmIHByZXZpb3VzWFZhbHVlID09PSAoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLnhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0UG9pbnQgPSBPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91c1Jlc3VsdFBvaW50KTtcclxuICAgICAgICAgICAgYWRkVG9SZXN1bHRNYXAoYWZ0ZXIueFZhbHVlLCByZXN1bHRQb2ludCk7XHJcbiAgICAgICAgICAgIG5ld0luZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpc1hVbm9yZGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocmVzdWx0UG9pbnQpO1xyXG4gICAgfVxyXG4gICAgbGV0IHByZXZpb3VzWCA9IC1JbmZpbml0eTtcclxuICAgIGlzWFVub3JkZXJlZCB8fCAoaXNYVW5vcmRlcmVkID0gcmVzdWx0LnNvbWUoKHBhdGhQb2ludCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgY2hhbmdlOiBtYXJrZXIsIHRvOiB7IHggPSAtSW5maW5pdHkgfSA9IHt9IH0gPSBwYXRoUG9pbnQ7XHJcbiAgICAgICAgaWYgKG1hcmtlciA9PT0gJ291dCcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB4IDwgcHJldmlvdXNYO1xyXG4gICAgICAgIHByZXZpb3VzWCA9IHg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0pKTtcclxuICAgIGlmIChpc1hVbm9yZGVyZWQpIHtcclxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHVuZGVmaW5lZCwgcmVzdWx0TWFwOiB1bmRlZmluZWQgfTtcclxuICAgIH1cclxuICAgIGJhY2tmaWxsUGF0aFBvaW50RGF0YShyZXN1bHQsIGJhY2tmaWxsU3BsaXRNb2RlKTtcclxuICAgIGlmIChtdWx0aURhdHVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0LCByZXN1bHRNYXA6IHJlc3VsdE1hcE11bHRpIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyByZXN1bHQsIHJlc3VsdE1hcDogcmVzdWx0TWFwU2luZ2xlIH07XHJcbn1cclxuZnVuY3Rpb24gZGV0ZXJtaW5lUGF0aFN0YXR1cyhuZXdEYXRhLCBvbGREYXRhKSB7XHJcbiAgICBsZXQgc3RhdHVzID0gJ3VwZGF0ZWQnO1xyXG4gICAgY29uc3QgdmlzaWJsZSA9IChkYXRhKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEudmlzaWJsZTtcclxuICAgIH07XHJcbiAgICBpZiAoIXZpc2libGUob2xkRGF0YSkgJiYgdmlzaWJsZShuZXdEYXRhKSkge1xyXG4gICAgICAgIHN0YXR1cyA9ICdhZGRlZCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2aXNpYmxlKG9sZERhdGEpICYmICF2aXNpYmxlKG5ld0RhdGEpKSB7XHJcbiAgICAgICAgc3RhdHVzID0gJ3JlbW92ZWQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXR1cztcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbihzdGF0dXMsIHZpc2libGVUb2dnbGVNb2RlKSB7XHJcbiAgICBjb25zdCBwaGFzZSA9IHZpc2libGVUb2dnbGVNb2RlID09PSAnbm9uZScgPyAndXBkYXRlZCcgOiBzdGF0dXM7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgZnJvbUZuOiAoX3BhdGgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG1peGluO1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAncmVtb3ZlZCcpIHtcclxuICAgICAgICAgICAgICAgIG1peGluID0geyBmaW5pc2g6IHsgdmlzaWJsZTogZmFsc2UgfSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ2FkZGVkJykge1xyXG4gICAgICAgICAgICAgICAgbWl4aW4gPSB7IHN0YXJ0OiB7IHZpc2libGU6IHRydWUgfSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWl4aW4gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGUk9NX1RPX01JWElOU1twaGFzZV0pLCBtaXhpbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0ZuOiAoX3BhdGgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIEZST01fVE9fTUlYSU5TW3BoYXNlXSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBpZiAodmlzaWJsZVRvZ2dsZU1vZGUgPT09ICdmYWRlJykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZyb21GbjogKHBhdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSBzdGF0dXMgPT09ICdhZGRlZCcgPyAwIDogcGF0aC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBvcGFjaXR5IH0sIHJlc3VsdC5mcm9tRm4ocGF0aCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0b0ZuOiAocGF0aCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHN0YXR1cyA9PT0gJ3JlbW92ZWQnID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG9wYWNpdHkgfSwgcmVzdWx0LnRvRm4ocGF0aCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZucyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSwgdmlzaWJsZVRvZ2dsZU1vZGUsIHJlbmRlcikge1xyXG4gICAgY29uc3Qgc3RhdHVzID0gZGV0ZXJtaW5lUGF0aFN0YXR1cyhuZXdEYXRhLCBvbGREYXRhKTtcclxuICAgIGNvbnN0IHJlbW92ZVBoYXNlRm4gPSAocmF0aW8sIHBhdGgpID0+IHtcclxuICAgICAgICByZW5kZXIocGFpckRhdGEsIHsgbW92ZTogMCwgb3V0OiByYXRpbyB9LCBwYXRoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVQaGFzZUZuID0gKHJhdGlvLCBwYXRoKSA9PiB7XHJcbiAgICAgICAgcmVuZGVyKHBhaXJEYXRhLCB7IG1vdmU6IHJhdGlvIH0sIHBhdGgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGFkZFBoYXNlRm4gPSAocmF0aW8sIHBhdGgpID0+IHtcclxuICAgICAgICByZW5kZXIocGFpckRhdGEsIHsgbW92ZTogMSwgaW46IHJhdGlvIH0sIHBhdGgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGhQcm9wZXJ0aWVzID0gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSk7XHJcbiAgICByZXR1cm4geyBzdGF0dXMsIHBhdGg6IHsgYWRkUGhhc2VGbiwgdXBkYXRlUGhhc2VGbiwgcmVtb3ZlUGhhc2VGbiB9LCBwYXRoUHJvcGVydGllcyB9O1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBkaWZmKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBpc0NhdGVnb3J5QmFzZWQgPSAoKF9hID0gbmV3RGF0YS5zY2FsZXMueCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnY2F0ZWdvcnknO1xyXG4gICAgY29uc3QgeyByZXN1bHQ6IHBhaXJEYXRhLCByZXN1bHRNYXA6IHBhaXJNYXAgfSA9IGlzQ2F0ZWdvcnlCYXNlZCAmJiBkaWZmID8gcGFpckNhdGVnb3J5RGF0YShuZXdEYXRhLCBvbGREYXRhLCBkaWZmKSA6IHBhaXJDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhKTtcclxuICAgIGxldCBzdGF0dXMgPSAndXBkYXRlZCc7XHJcbiAgICBpZiAob2xkRGF0YS52aXNpYmxlICYmICFuZXdEYXRhLnZpc2libGUpIHtcclxuICAgICAgICBzdGF0dXMgPSAncmVtb3ZlZCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghb2xkRGF0YS52aXNpYmxlICYmIG5ld0RhdGEudmlzaWJsZSkge1xyXG4gICAgICAgIHN0YXR1cyA9ICdhZGRlZCc7XHJcbiAgICB9XHJcbiAgICBpZiAocGFpckRhdGEgPT09IHVuZGVmaW5lZCB8fCBwYWlyTWFwID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXRoRm5zID0gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhLCAnZmFkZScsIHJlbmRlclBhcnRpYWxQYXRoKTtcclxuICAgIGNvbnN0IG1hcmtlciA9IHByZXBhcmVNYXJrZXJBbmltYXRpb24ocGFpck1hcCwgc3RhdHVzKTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhdGhGbnMpLCB7IG1hcmtlciB9KTtcclxufVxuXG52YXIgQXJlYVNlcmllc1RhZztcclxuKGZ1bmN0aW9uIChBcmVhU2VyaWVzVGFnKSB7XHJcbiAgICBBcmVhU2VyaWVzVGFnW0FyZWFTZXJpZXNUYWdbXCJGaWxsXCJdID0gMF0gPSBcIkZpbGxcIjtcclxuICAgIEFyZWFTZXJpZXNUYWdbQXJlYVNlcmllc1RhZ1tcIlN0cm9rZVwiXSA9IDFdID0gXCJTdHJva2VcIjtcclxuICAgIEFyZWFTZXJpZXNUYWdbQXJlYVNlcmllc1RhZ1tcIk1hcmtlclwiXSA9IDJdID0gXCJNYXJrZXJcIjtcclxuICAgIEFyZWFTZXJpZXNUYWdbQXJlYVNlcmllc1RhZ1tcIkxhYmVsXCJdID0gM10gPSBcIkxhYmVsXCI7XHJcbn0pKEFyZWFTZXJpZXNUYWcgfHwgKEFyZWFTZXJpZXNUYWcgPSB7fSkpO1xyXG5mdW5jdGlvbiBzcGxpdEZpbGxQb2ludHMoY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwb2ludHMgfSA9IGNvbnRleHQuZmlsbERhdGE7XHJcbiAgICByZXR1cm4geyB0b3A6IHBvaW50cy5zbGljZSgwLCBwb2ludHMubGVuZ3RoIC8gMiksIGJvdHRvbTogcG9pbnRzLnNsaWNlKHBvaW50cy5sZW5ndGggLyAyKS5yZXZlcnNlKCkgfTtcclxufVxyXG5mdW5jdGlvbiBwcmVwUG9pbnRzKGtleSwgY3R4LCBwb2ludHMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2NhbGVzOiBjdHguc2NhbGVzLFxyXG4gICAgICAgIG5vZGVEYXRhOiBwb2ludHNba2V5XSxcclxuICAgICAgICB2aXNpYmxlOiBjdHgudmlzaWJsZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFpckZpbGxDYXRlZ29yeURhdGEobmV3RGF0YSwgb2xkRGF0YSwgZGlmZikge1xyXG4gICAgY29uc3Qgb2xkUG9pbnRzID0gc3BsaXRGaWxsUG9pbnRzKG9sZERhdGEpO1xyXG4gICAgY29uc3QgbmV3UG9pbnRzID0gc3BsaXRGaWxsUG9pbnRzKG5ld0RhdGEpO1xyXG4gICAgY29uc3QgcGFpck9wdHMgPSB7IG11bHRpRGF0dW06IHRydWUgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiBwYWlyQ2F0ZWdvcnlEYXRhKHByZXBQb2ludHMoJ3RvcCcsIG5ld0RhdGEsIG5ld1BvaW50cyksIHByZXBQb2ludHMoJ3RvcCcsIG9sZERhdGEsIG9sZFBvaW50cyksIGRpZmYsIHBhaXJPcHRzKSxcclxuICAgICAgICBib3R0b206IHBhaXJDYXRlZ29yeURhdGEocHJlcFBvaW50cygnYm90dG9tJywgbmV3RGF0YSwgbmV3UG9pbnRzKSwgcHJlcFBvaW50cygnYm90dG9tJywgb2xkRGF0YSwgb2xkUG9pbnRzKSwgZGlmZiwgcGFpck9wdHMpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYWlyRmlsbENvbnRpbnVvdXNEYXRhKG5ld0RhdGEsIG9sZERhdGEpIHtcclxuICAgIGNvbnN0IG9sZFBvaW50cyA9IHNwbGl0RmlsbFBvaW50cyhvbGREYXRhKTtcclxuICAgIGNvbnN0IG5ld1BvaW50cyA9IHNwbGl0RmlsbFBvaW50cyhuZXdEYXRhKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiBwYWlyQ29udGludW91c0RhdGEocHJlcFBvaW50cygndG9wJywgbmV3RGF0YSwgbmV3UG9pbnRzKSwgcHJlcFBvaW50cygndG9wJywgb2xkRGF0YSwgb2xkUG9pbnRzKSksXHJcbiAgICAgICAgYm90dG9tOiBwYWlyQ29udGludW91c0RhdGEocHJlcFBvaW50cygnYm90dG9tJywgbmV3RGF0YSwgbmV3UG9pbnRzKSwgcHJlcFBvaW50cygnYm90dG9tJywgb2xkRGF0YSwgb2xkUG9pbnRzKSksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBkaWZmKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBpc0NhdGVnb3J5QmFzZWQgPSAoKF9hID0gbmV3RGF0YS5zY2FsZXMueCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnY2F0ZWdvcnknO1xyXG4gICAgbGV0IHN0YXR1cyA9ICd1cGRhdGVkJztcclxuICAgIGlmIChvbGREYXRhLnZpc2libGUgJiYgIW5ld0RhdGEudmlzaWJsZSkge1xyXG4gICAgICAgIHN0YXR1cyA9ICdyZW1vdmVkJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFvbGREYXRhLnZpc2libGUgJiYgbmV3RGF0YS52aXNpYmxlKSB7XHJcbiAgICAgICAgc3RhdHVzID0gJ2FkZGVkJztcclxuICAgIH1cclxuICAgIGNvbnN0IHByZXBhcmVNYXJrZXJQYWlycyA9ICgpID0+IHtcclxuICAgICAgICBpZiAoaXNDYXRlZ29yeUJhc2VkICYmIGRpZmYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJDYXRlZ29yeURhdGEobmV3RGF0YSwgb2xkRGF0YSwgZGlmZiwgeyBiYWNrZmlsbFNwbGl0TW9kZTogJ3N0YXRpYycsIG11bHRpRGF0dW06IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYWlyQ29udGludW91c0RhdGEobmV3RGF0YSwgb2xkRGF0YSwgeyBiYWNrZmlsbFNwbGl0TW9kZTogJ3N0YXRpYycgfSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJlcGFyZUZpbGxQYWlycyA9ICgpID0+IHtcclxuICAgICAgICBpZiAoaXNDYXRlZ29yeUJhc2VkICYmIGRpZmYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhaXJGaWxsQ2F0ZWdvcnlEYXRhKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFpckZpbGxDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB7IHJlc3VsdE1hcDogbWFya2VyUGFpck1hcCB9ID0gcHJlcGFyZU1hcmtlclBhaXJzKCk7XHJcbiAgICBjb25zdCB7IHRvcCwgYm90dG9tIH0gPSBwcmVwYXJlRmlsbFBhaXJzKCk7XHJcbiAgICBpZiAobWFya2VyUGFpck1hcCA9PT0gdW5kZWZpbmVkIHx8IHRvcC5yZXN1bHQgPT09IHVuZGVmaW5lZCB8fCBib3R0b20ucmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWlyRGF0YSA9IFsuLi50b3AucmVzdWx0LCAuLi5ib3R0b20ucmVzdWx0LnJldmVyc2UoKV07XHJcbiAgICBjb25zdCBmaWxsID0gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zKG5ld0RhdGEsIG9sZERhdGEsIHBhaXJEYXRhLCAnbm9uZScsIHJlbmRlclBhcnRpYWxQYXRoKTtcclxuICAgIGNvbnN0IG1hcmtlciA9IHByZXBhcmVNYXJrZXJBbmltYXRpb24obWFya2VyUGFpck1hcCwgc3RhdHVzKTtcclxuICAgIHJldHVybiB7IGZpbGwsIG1hcmtlciB9O1xyXG59XG5cbmNsYXNzIEFyZWFTZXJpZXMgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBtb2R1bGVDdHgsXHJcbiAgICAgICAgICAgIHBhdGhzUGVyU2VyaWVzOiAyLFxyXG4gICAgICAgICAgICBwYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0OiBbMCwgMTAwMF0sXHJcbiAgICAgICAgICAgIGhhc01hcmtlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgcGlja01vZGVzOiBbU2VyaWVzTm9kZVBpY2tNb2RlLk5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNULCBTZXJpZXNOb2RlUGlja01vZGUuRVhBQ1RfU0hBUEVfTUFUQ0hdLFxyXG4gICAgICAgICAgICBhbmltYXRpb25SZXNldEZuczoge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogYnVpbGRSZXNldFBhdGhGbih7IGdldE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0T3BhY2l0eSgpIH0pLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcclxuICAgICAgICAgICAgICAgIG1hcmtlcjogKG5vZGUsIGRhdHVtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNldE1hcmtlckZuKCkpLCByZXNldE1hcmtlclBvc2l0aW9uRm4obm9kZSwgZGF0dW0pKSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcclxuICAgICAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcclxuICAgICAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XHJcbiAgICAgICAgdGhpcy5maWxsID0gJyNjMTYwNjgnO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlID0gJyM4NzQzNDknO1xyXG4gICAgICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5saW5lRGFzaCA9IFswXTtcclxuICAgICAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLnhLZXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy54TmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gMjtcclxuICAgICAgICB0aGlzLnNoYWRvdyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB4S2V5LCB5S2V5LCBub3JtYWxpemVkVG8sIGRhdGEsIHZpc2libGUsIHNlcmllc0dyb3VwaW5nOiB7IGdyb3VwSW5kZXggPSB0aGlzLmlkIH0gPSB7fSB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHhLZXkgPT0gbnVsbCB8fCB5S2V5ID09IG51bGwgfHwgZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaXNDb250aW51b3VzWCwgaXNDb250aW51b3VzWSB9ID0gdGhpcy5pc0NvbnRpbnVvdXMoKTtcclxuICAgICAgICAgICAgY29uc3QgaWRzID0gW1xyXG4gICAgICAgICAgICAgICAgYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYCxcclxuICAgICAgICAgICAgICAgIGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy10cmFpbGluZ2AsXHJcbiAgICAgICAgICAgICAgICBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtcHJldmAsXHJcbiAgICAgICAgICAgICAgICBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtdHJhaWxpbmctcHJldmAsXHJcbiAgICAgICAgICAgICAgICBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtbWFya2VyYCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgZXh0cmFQcm9wcyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpc2VUbyA9IG5vcm1hbGl6ZWRUbyAmJiBpc0Zpbml0ZShub3JtYWxpemVkVG8pID8gbm9ybWFsaXplZFRvIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXNlVG8pIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhUHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKHRoaXMsIFtpZHNbMF0sIGlkc1sxXSwgaWRzWzRdXSwgbm9ybWFsaXNlVG8sICdyYW5nZScpKTtcclxuICAgICAgICAgICAgICAgIGV4dHJhUHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKHRoaXMsIFtpZHNbMl0sIGlkc1szXV0sIG5vcm1hbGlzZVRvLCAncmFuZ2UnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgdHdvIG9yIG1vcmUgZGF0dW1zIHNoYXJlIGFuIHgtdmFsdWUsIGkuZS4gbGluZWQgdXAgdmVydGljYWxseSwgdGhleSB3aWxsIGhhdmUgdGhlIHNhbWUgZGF0dW0gaWQuXHJcbiAgICAgICAgICAgIC8vIFRoZXkgbXVzdCBiZSBpZGVudGlmaWVkIHRoaXMgd2F5IHdoZW4gYW5pbWF0ZWQgdG8gZW5zdXJlIHRoZXkgY2FuIGJlIHRyYWNrZWQgd2hlbiB0aGVpciB5LXZhbHVlXHJcbiAgICAgICAgICAgIC8vIGlzIHVwZGF0ZWQuIElmIHRoaXMgaXMgYSBzdGF0aWMgY2hhcnQsIHdlIGNhbiBpbnN0ZWFkIG5vdCBib3RoZXIgd2l0aCBpZGVudGlmeWluZyBkYXR1bXMgYW5kXHJcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZ2FyYmFnZSBjb2xsZWN0IHRoZSBtYXJrZXIgc2VsZWN0aW9uLlxyXG4gICAgICAgICAgICBpZiAoIWlzQ29udGludW91c1ggJiYgYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbih0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29tbW9uID0geyBpbnZhbGlkVmFsdWU6IG51bGwgfTtcclxuICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tb24uZm9yY2VWYWx1ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XHJcbiAgICAgICAgICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BlcnR5KHRoaXMsIHhLZXksIGlzQ29udGludW91c1gsIHsgaWQ6ICd4VmFsdWUnIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgT2JqZWN0LmFzc2lnbih7IGlkOiBgeVZhbHVlUmF3YCB9LCBjb21tb24pKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgJ3dpbmRvdycsICdjdXJyZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IGB5VmFsdWVFbmRgIH0sIGNvbW1vbiksIHsgZ3JvdXBJZDogaWRzWzBdIH0pKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgJ3dpbmRvdy10cmFpbGluZycsICdjdXJyZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IGB5VmFsdWVTdGFydGAgfSwgY29tbW9uKSwgeyBncm91cElkOiBpZHNbMV0gfSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eSh0aGlzLCB5S2V5LCBpc0NvbnRpbnVvdXNZLCAnd2luZG93JywgJ2xhc3QnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpZDogYHlWYWx1ZVByZXZpb3VzRW5kYCB9LCBjb21tb24pLCB7IGdyb3VwSWQ6IGlkc1syXSB9KSksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KHRoaXMsIHlLZXksIGlzQ29udGludW91c1ksICd3aW5kb3ctdHJhaWxpbmcnLCAnbGFzdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGlkOiBgeVZhbHVlUHJldmlvdXNTdGFydGAgfSwgY29tbW9uKSwgeyBncm91cElkOiBpZHNbM10gfSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eSh0aGlzLCB5S2V5LCBpc0NvbnRpbnVvdXNZLCAnbm9ybWFsJywgJ2N1cnJlbnQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpZDogYHlWYWx1ZUN1bXVsYXRpdmVgIH0sIGNvbW1vbiksIHsgZ3JvdXBJZDogaWRzWzRdIH0pKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5leHRyYVByb3BzLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIGdyb3VwQnlLZXlzOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKCd1cGRhdGVEYXRhJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGF4ZXMgfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICBjb25zdCB4QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlhdO1xyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWV07XHJcbiAgICAgICAgY29uc3Qga2V5RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHhWYWx1ZWAsICdrZXknLCBwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICBjb25zdCB5RXh0ZW50ID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeVZhbHVlRW5kYCwgJ3ZhbHVlJywgcHJvY2Vzc2VkRGF0YSk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlgpIHtcclxuICAgICAgICAgICAgaWYgKChrZXlEZWYgPT09IG51bGwgfHwga2V5RGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrZXlEZWYuZGVmLnR5cGUpID09PSAna2V5JyAmJiBrZXlEZWYuZGVmLnZhbHVlVHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGtleXMpLCB4QXhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHlBeGlzIGluc3RhbmNlb2YgTG9nQXhpcyB8fCB5QXhpcyBpbnN0YW5jZW9mIFRpbWVBeGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KHlFeHRlbnQsIHlBeGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpeGVkWUV4dGVudCA9IFt5RXh0ZW50WzBdID4gMCA/IDAgOiB5RXh0ZW50WzBdLCB5RXh0ZW50WzFdIDwgMCA/IDAgOiB5RXh0ZW50WzFdXTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZml4ZWRZRXh0ZW50LCB5QXhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlTm9kZURhdGEoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZVNjYWxpbmc6IHsgZ2V0OiAoKSA9PiBzdXBlci5jYWxjdWxhdGVTY2FsaW5nIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBheGVzLCBkYXRhLCBwcm9jZXNzZWREYXRhOiB7IGRhdGE6IGdyb3VwZWREYXRhIH0gPSB7fSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB4QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlhdO1xyXG4gICAgICAgICAgICBjb25zdCB5QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldO1xyXG4gICAgICAgICAgICBpZiAoIXhBeGlzIHx8ICF5QXhpcyB8fCAhZGF0YSB8fCAhZGF0YU1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB5S2V5ID0gJycsIHhLZXkgPSAnJywgbWFya2VyLCBsYWJlbCwgZmlsbDogc2VyaWVzRmlsbCwgc3Ryb2tlOiBzZXJpZXNTdHJva2UgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2NhbGU6IHhTY2FsZSB9ID0geEF4aXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2NhbGU6IHlTY2FsZSB9ID0geUF4aXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRpbnVvdXNZID0gQ29udGludW91c1NjYWxlLmlzKHlTY2FsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHhPZmZzZXQgPSAoKF9hID0geFNjYWxlLmJhbmR3aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCBkZWZzID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmc0J5SWRzKHRoaXMsIFtcclxuICAgICAgICAgICAgICAgIGB5VmFsdWVTdGFydGAsXHJcbiAgICAgICAgICAgICAgICBgeVZhbHVlRW5kYCxcclxuICAgICAgICAgICAgICAgIGB5VmFsdWVSYXdgLFxyXG4gICAgICAgICAgICAgICAgYHlWYWx1ZVByZXZpb3VzU3RhcnRgLFxyXG4gICAgICAgICAgICAgICAgYHlWYWx1ZVByZXZpb3VzRW5kYCxcclxuICAgICAgICAgICAgICAgIGB5VmFsdWVDdW11bGF0aXZlYCxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZU1vdmVQb2ludCA9IChwbGFpblBvaW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvaW50IH0gPSBwbGFpblBvaW50LCBzdHJva2UgPSBfX3Jlc3QocGxhaW5Qb2ludCwgW1wicG9pbnRcIl0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBwb2ludDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwb2ludCksIHsgbW92ZVRvOiB0cnVlIH0pIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVQYXRoQ29vcmRpbmF0ZXMgPSAoeFZhbHVlLCBsYXN0WUVuZCwgeUVuZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhWYWx1ZSkgKyB4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldllDb29yZGluYXRlID0geVNjYWxlLmNvbnZlcnQobGFzdFlFbmQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycllDb29yZGluYXRlID0geVNjYWxlLmNvbnZlcnQoeUVuZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgcG9pbnQ6IHsgeCwgeTogY3VycllDb29yZGluYXRlIH0sIHlWYWx1ZTogeUVuZCwgeFZhbHVlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBwb2ludDogeyB4LCB5OiBwcmV2WUNvb3JkaW5hdGUgfSwgeVZhbHVlOiBsYXN0WUVuZCwgeFZhbHVlIH0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVNYXJrZXJDb29yZGluYXRlID0gKHhEYXR1bSwgeUVuZCwgcmF3WURhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3Vyclk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBub3Qgbm9ybWFsaXplZCwgdGhlIGludmFsaWQgZGF0YSBwb2ludHMgd2lsbCBiZSBwcm9jZXNzZWQgYXMgYHVuZGVmaW5lZGAgaW4gcHJvY2Vzc0RhdGEoKVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm9ybWFsaXplZCwgdGhlIGludmFsaWQgZGF0YSBwb2ludHMgd2lsbCBiZSBwcm9jZXNzZWQgYXMgMCByYXRoZXIgdGhhbiBgdW5kZWZpbmVkYFxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdW5wcm9jZXNzZWQgZGF0dW0gaXMgdmFsaWQgYXMgd2Ugb25seSB3YW50IHRvIHNob3cgbWFya2VycyBmb3IgdmFsaWQgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVkVG8gJiYgaXNGaW5pdGUodGhpcy5ub3JtYWxpemVkVG8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFuZFZhbGlkID0gbm9ybWFsaXplZCAmJiBjb250aW51b3VzWSAmJiBpc0NvbnRpbnVvdXMocmF3WURhdHVtKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gKCFub3JtYWxpemVkICYmICFpc05hTihyYXdZRGF0dW0pKSB8fCBub3JtYWxpemVkQW5kVmFsaWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyWSA9IHlFbmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoY3VyclkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgc2l6ZTogbWFya2VyLnNpemUgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUlkID0geUtleTtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlckRhdGEgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIGl0ZW1JZCxcclxuICAgICAgICAgICAgICAgIGZpbGxEYXRhOiB7IGl0ZW1JZCwgcG9pbnRzOiBbXSB9LFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGF0YTogeyBpdGVtSWQsIHBvaW50czogW10gfSxcclxuICAgICAgICAgICAgICAgIGxhYmVsRGF0YSxcclxuICAgICAgICAgICAgICAgIG5vZGVEYXRhOiBtYXJrZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgc2NhbGVzOiBfc3VwZXIuY2FsY3VsYXRlU2NhbGluZy5jYWxsKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBmaWxsUG9pbnRzID0gY29udGV4dC5maWxsRGF0YS5wb2ludHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGxQaGFudG9tUG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVBvaW50cyA9IGNvbnRleHQuc3Ryb2tlRGF0YS5wb2ludHM7XHJcbiAgICAgICAgICAgIGxldCBkYXR1bUlkeCA9IC0xO1xyXG4gICAgICAgICAgICBsZXQgbGFzdFhEYXR1bTtcclxuICAgICAgICAgICAgbGV0IGxhc3RZRGF0dW0gPSAtSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGdyb3VwZWREYXRhID09PSBudWxsIHx8IGdyb3VwZWREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cGVkRGF0YS5mb3JFYWNoKChkYXR1bUdyb3VwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleXMsIGtleXM6IFt4RGF0dW1dLCBkYXR1bTogZGF0dW1BcnJheSwgdmFsdWVzOiB2YWx1ZXNBcnJheSwgfSA9IGRhdHVtR3JvdXA7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNBcnJheS5mb3JFYWNoKCh2YWx1ZXMsIHZhbHVlSWR4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0dW1JZHgrKztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpZXNEYXR1bSA9IGRhdHVtQXJyYXlbdmFsdWVJZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzVmFsdWVzKGRlZnMsIHsga2V5cywgdmFsdWVzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeVZhbHVlUmF3OiB5RGF0dW0sIHlWYWx1ZUN1bXVsYXRpdmUgfSA9IGRhdGFWYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgeVZhbHVlU3RhcnQsIHlWYWx1ZUVuZCwgeVZhbHVlUHJldmlvdXNTdGFydCwgeVZhbHVlUHJldmlvdXNFbmQgfSA9IGRhdGFWYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRQb2ludCA9IHlEYXR1bSAhPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmtlciBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBjcmVhdGVNYXJrZXJDb29yZGluYXRlKHhEYXR1bSwgK3lWYWx1ZUN1bXVsYXRpdmUsIHlEYXR1bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkUG9pbnQgJiYgbWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckRhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZGF0dW1JZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRQb2ludDogeyB4OiBwb2ludC54LCB5OiBwb2ludC55IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlWYWx1ZUVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlWYWx1ZTogeURhdHVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFZhbHVlOiB4RGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogKF9hID0gbWFya2VyLmZpbGwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNlcmllc0ZpbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IChfYiA9IG1hcmtlci5zdHJva2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHNlcmllc1N0cm9rZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAoX2MgPSBtYXJrZXIuc3Ryb2tlV2lkdGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5zdHJva2VXaWR0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBsYWJlbCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkUG9pbnQgJiYgbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQobGFiZWwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB5RGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeUtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhOYW1lOiB0aGlzLnhOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeU5hbWU6IHRoaXMueU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICh2YWx1ZSkgPT4gKGlzTnVtYmVyKHZhbHVlKSA/IHZhbHVlLnRvRml4ZWQoMikgOiBTdHJpbmcodmFsdWUpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBkYXR1bUlkeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogeUtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvaW50LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwb2ludC55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbFRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogbGFiZWwuZm9udFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLmZvbnRGYW1pbHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ2JvdHRvbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGxhYmVsLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGwgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0WURhdHVtID09IG51bGwgfHwgeURhdHVtID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIGNvb3JkaW5hdGVzIHRvICd6ZXJvJyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeVZhbHVlU3RhcnQgPSB5VmFsdWVTdGFydCAhPT0gbnVsbCAmJiB5VmFsdWVTdGFydCAhPT0gdm9pZCAwID8geVZhbHVlU3RhcnQgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5VmFsdWVFbmQgPSB5VmFsdWVTdGFydCAhPT0gbnVsbCAmJiB5VmFsdWVTdGFydCAhPT0gdm9pZCAwID8geVZhbHVlU3RhcnQgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5VmFsdWVQcmV2aW91c1N0YXJ0ID0geVZhbHVlUHJldmlvdXNTdGFydCAhPT0gbnVsbCAmJiB5VmFsdWVQcmV2aW91c1N0YXJ0ICE9PSB2b2lkIDAgPyB5VmFsdWVQcmV2aW91c1N0YXJ0IDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVZhbHVlUHJldmlvdXNFbmQgPSB5VmFsdWVQcmV2aW91c1N0YXJ0ICE9PSBudWxsICYmIHlWYWx1ZVByZXZpb3VzU3RhcnQgIT09IHZvaWQgMCA/IHlWYWx1ZVByZXZpb3VzU3RhcnQgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbcHJldlRvcCwgcHJldkJvdHRvbV0gPSBjcmVhdGVQYXRoQ29vcmRpbmF0ZXMobGFzdFhEYXR1bSwgeVZhbHVlUHJldmlvdXNTdGFydCwgeVZhbHVlUHJldmlvdXNFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt0b3AsIGJvdHRvbV0gPSBjcmVhdGVQYXRoQ29vcmRpbmF0ZXMoeERhdHVtLCB5VmFsdWVTdGFydCwgeVZhbHVlRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4VmFsaWQgPSBsYXN0WERhdHVtICE9IG51bGwgJiYgeERhdHVtICE9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsUG9pbnRzLnB1c2gocHJldlRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxQaGFudG9tUG9pbnRzLnB1c2gocHJldkJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxQb2ludHMucHVzaCh0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsUGhhbnRvbVBvaW50cy5wdXNoKGJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cm9rZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkUG9pbnQgJiYgbGFzdFlEYXR1bSAhPSBudWxsICYmIGRhdHVtSWR4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VQb2ludHMucHVzaChjcmVhdGVNb3ZlUG9pbnQocHJldlRvcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VQb2ludHMucHVzaCh0b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsYXN0WERhdHVtID0geERhdHVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RZRGF0dW0gPSB5RGF0dW07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChzdHJva2VQb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlUG9pbnRzWzBdID0gY3JlYXRlTW92ZVBvaW50KHN0cm9rZVBvaW50c1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmlsbFBoYW50b21Qb2ludHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICBmaWxsUG9pbnRzLnB1c2goLi4uZmlsbFBoYW50b21Qb2ludHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2NvbnRleHRdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXIuaXNEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgbWFya2VyRmFjdG9yeSgpIHtcclxuICAgICAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLm1hcmtlcjtcclxuICAgICAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IG9wYWNpdHksIHZpc2libGUsIGFuaW1hdGlvbkVuYWJsZWQgfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IFtmaWxsLCBzdHJva2VdID0gb3B0cy5wYXRocztcclxuICAgICAgICAgICAgY29uc3QgeyBzZXJpZXNSZWN0SGVpZ2h0OiBoZWlnaHQsIHNlcmllc1JlY3RXaWR0aDogd2lkdGggfSA9IHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aCh0aGlzLnN0cm9rZVdpZHRoKTtcclxuICAgICAgICAgICAgc3Ryb2tlLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgdGFnOiBBcmVhU2VyaWVzVGFnLlN0cm9rZSxcclxuICAgICAgICAgICAgICAgIGZpbGw6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGxpbmVKb2luOiAoc3Ryb2tlLmxpbmVDYXAgPSAncm91bmQnKSxcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFBvaW50ZXJFdmVudHMuTm9uZSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5zdHJva2UsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMuc3Ryb2tlT3BhY2l0eSxcclxuICAgICAgICAgICAgICAgIGxpbmVEYXNoOiB0aGlzLmxpbmVEYXNoLFxyXG4gICAgICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMubGluZURhc2hPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGZpbGwuc2V0UHJvcGVydGllcyh7XHJcbiAgICAgICAgICAgICAgICB0YWc6IEFyZWFTZXJpZXNUYWcuRmlsbCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgbGluZUpvaW46ICdyb3VuZCcsXHJcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBQb2ludGVyRXZlbnRzLk5vbmUsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdGhpcy5maWxsT3BhY2l0eSxcclxuICAgICAgICAgICAgICAgIGxpbmVEYXNoOiB0aGlzLmxpbmVEYXNoLFxyXG4gICAgICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMubGluZURhc2hPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICBmaWxsU2hhZG93OiB0aGlzLnNoYWRvdyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUNsaXBQYXRoID0gKHBhdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5jbGlwUGF0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5jbGlwUGF0aCA9IG5ldyBQYXRoMkQoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmNsaXBTY2FsaW5nWCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5jbGlwU2NhbGluZ1kgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKF9hID0gcGF0aC5jbGlwUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFyKHsgdHJhY2tDaGFuZ2VzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgKF9iID0gcGF0aC5jbGlwUGF0aCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlY3QoLTI1LCAtMjUsICh3aWR0aCAhPT0gbnVsbCAmJiB3aWR0aCAhPT0gdm9pZCAwID8gd2lkdGggOiAwKSArIDUwLCAoaGVpZ2h0ICE9PSBudWxsICYmIGhlaWdodCAhPT0gdm9pZCAwID8gaGVpZ2h0IDogMCkgKyA1MCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHVwZGF0ZUNsaXBQYXRoKHN0cm9rZSk7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNsaXBQYXRoKGZpbGwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGF0aHMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKFtvcHRzLnBhdGhzXSwgW29wdHMuY29udGV4dERhdGFdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZpbGxQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGaWxsUGF0aChwYXRocywgY29udGV4dERhdGEpIHtcclxuICAgICAgICBjb250ZXh0RGF0YS5mb3JFYWNoKCh7IGZpbGxEYXRhIH0sIGNvbnRleHREYXRhSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2ZpbGxdID0gcGF0aHNbY29udGV4dERhdGFJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aDogZmlsbFBhdGggfSA9IGZpbGw7XHJcbiAgICAgICAgICAgIGZpbGxQYXRoLmNsZWFyKHsgdHJhY2tDaGFuZ2VzOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgcG9pbnQgfSBvZiBmaWxsRGF0YS5wb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludC5tb3ZlVG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsUGF0aC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsUGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmlsbFBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGZpbGwuY2hlY2tQYXRoRGlydHkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVN0cm9rZVBhdGgocGF0aHMsIGNvbnRleHREYXRhKSB7XHJcbiAgICAgICAgY29udGV4dERhdGEuZm9yRWFjaCgoeyBzdHJva2VEYXRhIH0sIGNvbnRleHREYXRhSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgWywgc3Ryb2tlXSA9IHBhdGhzW2NvbnRleHREYXRhSW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCB7IHBhdGg6IHN0cm9rZVBhdGggfSA9IHN0cm9rZTtcclxuICAgICAgICAgICAgc3Ryb2tlUGF0aC5jbGVhcih7IHRyYWNrQ2hhbmdlczogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB7IHBvaW50IH0gb2Ygc3Ryb2tlRGF0YS5wb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludC5tb3ZlVG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VQYXRoLm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0cm9rZS5jaGVja1BhdGhEaXJ0eSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWFya2VyOiB7IGVuYWJsZWQgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlbmFibGVkICYmIG5vZGVEYXRhID8gbm9kZURhdGEgOiBbXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VyLmlzRGlydHkoKSkge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeEtleSA9ICcnLCB5S2V5ID0gJycsIG1hcmtlciwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHkgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgdGhpcy5oaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xyXG4gICAgICAgICAgICAgICAgZmlsbCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKG5vZGUsIG1hcmtlciwgeyBkYXR1bSwgaGlnaGxpZ2h0ZWQsIHhLZXksIHlLZXkgfSwgYmFzZVN0eWxlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLm1hcmtDbGVhbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFiZWxTZWxlY3Rpb24udXBkYXRlKGxhYmVsRGF0YSwgKHRleHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRleHQudGFnID0gQXJlYVNlcmllc1RhZy5MYWJlbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGVuYWJsZWQ6IGxhYmVsRW5hYmxlZCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IHRoaXMubGFiZWw7XHJcbiAgICAgICAgICAgIGxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHksIGxhYmVsIH0gPSBkYXR1bTtcclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbCAmJiBsYWJlbEVuYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IGxhYmVsLnRleHRBbGlnbjtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IGxhYmVsLnRleHRCYXNlbGluZTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQueCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC55ID0geSAtIDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQuZmlsbCA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcclxuICAgICAgICBjb25zdCB7IHhLZXksIGlkOiBzZXJpZXNJZCwgYXhlcywgeE5hbWUsIHlOYW1lLCB0b29sdGlwLCBtYXJrZXIsIGRhdGFNb2RlbCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB7IHlLZXksIHhWYWx1ZSwgeVZhbHVlLCBkYXR1bSB9ID0gbm9kZURhdHVtO1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWF07XHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5ZXTtcclxuICAgICAgICBpZiAoISh4S2V5ICYmIHlLZXkpIHx8ICEoeEF4aXMgJiYgeUF4aXMgJiYgaXNOdW1iZXIoeVZhbHVlKSkgfHwgIWRhdGFNb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHhTdHJpbmcgPSB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHlTdHJpbmcgPSB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHlOYW1lKTtcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyAnOiAnICsgeVN0cmluZyk7XHJcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyh7IGZpbGw6IHRoaXMuZmlsbCB9LCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xyXG4gICAgICAgICAgICBzdHJva2U6IHRoaXMuc3Ryb2tlLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB7IGZpbGw6IGNvbG9yIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKG1hcmtlciwgeyBkYXR1bTogbm9kZURhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogZmFsc2UgfSwgYmFzZVN0eWxlKTtcclxuICAgICAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSwge1xyXG4gICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgeEtleSxcclxuICAgICAgICAgICAgeE5hbWUsXHJcbiAgICAgICAgICAgIHlLZXksXHJcbiAgICAgICAgICAgIHlOYW1lLFxyXG4gICAgICAgICAgICBjb2xvcixcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIHNlcmllc0lkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGlkLCB4S2V5LCB5S2V5LCB5TmFtZSwgbWFya2VyLCBmaWxsLCBzdHJva2UsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCB2aXNpYmxlIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5sZW5ndGgpIHx8ICF4S2V5IHx8ICF5S2V5IHx8IGxlZ2VuZFR5cGUgIT09ICdjYXRlZ29yeScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRUeXBlLFxyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICBpdGVtSWQ6IHlLZXksXHJcbiAgICAgICAgICAgICAgICBzZXJpZXNJZDogaWQsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB5TmFtZSAhPT0gbnVsbCAmJiB5TmFtZSAhPT0gdm9pZCAwID8geU5hbWUgOiB5S2V5LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG1hcmtlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogKF9hID0gbWFya2VyLmZpbGwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAoX2IgPSBtYXJrZXIuc3Ryb2tlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzdHJva2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IChfYyA9IG1hcmtlci5maWxsT3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmlsbE9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogKF9kID0gbWFya2VyLnN0cm9rZU9wYWNpdHkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IChfZSA9IG1hcmtlci5zdHJva2VXaWR0aCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcclxuICAgICAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbnMsIGxhYmVsU2VsZWN0aW9ucywgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xyXG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XHJcbiAgICAgICAgY29uc3QgeyBzZXJpZXNSZWN0V2lkdGg6IHdpZHRoID0gMCB9ID0gdGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcztcclxuICAgICAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xyXG4gICAgICAgIHBhdGhTd2lwZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIHBhdGhzLmZsYXQoKSk7XHJcbiAgICAgICAgcmVzZXRNb3Rpb24obWFya2VyU2VsZWN0aW9ucywgcmVzZXRNYXJrZXJQb3NpdGlvbkZuKTtcclxuICAgICAgICBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9ucywgd2lkdGgpO1xyXG4gICAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsICdsYWJlbHMnLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpIHtcclxuICAgICAgICBjb25zdCB7IGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xyXG4gICAgICAgIHN1cGVyLmFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcclxuICAgICAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbnMsIGxhYmVsU2VsZWN0aW9ucywgY29udGV4dERhdGEsIHBhdGhzLCBwcmV2aW91c0NvbnRleHREYXRhIH0gPSBhbmltYXRpb25EYXRhO1xyXG4gICAgICAgIHN1cGVyLnJlc2V0QWxsQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgICAgIGlmIChjb250ZXh0RGF0YS5sZW5ndGggPT09IDAgfHwgIXByZXZpb3VzQ29udGV4dERhdGEgfHwgcHJldmlvdXNDb250ZXh0RGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW1tmaWxsLCBzdHJva2VdXSA9IHBhdGhzO1xyXG4gICAgICAgIGNvbnN0IFtuZXdEYXRhXSA9IGNvbnRleHREYXRhO1xyXG4gICAgICAgIGNvbnN0IFtvbGREYXRhXSA9IHByZXZpb3VzQ29udGV4dERhdGE7XHJcbiAgICAgICAgY29uc3QgZm5zID0gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uKG5ld0RhdGEsIG9sZERhdGEsIChfYiA9IChfYSA9IHRoaXMucHJvY2Vzc2VkRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZHVjZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaWZmKTtcclxuICAgICAgICBpZiAoZm5zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsICdtYXJrZXJfdXBkYXRlJywgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9ucywgZm5zLm1hcmtlcik7XHJcbiAgICAgICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsICdmaWxsX3BhdGhfcHJvcGVydGllcycsIGFuaW1hdGlvbk1hbmFnZXIsIFtmaWxsXSwgZm5zLmZpbGwucGF0aFByb3BlcnRpZXMpO1xyXG4gICAgICAgIHBhdGhNb3Rpb24odGhpcy5pZCwgJ2ZpbGxfcGF0aF91cGRhdGUnLCBhbmltYXRpb25NYW5hZ2VyLCBbZmlsbF0sIGZucy5maWxsLnBhdGgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3Ryb2tlUGF0aChwYXRocywgY29udGV4dERhdGEpO1xyXG4gICAgICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgJ3N0cm9rZScsIGFuaW1hdGlvbk1hbmFnZXIsIFtzdHJva2VdKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnbGFiZWxzJywgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcclxuICAgIH1cclxuICAgIGlzTGFiZWxFbmFibGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsLmVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBub2RlRmFjdG9yeSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdyb3VwKCk7XHJcbiAgICB9XHJcbn1cclxuQXJlYVNlcmllcy5jbGFzc05hbWUgPSAnQXJlYVNlcmllcyc7XHJcbkFyZWFTZXJpZXMudHlwZSA9ICdhcmVhJztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQXJlYVNlcmllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKENPTE9SX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBBcmVhU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBBcmVhU2VyaWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDAsIDEpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbl0sIEFyZWFTZXJpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTElORV9EQVNIKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgQXJlYVNlcmllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBcmVhU2VyaWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQXJlYVNlcmllcy5wcm90b3R5cGUsIFwieEtleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQXJlYVNlcmllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEFyZWFTZXJpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEFyZWFTZXJpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUigwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBBcmVhU2VyaWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBBcmVhU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCB2b2lkIDApO1xuXG5jb25zdCBBcmVhU2VyaWVzTW9kdWxlID0ge1xyXG4gICAgdHlwZTogJ3NlcmllcycsXHJcbiAgICBvcHRpb25zS2V5OiAnc2VyaWVzW10nLFxyXG4gICAgcGFja2FnZVR5cGU6ICdjb21tdW5pdHknLFxyXG4gICAgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nXSxcclxuICAgIGlkZW50aWZpZXI6ICdhcmVhJyxcclxuICAgIGluc3RhbmNlQ29uc3RydWN0b3I6IEFyZWFTZXJpZXMsXHJcbiAgICBzdGFja2FibGU6IHRydWUsXHJcbiAgICBzZXJpZXNEZWZhdWx0czogREVGQVVMVF9DQVJURVNJQU5fQ0hBUlRfT1ZFUlJJREVTLFxyXG4gICAgdGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIF9fZXh0ZW5kc19fOiBFWFRFTkRTX1NFUklFU19ERUZBVUxUUyxcclxuICAgICAgICBub2RlQ2xpY2tSYW5nZTogJ25lYXJlc3QnLFxyXG4gICAgICAgIHRvb2x0aXA6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdub2RlJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXHJcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMCxcclxuICAgICAgICBsaW5lRGFzaDogWzBdLFxyXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxyXG4gICAgICAgIHNoYWRvdzoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcclxuICAgICAgICAgICAgeE9mZnNldDogMyxcclxuICAgICAgICAgICAgeU9mZnNldDogMyxcclxuICAgICAgICAgICAgYmx1cjogNSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcmtlcjoge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHNfXzogRVhURU5EU19DQVJURVNJQU5fTUFSS0VSX0RFRkFVTFRTLFxyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGZvbnRTdHlsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBmb250V2VpZ2h0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcclxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxyXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIHBhbGV0dGVGYWN0b3J5OiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBtYXJrZXIgfSA9IG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogbWFya2VyLmZpbGwsXHJcbiAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLnN0cm9rZSxcclxuICAgICAgICAgICAgbWFya2VyLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xuXG5jbGFzcyBBYnN0cmFjdEJhclNlcmllcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ3ZlcnRpY2FsJztcclxuICAgIH1cclxuICAgIGdldEJhbmRTY2FsZVBhZGRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgaW5uZXI6IDAuMiwgb3V0ZXI6IDAuMSB9O1xyXG4gICAgfVxyXG4gICAgc2hvdWxkRmxpcFhZKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnO1xyXG4gICAgfVxyXG4gICAgZ2V0QmFyRGlyZWN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNob3VsZEZsaXBYWSgpID8gQ2hhcnRBeGlzRGlyZWN0aW9uLlggOiBDaGFydEF4aXNEaXJlY3Rpb24uWTtcclxuICAgIH1cclxuICAgIGdldENhdGVnb3J5RGlyZWN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNob3VsZEZsaXBYWSgpID8gQ2hhcnRBeGlzRGlyZWN0aW9uLlkgOiBDaGFydEF4aXNEaXJlY3Rpb24uWDtcclxuICAgIH1cclxuICAgIGdldFZhbHVlQXhpcygpIHtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldEJhckRpcmVjdGlvbigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcclxuICAgIH1cclxuICAgIGdldENhdGVnb3J5QXhpcygpIHtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoRElSRUNUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEFic3RyYWN0QmFyU2VyaWVzLnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcblxuZnVuY3Rpb24gdXBkYXRlUmVjdCh7IHJlY3QsIGNvbmZpZyB9KSB7XHJcbiAgICBjb25zdCB7IGNyaXNwID0gdHJ1ZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgZmlsbFNoYWRvdywgdmlzaWJsZSA9IHRydWUsIH0gPSBjb25maWc7XHJcbiAgICByZWN0LmNyaXNwID0gY3Jpc3A7XHJcbiAgICByZWN0LmZpbGwgPSBmaWxsO1xyXG4gICAgcmVjdC5zdHJva2UgPSBzdHJva2U7XHJcbiAgICByZWN0LnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XHJcbiAgICByZWN0LmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHk7XHJcbiAgICByZWN0LnN0cm9rZU9wYWNpdHkgPSBzdHJva2VPcGFjaXR5O1xyXG4gICAgcmVjdC5saW5lRGFzaCA9IGxpbmVEYXNoO1xyXG4gICAgcmVjdC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xyXG4gICAgcmVjdC5maWxsU2hhZG93ID0gZmlsbFNoYWRvdztcclxuICAgIHJlY3QudmlzaWJsZSA9IHZpc2libGU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVjdENvbmZpZyhfYSkge1xyXG4gICAgdmFyIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgIHZhciB7IGRhdHVtLCBpc0hpZ2hsaWdodGVkLCBzdHlsZSwgaGlnaGxpZ2h0U3R5bGUsIGZvcm1hdHRlciwgc2VyaWVzSWQsIGN0eDogeyBjYWxsYmFja0NhY2hlIH0gfSA9IF9hLCBvcHRzID0gX19yZXN0KF9hLCBbXCJkYXR1bVwiLCBcImlzSGlnaGxpZ2h0ZWRcIiwgXCJzdHlsZVwiLCBcImhpZ2hsaWdodFN0eWxlXCIsIFwiZm9ybWF0dGVyXCIsIFwic2VyaWVzSWRcIiwgXCJjdHhcIl0pO1xyXG4gICAgY29uc3QgeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCB9ID0gbWVyZ2VEZWZhdWx0cyhpc0hpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLCBzdHlsZSk7XHJcbiAgICBjb25zdCB7IHN0cm9rZU9wYWNpdHksIGZpbGxTaGFkb3csIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCB9ID0gc3R5bGU7XHJcbiAgICBsZXQgZm9ybWF0O1xyXG4gICAgaWYgKGZvcm1hdHRlcikge1xyXG4gICAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIE9iamVjdC5hc3NpZ24oeyBkYXR1bTogZGF0dW0uZGF0dW0sIHhLZXk6IGRhdHVtLnhLZXksIGZpbGwsXHJcbiAgICAgICAgICAgIHN0cm9rZSxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsIGhpZ2hsaWdodGVkOiBpc0hpZ2hsaWdodGVkLCBzZXJpZXNJZCB9LCBvcHRzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpbGw6IChfYiA9IGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5maWxsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmaWxsLFxyXG4gICAgICAgIHN0cm9rZTogKF9jID0gZm9ybWF0ID09PSBudWxsIHx8IGZvcm1hdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0LnN0cm9rZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogc3Ryb2tlLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiAoX2QgPSBmb3JtYXQgPT09IG51bGwgfHwgZm9ybWF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXQuc3Ryb2tlV2lkdGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHN0cm9rZVdpZHRoLFxyXG4gICAgICAgIGZpbGxPcGFjaXR5OiAoX2UgPSBmb3JtYXQgPT09IG51bGwgfHwgZm9ybWF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXQuZmlsbE9wYWNpdHkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZpbGxPcGFjaXR5LFxyXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IChfZiA9IGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5zdHJva2VPcGFjaXR5KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBzdHJva2VPcGFjaXR5LFxyXG4gICAgICAgIGxpbmVEYXNoLFxyXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0LFxyXG4gICAgICAgIGZpbGxTaGFkb3csXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrQ3Jpc3AodmlzaWJsZVJhbmdlID0gW10pIHtcclxuICAgIGNvbnN0IFt2aXNpYmxlTWluLCB2aXNpYmxlTWF4XSA9IHZpc2libGVSYW5nZTtcclxuICAgIGNvbnN0IGlzWm9vbWVkID0gdmlzaWJsZU1pbiAhPT0gMCB8fCB2aXNpYmxlTWF4ICE9PSAxO1xyXG4gICAgcmV0dXJuICFpc1pvb21lZDtcclxufVxyXG5mdW5jdGlvbiBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKGlzVmVydGljYWwsIGF4ZXMpIHtcclxuICAgIGNvbnN0IHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfSA9IGdldFN0YXJ0aW5nVmFsdWVzKGlzVmVydGljYWwsIGF4ZXMpO1xyXG4gICAgY29uc3QgaXNEYXR1bU5lZ2F0aXZlID0gKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBpc05lZ2F0aXZlKChfYSA9IGRhdHVtWyd5VmFsdWUnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgY2FsY3VsYXRlID0gKGRhdHVtLCBwcmV2RGF0dW0pID0+IHtcclxuICAgICAgICBsZXQgeCA9IGlzVmVydGljYWwgPyBkYXR1bS54IDogc3RhcnRpbmdYO1xyXG4gICAgICAgIGxldCB5ID0gaXNWZXJ0aWNhbCA/IHN0YXJ0aW5nWSA6IGRhdHVtLnk7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gaXNWZXJ0aWNhbCA/IGRhdHVtLndpZHRoIDogMDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gaXNWZXJ0aWNhbCA/IDAgOiBkYXR1bS5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKHByZXZEYXR1bSAmJiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpKSB7XHJcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXHJcbiAgICAgICAgICAgICh7IHgsIHkgfSA9IHByZXZEYXR1bSk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gaXNWZXJ0aWNhbCA/IHByZXZEYXR1bS53aWR0aCA6IDA7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGlzVmVydGljYWwgPyAwIDogcHJldkRhdHVtLmhlaWdodDtcclxuICAgICAgICAgICAgaWYgKGlzVmVydGljYWwgJiYgIWlzRGF0dW1OZWdhdGl2ZShwcmV2RGF0dW0pKSB7XHJcbiAgICAgICAgICAgICAgICB5ICs9IHByZXZEYXR1bS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVmVydGljYWwgJiYgaXNEYXR1bU5lZ2F0aXZlKHByZXZEYXR1bSkpIHtcclxuICAgICAgICAgICAgICAgIHggKz0gcHJldkRhdHVtLndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4geyBpc1ZlcnRpY2FsLCBjYWxjdWxhdGUgfTtcclxufVxyXG5mdW5jdGlvbiBtaWRwb2ludFN0YXJ0aW5nQmFyUG9zaXRpb24oaXNWZXJ0aWNhbCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1ZlcnRpY2FsLFxyXG4gICAgICAgIGNhbGN1bGF0ZTogKGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBpc1ZlcnRpY2FsID8gZGF0dW0ueCA6IGRhdHVtLnggKyBkYXR1bS53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiBpc1ZlcnRpY2FsID8gZGF0dW0ueSArIGRhdHVtLmhlaWdodCAvIDIgOiBkYXR1bS55LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGlzVmVydGljYWwgPyBkYXR1bS53aWR0aCA6IDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGlzVmVydGljYWwgPyAwIDogZGF0dW0uaGVpZ2h0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoaW5pdFBvcykge1xyXG4gICAgY29uc3QgaXNSZW1vdmVkID0gKGRhdHVtKSA9PiBkYXR1bSA9PSBudWxsIHx8IGlzTmFOKGRhdHVtLngpIHx8IGlzTmFOKGRhdHVtLnkpO1xyXG4gICAgY29uc3QgZnJvbUZuID0gKHJlY3QsIGRhdHVtLCBzdGF0dXMpID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAndXBkYXRlZCcgJiYgaXNSZW1vdmVkKGRhdHVtKSkge1xyXG4gICAgICAgICAgICBzdGF0dXMgPSAncmVtb3ZlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ3VwZGF0ZWQnICYmIGlzUmVtb3ZlZChyZWN0LnByZXZpb3VzRGF0dW0pKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9ICdhZGRlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbnRpbnVlIGZyb20gY3VycmVudCByZW5kZXJpbmcgbG9jYXRpb24uXHJcbiAgICAgICAgbGV0IHNvdXJjZSA9IHsgeDogcmVjdC54LCB5OiByZWN0LnksIHdpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0IH07XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3Vua25vd24nIHx8IHN0YXR1cyA9PT0gJ2FkZGVkJykge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBpbml0UG9zLmNhbGN1bGF0ZShkYXR1bSwgcmVjdC5wcmV2aW91c0RhdHVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc291cmNlKSwgRlJPTV9UT19NSVhJTlNbc3RhdHVzXSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdG9GbiA9IChyZWN0LCBkYXR1bSwgc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlbW92ZWQnIHx8IGlzUmVtb3ZlZChkYXR1bSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluaXRQb3MuY2FsY3VsYXRlKGRhdHVtLCByZWN0LnByZXZpb3VzRGF0dW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB4OiBkYXR1bS54LCB5OiBkYXR1bS55LCB3aWR0aDogZGF0dW0ud2lkdGgsIGhlaWdodDogZGF0dW0uaGVpZ2h0IH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHsgdG9GbiwgZnJvbUZuIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3RhcnRpbmdWYWx1ZXMoaXNWZXJ0aWNhbCwgYXhlcykge1xyXG4gICAgY29uc3QgYXhpcyA9IGF4ZXNbaXNWZXJ0aWNhbCA/IENoYXJ0QXhpc0RpcmVjdGlvbi5ZIDogQ2hhcnRBeGlzRGlyZWN0aW9uLlhdO1xyXG4gICAgbGV0IHN0YXJ0aW5nWCA9IEluZmluaXR5O1xyXG4gICAgbGV0IHN0YXJ0aW5nWSA9IDA7XHJcbiAgICBpZiAoIWF4aXMpIHtcclxuICAgICAgICByZXR1cm4geyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICBzdGFydGluZ1kgPSBheGlzLnNjYWxlLmNvbnZlcnQoQ29udGludW91c1NjYWxlLmlzKGF4aXMuc2NhbGUpID8gMCA6IE1hdGgubWF4KC4uLmF4aXMucmFuZ2UpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXJ0aW5nWCA9IGF4aXMuc2NhbGUuY29udmVydChDb250aW51b3VzU2NhbGUuaXMoYXhpcy5zY2FsZSkgPyAwIDogTWF0aC5taW4oLi4uYXhpcy5yYW5nZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfTtcclxufVxyXG5mdW5jdGlvbiByZXNldEJhclNlbGVjdGlvbnNGbihfbm9kZSwgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pIHtcclxuICAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfTtcclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMYWJlbE5vZGUodGV4dE5vZGUsIGxhYmVsLCBsYWJlbERhdHVtKSB7XHJcbiAgICBpZiAobGFiZWwuZW5hYmxlZCAmJiBsYWJlbERhdHVtKSB7XHJcbiAgICAgICAgY29uc3QgeyB4LCB5LCB0ZXh0LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSB9ID0gbGFiZWxEYXR1bTtcclxuICAgICAgICBjb25zdCB7IGNvbG9yOiBmaWxsLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5IH0gPSBsYWJlbDtcclxuICAgICAgICB0ZXh0Tm9kZS5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgZmlsbCxcclxuICAgICAgICAgICAgZm9udFN0eWxlLFxyXG4gICAgICAgICAgICBmb250V2VpZ2h0LFxyXG4gICAgICAgICAgICBmb250U2l6ZSxcclxuICAgICAgICAgICAgZm9udEZhbWlseSxcclxuICAgICAgICAgICAgdGV4dEFsaWduLFxyXG4gICAgICAgICAgICB0ZXh0QmFzZWxpbmUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0ZXh0Tm9kZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRqdXN0TGFiZWxQbGFjZW1lbnQoeyBpc1Bvc2l0aXZlLCBpc1ZlcnRpY2FsLCBwbGFjZW1lbnQsIHBhZGRpbmcgPSAwLCByZWN0LCB9KSB7XHJcbiAgICBsZXQgeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xyXG4gICAgbGV0IHkgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XHJcbiAgICBsZXQgdGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcbiAgICBzd2l0Y2ggKHBsYWNlbWVudCkge1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0Jzoge1xyXG4gICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgeSA9IGlzUG9zaXRpdmUgPyByZWN0LnkgKyByZWN0LmhlaWdodCArIHBhZGRpbmcgOiByZWN0LnkgLSBwYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gaXNQb3NpdGl2ZSA/ICd0b3AnIDogJ2JvdHRvbSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gaXNQb3NpdGl2ZSA/IHJlY3QueCAtIHBhZGRpbmcgOiByZWN0LnggKyByZWN0LndpZHRoICsgcGFkZGluZztcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGlzUG9zaXRpdmUgPyAnc3RhcnQnIDogJ2VuZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ291dHNpZGUnOlxyXG4gICAgICAgIGNhc2UgJ2VuZCc6IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHkgPSBpc1Bvc2l0aXZlID8gcmVjdC55IC0gcGFkZGluZyA6IHJlY3QueSArIHJlY3QuaGVpZ2h0ICsgcGFkZGluZztcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IGlzUG9zaXRpdmUgPyAnYm90dG9tJyA6ICd0b3AnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeCA9IGlzUG9zaXRpdmUgPyByZWN0LnggKyByZWN0LndpZHRoICsgcGFkZGluZyA6IHJlY3QueCAtIHBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBpc1Bvc2l0aXZlID8gJ3N0YXJ0JyA6ICdlbmQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IHgsIHksIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lIH07XHJcbn1cblxudmFyIEJhclNlcmllc05vZGVUYWc7XHJcbihmdW5jdGlvbiAoQmFyU2VyaWVzTm9kZVRhZykge1xyXG4gICAgQmFyU2VyaWVzTm9kZVRhZ1tCYXJTZXJpZXNOb2RlVGFnW1wiQmFyXCJdID0gMF0gPSBcIkJhclwiO1xyXG4gICAgQmFyU2VyaWVzTm9kZVRhZ1tCYXJTZXJpZXNOb2RlVGFnW1wiTGFiZWxcIl0gPSAxXSA9IFwiTGFiZWxcIjtcclxufSkoQmFyU2VyaWVzTm9kZVRhZyB8fCAoQmFyU2VyaWVzTm9kZVRhZyA9IHt9KSk7XHJcbmNsYXNzIEJhclNlcmllc0xhYmVsIGV4dGVuZHMgTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnBsYWNlbWVudCA9ICdpbnNpZGUnO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoU1RSSU5HX1VOSU9OKCdpbnNpZGUnLCAnb3V0c2lkZScpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJhclNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwgdm9pZCAwKTtcclxuY2xhc3MgQmFyU2VyaWVzIGV4dGVuZHMgQWJzdHJhY3RCYXJTZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBtb2R1bGVDdHgsXHJcbiAgICAgICAgICAgIHBpY2tNb2RlczogW1Nlcmllc05vZGVQaWNrTW9kZS5FWEFDVF9TSEFQRV9NQVRDSF0sXHJcbiAgICAgICAgICAgIHBhdGhzUGVyU2VyaWVzOiAwLFxyXG4gICAgICAgICAgICBoYXNIaWdobGlnaHRlZExhYmVsczogdHJ1ZSxcclxuICAgICAgICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XHJcbiAgICAgICAgICAgICAgICBkYXR1bTogcmVzZXRCYXJTZWxlY3Rpb25zRm4sXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgQmFyU2VyaWVzTGFiZWwoKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xyXG4gICAgICAgIHRoaXMuZmlsbCA9ICcjYzE2MDY4JztcclxuICAgICAgICB0aGlzLnN0cm9rZSA9ICcjODc0MzQ5JztcclxuICAgICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMubGluZURhc2ggPSBbMF07XHJcbiAgICAgICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy54S2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueE5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy55S2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueU5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdGFja0dyb3VwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuc2hhZG93ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBiYXJzIHdpdGhpbiBlYWNoIGdyb3VwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JvdXBTY2FsZSA9IG5ldyBCYW5kU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRCYXJEaXJlY3Rpb24oKSA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlgpIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDaGFydEF4aXNEaXJlY3Rpb24uWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2hhcnRBeGlzRGlyZWN0aW9uLlg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHhLZXksIHlLZXksIG5vcm1hbGl6ZWRUbywgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQgfSA9IHt9LCBkYXRhID0gW10gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh4S2V5ID09IG51bGwgfHwgeUtleSA9PSBudWxsIHx8IGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVG9BYnMgPSBNYXRoLmFicyhub3JtYWxpemVkVG8gIT09IG51bGwgJiYgbm9ybWFsaXplZFRvICE9PSB2b2lkIDAgPyBub3JtYWxpemVkVG8gOiBOYU4pO1xyXG4gICAgICAgICAgICBjb25zdCBpc0NvbnRpbnVvdXNYID0gQ29udGludW91c1NjYWxlLmlzKChfYSA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2FsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ29udGludW91c1kgPSBDb250aW51b3VzU2NhbGUuaXMoKF9iID0gdGhpcy5nZXRWYWx1ZUF4aXMoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjYWxlKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhY2tHcm91cE5hbWUgPSBgYmFyLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlc2A7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrR3JvdXBUcmFpbGluZ05hbWUgPSBgJHtzdGFja0dyb3VwTmFtZX0tdHJhaWxpbmdgO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpc2VUbyA9IG5vcm1hbGl6ZWRUb0FicyAmJiBpc0Zpbml0ZShub3JtYWxpemVkVG9BYnMpID8gbm9ybWFsaXplZFRvQWJzIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBjb25zdCBleHRyYVByb3BzID0gW107XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpc2VUbykge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFQcm9wcy5wdXNoKG5vcm1hbGlzZUdyb3VwVG8odGhpcywgW3N0YWNrR3JvdXBOYW1lLCBzdGFja0dyb3VwVHJhaWxpbmdOYW1lXSwgbm9ybWFsaXNlVG8sICdyYW5nZScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhUHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbih0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZVByb3BzID0gIXRoaXMudmlzaWJsZSA/IHsgZm9yY2VWYWx1ZTogMCB9IDoge307XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSB9ID0geWllbGQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XHJcbiAgICAgICAgICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BlcnR5KHRoaXMsIHhLZXksIGlzQ29udGludW91c1gsIHsgaWQ6ICd4VmFsdWUnIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgT2JqZWN0LmFzc2lnbih7IGlkOiBgeVZhbHVlLXJhd2AsIGludmFsaWRWYWx1ZTogbnVsbCB9LCB2aXNpYmxlUHJvcHMpKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgJ25vcm1hbCcsICdjdXJyZW50JywgT2JqZWN0LmFzc2lnbih7IGlkOiBgeVZhbHVlLWVuZGAsIGludmFsaWRWYWx1ZTogbnVsbCwgbWlzc2luZ1ZhbHVlOiAwLCBncm91cElkOiBzdGFja0dyb3VwTmFtZSwgc2VwYXJhdGVOZWdhdGl2ZTogdHJ1ZSB9LCB2aXNpYmxlUHJvcHMpKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgJ3RyYWlsaW5nJywgJ2N1cnJlbnQnLCBPYmplY3QuYXNzaWduKHsgaWQ6IGB5VmFsdWUtc3RhcnRgLCBpbnZhbGlkVmFsdWU6IG51bGwsIG1pc3NpbmdWYWx1ZTogMCwgZ3JvdXBJZDogc3RhY2tHcm91cFRyYWlsaW5nTmFtZSwgc2VwYXJhdGVOZWdhdGl2ZTogdHJ1ZSB9LCB2aXNpYmxlUHJvcHMpKSxcclxuICAgICAgICAgICAgICAgICAgICAuLi4oaXNDb250aW51b3VzWCA/IFtTTUFMTEVTVF9LRVlfSU5URVJWQUxdIDogW10pLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4dHJhUHJvcHMsXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBCeUtleXM6IHRydWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsID0ge1xyXG4gICAgICAgICAgICAgICAgeDogKF9kID0gKF9jID0gcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc21hbGxlc3RLZXlJbnRlcnZhbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogSW5maW5pdHksXHJcbiAgICAgICAgICAgICAgICB5OiBJbmZpbml0eSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKCd1cGRhdGVEYXRhJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgY29uc3QgeyByZWR1Y2VkOiB7IFtTTUFMTEVTVF9LRVlfSU5URVJWQUwucHJvcGVydHldOiBzbWFsbGVzdFggfSA9IHt9IH0gPSBwcm9jZXNzZWREYXRhO1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5QXhpcyA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcclxuICAgICAgICBjb25zdCBrZXlEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgJ2tleScsIHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIGNvbnN0IHlFeHRlbnQgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5VmFsdWUtZW5kYCwgJ3ZhbHVlJywgcHJvY2Vzc2VkRGF0YSk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpKSB7XHJcbiAgICAgICAgICAgIGlmICgoa2V5RGVmID09PSBudWxsIHx8IGtleURlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDoga2V5RGVmLmRlZi50eXBlKSA9PT0gJ2tleScgJiYgKGtleURlZiA9PT0gbnVsbCB8fCBrZXlEZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGtleURlZi5kZWYudmFsdWVUeXBlKSA9PT0gJ2NhdGVnb3J5Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2NhbGVQYWRkaW5nID0gc21hbGxlc3RYICE9IG51bGwgJiYgaXNGaW5pdGUoc21hbGxlc3RYKSA/IHNtYWxsZXN0WCA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXNFeHRlbnQgPSAoX2EgPSBleHRlbnQoa2V5cykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtOYU4sIE5hTl07XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IENoYXJ0QXhpc0RpcmVjdGlvbi5ZKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChba2V5c0V4dGVudFswXSArIC1zY2FsZVBhZGRpbmcsIGtleXNFeHRlbnRbMV1dLCBjYXRlZ29yeUF4aXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KFtrZXlzRXh0ZW50WzBdLCBrZXlzRXh0ZW50WzFdICsgc2NhbGVQYWRkaW5nXSwgY2F0ZWdvcnlBeGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5nZXRWYWx1ZUF4aXMoKSBpbnN0YW5jZW9mIExvZ0F4aXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeUV4dGVudCwgdmFsdWVBeGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpeGVkWUV4dGVudCA9IFt5RXh0ZW50WzBdID4gMCA/IDAgOiB5RXh0ZW50WzBdLCB5RXh0ZW50WzFdIDwgMCA/IDAgOiB5RXh0ZW50WzFdXTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZml4ZWRZRXh0ZW50LCB2YWx1ZUF4aXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZU5vZGVEYXRhKCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBjYWxjdWxhdGVTY2FsaW5nOiB7IGdldDogKCkgPT4gc3VwZXIuY2FsY3VsYXRlU2NhbGluZyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhTW9kZWwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKTtcclxuICAgICAgICAgICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldFZhbHVlQXhpcygpO1xyXG4gICAgICAgICAgICBpZiAoIShkYXRhTW9kZWwgJiYgeEF4aXMgJiYgeUF4aXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdyb3VwU2NhbGUsIHlLZXkgPSAnJywgeEtleSA9ICcnLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBsYWJlbCwgcHJvY2Vzc2VkRGF0YSwgY3R4OiB7IHNlcmllc1N0YXRlTWFuYWdlciB9LCBzbWFsbGVzdERhdGFJbnRlcnZhbCwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHhCYW5kV2lkdGggPSBDb250aW51b3VzU2NhbGUuaXMoeFNjYWxlKVxyXG4gICAgICAgICAgICAgICAgPyB4U2NhbGUuY2FsY0JhbmR3aWR0aChzbWFsbGVzdERhdGFJbnRlcnZhbCA9PT0gbnVsbCB8fCBzbWFsbGVzdERhdGFJbnRlcnZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc21hbGxlc3REYXRhSW50ZXJ2YWwueClcclxuICAgICAgICAgICAgICAgIDogeFNjYWxlLmJhbmR3aWR0aDtcclxuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaW5kZXg6IGdyb3VwSW5kZXgsIHZpc2libGVHcm91cENvdW50IH0gPSBzZXJpZXNTdGF0ZU1hbmFnZXIuZ2V0VmlzaWJsZVBlZXJHcm91cEluZGV4KHRoaXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBncm91cElkeCA9IDA7IGdyb3VwSWR4IDwgdmlzaWJsZUdyb3VwQ291bnQ7IGdyb3VwSWR4KyspIHtcclxuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKFN0cmluZyhncm91cElkeCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyb3VwU2NhbGUuZG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgICAgICBncm91cFNjYWxlLnJhbmdlID0gWzAsIHhCYW5kV2lkdGggIT09IG51bGwgJiYgeEJhbmRXaWR0aCAhPT0gdm9pZCAwID8geEJhbmRXaWR0aCA6IDBdO1xyXG4gICAgICAgICAgICBpZiAoeEF4aXMgaW5zdGFuY2VvZiBDYXRlZ29yeUF4aXMpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwU2NhbGUucGFkZGluZ0lubmVyID0geEF4aXMuZ3JvdXBQYWRkaW5nSW5uZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoeEF4aXMgaW5zdGFuY2VvZiBHcm91cGVkQ2F0ZWdvcnlBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cFNjYWxlLnBhZGRpbmcgPSAwLjE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOdW1iZXIgb3IgVGltZSBheGlzXHJcbiAgICAgICAgICAgICAgICBncm91cFNjYWxlLnBhZGRpbmcgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRvIGdldCBleGFjdGx5IGAwYCBwYWRkaW5nIHdlIG5lZWQgdG8gdHVybiBvZmYgcm91bmRpbmdcclxuICAgICAgICAgICAgZ3JvdXBTY2FsZS5yb3VuZCA9IGdyb3VwU2NhbGUucGFkZGluZyAhPT0gMDtcclxuICAgICAgICAgICAgY29uc3QgYmFyV2lkdGggPSBncm91cFNjYWxlLmJhbmR3aWR0aCA+PSAxXHJcbiAgICAgICAgICAgICAgICA/IC8vIFBpeGVsLXJvdW5kZWQgdmFsdWUgZm9yIGxvdy12b2x1bWUgYmFyIGNoYXJ0cy5cclxuICAgICAgICAgICAgICAgICAgICBncm91cFNjYWxlLmJhbmR3aWR0aFxyXG4gICAgICAgICAgICAgICAgOiAvLyBIYW5kbGUgaGlnaC12b2x1bWUgYmFyIGNoYXJ0cyBncmFjZWZ1bGx5LlxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU2NhbGUucmF3QmFuZHdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCB4SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHhWYWx1ZWApLmluZGV4O1xyXG4gICAgICAgICAgICBjb25zdCB5UmF3SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1yYXdgKS5pbmRleDtcclxuICAgICAgICAgICAgY29uc3QgeVN0YXJ0SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1zdGFydGApLmluZGV4O1xyXG4gICAgICAgICAgICBjb25zdCB5RW5kSW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1lbmRgKS5pbmRleDtcclxuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgaXRlbUlkOiB5S2V5LFxyXG4gICAgICAgICAgICAgICAgbm9kZURhdGE6IFtdLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxEYXRhOiBbXSxcclxuICAgICAgICAgICAgICAgIHNjYWxlczogX3N1cGVyLmNhbGN1bGF0ZVNjYWxpbmcuY2FsbCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSB8fCBhbmltYXRpb25FbmFibGVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBwcm9jZXNzZWREYXRhID09PSBudWxsIHx8IHByb2Nlc3NlZERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3NlZERhdGEuZGF0YS5mb3JFYWNoKCh7IGtleXMsIGRhdHVtOiBzZXJpZXNEYXR1bSwgdmFsdWVzIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhWYWx1ZSA9IGtleXNbeEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclkgPSArdmFsdWVzWzBdW3lFbmRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2WSA9ICt2YWx1ZXNbMF1beVN0YXJ0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeVJhd1ZhbHVlID0gdmFsdWVzWzBdW3lSYXdJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJYID0geCArIGdyb3VwU2NhbGUuY29udmVydChTdHJpbmcoZ3JvdXBJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGN1cnJZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydChjdXJyWSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21ZID0geVNjYWxlLmNvbnZlcnQocHJldlkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFyQWxvbmdYID0gdGhpcy5nZXRCYXJEaXJlY3Rpb24oKSA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGJhckFsb25nWCA/IE1hdGgubWluKHksIGJvdHRvbVkpIDogYmFyWCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBiYXJBbG9uZ1ggPyBiYXJYIDogTWF0aC5taW4oeSwgYm90dG9tWSksXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJhckFsb25nWCA/IE1hdGguYWJzKGJvdHRvbVkgLSB5KSA6IGJhcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYmFyQWxvbmdYID8gYmFyV2lkdGggOiBNYXRoLmFicyhib3R0b21ZIC0geSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBmb250U3R5bGU6IGxhYmVsRm9udFN0eWxlLCBmb250V2VpZ2h0OiBsYWJlbEZvbnRXZWlnaHQsIGZvbnRTaXplOiBsYWJlbEZvbnRTaXplLCBmb250RmFtaWx5OiBsYWJlbEZvbnRGYW1pbHksIGNvbG9yOiBsYWJlbENvbG9yLCBwbGFjZW1lbnQsIH0gPSBsYWJlbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KHRoaXMubGFiZWwsIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW1bMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHlSYXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgeE5hbWU6IHRoaXMueE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgeU5hbWU6IHRoaXMueU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kSXRlbU5hbWU6IHRoaXMubGVnZW5kSXRlbU5hbWUsXHJcbiAgICAgICAgICAgICAgICB9LCAodmFsdWUpID0+IChpc051bWJlcih2YWx1ZSkgPyB2YWx1ZS50b0ZpeGVkKDIpIDogJycpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsRGF0dW0gPSBsYWJlbFRleHRcclxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oeyB0ZXh0OiBsYWJlbFRleHQsIGZpbGw6IGxhYmVsQ29sb3IsIGZvbnRTdHlsZTogbGFiZWxGb250U3R5bGUsIGZvbnRXZWlnaHQ6IGxhYmVsRm9udFdlaWdodCwgZm9udFNpemU6IGxhYmVsRm9udFNpemUsIGZvbnRGYW1pbHk6IGxhYmVsRm9udEZhbWlseSB9LCBhZGp1c3RMYWJlbFBsYWNlbWVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUG9zaXRpdmU6IHlSYXdWYWx1ZSA+PSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiAhYmFyQWxvbmdYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyID0gdGhpcy5zaG91bGRGbGlwWFkoKSA/IHJlY3QuaGVpZ2h0IDogcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllczogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVWYWx1ZTogY3VyclksXHJcbiAgICAgICAgICAgICAgICAgICAgeFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHlWYWx1ZTogeVJhd1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgeEtleSxcclxuICAgICAgICAgICAgICAgICAgICBjYXBEZWZhdWx0czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhSYXRpb011bHRpcGxpZXI6IGxlbmd0aFJhdGlvTXVsdGlwbGllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoTWF4OiBsZW5ndGhSYXRpb011bHRpcGxpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB4OiByZWN0LngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcmVjdC55LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlkUG9pbnQ6IHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbERhdHVtLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQubm9kZURhdGEucHVzaChub2RlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxhYmVsRGF0YS5wdXNoKG5vZGVEYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbY29udGV4dF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBub2RlRmFjdG9yeSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0cy5kYXR1bVNlbGVjdGlvbi51cGRhdGUob3B0cy5ub2RlRGF0YSwgKHJlY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlY3QudGFnID0gQmFyU2VyaWVzTm9kZVRhZy5CYXI7XHJcbiAgICAgICAgICAgIH0sIChkYXR1bSkgPT4gZGF0dW0ueFZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZURhdHVtTm9kZXMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0dW1TZWxlY3Rpb24sIGlzSGlnaGxpZ2h0IH0gPSBvcHRzO1xyXG4gICAgICAgICAgICBjb25zdCB7IHlLZXkgPSAnJywgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBzaGFkb3csIGZvcm1hdHRlciwgaWQ6IHNlcmllc0lkLCBoaWdobGlnaHRTdHlsZTogeyBpdGVtOiBpdGVtSGlnaGxpZ2h0U3R5bGUgfSwgY3R4LCBzdGFja0dyb3VwLCB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgeEF4aXMgPSB0aGlzLmF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlhdO1xyXG4gICAgICAgICAgICBjb25zdCBjcmlzcCA9IGNoZWNrQ3Jpc3AoeEF4aXMgPT09IG51bGwgfHwgeEF4aXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHhBeGlzLnZpc2libGVSYW5nZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5QWxvbmdYID0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpID09PSBDaGFydEF4aXNEaXJlY3Rpb24uWDtcclxuICAgICAgICAgICAgZGF0dW1TZWxlY3Rpb24uZWFjaCgocmVjdCwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2gsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2hPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFNoYWRvdzogc2hhZG93LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMuc3Ryb2tlV2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSBjYXRlZ29yeUFsb25nWCA/IGRhdHVtLndpZHRoID4gMCA6IGRhdHVtLmhlaWdodCA+IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBnZXRSZWN0Q29uZmlnKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICBpc0hpZ2hsaWdodGVkOiBpc0hpZ2hsaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRTdHlsZTogaXRlbUhpZ2hsaWdodFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcixcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNJZCxcclxuICAgICAgICAgICAgICAgICAgICBzdGFja0dyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcclxuICAgICAgICAgICAgICAgICAgICB5S2V5LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuY3Jpc3AgPSBjcmlzcDtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVJlY3QoeyByZWN0LCBjb25maWcgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmxhYmVsLmVuYWJsZWQgPyBvcHRzLmxhYmVsRGF0YSA6IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoZGF0YSwgKHRleHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRleHQudGFnID0gQmFyU2VyaWVzTm9kZVRhZy5MYWJlbDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IFBvaW50ZXJFdmVudHMuTm9uZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHROb2RlLCBkYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlTGFiZWxOb2RlKHRleHROb2RlLCB0aGlzLmxhYmVsLCBkYXR1bS5sYWJlbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHsgeEtleSwgeUtleSwgcHJvY2Vzc2VkRGF0YSwgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpO1xyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcclxuICAgICAgICBjb25zdCB7IHhWYWx1ZSwgeVZhbHVlLCBkYXR1bSB9ID0gbm9kZURhdHVtO1xyXG4gICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAheEtleSB8fCAheUtleSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB4TmFtZSwgeU5hbWUsIGZpbGwsIHN0cm9rZSwgdG9vbHRpcCwgZm9ybWF0dGVyLCBpZDogc2VyaWVzSWQsIHN0YWNrR3JvdXAgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMuc3Ryb2tlV2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IHhTdHJpbmcgPSB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHlTdHJpbmcgPSB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHlOYW1lKTtcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyAnOiAnICsgeVN0cmluZyk7XHJcbiAgICAgICAgbGV0IGZvcm1hdDtcclxuICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgICAgICAgICAgZmlsbCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgeEtleSxcclxuICAgICAgICAgICAgICAgIHlLZXksXHJcbiAgICAgICAgICAgICAgICBzZXJpZXNJZCxcclxuICAgICAgICAgICAgICAgIHN0YWNrR3JvdXAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb2xvciA9IChfYSA9IGZvcm1hdCA9PT0gbnVsbCB8fCBmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdC5maWxsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWxsO1xyXG4gICAgICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LCBPYmplY3QuYXNzaWduKHsgZGF0dW0sXHJcbiAgICAgICAgICAgIHhLZXksXHJcbiAgICAgICAgICAgIHhOYW1lLFxyXG4gICAgICAgICAgICB5S2V5LFxyXG4gICAgICAgICAgICB5TmFtZSxcclxuICAgICAgICAgICAgY29sb3IsXHJcbiAgICAgICAgICAgIHRpdGxlLFxyXG4gICAgICAgICAgICBzZXJpZXNJZCxcclxuICAgICAgICAgICAgc3RhY2tHcm91cCB9LCB0aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoZGF0dW0pKSk7XHJcbiAgICB9XHJcbiAgICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBpZCwgZGF0YSwgeEtleSwgeUtleSwgeU5hbWUsIGxlZ2VuZEl0ZW1OYW1lLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgdmlzaWJsZSwgc2hvd0luTGVnZW5kLCB9ID0gdGhpcztcclxuICAgICAgICBpZiAobGVnZW5kVHlwZSAhPT0gJ2NhdGVnb3J5JyB8fCAhc2hvd0luTGVnZW5kIHx8ICEoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmxlbmd0aCkgfHwgIXhLZXkgfHwgIXlLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRUeXBlOiAnY2F0ZWdvcnknLFxyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICBpdGVtSWQ6IHlLZXksXHJcbiAgICAgICAgICAgICAgICBzZXJpZXNJZDogaWQsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHsgdGV4dDogKF9hID0gbGVnZW5kSXRlbU5hbWUgIT09IG51bGwgJiYgbGVnZW5kSXRlbU5hbWUgIT09IHZvaWQgMCA/IGxlZ2VuZEl0ZW1OYW1lIDogeU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHlLZXkgfSxcclxuICAgICAgICAgICAgICAgIG1hcmtlcjogeyBmaWxsLCBzdHJva2UsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCB9LFxyXG4gICAgICAgICAgICAgICAgbGVnZW5kSXRlbU5hbWUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgZGF0dW1TZWxlY3Rpb25zLCBsYWJlbFNlbGVjdGlvbnMsIGFubm90YXRpb25TZWxlY3Rpb25zIH0pIHtcclxuICAgICAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcsIHRoaXMuYXhlcykpO1xyXG4gICAgICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCAnbm9kZXMnLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBkYXR1bVNlbGVjdGlvbnMsIGZucyk7XHJcbiAgICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgJ2xhYmVscycsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9ucyk7XHJcbiAgICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgJ2Fubm90YXRpb25zJywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IGRhdHVtU2VsZWN0aW9ucywgbGFiZWxTZWxlY3Rpb25zLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyB9ID0gZGF0YTtcclxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IChfYiA9IChfYSA9IHRoaXMucHJvY2Vzc2VkRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZHVjZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaWZmO1xyXG4gICAgICAgIGNvbnN0IGZucyA9IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbih0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJywgdGhpcy5heGVzKSk7XHJcbiAgICAgICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsICdub2RlcycsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGRhdHVtU2VsZWN0aW9ucywgZm5zLCAoXywgZGF0dW0pID0+IFN0cmluZyhkYXR1bS54VmFsdWUpLCBkaWZmKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnbGFiZWxzJywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnYW5ub3RhdGlvbnMnLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBpc0xhYmVsRW5hYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5lbmFibGVkO1xyXG4gICAgfVxyXG59XHJcbkJhclNlcmllcy5jbGFzc05hbWUgPSAnQmFyU2VyaWVzJztcclxuQmFyU2VyaWVzLnR5cGUgPSAnYmFyJztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJhclNlcmllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQmFyU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBCYXJTZXJpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCwgMSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgQmFyU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0xJTkVfREFTSCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIEJhclNlcmllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBCYXJTZXJpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0ZVTkNUSU9OKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuXSwgQmFyU2VyaWVzLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJhclNlcmllcy5wcm90b3R5cGUsIFwieEtleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQmFyU2VyaWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQmFyU2VyaWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBCYXJTZXJpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBCYXJTZXJpZXMucHJvdG90eXBlLCBcInN0YWNrR3JvdXBcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSKCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgQmFyU2VyaWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBCYXJTZXJpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIHZvaWQgMCk7XG5cbmNvbnN0IEJhclNlcmllc01vZHVsZSA9IHtcclxuICAgIHR5cGU6ICdzZXJpZXMnLFxyXG4gICAgb3B0aW9uc0tleTogJ3Nlcmllc1tdJyxcclxuICAgIHBhY2thZ2VUeXBlOiAnY29tbXVuaXR5JyxcclxuICAgIGNoYXJ0VHlwZXM6IFsnY2FydGVzaWFuJ10sXHJcbiAgICBpZGVudGlmaWVyOiAnYmFyJyxcclxuICAgIGluc3RhbmNlQ29uc3RydWN0b3I6IEJhclNlcmllcyxcclxuICAgIHN0YWNrYWJsZTogdHJ1ZSxcclxuICAgIGdyb3VwYWJsZTogdHJ1ZSxcclxuICAgIHNlcmllc0RlZmF1bHRzOiB7XHJcbiAgICAgICAgYXhlczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBDQVJURVNJQU5fQVhJU19UWVBFUy5OVU1CRVIsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogQ0FSVEVTSUFOX0FYSVNfUE9TSVRJT05TLkxFRlQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IENBUlRFU0lBTl9BWElTX1RZUEVTLkNBVEVHT1JZLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IENBUlRFU0lBTl9BWElTX1BPU0lUSU9OUy5CT1RUT00sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICBzd2FwRGVmYXVsdEF4ZXNDb25kaXRpb246IChzZXJpZXMpID0+IChzZXJpZXMgPT09IG51bGwgfHwgc2VyaWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJpZXMuZGlyZWN0aW9uKSA9PT0gJ2hvcml6b250YWwnLFxyXG4gICAgdGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIF9fZXh0ZW5kc19fOiBFWFRFTkRTX1NFUklFU19ERUZBVUxUUyxcclxuICAgICAgICBmaWxsT3BhY2l0eTogMSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMCxcclxuICAgICAgICBsaW5lRGFzaDogWzBdLFxyXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogTk9STUFMLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxyXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcGxhY2VtZW50OiAnaW5zaWRlJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNoYWRvdzoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcclxuICAgICAgICAgICAgeE9mZnNldDogMyxcclxuICAgICAgICAgICAgeU9mZnNldDogMyxcclxuICAgICAgICAgICAgYmx1cjogNSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIGVudGVycHJpc2VUaGVtZVRlbXBsYXRlOiB7XHJcbiAgICAgICAgZXJyb3JCYXI6IHtcclxuICAgICAgICAgICAgY2FwOiB7XHJcbiAgICAgICAgICAgICAgICBsZW5ndGhSYXRpbzogMC4zLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgcGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5LFxyXG59O1xuXG5jbGFzcyBCdWJibGVTZXJpZXNOb2RlQ2xpY2tFdmVudCBleHRlbmRzIENhcnRlc2lhblNlcmllc05vZGVDbGlja0V2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XHJcbiAgICAgICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xyXG4gICAgICAgIHRoaXMuc2l6ZUtleSA9IHNlcmllcy5zaXplS2V5O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEJ1YmJsZVNlcmllc01hcmtlciBleHRlbmRzIFNlcmllc01hcmtlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzZXJpZXMgYHNpemVLZXlgIHZhbHVlcyBhbG9uZyB3aXRoIHRoZSBgc2l6ZWAgYW5kIGBtYXhTaXplYCBjb25maWdzIHdpbGwgYmUgdXNlZCB0b1xyXG4gICAgICAgICAqIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgbWFya2VyLiBBbGwgdmFsdWVzIHdpbGwgYmUgbWFwcGVkIHRvIGEgbWFya2VyIHNpemUgd2l0aGluIHRoZVxyXG4gICAgICAgICAqIGBbc2l6ZSwgbWF4U2l6ZV1gIHJhbmdlLCB3aGVyZSB0aGUgbGFyZ2VzdCB2YWx1ZXMgd2lsbCBjb3JyZXNwb25kIHRvIHRoZSBgbWF4U2l6ZWAgYW5kIHRoZVxyXG4gICAgICAgICAqIGxvd2VzdCB0byB0aGUgYHNpemVgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IDMwO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IFJlZHJhd1R5cGUuTUFKT1IgfSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBCdWJibGVTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcIm1heFNpemVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfTlVNQkVSX0FSUkFZKSxcclxuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiBSZWRyYXdUeXBlLk1BSk9SIH0pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG5dLCBCdWJibGVTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImRvbWFpblwiLCB2b2lkIDApO1xyXG5jbGFzcyBCdWJibGVTZXJpZXMgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBtb2R1bGVDdHgsXHJcbiAgICAgICAgICAgIHBpY2tNb2RlczogW1xyXG4gICAgICAgICAgICAgICAgU2VyaWVzTm9kZVBpY2tNb2RlLk5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNULFxyXG4gICAgICAgICAgICAgICAgU2VyaWVzTm9kZVBpY2tNb2RlLk5FQVJFU1RfTk9ERSxcclxuICAgICAgICAgICAgICAgIFNlcmllc05vZGVQaWNrTW9kZS5FWEFDVF9TSEFQRV9NQVRDSCxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgcGF0aHNQZXJTZXJpZXM6IDAsXHJcbiAgICAgICAgICAgIGhhc01hcmtlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiByZXNldExhYmVsRm4sXHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHJlc2V0TWFya2VyRm4sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5Ob2RlQ2xpY2tFdmVudCA9IEJ1YmJsZVNlcmllc05vZGVDbGlja0V2ZW50O1xyXG4gICAgICAgIHRoaXMuc2l6ZVNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBuZXcgQnViYmxlU2VyaWVzTWFya2VyKCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5sYWJlbEtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnhOYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueU5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zaXplTmFtZSA9ICdTaXplJztcclxuICAgICAgICB0aGlzLmxhYmVsTmFtZSA9ICdMYWJlbCc7XHJcbiAgICAgICAgdGhpcy54S2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueUtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnNpemVLZXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jb2xvcktleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvbG9yTmFtZSA9ICdDb2xvcic7XHJcbiAgICAgICAgdGhpcy5jb2xvclJhbmdlID0gWycjZmZmZjAwJywgJyMwMGZmMDAnLCAnIzAwMDBmZiddO1xyXG4gICAgICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5LCBjb2xvclNjYWxlLCBjb2xvckRvbWFpbiwgY29sb3JSYW5nZSwgY29sb3JLZXksIG1hcmtlciwgZGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHhLZXkgPT0gbnVsbCB8fCB5S2V5ID09IG51bGwgfHwgc2l6ZUtleSA9PSBudWxsIHx8IGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgeyBpc0NvbnRpbnVvdXNYLCBpc0NvbnRpbnVvdXNZIH0gPSB0aGlzLmlzQ29udGludW91cygpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0geWllbGQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XHJcbiAgICAgICAgICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BlcnR5KHRoaXMsIHhLZXksIGlzQ29udGludW91c1gsIHsgaWQ6ICd4S2V5LXJhdycgfSksXHJcbiAgICAgICAgICAgICAgICAgICAga2V5UHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgeyBpZDogJ3lLZXktcmF3JyB9KSxcclxuICAgICAgICAgICAgICAgICAgICAuLi4obGFiZWxLZXkgPyBba2V5UHJvcGVydHkodGhpcywgbGFiZWxLZXksIGZhbHNlLCB7IGlkOiBgbGFiZWxLZXktcmF3YCB9KV0gOiBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVQcm9wZXJ0eSh0aGlzLCB4S2V5LCBpc0NvbnRpbnVvdXNYLCB7IGlkOiBgeFZhbHVlYCB9KSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVByb3BlcnR5KHRoaXMsIHlLZXksIGlzQ29udGludW91c1ksIHsgaWQ6IGB5VmFsdWVgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlUHJvcGVydHkodGhpcywgc2l6ZUtleSwgdHJ1ZSwgeyBpZDogYHNpemVWYWx1ZWAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKGNvbG9yS2V5ID8gW3ZhbHVlUHJvcGVydHkodGhpcywgY29sb3JLZXksIHRydWUsIHsgaWQ6IGBjb2xvclZhbHVlYCB9KV0gOiBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKGxhYmVsS2V5ID8gW3ZhbHVlUHJvcGVydHkodGhpcywgbGFiZWxLZXksIGZhbHNlLCB7IGlkOiBgbGFiZWxWYWx1ZWAgfSldIDogW10pLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIGRhdGFWaXNpYmxlOiB0aGlzLnZpc2libGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBzaXplS2V5SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzaXplVmFsdWVgKS5pbmRleDtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkU2l6ZSA9IChfYSA9IHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlc1tzaXplS2V5SWR4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZVNjYWxlLmRvbWFpbiA9IG1hcmtlci5kb21haW4gPyBtYXJrZXIuZG9tYWluIDogcHJvY2Vzc2VkU2l6ZTtcclxuICAgICAgICAgICAgaWYgKGNvbG9yS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvcktleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgY29sb3JTY2FsZS5kb21haW4gPSAoX2IgPSBjb2xvckRvbWFpbiAhPT0gbnVsbCAmJiBjb2xvckRvbWFpbiAhPT0gdm9pZCAwID8gY29sb3JEb21haW4gOiBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbY29sb3JLZXlJZHhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcclxuICAgICAgICAgICAgICAgIGNvbG9yU2NhbGUucmFuZ2UgPSBjb2xvclJhbmdlO1xyXG4gICAgICAgICAgICAgICAgY29sb3JTY2FsZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oJ3VwZGF0ZURhdGEnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcclxuICAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIGNvbnN0IGlkID0gZGlyZWN0aW9uID09PSBDaGFydEF4aXNEaXJlY3Rpb24uWCA/IGB4VmFsdWVgIDogYHlWYWx1ZWA7XHJcbiAgICAgICAgY29uc3QgZGF0YURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgaWQpO1xyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgaWQsICd2YWx1ZScsIHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIGlmICgoZGF0YURlZiA9PT0gbnVsbCB8fCBkYXRhRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhRGVmLmRlZi50eXBlKSA9PT0gJ3ZhbHVlJyAmJiAoZGF0YURlZiA9PT0gbnVsbCB8fCBkYXRhRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhRGVmLmRlZi52YWx1ZVR5cGUpID09PSAnY2F0ZWdvcnknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcclxuICAgICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSwgYXhpcyk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVOb2RlRGF0YSgpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgY2FsY3VsYXRlU2NhbGluZzogeyBnZXQ6ICgpID0+IHN1cGVyLmNhbGN1bGF0ZVNjYWxpbmcgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZpc2libGUsIGF4ZXMsIHlLZXkgPSAnJywgeEtleSA9ICcnLCBsYWJlbCwgbGFiZWxLZXksIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgY29sb3JTY2FsZSwgc2l6ZUtleSA9ICcnLCBjb2xvcktleSwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHhBeGlzID0gYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWF07XHJcbiAgICAgICAgICAgIGNvbnN0IHlBeGlzID0gYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWV07XHJcbiAgICAgICAgICAgIGlmICghKGRhdGFNb2RlbCAmJiBwcm9jZXNzZWREYXRhICYmIHZpc2libGUgJiYgeEF4aXMgJiYgeUF4aXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICBjb25zdCB4RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCkuaW5kZXg7XHJcbiAgICAgICAgICAgIGNvbnN0IHlEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWVgKS5pbmRleDtcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZURhdGFJZHggPSBzaXplS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzaXplVmFsdWVgKS5pbmRleCA6IC0xO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvckRhdGFJZHggPSBjb2xvcktleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApLmluZGV4IDogLTE7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsRGF0YUlkeCA9IGxhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsYWJlbFZhbHVlYCkuaW5kZXggOiAtMTtcclxuICAgICAgICAgICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHlTY2FsZSA9IHlBeGlzLnNjYWxlO1xyXG4gICAgICAgICAgICBjb25zdCB4T2Zmc2V0ID0gKChfYSA9IHhTY2FsZS5iYW5kd2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIC8gMjtcclxuICAgICAgICAgICAgY29uc3QgeU9mZnNldCA9ICgoX2IgPSB5U2NhbGUuYmFuZHdpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2l6ZVNjYWxlLCBtYXJrZXIgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGVEYXRhID0gW107XHJcbiAgICAgICAgICAgIHNpemVTY2FsZS5yYW5nZSA9IFttYXJrZXIuc2l6ZSwgbWFya2VyLm1heFNpemVdO1xyXG4gICAgICAgICAgICBjb25zdCBmb250ID0gbGFiZWwuZ2V0Rm9udCgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdmFsdWVzLCBkYXR1bSB9IG9mIChfYyA9IHByb2Nlc3NlZERhdGEuZGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhEYXR1bSA9IHZhbHVlc1t4RGF0YUlkeF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5RGF0dW0gPSB2YWx1ZXNbeURhdGFJZHhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSkgKyB5T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQobGFiZWwsIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGFiZWxLZXkgPyB2YWx1ZXNbbGFiZWxEYXRhSWR4XSA6IHlEYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUtleSxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbEtleSxcclxuICAgICAgICAgICAgICAgICAgICB4TmFtZTogdGhpcy54TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB5TmFtZTogdGhpcy55TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplTmFtZTogdGhpcy5zaXplTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbE5hbWU6IHRoaXMubGFiZWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gSGRwaUNhbnZhcy5nZXRUZXh0U2l6ZShTdHJpbmcobGFiZWxUZXh0KSwgZm9udCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJTaXplID0gc2l6ZUtleSA/IHNpemVTY2FsZS5jb252ZXJ0KHZhbHVlc1tzaXplRGF0YUlkeF0pIDogbWFya2VyLnNpemU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsID0gY29sb3JLZXkgPyBjb2xvclNjYWxlLmNvbnZlcnQodmFsdWVzW2NvbG9yRGF0YUlkeF0pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgbm9kZURhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogeUtleSxcclxuICAgICAgICAgICAgICAgICAgICB5S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHhLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgeFZhbHVlOiB4RGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgeVZhbHVlOiB5RGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVZhbHVlOiB2YWx1ZXNbc2l6ZURhdGFJZHhdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiB7IHgsIHksIHNpemU6IG1hcmtlclNpemUgfSxcclxuICAgICAgICAgICAgICAgICAgICBtaWRQb2ludDogeyB4LCB5IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbCxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogT2JqZWN0LmFzc2lnbih7IHRleHQ6IGxhYmVsVGV4dCB9LCBzaXplKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiAoX2QgPSB0aGlzLnlLZXkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZXM6IF9zdXBlci5jYWxjdWxhdGVTY2FsaW5nLmNhbGwodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2VyLmlzRGlydHkoKTtcclxuICAgIH1cclxuICAgIGdldExhYmVsRGF0YSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY29udGV4dE5vZGVEYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkdWNlKChyLCBuKSA9PiByLmNvbmNhdChuLmxhYmVsRGF0YSksIFtdKTtcclxuICAgIH1cclxuICAgIG1hcmtlckZhY3RvcnkoKSB7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5tYXJrZXI7XHJcbiAgICAgICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBub2RlRGF0YSwgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMubWFya2VyLmVuYWJsZWQgPyBub2RlRGF0YSA6IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZShkYXRhLCB1bmRlZmluZWQsIChkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcclxuICAgICAgICAgICAgY29uc3QgeyB4S2V5ID0gJycsIHlLZXkgPSAnJywgc2l6ZUtleSA9ICcnLCBsYWJlbEtleSwgbWFya2VyIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKGhpZ2hsaWdodGVkICYmIHRoaXMuaGlnaGxpZ2h0U3R5bGUuaXRlbSwgbWFya2VyLmdldFN0eWxlKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnNpemVTY2FsZS5yYW5nZSA9IFttYXJrZXIuc2l6ZSwgbWFya2VyLm1heFNpemVdO1xyXG4gICAgICAgICAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSwgYmFzZVN0eWxlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VyLm1hcmtDbGVhbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsOiB7IGVuYWJsZWQgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlZExhYmVscyA9IGVuYWJsZWQgPyAoX2IgPSAoX2EgPSB0aGlzLmNoYXJ0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxhY2VMYWJlbHMoKS5nZXQodGhpcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdIDogW107XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlZE5vZGVEYXR1bSA9IHBsYWNlZExhYmVscy5tYXAoKHYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHYuZGF0dW0pLCB7IHBvaW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogdi54LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHYueSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplOiB2LmRhdHVtLnBvaW50LnNpemUsXHJcbiAgICAgICAgICAgICAgICB9IH0pKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbFNlbGVjdGlvbi51cGRhdGUocGxhY2VkTm9kZURhdHVtKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHQgPSBkYXR1bS5sYWJlbC50ZXh0O1xyXG4gICAgICAgICAgICAgICAgdGV4dC5maWxsID0gbGFiZWwuY29sb3I7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnggPSAoX2IgPSAoX2EgPSBkYXR1bS5wb2ludCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLngpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnkgPSAoX2QgPSAoX2MgPSBkYXR1bS5wb2ludCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcclxuICAgICAgICAgICAgICAgIHRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xyXG4gICAgICAgICAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGF4ZXMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5YXTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldO1xyXG4gICAgICAgIGlmICgheEtleSB8fCAheUtleSB8fCAheEF4aXMgfHwgIXlBeGlzIHx8ICFzaXplS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBtYXJrZXIsIHRvb2x0aXAsIHhOYW1lLCB5TmFtZSwgc2l6ZU5hbWUsIGxhYmVsS2V5LCBsYWJlbE5hbWUsIGlkOiBzZXJpZXNJZCB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKHsgZmlsbDogbm9kZURhdHVtLmZpbGwsIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKG1hcmtlci5zdHJva2VXaWR0aCkgfSwgbWFya2VyLmdldFN0eWxlKCkpO1xyXG4gICAgICAgIGNvbnN0IHsgZmlsbDogY29sb3IgPSAnZ3JheScgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUobWFya2VyLCB7IGRhdHVtOiBub2RlRGF0dW0sIGhpZ2hsaWdodGVkOiBmYWxzZSwgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSwgYmFzZVN0eWxlKTtcclxuICAgICAgICBjb25zdCB0aXRsZSA9IChfYSA9IHRoaXMudGl0bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHlOYW1lO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0dW0sIHhWYWx1ZSwgeVZhbHVlLCBzaXplVmFsdWUsIGxhYmVsOiB7IHRleHQ6IGxhYmVsVGV4dCB9LCB9ID0gbm9kZURhdHVtO1xyXG4gICAgICAgIGNvbnN0IHhTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKSk7XHJcbiAgICAgICAgY29uc3QgeVN0cmluZyA9IHNhbml0aXplSHRtbCh5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpKTtcclxuICAgICAgICBsZXQgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbCh4TmFtZSAhPT0gbnVsbCAmJiB4TmFtZSAhPT0gdm9pZCAwID8geE5hbWUgOiB4S2V5KX08L2I+OiAke3hTdHJpbmd9PGJyPmAgK1xyXG4gICAgICAgICAgICBgPGI+JHtzYW5pdGl6ZUh0bWwoeU5hbWUgIT09IG51bGwgJiYgeU5hbWUgIT09IHZvaWQgMCA/IHlOYW1lIDogeUtleSl9PC9iPjogJHt5U3RyaW5nfWA7XHJcbiAgICAgICAgaWYgKHNpemVLZXkpIHtcclxuICAgICAgICAgICAgY29udGVudCArPSBgPGJyPjxiPiR7c2FuaXRpemVIdG1sKHNpemVOYW1lICE9PSBudWxsICYmIHNpemVOYW1lICE9PSB2b2lkIDAgPyBzaXplTmFtZSA6IHNpemVLZXkpfTwvYj46ICR7c2FuaXRpemVIdG1sKFN0cmluZyhzaXplVmFsdWUpKX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFiZWxLZXkpIHtcclxuICAgICAgICAgICAgY29udGVudCA9IGA8Yj4ke3Nhbml0aXplSHRtbChsYWJlbE5hbWUgIT09IG51bGwgJiYgbGFiZWxOYW1lICE9PSB2b2lkIDAgPyBsYWJlbE5hbWUgOiBsYWJlbEtleSl9PC9iPjogJHtzYW5pdGl6ZUh0bWwobGFiZWxUZXh0KX08YnI+YCArIGNvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LCB7XHJcbiAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICB4TmFtZSxcclxuICAgICAgICAgICAgeUtleSxcclxuICAgICAgICAgICAgeU5hbWUsXHJcbiAgICAgICAgICAgIHNpemVLZXksXHJcbiAgICAgICAgICAgIHNpemVOYW1lLFxyXG4gICAgICAgICAgICBsYWJlbEtleSxcclxuICAgICAgICAgICAgbGFiZWxOYW1lLFxyXG4gICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgY29sb3IsXHJcbiAgICAgICAgICAgIHNlcmllc0lkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TGVnZW5kRGF0YSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBpZCwgZGF0YSwgeEtleSwgeUtleSwgc2l6ZUtleSwgeU5hbWUsIHRpdGxlLCB2aXNpYmxlLCBtYXJrZXIgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZSwgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGggfSA9IG1hcmtlcjtcclxuICAgICAgICBpZiAoISgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmxlbmd0aCkgJiYgeEtleSAmJiB5S2V5ICYmIHNpemVLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kVHlwZTogJ2NhdGVnb3J5JyxcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgaXRlbUlkOiB5S2V5LFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzSWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKF9hID0gdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogeU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHlLZXksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbWFya2VyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCAhPT0gbnVsbCAmJiBmaWxsICE9PSB2b2lkIDAgPyBmaWxsIDogJ3JnYmEoMCwgMCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlICE9PSBudWxsICYmIHN0cm9rZSAhPT0gdm9pZCAwID8gc3Ryb2tlIDogJ3JnYmEoMCwgMCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSAhPT0gbnVsbCAmJiBmaWxsT3BhY2l0eSAhPT0gdm9pZCAwID8gZmlsbE9wYWNpdHkgOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHkgIT09IG51bGwgJiYgc3Ryb2tlT3BhY2l0eSAhPT0gdm9pZCAwID8gc3Ryb2tlT3BhY2l0eSA6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoICE9PSBudWxsICYmIHN0cm9rZVdpZHRoICE9PSB2b2lkIDAgPyBzdHJva2VXaWR0aCA6IDAsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeSh7IG1hcmtlclNlbGVjdGlvbnMsIGxhYmVsU2VsZWN0aW9ucyB9KSB7XHJcbiAgICAgICAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbih0aGlzLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb25zKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnbGFiZWxzJywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcclxuICAgIH1cclxuICAgIGdldERhdHVtSWQoZGF0dW0pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRGF0dW1JZChbYCR7ZGF0dW0ueFZhbHVlfWAsIGAke2RhdHVtLnlWYWx1ZX1gLCBkYXR1bS5sYWJlbC50ZXh0XSk7XHJcbiAgICB9XHJcbiAgICBpc0xhYmVsRW5hYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5lbmFibGVkO1xyXG4gICAgfVxyXG4gICAgbm9kZUZhY3RvcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcm91cCgpO1xyXG4gICAgfVxyXG59XHJcbkJ1YmJsZVNlcmllcy5jbGFzc05hbWUgPSAnQnViYmxlU2VyaWVzJztcclxuQnViYmxlU2VyaWVzLnR5cGUgPSAnYnViYmxlJztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJ1YmJsZVNlcmllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJ1YmJsZVNlcmllcy5wcm90b3R5cGUsIFwibGFiZWxLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJ1YmJsZVNlcmllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJ1YmJsZVNlcmllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJ1YmJsZVNlcmllcy5wcm90b3R5cGUsIFwic2l6ZU5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJ1YmJsZVNlcmllcy5wcm90b3R5cGUsIFwibGFiZWxOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBCdWJibGVTZXJpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEJ1YmJsZVNlcmllcy5wcm90b3R5cGUsIFwieUtleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgQnViYmxlU2VyaWVzLnByb3RvdHlwZSwgXCJzaXplS2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBCdWJibGVTZXJpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBCdWJibGVTZXJpZXMucHJvdG90eXBlLCBcImNvbG9yTmFtZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVJfQVJSQVkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG5dLCBCdWJibGVTZXJpZXMucHJvdG90eXBlLCBcImNvbG9yRG9tYWluXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgQnViYmxlU2VyaWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIHZvaWQgMCk7XG5cbmNvbnN0IEJ1YmJsZVNlcmllc01vZHVsZSA9IHtcclxuICAgIHR5cGU6ICdzZXJpZXMnLFxyXG4gICAgb3B0aW9uc0tleTogJ3Nlcmllc1tdJyxcclxuICAgIHBhY2thZ2VUeXBlOiAnY29tbXVuaXR5JyxcclxuICAgIGNoYXJ0VHlwZXM6IFsnY2FydGVzaWFuJ10sXHJcbiAgICBpZGVudGlmaWVyOiAnYnViYmxlJyxcclxuICAgIGluc3RhbmNlQ29uc3RydWN0b3I6IEJ1YmJsZVNlcmllcyxcclxuICAgIHNlcmllc0RlZmF1bHRzOiB7XHJcbiAgICAgICAgYXhlczogW1xyXG4gICAgICAgICAgICB7IHR5cGU6IENBUlRFU0lBTl9BWElTX1RZUEVTLk5VTUJFUiwgcG9zaXRpb246IENBUlRFU0lBTl9BWElTX1BPU0lUSU9OUy5CT1RUT00gfSxcclxuICAgICAgICAgICAgeyB0eXBlOiBDQVJURVNJQU5fQVhJU19UWVBFUy5OVU1CRVIsIHBvc2l0aW9uOiBDQVJURVNJQU5fQVhJU19QT1NJVElPTlMuTEVGVCB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAgdGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIF9fZXh0ZW5kc19fOiBFWFRFTkRTX1NFUklFU19ERUZBVUxUUyxcclxuICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbm9kZScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYXJrZXI6IHtcclxuICAgICAgICAgICAgX19leHRlbmRzX186IEVYVEVORFNfQ0FSVEVTSUFOX01BUktFUl9ERUZBVUxUUyxcclxuICAgICAgICAgICAgbWF4U2l6ZTogMzAsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZm9udFN0eWxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxyXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBwYWxldHRlRmFjdG9yeTogbWFya2VyUGFsZXR0ZUZhY3RvcnksXHJcbn07XG5cbmNvbnN0IEhJU1RPR1JBTV9BR0dSRUdBVElPTlMgPSBbJ2NvdW50JywgJ3N1bScsICdtZWFuJ107XHJcbmNvbnN0IEhJU1RPR1JBTV9BR0dSRUdBVElPTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2KSA9PiBISVNUT0dSQU1fQUdHUkVHQVRJT05TLmluY2x1ZGVzKHYpLCBgZXhwZWN0aW5nIGEgaGlzdG9ncmFtIGFnZ3JlZ2F0aW9uIGtleXdvcmQgc3VjaCBhcyAnY291bnQnLCAnc3VtJyBvciAnbWVhbmApO1xyXG52YXIgSGlzdG9ncmFtU2VyaWVzTm9kZVRhZztcclxuKGZ1bmN0aW9uIChIaXN0b2dyYW1TZXJpZXNOb2RlVGFnKSB7XHJcbiAgICBIaXN0b2dyYW1TZXJpZXNOb2RlVGFnW0hpc3RvZ3JhbVNlcmllc05vZGVUYWdbXCJCaW5cIl0gPSAwXSA9IFwiQmluXCI7XHJcbiAgICBIaXN0b2dyYW1TZXJpZXNOb2RlVGFnW0hpc3RvZ3JhbVNlcmllc05vZGVUYWdbXCJMYWJlbFwiXSA9IDFdID0gXCJMYWJlbFwiO1xyXG59KShIaXN0b2dyYW1TZXJpZXNOb2RlVGFnIHx8IChIaXN0b2dyYW1TZXJpZXNOb2RlVGFnID0ge30pKTtcclxuY29uc3QgZGVmYXVsdEJpbkNvdW50ID0gMTA7XHJcbmNsYXNzIEhpc3RvZ3JhbVNlcmllcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcclxuICAgICAgICBzdXBlcih7XHJcbiAgICAgICAgICAgIG1vZHVsZUN0eCxcclxuICAgICAgICAgICAgcGlja01vZGVzOiBbU2VyaWVzTm9kZVBpY2tNb2RlLkVYQUNUX1NIQVBFX01BVENIXSxcclxuICAgICAgICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XHJcbiAgICAgICAgICAgICAgICBkYXR1bTogcmVzZXRCYXJTZWxlY3Rpb25zRm4sXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgTGFiZWwoKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xyXG4gICAgICAgIHRoaXMuZmlsbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0cm9rZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMubGluZURhc2ggPSBbMF07XHJcbiAgICAgICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy54S2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYXJlYVBsb3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0aW9uID0gJ3N1bSc7XHJcbiAgICAgICAgdGhpcy5iaW5Db3VudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnhOYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueUtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnlOYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuc2hhZG93ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlZEJpbnMgPSBbXTtcclxuICAgIH1cclxuICAgIC8vIER1cmluZyBwcm9jZXNzRGF0YSBwaGFzZSwgdXNlZCB0byB1bmlmeSBkaWZmZXJlbnQgd2F5cyBvZiB0aGUgdXNlciBzcGVjaWZ5aW5nXHJcbiAgICAvLyB0aGUgYmlucy4gUmV0dXJucyBiaW5zIGluIGZvcm1hdFtbbWluMSwgbWF4MV0sIFttaW4yLCBtYXgyXSwgLi4uIF0uXHJcbiAgICBkZXJpdmVCaW5zKHhEb21haW4pIHtcclxuICAgICAgICBpZiAodGhpcy5iaW5Db3VudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJpblN0YXJ0cyA9IHRpY2tzKHhEb21haW5bMF0sIHhEb21haW5bMV0sIGRlZmF1bHRCaW5Db3VudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJpblNpemUgPSB0aWNrU3RlcCh4RG9tYWluWzBdLCB4RG9tYWluWzFdLCBkZWZhdWx0QmluQ291bnQpO1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdEJpbkVuZCA9IGJpblN0YXJ0c1swXTtcclxuICAgICAgICAgICAgY29uc3QgZXhwYW5kU3RhcnRUb0JpbiA9IChuKSA9PiBbbiwgbiArIGJpblNpemVdO1xyXG4gICAgICAgICAgICByZXR1cm4gW1tmaXJzdEJpbkVuZCAtIGJpblNpemUsIGZpcnN0QmluRW5kXSwgLi4uYmluU3RhcnRzLm1hcChleHBhbmRTdGFydFRvQmluKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVOaWNlQmlucyh4RG9tYWluLCB0aGlzLmJpbkNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVOaWNlQmlucyhkb21haW4sIGJpbkNvdW50KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRHdWVzcyA9IE1hdGguZmxvb3IoZG9tYWluWzBdKTtcclxuICAgICAgICBjb25zdCBzdG9wID0gZG9tYWluWzFdO1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gYmluQ291bnQgfHwgMTtcclxuICAgICAgICBjb25zdCB7IHN0YXJ0LCBiaW5TaXplIH0gPSB0aGlzLmNhbGN1bGF0ZU5pY2VTdGFydChzdGFydEd1ZXNzLCBzdG9wLCBzZWdtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmlucyhzdGFydCwgc3RvcCwgYmluU2l6ZSwgc2VnbWVudHMpO1xyXG4gICAgfVxyXG4gICAgZ2V0QmlucyhzdGFydCwgc3RvcCwgc3RlcCwgY291bnQpIHtcclxuICAgICAgICBjb25zdCBiaW5zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLnJvdW5kKChzdGFydCArIGkgKiBzdGVwKSAqIDEwKSAvIDEwO1xyXG4gICAgICAgICAgICBsZXQgYiA9IE1hdGgucm91bmQoKHN0YXJ0ICsgKGkgKyAxKSAqIHN0ZXApICogMTApIC8gMTA7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBjb3VudCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBNYXRoLm1heChiLCBzdG9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiaW5zW2ldID0gW2EsIGJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmlucztcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZU5pY2VTdGFydChhLCBiLCBzZWdtZW50cykge1xyXG4gICAgICAgIGNvbnN0IGJpblNpemUgPSBNYXRoLmFicyhiIC0gYSkgLyBzZWdtZW50cztcclxuICAgICAgICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChiaW5TaXplKSk7XHJcbiAgICAgICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcclxuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoYSAvIG1hZ25pdHVkZSkgKiBtYWduaXR1ZGU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgIGJpblNpemUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB4S2V5LCB5S2V5LCBkYXRhLCBhcmVhUGxvdCwgYWdncmVnYXRpb24gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gW2tleVByb3BlcnR5KHRoaXMsIHhLZXksIHRydWUpLCBTT1JUX0RPTUFJTl9HUk9VUFNdO1xyXG4gICAgICAgICAgICBpZiAoeUtleSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFnZ1Byb3AgPSBncm91cENvdW50KHRoaXMsICdncm91cENvdW50Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRpb24gPT09ICdjb3VudCcpIDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFnZ3JlZ2F0aW9uID09PSAnc3VtJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFnZ1Byb3AgPSBncm91cFN1bSh0aGlzLCAnZ3JvdXBBZ2cnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFnZ3JlZ2F0aW9uID09PSAnbWVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZ2dQcm9wID0gZ3JvdXBBdmVyYWdlKHRoaXMsICdncm91cEFnZycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZWFQbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWdnUHJvcCA9IGFyZWEodGhpcywgJ2dyb3VwQWdnJywgYWdnUHJvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgdHJ1ZSwgeyBpbnZhbGlkVmFsdWU6IHVuZGVmaW5lZCB9KSwgYWdnUHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWdnUHJvcCA9IGdyb3VwQ291bnQodGhpcywgJ2dyb3VwQWdnJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJlYVBsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZ2dQcm9wID0gYXJlYSh0aGlzLCAnZ3JvdXBBZ2cnLCBhZ2dQcm9wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goYWdnUHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZ3JvdXBCeUZuID0gKGRhdGFTZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhFeHRlbnQgPSBmaXhOdW1lcmljRXh0ZW50KGRhdGFTZXQuZG9tYWluLmtleXNbMF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhFeHRlbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gYnVja2V0cyBjYW4gYmUgY2FsY3VsYXRlZC5cclxuICAgICAgICAgICAgICAgICAgICBkYXRhU2V0LmRvbWFpbi5ncm91cHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5zID0gKF9hID0gdGhpcy5iaW5zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmRlcml2ZUJpbnMoeEV4dGVudCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5Db3VudCA9IGJpbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkQmlucyA9IFsuLi5iaW5zXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhWYWx1ZSA9IGl0ZW0ua2V5c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbkNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEJpbiA9IGJpbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4VmFsdWUgPj0gbmV4dEJpblswXSAmJiB4VmFsdWUgPCBuZXh0QmluWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEJpbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYmluQ291bnQgLSAxICYmIHhWYWx1ZSA8PSBuZXh0QmluWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlIG9mIGEgdmFsdWUgYmVpbmcgYXQgdGhlIG1heGltdW0gZXh0ZW50LCBhbmQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5hbCBiaW4gYWxpZ25pbmcgd2l0aCBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0QmluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSAmJiB0aGlzLnByb2Nlc3NlZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEsIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHZvaWQgMCA/IGRhdGEgOiBbXSwge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgICAgICAgICBkYXRhVmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBCeUZuLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKCd1cGRhdGVEYXRhJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8ICF0aGlzLmNhbGN1bGF0ZWRCaW5zLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIGNvbnN0IHlEb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGBncm91cEFnZ2AsICdhZ2dyZWdhdGUnLCBwcm9jZXNzZWREYXRhKTtcclxuICAgICAgICBjb25zdCB4RG9tYWluTWluID0gKF9hID0gdGhpcy5jYWxjdWxhdGVkQmlucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdWzBdO1xyXG4gICAgICAgIGNvbnN0IHhEb21haW5NYXggPSAoX2IgPSB0aGlzLmNhbGN1bGF0ZWRCaW5zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbKChfZCA9IChfYyA9IHRoaXMuY2FsY3VsYXRlZEJpbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApIC0gMV1bMV07XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoW3hEb21haW5NaW4sIHhEb21haW5NYXhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeURvbWFpbik7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVOb2RlRGF0YSgpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgY2FsY3VsYXRlU2NhbGluZzogeyBnZXQ6ICgpID0+IHN1cGVyLmNhbGN1bGF0ZVNjYWxpbmcgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGF4ZXMsIHByb2Nlc3NlZERhdGEsIGN0eDogeyBjYWxsYmFja0NhY2hlIH0sIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB4QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlhdO1xyXG4gICAgICAgICAgICBjb25zdCB5QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCAheEF4aXMgfHwgIXlBeGlzIHx8ICFwcm9jZXNzZWREYXRhIHx8IHByb2Nlc3NlZERhdGEudHlwZSAhPT0gJ2dyb3VwZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyBzY2FsZTogeFNjYWxlIH0gPSB4QXhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBzY2FsZTogeVNjYWxlIH0gPSB5QXhpcztcclxuICAgICAgICAgICAgY29uc3QgeyBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBpZDogc2VyaWVzSWQsIHlLZXkgPSAnJywgeEtleSA9ICcnIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsOiB7IGZvcm1hdHRlcjogbGFiZWxGb3JtYXR0ZXIgPSAocGFyYW1zKSA9PiBTdHJpbmcocGFyYW1zLnZhbHVlKSwgZm9udFN0eWxlOiBsYWJlbEZvbnRTdHlsZSwgZm9udFdlaWdodDogbGFiZWxGb250V2VpZ2h0LCBmb250U2l6ZTogbGFiZWxGb250U2l6ZSwgZm9udEZhbWlseTogbGFiZWxGb250RmFtaWx5LCBjb2xvcjogbGFiZWxDb2xvciwgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEuZGF0YS5mb3JFYWNoKChncm91cCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBhZ2dWYWx1ZXM6IFtbbmVnYXRpdmVBZ2csIHBvc2l0aXZlQWdnXV0gPSBbWzAsIDBdXSwgZGF0dW0sIGRhdHVtOiB7IGxlbmd0aDogZnJlcXVlbmN5IH0sIGtleXM6IGRvbWFpbiwga2V5czogW3hEb21haW5NaW4sIHhEb21haW5NYXhdLCB9ID0gZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4TWluUHggPSB4U2NhbGUuY29udmVydCh4RG9tYWluTWluKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhNYXhQeCA9IHhTY2FsZS5jb252ZXJ0KHhEb21haW5NYXgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBuZWdhdGl2ZUFnZyArIHBvc2l0aXZlQWdnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeVplcm9QeCA9IHlTY2FsZS5jb252ZXJ0KDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeU1heFB4ID0geVNjYWxlLmNvbnZlcnQodG90YWwpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IHhNYXhQeCAtIHhNaW5QeDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBNYXRoLmFicyh5TWF4UHggLSB5WmVyb1B4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkRhdHVtTGFiZWwgPSB0b3RhbCAhPT0gMFxyXG4gICAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAoX2EgPSBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWxGb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b3RhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeUtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhOYW1lOiB0aGlzLnhOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeU5hbWU6IHRoaXMueU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBTdHJpbmcodG90YWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U3R5bGU6IGxhYmVsRm9udFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbEZvbnRXZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBsYWJlbEZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBsYWJlbEZvbnRGYW1pbHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGxhYmVsQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHhNaW5QeCArIHcgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5TWF4UHggKyBoIC8gMixcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlTWlkUG9pbnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogeE1pblB4ICsgdyAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogeU1heFB4ICsgaCAvIDIsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbm9kZURhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggc2VsZWN0aW9uIGlzIGFuIGFnZ3JlZ2F0aW9uIG9mIG11bHRpcGxlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZFZhbHVlOiB0b3RhbCxcclxuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXHJcbiAgICAgICAgICAgICAgICAgICAgeUtleSxcclxuICAgICAgICAgICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IHhNaW5QeCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB5TWF4UHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeFZhbHVlOiB4TWluUHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeVZhbHVlOiB5TWF4UHgsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pZFBvaW50OiBub2RlTWlkUG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogZmlsbCxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHNlbGVjdGlvbkRhdHVtTGFiZWwsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiAoX2EgPSB0aGlzLnlLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZXM6IF9zdXBlci5jYWxjdWxhdGVTY2FsaW5nLmNhbGwodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uVmFsaWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5vZGVGYWN0b3J5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZURhdGEsIGRhdHVtU2VsZWN0aW9uIH0gPSBvcHRzO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0dW1TZWxlY3Rpb24udXBkYXRlKG5vZGVEYXRhLCAocmVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVjdC50YWcgPSBIaXN0b2dyYW1TZXJpZXNOb2RlVGFnLkJpbjtcclxuICAgICAgICAgICAgICAgIHJlY3QuY3Jpc3AgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LCAoZGF0dW0pID0+IGRhdHVtLmRvbWFpbi5qb2luKCdfJykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlRGF0dW1Ob2RlcyhvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBkYXR1bVNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGlzRGF0dW1IaWdobGlnaHRlZCB9ID0gb3B0cztcclxuICAgICAgICAgICAgY29uc3QgeyBmaWxsT3BhY2l0eTogc2VyaWVzRmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIHNoYWRvdywgaGlnaGxpZ2h0U3R5bGU6IHsgaXRlbTogeyBmaWxsOiBoaWdobGlnaHRlZEZpbGwsIGZpbGxPcGFjaXR5OiBoaWdobGlnaHRGaWxsT3BhY2l0eSA9IHNlcmllc0ZpbGxPcGFjaXR5LCBzdHJva2U6IGhpZ2hsaWdodGVkU3Ryb2tlLCBzdHJva2VXaWR0aDogaGlnaGxpZ2h0ZWREYXR1bVN0cm9rZVdpZHRoLCB9LCB9LCB9ID0gdGhpcztcclxuICAgICAgICAgICAgZGF0dW1TZWxlY3Rpb24uZWFjaCgocmVjdCwgZGF0dW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBpc0RhdHVtSGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0ZWREYXR1bVN0cm9rZVdpZHRoICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICA/IGhpZ2hsaWdodGVkRGF0dW1TdHJva2VXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIDogZGF0dW0uc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsT3BhY2l0eSA9IGlzRGF0dW1IaWdobGlnaHRlZCA/IGhpZ2hsaWdodEZpbGxPcGFjaXR5IDogc2VyaWVzRmlsbE9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICByZWN0LmZpbGwgPSAoX2EgPSAoaXNEYXR1bUhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0ZWRGaWxsIDogdW5kZWZpbmVkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGF0dW0uZmlsbDtcclxuICAgICAgICAgICAgICAgIHJlY3Quc3Ryb2tlID0gKF9iID0gKGlzRGF0dW1IaWdobGlnaHRlZCA/IGhpZ2hsaWdodGVkU3Ryb2tlIDogdW5kZWZpbmVkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGF0dW0uc3Ryb2tlO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgcmVjdC5zdHJva2VPcGFjaXR5ID0gc3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIHJlY3Quc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QubGluZURhc2ggPSB0aGlzLmxpbmVEYXNoO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5saW5lRGFzaE9mZnNldCA9IHRoaXMubGluZURhc2hPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZWN0LmZpbGxTaGFkb3cgPSBzaGFkb3c7XHJcbiAgICAgICAgICAgICAgICByZWN0LnpJbmRleCA9IGlzRGF0dW1IaWdobGlnaHRlZCA/IFNlcmllcy5oaWdobGlnaHRlZFpJbmRleCA6IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmVjdC52aXNpYmxlID0gZGF0dW0uaGVpZ2h0ID4gMDsgLy8gcHJldmVudCBzdHJva2UgZnJvbSByZW5kZXJpbmcgZm9yIHplcm8gaGVpZ2h0IGNvbHVtbnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFiZWxTZWxlY3Rpb24udXBkYXRlKGxhYmVsRGF0YSwgKHRleHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRleHQudGFnID0gSGlzdG9ncmFtU2VyaWVzTm9kZVRhZy5MYWJlbDtcclxuICAgICAgICAgICAgICAgIHRleHQucG9pbnRlckV2ZW50cyA9IFBvaW50ZXJFdmVudHMuTm9uZTtcclxuICAgICAgICAgICAgICAgIHRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsRW5hYmxlZCA9IHRoaXMubGFiZWwuZW5hYmxlZDtcclxuICAgICAgICAgICAgbGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0ubGFiZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwgJiYgbGFiZWxFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnggPSBsYWJlbC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQueSA9IGxhYmVsLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmZpbGwgPSBsYWJlbC5maWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcclxuICAgICAgICBjb25zdCB7IHhLZXksIHlLZXkgPSAnJywgYXhlcyB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCB4QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlhdO1xyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWV07XHJcbiAgICAgICAgaWYgKCF4S2V5IHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHhOYW1lLCB5TmFtZSwgZmlsbDogY29sb3IsIHRvb2x0aXAsIGFnZ3JlZ2F0aW9uLCBpZDogc2VyaWVzSWQgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeyBhZ2dyZWdhdGVkVmFsdWUsIGZyZXF1ZW5jeSwgZG9tYWluOiBbcmFuZ2VNaW4sIHJhbmdlTWF4XSwgfSA9IG5vZGVEYXR1bTtcclxuICAgICAgICBjb25zdCB0aXRsZSA9IGAke3Nhbml0aXplSHRtbCh4TmFtZSAhPT0gbnVsbCAmJiB4TmFtZSAhPT0gdm9pZCAwID8geE5hbWUgOiB4S2V5KX06ICR7eEF4aXMuZm9ybWF0RGF0dW0ocmFuZ2VNaW4pfSAtICR7eEF4aXMuZm9ybWF0RGF0dW0ocmFuZ2VNYXgpfWA7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB5S2V5XHJcbiAgICAgICAgICAgID8gYDxiPiR7c2FuaXRpemVIdG1sKHlOYW1lICE9PSBudWxsICYmIHlOYW1lICE9PSB2b2lkIDAgPyB5TmFtZSA6IHlLZXkpfSAoJHthZ2dyZWdhdGlvbn0pPC9iPjogJHt5QXhpcy5mb3JtYXREYXR1bShhZ2dyZWdhdGVkVmFsdWUpfTxicj5gXHJcbiAgICAgICAgICAgIDogJyc7XHJcbiAgICAgICAgY29udGVudCArPSBgPGI+RnJlcXVlbmN5PC9iPjogJHtmcmVxdWVuY3l9YDtcclxuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKGRlZmF1bHRzLCB7XHJcbiAgICAgICAgICAgIGRhdHVtOiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBub2RlRGF0dW0uZGF0dW0sXHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkVmFsdWU6IG5vZGVEYXR1bS5hZ2dyZWdhdGVkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBkb21haW46IG5vZGVEYXR1bS5kb21haW4sXHJcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG5vZGVEYXR1bS5mcmVxdWVuY3ksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHhLZXksXHJcbiAgICAgICAgICAgIHhOYW1lLFxyXG4gICAgICAgICAgICB5S2V5LFxyXG4gICAgICAgICAgICB5TmFtZSxcclxuICAgICAgICAgICAgY29sb3IsXHJcbiAgICAgICAgICAgIHRpdGxlLFxyXG4gICAgICAgICAgICBzZXJpZXNJZCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IGlkLCBkYXRhLCB4S2V5LCB5TmFtZSwgdmlzaWJsZSwgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwIHx8IGxlZ2VuZFR5cGUgIT09ICdjYXRlZ29yeScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRUeXBlOiAnY2F0ZWdvcnknLFxyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICBpdGVtSWQ6IHhLZXksXHJcbiAgICAgICAgICAgICAgICBzZXJpZXNJZDogaWQsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB2aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAoX2EgPSB5TmFtZSAhPT0gbnVsbCAmJiB5TmFtZSAhPT0gdm9pZCAwID8geU5hbWUgOiB4S2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnRnJlcXVlbmN5JyxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBmaWxsICE9PSBudWxsICYmIGZpbGwgIT09IHZvaWQgMCA/IGZpbGwgOiAncmdiYSgwLCAwLCAwLCAwKScsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UgIT09IG51bGwgJiYgc3Ryb2tlICE9PSB2b2lkIDAgPyBzdHJva2UgOiAncmdiYSgwLCAwLCAwLCAwKScsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeSh7IGRhdHVtU2VsZWN0aW9ucywgbGFiZWxTZWxlY3Rpb25zIH0pIHtcclxuICAgICAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odHJ1ZSwgdGhpcy5heGVzKSk7XHJcbiAgICAgICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsICdkYXR1bXMnLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBkYXR1bVNlbGVjdGlvbnMsIGZucyk7XHJcbiAgICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgJ2xhYmVscycsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGRpZmYgPSAoX2IgPSAoX2EgPSB0aGlzLnByb2Nlc3NlZERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWR1Y2VkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlmZjtcclxuICAgICAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odHJ1ZSwgdGhpcy5heGVzKSk7XHJcbiAgICAgICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsICdkYXR1bXMnLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBkYXRhLmRhdHVtU2VsZWN0aW9ucywgZm5zLCAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSksIGRpZmYpO1xyXG4gICAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsICdsYWJlbHMnLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBkYXRhLmxhYmVsU2VsZWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXREYXR1bUlkKGRhdHVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURhdHVtSWQoZGF0dW0uZG9tYWluLm1hcCgoZCkgPT4gYCR7ZH1gKSk7XHJcbiAgICB9XHJcbiAgICBpc0xhYmVsRW5hYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5lbmFibGVkO1xyXG4gICAgfVxyXG59XHJcbkhpc3RvZ3JhbVNlcmllcy5jbGFzc05hbWUgPSAnSGlzdG9ncmFtU2VyaWVzJztcclxuSGlzdG9ncmFtU2VyaWVzLnR5cGUgPSAnaGlzdG9ncmFtJztcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEhpc3RvZ3JhbVNlcmllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgSGlzdG9ncmFtU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwLCAxKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG5dLCBIaXN0b2dyYW1TZXJpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCwgMSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuXSwgSGlzdG9ncmFtU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0xJTkVfREFTSCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIEhpc3RvZ3JhbVNlcmllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBIaXN0b2dyYW1TZXJpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBIaXN0b2dyYW1TZXJpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShCT09MRUFOKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG5dLCBIaXN0b2dyYW1TZXJpZXMucHJvdG90eXBlLCBcImFyZWFQbG90XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0FSUkFZKCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG5dLCBIaXN0b2dyYW1TZXJpZXMucHJvdG90eXBlLCBcImJpbnNcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShISVNUT0dSQU1fQUdHUkVHQVRJT04pLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgSGlzdG9ncmFtU2VyaWVzLnByb3RvdHlwZSwgXCJhZ2dyZWdhdGlvblwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9OVU1CRVIoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgSGlzdG9ncmFtU2VyaWVzLnByb3RvdHlwZSwgXCJiaW5Db3VudFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgSGlzdG9ncmFtU2VyaWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgSGlzdG9ncmFtU2VyaWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBIaXN0b2dyYW1TZXJpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgSGlzdG9ncmFtU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCB2b2lkIDApO1xuXG5jb25zdCBIaXN0b2dyYW1TZXJpZXNNb2R1bGUgPSB7XHJcbiAgICB0eXBlOiAnc2VyaWVzJyxcclxuICAgIG9wdGlvbnNLZXk6ICdzZXJpZXNbXScsXHJcbiAgICBwYWNrYWdlVHlwZTogJ2NvbW11bml0eScsXHJcbiAgICBjaGFydFR5cGVzOiBbJ2NhcnRlc2lhbiddLFxyXG4gICAgaWRlbnRpZmllcjogJ2hpc3RvZ3JhbScsXHJcbiAgICBpbnN0YW5jZUNvbnN0cnVjdG9yOiBIaXN0b2dyYW1TZXJpZXMsXHJcbiAgICBzZXJpZXNEZWZhdWx0czoge1xyXG4gICAgICAgIGF4ZXM6IFtcclxuICAgICAgICAgICAgeyB0eXBlOiBDQVJURVNJQU5fQVhJU19UWVBFUy5OVU1CRVIsIHBvc2l0aW9uOiBDQVJURVNJQU5fQVhJU19QT1NJVElPTlMuQk9UVE9NIH0sXHJcbiAgICAgICAgICAgIHsgdHlwZTogQ0FSVEVTSUFOX0FYSVNfVFlQRVMuTlVNQkVSLCBwb3NpdGlvbjogQ0FSVEVTSUFOX0FYSVNfUE9TSVRJT05TLkxFRlQgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHRoZW1lVGVtcGxhdGU6IHtcclxuICAgICAgICBfX2V4dGVuZHNfXzogRVhURU5EU19TRVJJRVNfREVGQVVMVFMsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXHJcbiAgICAgICAgZmlsbE9wYWNpdHk6IDEsXHJcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcclxuICAgICAgICBsaW5lRGFzaDogWzBdLFxyXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxyXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNoYWRvdzoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcclxuICAgICAgICAgICAgeE9mZnNldDogMyxcclxuICAgICAgICAgICAgeU9mZnNldDogMyxcclxuICAgICAgICAgICAgYmx1cjogNSxcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIHBhbGV0dGVGYWN0b3J5OiAoeyB0YWtlQ29sb3JzIH0pID0+IHtcclxuICAgICAgICBjb25zdCB7IGZpbGxzOiBbZmlsbF0sIHN0cm9rZXM6IFtzdHJva2VdLCB9ID0gdGFrZUNvbG9ycygxKTtcclxuICAgICAgICByZXR1cm4geyBmaWxsLCBzdHJva2UgfTtcclxuICAgIH0sXHJcbn07XG5cbmNsYXNzIExpbmVTZXJpZXMgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBtb2R1bGVDdHgsXHJcbiAgICAgICAgICAgIGhhc01hcmtlcnM6IHRydWUsXHJcbiAgICAgICAgICAgIHBpY2tNb2RlczogW1xyXG4gICAgICAgICAgICAgICAgU2VyaWVzTm9kZVBpY2tNb2RlLk5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNULFxyXG4gICAgICAgICAgICAgICAgU2VyaWVzTm9kZVBpY2tNb2RlLk5FQVJFU1RfTk9ERSxcclxuICAgICAgICAgICAgICAgIFNlcmllc05vZGVQaWNrTW9kZS5FWEFDVF9TSEFQRV9NQVRDSCxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxyXG4gICAgICAgICAgICBhbmltYXRpb25SZXNldEZuczoge1xyXG4gICAgICAgICAgICAgICAgcGF0aDogYnVpbGRSZXNldFBhdGhGbih7IGdldE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0T3BhY2l0eSgpIH0pLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcclxuICAgICAgICAgICAgICAgIG1hcmtlcjogKG5vZGUsIGRhdHVtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNldE1hcmtlckZuKCkpLCByZXNldE1hcmtlclBvc2l0aW9uRm4obm9kZSwgZGF0dW0pKSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBMYWJlbCgpO1xyXG4gICAgICAgIHRoaXMubWFya2VyID0gbmV3IFNlcmllc01hcmtlcigpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0cm9rZSA9ICcjODc0MzQ5JztcclxuICAgICAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xyXG4gICAgICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy54S2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueE5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy55S2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueU5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeEtleSwgeUtleSwgZGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHhLZXkgPT0gbnVsbCB8fCB5S2V5ID09IG51bGwgfHwgZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaXNDb250aW51b3VzWCwgaXNDb250aW51b3VzWSB9ID0gdGhpcy5pc0NvbnRpbnVvdXMoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gSWYgdHdvIG9yIG1vcmUgZGF0dW1zIHNoYXJlIGFuIHgtdmFsdWUsIGkuZS4gbGluZWQgdXAgdmVydGljYWxseSwgdGhleSB3aWxsIGhhdmUgdGhlIHNhbWUgZGF0dW0gaWQuXHJcbiAgICAgICAgICAgIC8vIFRoZXkgbXVzdCBiZSBpZGVudGlmaWVkIHRoaXMgd2F5IHdoZW4gYW5pbWF0ZWQgdG8gZW5zdXJlIHRoZXkgY2FuIGJlIHRyYWNrZWQgd2hlbiB0aGVpciB5LXZhbHVlXHJcbiAgICAgICAgICAgIC8vIGlzIHVwZGF0ZWQuIElmIHRoaXMgaXMgYSBzdGF0aWMgY2hhcnQsIHdlIGNhbiBpbnN0ZWFkIG5vdCBib3RoZXIgd2l0aCBpZGVudGlmeWluZyBkYXR1bXMgYW5kXHJcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZ2FyYmFnZSBjb2xsZWN0IHRoZSBtYXJrZXIgc2VsZWN0aW9uLlxyXG4gICAgICAgICAgICBpZiAoIWlzQ29udGludW91c1gpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goa2V5UHJvcGVydHkodGhpcywgeEtleSwgaXNDb250aW51b3VzWCwgeyBpZDogJ3hLZXknIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKHRoaXMsIGlzQ29udGludW91c1ggPyBbJ3hWYWx1ZSddIDogW10pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkodGhpcywgeEtleSwgaXNDb250aW51b3VzWCwgeyBpZDogJ3hWYWx1ZScgfSksIHZhbHVlUHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgeyBpZDogJ3lWYWx1ZScsIGludmFsaWRWYWx1ZTogdW5kZWZpbmVkIH0pKTtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7IHByb3BzIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oJ3VwZGF0ZURhdGEnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCB7IGF4ZXMsIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcclxuICAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWF07XHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5ZXTtcclxuICAgICAgICBjb25zdCB4RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlgpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgJ3ZhbHVlJywgcHJvY2Vzc2VkRGF0YSk7XHJcbiAgICAgICAgICAgIGlmICgoeERlZiA9PT0gbnVsbCB8fCB4RGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB4RGVmLmRlZi50eXBlKSA9PT0gJ3ZhbHVlJyAmJiB4RGVmLmRlZi52YWx1ZVR5cGUgPT09ICdjYXRlZ29yeScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGRvbWFpbiksIHhBeGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZWAsICd2YWx1ZScsIHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChkb21haW4sIHlBeGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVOb2RlRGF0YSgpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgY2FsY3VsYXRlU2NhbGluZzogeyBnZXQ6ICgpID0+IHN1cGVyLmNhbGN1bGF0ZVNjYWxpbmcgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBheGVzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB4QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlhdO1xyXG4gICAgICAgICAgICBjb25zdCB5QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldO1xyXG4gICAgICAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyBsYWJlbCwgeUtleSA9ICcnLCB4S2V5ID0gJycgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xyXG4gICAgICAgICAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcclxuICAgICAgICAgICAgY29uc3QgeE9mZnNldCA9ICgoX2EgPSB4U2NhbGUuYmFuZHdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHlPZmZzZXQgPSAoKF9iID0geVNjYWxlLmJhbmR3aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5tYXJrZXIuZW5hYmxlZCA/IHRoaXMubWFya2VyLnNpemUgOiAwO1xyXG4gICAgICAgICAgICBjb25zdCB4SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKS5pbmRleDtcclxuICAgICAgICAgICAgY29uc3QgeUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlYCkuaW5kZXg7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlVG8gPSB0cnVlO1xyXG4gICAgICAgICAgICBsZXQgbmV4dFBvaW50O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBuZXh0UG9pbnQgIT09IG51bGwgJiYgbmV4dFBvaW50ICE9PSB2b2lkIDAgPyBuZXh0UG9pbnQgOiBwcm9jZXNzZWREYXRhLmRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeElkeF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5RGF0dW0gPSB2YWx1ZXNbeUlkeF07XHJcbiAgICAgICAgICAgICAgICBpZiAoeURhdHVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVG8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlVG8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gcHJvY2Vzc2VkRGF0YS5kYXRhW2kgKyAxXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlc1t5SWR4XSkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHByb2Nlc3NlZERhdGEuZGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSkgKyB5T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGxhYmVsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB5RGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4TmFtZTogdGhpcy54TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeU5hbWU6IHRoaXMueU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgKHZhbHVlKSA9PiAoaXNOdW1iZXIodmFsdWUpID8gdmFsdWUudG9GaXhlZCgyKSA6IFN0cmluZyh2YWx1ZSkpKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeUtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHsgeCwgeSwgbW92ZVRvLCBzaXplIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVZhbHVlOiB5RGF0dW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhWYWx1ZTogeERhdHVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXBEZWZhdWx0czogeyBsZW5ndGhSYXRpb011bHRpcGxpZXI6IHRoaXMubWFya2VyLmdldERpYW1ldGVyKCksIGxlbmd0aE1heDogSW5maW5pdHkgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWxUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogbGFiZWwuZm9udFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsLmZvbnRXZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLmZvbnRGYW1pbHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdib3R0b20nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGxhYmVsLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRvID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZXM6IF9zdXBlci5jYWxjdWxhdGVTY2FsaW5nLmNhbGwodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2VyLmlzRGlydHkoKTtcclxuICAgIH1cclxuICAgIG1hcmtlckZhY3RvcnkoKSB7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5tYXJrZXI7XHJcbiAgICAgICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBhdGhOb2RlcyhvcHRzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHBhdGhzOiBbbGluZU5vZGVdLCBvcGFjaXR5LCB2aXNpYmxlLCBhbmltYXRpb25FbmFibGVkLCB9ID0gb3B0cztcclxuICAgICAgICAgICAgY29uc3QgeyBzZXJpZXNSZWN0SGVpZ2h0OiBoZWlnaHQsIHNlcmllc1JlY3RXaWR0aDogd2lkdGggfSA9IHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgICAgIGxpbmVOb2RlLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgZmlsbDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgbGluZUpvaW46ICdyb3VuZCcsXHJcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBQb2ludGVyRXZlbnRzLk5vbmUsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLnN0cm9rZSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMuc3Ryb2tlV2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5zdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgbGluZURhc2g6IHRoaXMubGluZURhc2gsXHJcbiAgICAgICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5saW5lRGFzaE9mZnNldCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9uRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgbGluZU5vZGUudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmVOb2RlLmNsaXBQYXRoID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlLmNsaXBQYXRoID0gbmV3IFBhdGgyRCgpO1xyXG4gICAgICAgICAgICAgICAgbGluZU5vZGUuY2xpcFNjYWxpbmdYID0gMTtcclxuICAgICAgICAgICAgICAgIGxpbmVOb2RlLmNsaXBTY2FsaW5nWSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKF9hID0gbGluZU5vZGUuY2xpcFBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcih7IHRyYWNrQ2hhbmdlczogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgKF9iID0gbGluZU5vZGUuY2xpcFBhdGgpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWN0KC0yNSwgLTI1LCAod2lkdGggIT09IG51bGwgJiYgd2lkdGggIT09IHZvaWQgMCA/IHdpZHRoIDogMCkgKyA1MCwgKGhlaWdodCAhPT0gbnVsbCAmJiBoZWlnaHQgIT09IHZvaWQgMCA/IGhlaWdodCA6IDApICsgNTApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBub2RlRGF0YSB9ID0gb3B0cztcclxuICAgICAgICAgICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2hhcGUsIGVuYWJsZWQgfSA9IHRoaXMubWFya2VyO1xyXG4gICAgICAgICAgICBub2RlRGF0YSA9IHNoYXBlICYmIGVuYWJsZWQgPyBub2RlRGF0YSA6IFtdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUobm9kZURhdGEsIHVuZGVmaW5lZCwgKGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xyXG4gICAgICAgICAgICBjb25zdCB7IHhLZXkgPSAnJywgeUtleSA9ICcnLCBtYXJrZXIsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgdGhpcy5oaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgYXBwbHlUcmFuc2xhdGlvbiA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XHJcbiAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5IH0sIGJhc2VTdHlsZSwgeyBhcHBseVRyYW5zbGF0aW9uIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIubWFya0NsZWFuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBsYWJlbERhdGEgfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2hhcGUsIGVuYWJsZWQgfSA9IHRoaXMubWFya2VyO1xyXG4gICAgICAgICAgICBsYWJlbERhdGEgPSBzaGFwZSAmJiBlbmFibGVkID8gbGFiZWxEYXRhIDogW107XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbFNlbGVjdGlvbi51cGRhdGUobGFiZWxEYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZW5hYmxlZDogbGFiZWxFbmFibGVkLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gdGhpcy5sYWJlbDtcclxuICAgICAgICAgICAgbGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9pbnQsIGxhYmVsIH0gPSBkYXR1bTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXR1bSAmJiBsYWJlbCAmJiBsYWJlbEVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQudGV4dEFsaWduID0gbGFiZWwudGV4dEFsaWduO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC54ID0gcG9pbnQueDtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LnkgPSBwb2ludC55IC0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB7IHhLZXksIHlLZXksIGF4ZXMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5YXTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IGF4ZXNbQ2hhcnRBeGlzRGlyZWN0aW9uLlldO1xyXG4gICAgICAgIGlmICgheEtleSB8fCAheUtleSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB4TmFtZSwgeU5hbWUsIHRvb2x0aXAsIG1hcmtlciwgaWQ6IHNlcmllc0lkIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0dW0sIHhWYWx1ZSwgeVZhbHVlIH0gPSBub2RlRGF0dW07XHJcbiAgICAgICAgY29uc3QgeFN0cmluZyA9IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgeVN0cmluZyA9IHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSk7XHJcbiAgICAgICAgY29uc3QgdGl0bGUgPSBzYW5pdGl6ZUh0bWwoKF9hID0gdGhpcy50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeU5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoeFN0cmluZyArICc6ICcgKyB5U3RyaW5nKTtcclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKHsgZmlsbDogbWFya2VyLnN0cm9rZSB9LCBtYXJrZXIuZ2V0U3R5bGUoKSwgeyBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCB9KTtcclxuICAgICAgICBjb25zdCB7IGZpbGw6IGNvbG9yIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlKG1hcmtlciwgeyBkYXR1bTogbm9kZURhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogZmFsc2UgfSwgYmFzZVN0eWxlKTtcclxuICAgICAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSwgT2JqZWN0LmFzc2lnbih7IGRhdHVtLFxyXG4gICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICB4TmFtZSxcclxuICAgICAgICAgICAgeUtleSxcclxuICAgICAgICAgICAgeU5hbWUsXHJcbiAgICAgICAgICAgIHRpdGxlLFxyXG4gICAgICAgICAgICBjb2xvcixcclxuICAgICAgICAgICAgc2VyaWVzSWQgfSwgdGhpcy5nZXRNb2R1bGVUb29sdGlwUGFyYW1zKGRhdHVtKSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcclxuICAgICAgICBjb25zdCB7IGlkLCBkYXRhLCB4S2V5LCB5S2V5LCB5TmFtZSwgdmlzaWJsZSwgdGl0bGUsIG1hcmtlciwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5IH0gPSB0aGlzO1xyXG4gICAgICAgIGlmICghKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubGVuZ3RoKSAmJiB4S2V5ICYmIHlLZXkgJiYgbGVnZW5kVHlwZSA9PT0gJ2NhdGVnb3J5JykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRUeXBlOiAnY2F0ZWdvcnknLFxyXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgaXRlbUlkOiB5S2V5LFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzSWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKF9hID0gdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogeU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHlLZXksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbWFya2VyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAoX2IgPSBtYXJrZXIuZmlsbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3JnYmEoMCwgMCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogKF9kID0gKF9jID0gbWFya2VyLnN0cm9rZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogc3Ryb2tlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAncmdiYSgwLCAwLCAwLCAwKScsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IChfZSA9IG1hcmtlci5maWxsT3BhY2l0eSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAoX2cgPSAoX2YgPSBtYXJrZXIuc3Ryb2tlT3BhY2l0eSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogc3Ryb2tlT3BhY2l0eSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogKF9oID0gbWFya2VyLnN0cm9rZVdpZHRoKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAwLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGF0aHMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKFtvcHRzLnBhdGhzXSwgW29wdHMuY29udGV4dERhdGFdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpIHtcclxuICAgICAgICBjb250ZXh0RGF0YS5mb3JFYWNoKCh7IG5vZGVEYXRhIH0sIGNvbnRleHREYXRhSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2xpbmVOb2RlXSA9IHBhdGhzW2NvbnRleHREYXRhSW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCB7IHBhdGg6IGxpbmVQYXRoIH0gPSBsaW5lTm9kZTtcclxuICAgICAgICAgICAgbGluZVBhdGguY2xlYXIoeyB0cmFja0NoYW5nZXM6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGF0YSBvZiBub2RlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucG9pbnQubW92ZVRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVBhdGgubW92ZVRvKGRhdGEucG9pbnQueCwgZGF0YS5wb2ludC55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVQYXRoLmxpbmVUbyhkYXRhLnBvaW50LngsIGRhdGEucG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGluZU5vZGUuY2hlY2tQYXRoRGlydHkoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcclxuICAgICAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbnMsIGxhYmVsU2VsZWN0aW9ucywgYW5ub3RhdGlvblNlbGVjdGlvbnMsIGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcclxuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xyXG4gICAgICAgIGNvbnN0IHsgc2VyaWVzUmVjdFdpZHRoOiB3aWR0aCA9IDAgfSA9IHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcclxuICAgICAgICBwYXRoU3dpcGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBwYXRocy5mbGF0KCkpO1xyXG4gICAgICAgIHJlc2V0TW90aW9uKG1hcmtlclNlbGVjdGlvbnMsIHJlc2V0TWFya2VyUG9zaXRpb25Gbik7XHJcbiAgICAgICAgbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHdpZHRoKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnbGFiZWxzJywgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnYW5ub3RhdGlvbnMnLCBhbmltYXRpb25NYW5hZ2VyLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBhbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHsgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XHJcbiAgICAgICAgc3VwZXIuYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xyXG4gICAgICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9ucywgbGFiZWxTZWxlY3Rpb25zLCBhbm5vdGF0aW9uU2VsZWN0aW9ucywgY29udGV4dERhdGEsIHBhdGhzLCBwcmV2aW91c0NvbnRleHREYXRhIH0gPSBhbmltYXRpb25EYXRhO1xyXG4gICAgICAgIHN1cGVyLnJlc2V0QWxsQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xyXG4gICAgICAgIGlmIChjb250ZXh0RGF0YS5sZW5ndGggPT09IDAgfHwgIXByZXZpb3VzQ29udGV4dERhdGEgfHwgcHJldmlvdXNDb250ZXh0RGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW3BhdGhdID0gcGF0aHM7XHJcbiAgICAgICAgY29uc3QgW25ld0RhdGFdID0gY29udGV4dERhdGE7XHJcbiAgICAgICAgY29uc3QgW29sZERhdGFdID0gcHJldmlvdXNDb250ZXh0RGF0YTtcclxuICAgICAgICBjb25zdCBmbnMgPSBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgKF9iID0gKF9hID0gdGhpcy5wcm9jZXNzZWREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkdWNlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpZmYpO1xyXG4gICAgICAgIGlmIChmbnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBhbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgJ21hcmtlcicsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIGZucy5tYXJrZXIpO1xyXG4gICAgICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCAncGF0aF9wcm9wZXJ0aWVzJywgYW5pbWF0aW9uTWFuYWdlciwgcGF0aCwgZm5zLnBhdGhQcm9wZXJ0aWVzKTtcclxuICAgICAgICBwYXRoTW90aW9uKHRoaXMuaWQsICdwYXRoX3VwZGF0ZScsIGFuaW1hdGlvbk1hbmFnZXIsIHBhdGgsIGZucy5wYXRoKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnbGFiZWxzJywgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnYW5ub3RhdGlvbnMnLCBhbmltYXRpb25NYW5hZ2VyLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXREYXR1bUlkKGRhdHVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURhdHVtSWQoW2Ake2RhdHVtLnhWYWx1ZX1gXSk7XHJcbiAgICB9XHJcbiAgICBpc0xhYmVsRW5hYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5lbmFibGVkO1xyXG4gICAgfVxyXG4gICAgZ2V0QmFuZFNjYWxlUGFkZGluZygpIHtcclxuICAgICAgICByZXR1cm4geyBpbm5lcjogMSwgb3V0ZXI6IDAuMSB9O1xyXG4gICAgfVxyXG4gICAgbm9kZUZhY3RvcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcm91cCgpO1xyXG4gICAgfVxyXG59XHJcbkxpbmVTZXJpZXMuY2xhc3NOYW1lID0gJ0xpbmVTZXJpZXMnO1xyXG5MaW5lU2VyaWVzLnR5cGUgPSAnbGluZSc7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBMaW5lU2VyaWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgTGluZVNlcmllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX0xJTkVfREFTSCksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIExpbmVTZXJpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgTGluZVNlcmllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShOVU1CRVIkMSgwKSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG5dLCBMaW5lU2VyaWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE5VTUJFUiQxKDAsIDEpKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbl0sIExpbmVTZXJpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIExpbmVTZXJpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIExpbmVTZXJpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBMaW5lU2VyaWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBMaW5lU2VyaWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCB2b2lkIDApO1xuXG5jb25zdCBMaW5lU2VyaWVzTW9kdWxlID0ge1xyXG4gICAgdHlwZTogJ3NlcmllcycsXHJcbiAgICBvcHRpb25zS2V5OiAnc2VyaWVzW10nLFxyXG4gICAgcGFja2FnZVR5cGU6ICdjb21tdW5pdHknLFxyXG4gICAgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nXSxcclxuICAgIGlkZW50aWZpZXI6ICdsaW5lJyxcclxuICAgIGluc3RhbmNlQ29uc3RydWN0b3I6IExpbmVTZXJpZXMsXHJcbiAgICBzZXJpZXNEZWZhdWx0czogREVGQVVMVF9DQVJURVNJQU5fQ0hBUlRfT1ZFUlJJREVTLFxyXG4gICAgdGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIF9fZXh0ZW5kc19fOiBFWFRFTkRTX1NFUklFU19ERUZBVUxUUyxcclxuICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbm9kZScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzdHJva2VPcGFjaXR5OiAxLFxyXG4gICAgICAgIGxpbmVEYXNoOiBbMF0sXHJcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXHJcbiAgICAgICAgbWFya2VyOiB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kc19fOiBFWFRFTkRTX0NBUlRFU0lBTl9NQVJLRVJfREVGQVVMVFMsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBlbnRlcnByaXNlVGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIGVycm9yQmFyOiB7XHJcbiAgICAgICAgICAgIGNhcDoge1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoUmF0aW86IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBwYWxldHRlRmFjdG9yeTogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgbWFya2VyIH0gPSBtYXJrZXJQYWxldHRlRmFjdG9yeShwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLmZpbGwsXHJcbiAgICAgICAgICAgIG1hcmtlcixcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxufTtcblxuY2xhc3MgU2NhdHRlclNlcmllcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcclxuICAgICAgICBzdXBlcih7XHJcbiAgICAgICAgICAgIG1vZHVsZUN0eCxcclxuICAgICAgICAgICAgcGlja01vZGVzOiBbXHJcbiAgICAgICAgICAgICAgICBTZXJpZXNOb2RlUGlja01vZGUuTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1QsXHJcbiAgICAgICAgICAgICAgICBTZXJpZXNOb2RlUGlja01vZGUuTkVBUkVTVF9OT0RFLFxyXG4gICAgICAgICAgICAgICAgU2VyaWVzTm9kZVBpY2tNb2RlLkVYQUNUX1NIQVBFX01BVENILFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBwYXRoc1BlclNlcmllczogMCxcclxuICAgICAgICAgICAgaGFzTWFya2VyczogdHJ1ZSxcclxuICAgICAgICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxyXG4gICAgICAgICAgICBhbmltYXRpb25SZXNldEZuczoge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyOiByZXNldE1hcmtlckZuLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcclxuICAgICAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxhYmVsS2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueE5hbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy55TmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxhYmVsTmFtZSA9ICdMYWJlbCc7XHJcbiAgICAgICAgdGhpcy54S2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMueUtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvbG9yS2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY29sb3JOYW1lID0gJ0NvbG9yJztcclxuICAgICAgICB0aGlzLmNvbG9yUmFuZ2UgPSBbJyNmZmZmMDAnLCAnIzAwZmYwMCcsICcjMDAwMGZmJ107XHJcbiAgICAgICAgdGhpcy5jb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSwgZGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHhLZXkgPT0gbnVsbCB8fCB5S2V5ID09IG51bGwgfHwgZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB7IGlzQ29udGludW91c1gsIGlzQ29udGludW91c1kgfSA9IHRoaXMuaXNDb250aW51b3VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29sb3JTY2FsZSwgY29sb3JEb21haW4sIGNvbG9yUmFuZ2UsIGNvbG9yS2V5IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0geWllbGQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XHJcbiAgICAgICAgICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BlcnR5KHRoaXMsIHhLZXksIGlzQ29udGludW91c1gsIHsgaWQ6ICd4S2V5LXJhdycgfSksXHJcbiAgICAgICAgICAgICAgICAgICAga2V5UHJvcGVydHkodGhpcywgeUtleSwgaXNDb250aW51b3VzWSwgeyBpZDogJ3lLZXktcmF3JyB9KSxcclxuICAgICAgICAgICAgICAgICAgICAuLi4obGFiZWxLZXkgPyBba2V5UHJvcGVydHkodGhpcywgbGFiZWxLZXksIGZhbHNlLCB7IGlkOiBgbGFiZWxLZXktcmF3YCB9KV0gOiBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVQcm9wZXJ0eSh0aGlzLCB4S2V5LCBpc0NvbnRpbnVvdXNYLCB7IGlkOiBgeFZhbHVlYCB9KSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVByb3BlcnR5KHRoaXMsIHlLZXksIGlzQ29udGludW91c1ksIHsgaWQ6IGB5VmFsdWVgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihjb2xvcktleSA/IFt2YWx1ZVByb3BlcnR5KHRoaXMsIGNvbG9yS2V5LCB0cnVlLCB7IGlkOiBgY29sb3JWYWx1ZWAgfSldIDogW10pLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihsYWJlbEtleSA/IFt2YWx1ZVByb3BlcnR5KHRoaXMsIGxhYmVsS2V5LCBmYWxzZSwgeyBpZDogYGxhYmVsVmFsdWVgIH0pXSA6IFtdKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBkYXRhVmlzaWJsZTogdGhpcy52aXNpYmxlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGNvbG9yS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvcktleUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY29sb3JWYWx1ZWApLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgY29sb3JTY2FsZS5kb21haW4gPSAoX2EgPSBjb2xvckRvbWFpbiAhPT0gbnVsbCAmJiBjb2xvckRvbWFpbiAhPT0gdm9pZCAwID8gY29sb3JEb21haW4gOiBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbY29sb3JLZXlJZHhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICAgICAgICAgIGNvbG9yU2NhbGUucmFuZ2UgPSBjb2xvclJhbmdlO1xyXG4gICAgICAgICAgICAgICAgY29sb3JTY2FsZS51cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oJ3VwZGF0ZURhdGEnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcclxuICAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIGNvbnN0IGlkID0gZGlyZWN0aW9uID09PSBDaGFydEF4aXNEaXJlY3Rpb24uWCA/IGB4VmFsdWVgIDogYHlWYWx1ZWA7XHJcbiAgICAgICAgY29uc3QgZGF0YURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgaWQpO1xyXG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgaWQsICd2YWx1ZScsIHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIGlmICgoZGF0YURlZiA9PT0gbnVsbCB8fCBkYXRhRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhRGVmLmRlZi50eXBlKSA9PT0gJ3ZhbHVlJyAmJiAoZGF0YURlZiA9PT0gbnVsbCB8fCBkYXRhRGVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhRGVmLmRlZi52YWx1ZVR5cGUpID09PSAnY2F0ZWdvcnknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcclxuICAgICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSwgYXhpcyk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVOb2RlRGF0YSgpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgY2FsY3VsYXRlU2NhbGluZzogeyBnZXQ6ICgpID0+IHN1cGVyLmNhbGN1bGF0ZVNjYWxpbmcgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZpc2libGUsIGF4ZXMsIHlLZXkgPSAnJywgeEtleSA9ICcnLCBsYWJlbCwgbGFiZWxLZXksIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgeEF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5YXTtcclxuICAgICAgICAgICAgY29uc3QgeUF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5ZXTtcclxuICAgICAgICAgICAgaWYgKCEoZGF0YU1vZGVsICYmIHByb2Nlc3NlZERhdGEgJiYgdmlzaWJsZSAmJiB4QXhpcyAmJiB5QXhpcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHhEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKS5pbmRleDtcclxuICAgICAgICAgICAgY29uc3QgeURhdGFJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZWApLmluZGV4O1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvckRhdGFJZHggPSB0aGlzLmNvbG9yS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjb2xvclZhbHVlYCkuaW5kZXggOiAtMTtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxEYXRhSWR4ID0gdGhpcy5sYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGFiZWxWYWx1ZWApLmluZGV4IDogLTE7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29sb3JTY2FsZSwgY29sb3JLZXkgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xyXG4gICAgICAgICAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcclxuICAgICAgICAgICAgY29uc3QgeE9mZnNldCA9ICgoX2EgPSB4U2NhbGUuYmFuZHdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IHlPZmZzZXQgPSAoKF9iID0geVNjYWxlLmJhbmR3aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgZm9udCA9IGxhYmVsLmdldEZvbnQoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlcywgZGF0dW0gfSBvZiAoX2MgPSBwcm9jZXNzZWREYXRhLmRhdGEpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4RGF0dW0gPSB2YWx1ZXNbeERhdGFJZHhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeURhdHVtID0gdmFsdWVzW3lEYXRhSWR4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydCh5RGF0dW0pICsgeU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KHRoaXMubGFiZWwsIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGFiZWxLZXkgPyB2YWx1ZXNbbGFiZWxEYXRhSWR4XSA6IHlEYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICB4S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgeE5hbWU6IHRoaXMueE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgeU5hbWU6IHRoaXMueU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxOYW1lOiB0aGlzLmxhYmVsTmFtZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IEhkcGlDYW52YXMuZ2V0VGV4dFNpemUobGFiZWxUZXh0LCBmb250KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGwgPSBjb2xvcktleSA/IGNvbG9yU2NhbGUuY29udmVydCh2YWx1ZXNbY29sb3JEYXRhSWR4XSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBub2RlRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiB5S2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHlLZXksXHJcbiAgICAgICAgICAgICAgICAgICAgeEtleSxcclxuICAgICAgICAgICAgICAgICAgICBkYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICB4VmFsdWU6IHhEYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICB5VmFsdWU6IHlEYXR1bSxcclxuICAgICAgICAgICAgICAgICAgICBjYXBEZWZhdWx0czogeyBsZW5ndGhSYXRpb011bHRpcGxpZXI6IHRoaXMubWFya2VyLmdldERpYW1ldGVyKCksIGxlbmd0aE1heDogSW5maW5pdHkgfSxcclxuICAgICAgICAgICAgICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBtYXJrZXIuc2l6ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBPYmplY3QuYXNzaWduKHsgdGV4dDogbGFiZWxUZXh0IH0sIHNpemUpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IChfZCA9IHRoaXMueUtleSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5pZCxcclxuICAgICAgICAgICAgICAgICAgICBub2RlRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlczogX3N1cGVyLmNhbGN1bGF0ZVNjYWxpbmcuY2FsbCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaXNQYXRoT3JTZWxlY3Rpb25EaXJ0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXIuaXNEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0TGFiZWxEYXRhKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jb250ZXh0Tm9kZURhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWR1Y2UoKHIsIG4pID0+IHIuY29uY2F0KG4ubGFiZWxEYXRhKSwgW10pO1xyXG4gICAgfVxyXG4gICAgbWFya2VyRmFjdG9yeSgpIHtcclxuICAgICAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLm1hcmtlcjtcclxuICAgICAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWFya2VyOiB7IGVuYWJsZWQgfSwgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlci5pc0RpcnR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZW5hYmxlZCA/IG5vZGVEYXRhIDogW107XHJcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeEtleSA9ICcnLCB5S2V5ID0gJycsIGxhYmVsS2V5LCBtYXJrZXIgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgdGhpcy5oaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSk7XHJcbiAgICAgICAgICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5LCBsYWJlbEtleSB9LCBiYXNlU3R5bGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXIubWFya0NsZWFuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWw6IHsgZW5hYmxlZCB9LCB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgcGxhY2VkTGFiZWxzID0gZW5hYmxlZCA/IChfYiA9IChfYSA9IHRoaXMuY2hhcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbGFjZUxhYmVscygpLmdldCh0aGlzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10gOiBbXTtcclxuICAgICAgICAgICAgY29uc3QgcGxhY2VkTm9kZURhdHVtID0gcGxhY2VkTGFiZWxzLm1hcCgodikgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdi5kYXR1bSksIHsgcG9pbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiB2LngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogdi55LFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHYuZGF0dW0ucG9pbnQuc2l6ZSxcclxuICAgICAgICAgICAgICAgIH0gfSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZShwbGFjZWROb2RlRGF0dW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsYWJlbFNlbGVjdGlvbiB9ID0gb3B0cztcclxuICAgICAgICAgICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAgICAgICAgIHRleHQudGV4dCA9IGRhdHVtLmxhYmVsLnRleHQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LmZpbGwgPSBsYWJlbC5jb2xvcjtcclxuICAgICAgICAgICAgICAgIHRleHQueCA9IChfYiA9IChfYSA9IGRhdHVtLnBvaW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICAgICAgICAgIHRleHQueSA9IChfZCA9IChfYyA9IGRhdHVtLnBvaW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMDtcclxuICAgICAgICAgICAgICAgIHRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcclxuICAgICAgICAgICAgICAgIHRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcclxuICAgICAgICAgICAgICAgIHRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICAgICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9vbHRpcEh0bWwobm9kZURhdHVtKSB7XHJcbiAgICAgICAgY29uc3QgeyB4S2V5LCB5S2V5LCBheGVzIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gYXhlc1tDaGFydEF4aXNEaXJlY3Rpb24uWF07XHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSBheGVzW0NoYXJ0QXhpc0RpcmVjdGlvbi5ZXTtcclxuICAgICAgICBpZiAoIXhLZXkgfHwgIXlLZXkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgbWFya2VyLCB0b29sdGlwLCB4TmFtZSwgeU5hbWUsIGxhYmVsS2V5LCBsYWJlbE5hbWUsIGlkOiBzZXJpZXNJZCwgdGl0bGUgPSB5TmFtZSB9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKHsgZmlsbDogbm9kZURhdHVtLmZpbGwsIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKG1hcmtlci5zdHJva2VXaWR0aCkgfSwgbWFya2VyLmdldFN0eWxlKCkpO1xyXG4gICAgICAgIGNvbnN0IHsgZmlsbDogY29sb3IgPSAnZ3JheScgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUobWFya2VyLCB7IGRhdHVtOiBub2RlRGF0dW0sIGhpZ2hsaWdodGVkOiBmYWxzZSwgeEtleSwgeUtleSwgbGFiZWxLZXkgfSwgYmFzZVN0eWxlKTtcclxuICAgICAgICBjb25zdCB7IGRhdHVtLCB4VmFsdWUsIHlWYWx1ZSwgbGFiZWwgfSA9IG5vZGVEYXR1bTtcclxuICAgICAgICBjb25zdCB4U3RyaW5nID0gc2FuaXRpemVIdG1sKHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSkpO1xyXG4gICAgICAgIGNvbnN0IHlTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKSk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwoeE5hbWUgIT09IG51bGwgJiYgeE5hbWUgIT09IHZvaWQgMCA/IHhOYW1lIDogeEtleSl9PC9iPjogJHt4U3RyaW5nfTxicj5gICtcclxuICAgICAgICAgICAgYDxiPiR7c2FuaXRpemVIdG1sKHlOYW1lICE9PSBudWxsICYmIHlOYW1lICE9PSB2b2lkIDAgPyB5TmFtZSA6IHlLZXkpfTwvYj46ICR7eVN0cmluZ31gO1xyXG4gICAgICAgIGlmIChsYWJlbEtleSkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gYDxiPiR7c2FuaXRpemVIdG1sKGxhYmVsTmFtZSAhPT0gbnVsbCAmJiBsYWJlbE5hbWUgIT09IHZvaWQgMCA/IGxhYmVsTmFtZSA6IGxhYmVsS2V5KX08L2I+OiAke3Nhbml0aXplSHRtbChsYWJlbC50ZXh0KX08YnI+YCArIGNvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LCBPYmplY3QuYXNzaWduKHsgZGF0dW0sXHJcbiAgICAgICAgICAgIHhLZXksXHJcbiAgICAgICAgICAgIHhOYW1lLFxyXG4gICAgICAgICAgICB5S2V5LFxyXG4gICAgICAgICAgICB5TmFtZSxcclxuICAgICAgICAgICAgbGFiZWxLZXksXHJcbiAgICAgICAgICAgIGxhYmVsTmFtZSxcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIGNvbG9yLFxyXG4gICAgICAgICAgICBzZXJpZXNJZCB9LCB0aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoZGF0dW0pKSk7XHJcbiAgICB9XHJcbiAgICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xyXG4gICAgICAgIGNvbnN0IHsgaWQsIGRhdGEsIHhLZXksIHlLZXksIHlOYW1lLCB0aXRsZSwgdmlzaWJsZSwgbWFya2VyIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGggfSA9IG1hcmtlcjtcclxuICAgICAgICBpZiAoISgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmxlbmd0aCkgJiYgeEtleSAmJiB5S2V5ICYmIGxlZ2VuZFR5cGUgPT09ICdjYXRlZ29yeScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kVHlwZTogJ2NhdGVnb3J5JyxcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgaXRlbUlkOiB5S2V5LFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzSWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogKF9hID0gdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogeU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHlLZXksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbWFya2VyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAoX2MgPSAoX2IgPSBtYXJrZXIuZmlsbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmlsbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ3JnYmEoMCwgMCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogKF9lID0gKF9kID0gbWFya2VyLnN0cm9rZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogc3Ryb2tlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAncmdiYSgwLCAwLCAwLCAwKScsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5ICE9PSBudWxsICYmIGZpbGxPcGFjaXR5ICE9PSB2b2lkIDAgPyBmaWxsT3BhY2l0eSA6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eSAhPT0gbnVsbCAmJiBzdHJva2VPcGFjaXR5ICE9PSB2b2lkIDAgPyBzdHJva2VPcGFjaXR5IDogMSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGggIT09IG51bGwgJiYgc3Ryb2tlV2lkdGggIT09IHZvaWQgMCA/IHN0cm9rZVdpZHRoIDogMCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcclxuICAgICAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbnMsIGxhYmVsU2VsZWN0aW9ucywgYW5ub3RhdGlvblNlbGVjdGlvbnMgfSA9IGRhdGE7XHJcbiAgICAgICAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbih0aGlzLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb25zKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnbGFiZWxzJywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcclxuICAgICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCAnYW5ub3RhdGlvbnMnLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBpc0xhYmVsRW5hYmxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbC5lbmFibGVkO1xyXG4gICAgfVxyXG4gICAgbm9kZUZhY3RvcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcm91cCgpO1xyXG4gICAgfVxyXG59XHJcblNjYXR0ZXJTZXJpZXMuY2xhc3NOYW1lID0gJ1NjYXR0ZXJTZXJpZXMnO1xyXG5TY2F0dGVyU2VyaWVzLnR5cGUgPSAnc2NhdHRlcic7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBTY2F0dGVyU2VyaWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgU2NhdHRlclNlcmllcy5wcm90b3R5cGUsIFwibGFiZWxLZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIFNjYXR0ZXJTZXJpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBTY2F0dGVyU2VyaWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgU2NhdHRlclNlcmllcy5wcm90b3R5cGUsIFwibGFiZWxOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBTY2F0dGVyU2VyaWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBTY2F0dGVyU2VyaWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX1NUUklORyksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG5dLCBTY2F0dGVyU2VyaWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgU2NhdHRlclNlcmllcy5wcm90b3R5cGUsIFwiY29sb3JOYW1lXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoT1BUX05VTUJFUl9BUlJBWSksXHJcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbl0sIFNjYXR0ZXJTZXJpZXMucHJvdG90eXBlLCBcImNvbG9yRG9tYWluXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgU2NhdHRlclNlcmllcy5wcm90b3R5cGUsIFwiY29sb3JSYW5nZVwiLCB2b2lkIDApO1xuXG5jb25zdCBTY2F0dGVyU2VyaWVzTW9kdWxlID0ge1xyXG4gICAgdHlwZTogJ3NlcmllcycsXHJcbiAgICBvcHRpb25zS2V5OiAnc2VyaWVzW10nLFxyXG4gICAgcGFja2FnZVR5cGU6ICdjb21tdW5pdHknLFxyXG4gICAgY2hhcnRUeXBlczogWydjYXJ0ZXNpYW4nXSxcclxuICAgIGlkZW50aWZpZXI6ICdzY2F0dGVyJyxcclxuICAgIGluc3RhbmNlQ29uc3RydWN0b3I6IFNjYXR0ZXJTZXJpZXMsXHJcbiAgICBzZXJpZXNEZWZhdWx0czoge1xyXG4gICAgICAgIGF4ZXM6IFtcclxuICAgICAgICAgICAgeyB0eXBlOiBDQVJURVNJQU5fQVhJU19UWVBFUy5OVU1CRVIsIHBvc2l0aW9uOiBDQVJURVNJQU5fQVhJU19QT1NJVElPTlMuQk9UVE9NIH0sXHJcbiAgICAgICAgICAgIHsgdHlwZTogQ0FSVEVTSUFOX0FYSVNfVFlQRVMuTlVNQkVSLCBwb3NpdGlvbjogQ0FSVEVTSUFOX0FYSVNfUE9TSVRJT05TLkxFRlQgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHRoZW1lVGVtcGxhdGU6IHtcclxuICAgICAgICBfX2V4dGVuZHNfXzogRVhURU5EU19TRVJJRVNfREVGQVVMVFMsXHJcbiAgICAgICAgdG9vbHRpcDoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ25vZGUnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWFya2VyOiB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kc19fOiBFWFRFTkRTX0NBUlRFU0lBTl9NQVJLRVJfREVGQVVMVFMsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgZm9udFN0eWxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxyXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBlbnRlcnByaXNlVGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIGVycm9yQmFyOiB7XHJcbiAgICAgICAgICAgIGNhcDoge1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoUmF0aW86IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBwYWxldHRlRmFjdG9yeTogbWFya2VyUGFsZXR0ZUZhY3RvcnksXHJcbn07XG5cbmNvbnN0IFBpZVNlcmllc01vZHVsZSA9IHtcclxuICAgIHR5cGU6ICdzZXJpZXMnLFxyXG4gICAgb3B0aW9uc0tleTogJ3Nlcmllc1tdJyxcclxuICAgIHBhY2thZ2VUeXBlOiAnY29tbXVuaXR5JyxcclxuICAgIGNoYXJ0VHlwZXM6IFsncG9sYXInXSxcclxuICAgIGlkZW50aWZpZXI6ICdwaWUnLFxyXG4gICAgaW5zdGFuY2VDb25zdHJ1Y3RvcjogUGllU2VyaWVzLFxyXG4gICAgc2VyaWVzRGVmYXVsdHM6IHt9LFxyXG4gICAgdGhlbWVUZW1wbGF0ZToge1xyXG4gICAgICAgIF9fZXh0ZW5kc19fOiBFWFRFTkRTX1NFUklFU19ERUZBVUxUUyxcclxuICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogTk9STUFMLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgc3BhY2luZzogNSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbGxvdXRMYWJlbDoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgb2Zmc2V0OiAzLFxyXG4gICAgICAgICAgICBtaW5BbmdsZTogMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlY3RvckxhYmVsOiB7XHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGZvbnRTdHlsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBOT1JNQUwsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcclxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uT2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICBwb3NpdGlvblJhdGlvOiAwLjUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWxsb3V0TGluZToge1xyXG4gICAgICAgICAgICBsZW5ndGg6IDEwLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZpbGxPcGFjaXR5OiAxLFxyXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXHJcbiAgICAgICAgbGluZURhc2g6IFswXSxcclxuICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcclxuICAgICAgICByb3RhdGlvbjogMCxcclxuICAgICAgICBvdXRlclJhZGl1c09mZnNldDogMCxcclxuICAgICAgICBpbm5lclJhZGl1c09mZnNldDogMCxcclxuICAgICAgICBzaGFkb3c6IHtcclxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXHJcbiAgICAgICAgICAgIHhPZmZzZXQ6IDMsXHJcbiAgICAgICAgICAgIHlPZmZzZXQ6IDMsXHJcbiAgICAgICAgICAgIGJsdXI6IDUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbm5lckxhYmVsczoge1xyXG4gICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgbWFyZ2luOiAyLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgcGFsZXR0ZUZhY3Rvcnk6ICh7IHRha2VDb2xvcnMsIGNvbG9yc0NvdW50LCB1c2VyUGFsZXR0ZSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBmaWxscywgc3Ryb2tlcyB9ID0gdGFrZUNvbG9ycyhjb2xvcnNDb3VudCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbHMsXHJcbiAgICAgICAgICAgIHN0cm9rZXM6IHVzZXJQYWxldHRlID8gc3Ryb2tlcyA6IFtERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0VdLFxyXG4gICAgICAgICAgICBjYWxsb3V0TGluZToge1xyXG4gICAgICAgICAgICAgICAgY29sb3JzOiBzdHJva2VzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xuXG5mdW5jdGlvbiByZWdpc3RlckluYnVpbHRNb2R1bGVzKCkge1xyXG4gICAgcmVnaXN0ZXJNb2R1bGUoQmFja2dyb3VuZE1vZHVsZSk7XHJcbiAgICByZWdpc3Rlck1vZHVsZShOYXZpZ2F0b3JNb2R1bGUpO1xyXG4gICAgcmVnaXN0ZXJNb2R1bGUoQXJlYVNlcmllc01vZHVsZSk7XHJcbiAgICByZWdpc3Rlck1vZHVsZShCYXJTZXJpZXNNb2R1bGUpO1xyXG4gICAgcmVnaXN0ZXJNb2R1bGUoQnViYmxlU2VyaWVzTW9kdWxlKTtcclxuICAgIHJlZ2lzdGVyTW9kdWxlKExpbmVTZXJpZXNNb2R1bGUpO1xyXG4gICAgcmVnaXN0ZXJNb2R1bGUoU2NhdHRlclNlcmllc01vZHVsZSk7XHJcbiAgICByZWdpc3Rlck1vZHVsZShQaWVTZXJpZXNNb2R1bGUpO1xyXG4gICAgcmVnaXN0ZXJNb2R1bGUoSGlzdG9ncmFtU2VyaWVzTW9kdWxlKTtcclxufVxuXG5mdW5jdGlvbiBpbnZlcnRTaGFwZURpcmVjdGlvbiguLi5zdXBwb3J0ZWRTaGFwZXMpIHtcclxuICAgIGZvciAoY29uc3Qgc2hhcGUgb2Ygc3VwcG9ydGVkU2hhcGVzKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlIGluc3RhbmNlb2YgUmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHNoYXBlO1xyXG4gICAgICAgICAgICBzaGFwZS5zZXRQcm9wZXJ0aWVzKHsgeDogeSwgeTogeCwgd2lkdGg6IGhlaWdodCwgaGVpZ2h0OiB3aWR0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBMaW5lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHNoYXBlO1xyXG4gICAgICAgICAgICBzaGFwZS5zZXRQcm9wZXJ0aWVzKHsgeDE6IHkxLCB5MTogeDEsIHgyOiB5MiwgeTI6IHgyIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBIaWVyYXJjaHlOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmllcywgaW5kZXgsIGRhdHVtLCBzaXplLCBjb2xvclZhbHVlLCBmaWxsLCBzdHJva2UsIHN1bVNpemUsIGRlcHRoLCBwYXJlbnQsIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuZGF0dW0gPSBkYXR1bTtcclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIHRoaXMuY29sb3JWYWx1ZSA9IGNvbG9yVmFsdWU7XHJcbiAgICAgICAgdGhpcy5maWxsID0gZmlsbDtcclxuICAgICAgICB0aGlzLnN0cm9rZSA9IHN0cm9rZTtcclxuICAgICAgICB0aGlzLnN1bVNpemUgPSBzdW1TaXplO1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5taWRQb2ludCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgfVxyXG4gICAgY29udGFpbnMob3RoZXIpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IG90aGVyO1xyXG4gICAgICAgIC8vIEluZGV4IGNoZWNrIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIC0gaXQgZG9lcyBub3QgYWZmZWN0IGNvcnJlY3RuZXNzXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50LmluZGV4ID49IHRoaXMuaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgd2FsayhjYWxsYmFjaywgb3JkZXIgPSBIaWVyYXJjaHlOb2RlLldhbGsuUHJlT3JkZXIpIHtcclxuICAgICAgICBpZiAob3JkZXIgPT09IEhpZXJhcmNoeU5vZGUuV2Fsay5QcmVPcmRlcikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZC53YWxrKGNhbGxiYWNrLCBvcmRlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9yZGVyID09PSBIaWVyYXJjaHlOb2RlLldhbGsuUG9zdE9yZGVyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICB5aWVsZCB0aGlzO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB5aWVsZCogY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkhpZXJhcmNoeU5vZGUuV2FsayA9IHtcclxuICAgIFByZU9yZGVyOiAwLFxyXG4gICAgUG9zdE9yZGVyOiAxLFxyXG59O1xyXG5jbGFzcyBIaWVyYXJjaHlTZXJpZXMgZXh0ZW5kcyBTZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBtb2R1bGVDdHgsXHJcbiAgICAgICAgICAgIHBpY2tNb2RlczogW1Nlcmllc05vZGVQaWNrTW9kZS5FWEFDVF9TSEFQRV9NQVRDSF0sXHJcbiAgICAgICAgICAgIGNvbnRlbnRHcm91cFZpcnR1YWw6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5LZXkgPSAnY2hpbGRyZW4nO1xyXG4gICAgICAgIHRoaXMuc2l6ZUtleSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvbG9yS2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY29sb3JOYW1lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZmlsbHMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlcyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9TVFJPS0VTKTtcclxuICAgICAgICB0aGlzLmNvbG9yUmFuZ2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yb290Tm9kZSA9IG5ldyBIaWVyYXJjaHlOb2RlKHRoaXMsIDAsIHVuZGVmaW5lZCwgMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFtdKTtcclxuICAgICAgICB0aGlzLmNvbG9yRG9tYWluID0gWzAsIDBdO1xyXG4gICAgICAgIHRoaXMubWF4RGVwdGggPSAwO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKCdlbXB0eScsIHtcclxuICAgICAgICAgICAgZW1wdHk6IHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ3JlYWR5JyxcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVhZHk6IHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGE6ICd3YWl0aW5nJyxcclxuICAgICAgICAgICAgICAgIGNsZWFyOiAnY2xlYXJpbmcnLFxyXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0OiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSksXHJcbiAgICAgICAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2FpdGluZzoge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAncmVhZHknLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsZWFyaW5nOiB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdlbXB0eScsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSwgKCkgPT4gdGhpcy5jaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkpO1xyXG4gICAgfVxyXG4gICAgaGFzRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpICYmIHRoaXMuZGF0YS5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc0RhdGEoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuS2V5LCBzaXplS2V5LCBjb2xvcktleSwgZmlsbHMsIHN0cm9rZXMsIGNvbG9yUmFuZ2UgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGdldEluZGV4ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IG1heERlcHRoID0gMDtcclxuICAgICAgICAgICAgbGV0IG1pbkNvbG9yID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIGxldCBtYXhDb2xvciA9IC1JbmZpbml0eTtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JzID0gbmV3IEFycmF5KCgoX2IgPSAoX2EgPSB0aGlzLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApICsgMSkuZmlsbCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVOb2RlID0gKGRhdHVtLCBwYXJlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gcGFyZW50LmRlcHRoICE9IG51bGwgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW5LZXkgIT0gbnVsbCA/IGRhdHVtW2NoaWxkcmVuS2V5XSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzTGVhZiA9IGNoaWxkcmVuID09IG51bGwgfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSBzaXplS2V5ICE9IG51bGwgPyBkYXR1bVtzaXplS2V5XSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplID0gaXNMZWFmID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdW1TaXplID0gc2l6ZTtcclxuICAgICAgICAgICAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JLZXkgIT0gbnVsbCA/IGRhdHVtW2NvbG9yS2V5XSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzW2luZGV4XSA9IGNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkNvbG9yID0gTWF0aC5taW4obWluQ29sb3IsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXhDb2xvciA9IE1hdGgubWF4KG1heENvbG9yLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwZW5kQ2hpbGRyZW4obmV3IEhpZXJhcmNoeU5vZGUodGhpcywgaW5kZXgsIGRhdHVtLCBzaXplLCBjb2xvciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHN1bVNpemUsIGRlcHRoLCBwYXJlbnQsIFtdKSwgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBhcHBlbmRDaGlsZHJlbiA9IChub2RlLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNyZWF0ZU5vZGUoZGF0dW0sIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdW1TaXplICs9IGNoaWxkLnN1bVNpemU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IGFwcGVuZENoaWxkcmVuKG5ldyBIaWVyYXJjaHlOb2RlKHRoaXMsIDAsIHVuZGVmaW5lZCwgMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFtdKSwgdGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JEb21haW4gPSBbbWluQ29sb3IsIG1heENvbG9yXTtcclxuICAgICAgICAgICAgbGV0IGNvbG9yU2NhbGU7XHJcbiAgICAgICAgICAgIGlmIChjb2xvclJhbmdlICE9IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKG1pbkNvbG9yKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4Q29sb3IpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbG9yU2NhbGUuZG9tYWluID0gY29sb3JEb21haW47XHJcbiAgICAgICAgICAgICAgICBjb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcclxuICAgICAgICAgICAgICAgIGNvbG9yU2NhbGUudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC53YWxrKChub2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvcnNbbm9kZS5pbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbCA9IGNvbG9yU2NhbGUgPT09IG51bGwgfHwgY29sb3JTY2FsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sb3JTY2FsZS5jb252ZXJ0KGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbCAhPT0gbnVsbCAmJiBmaWxsICE9PSB2b2lkIDAgPyBmaWxsIDogKGZpbGwgPSBmaWxscyA9PT0gbnVsbCB8fCBmaWxscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsbHNbaW5kZXggJSBmaWxscy5sZW5ndGhdKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmZpbGwgPSBmaWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBJZiB0aGVyZSdzIGEgY29sb3Igc2NhbGUsIHRoZSBzdHJva2VzIHdvbid0IG1ha2Ugc2Vuc2UuIEZvciBub3csIGp1c3QgaGFyZC1jb2RlIHRoaXMgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3Ryb2tlID0gY29sb3JTY2FsZSA9PSBudWxsID8gc3Ryb2tlcyA9PT0gbnVsbCB8fCBzdHJva2VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VzW2luZGV4ICUgc3Ryb2tlcy5sZW5ndGhdIDogJ3JnYmEoMCwgMCwgMCwgMC4yKSc7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcclxuICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCA9IG1heERlcHRoO1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yRG9tYWluID0gY29sb3JEb21haW47XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMoKTtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVOb2RlcygpO1xyXG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25EYXRhID0gdGhpcy5nZXRBbmltYXRpb25EYXRhKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZSA9IHRoaXMuY2hlY2tSZXNpemUoc2VyaWVzUmVjdCk7XHJcbiAgICAgICAgICAgIGlmIChyZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbigncmVzaXplJywgYW5pbWF0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKCd1cGRhdGUnLCBhbmltYXRpb25EYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgZGF0dW0gPSAoX2EgPSB0aGlzLmFuaW1hdGlvblJlc2V0Rm5zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0dW07XHJcbiAgICAgICAgLy8gU3RvcCBhbnkgcnVubmluZyBhbmltYXRpb25zIGJ5IHByZWZpeCBjb252ZW50aW9uLlxyXG4gICAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcclxuICAgICAgICBpZiAoZGF0dW0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXNldE1vdGlvbihkYXRhLmRhdHVtU2VsZWN0aW9ucywgZGF0dW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcclxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcclxuICAgICAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGRhdHVtID0gKF9hID0gdGhpcy5hbmltYXRpb25SZXNldEZucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdHVtO1xyXG4gICAgICAgIGlmIChkYXR1bSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgZGF0dW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcclxuICAgIH1cclxuICAgIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpIHtcclxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcclxuICAgICAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0aW9uVHJhbnNpdGlvbkNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbignY2xlYXInLCB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbmltYXRpb25EYXRhKCkge1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB7XHJcbiAgICAgICAgICAgIGRhdHVtU2VsZWN0aW9uczogW3RoaXMuZ3JvdXBTZWxlY3Rpb25dLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkRhdGE7XHJcbiAgICB9XHJcbiAgICBpc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldExhYmVsRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBnZXRTZXJpZXNEb21haW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XHJcbiAgICB9XHJcbiAgICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gbGVnZW5kVHlwZSA9PT0gJ2dyYWRpZW50JyAmJiB0aGlzLmNvbG9yS2V5ICE9IG51bGwgJiYgdGhpcy5jb2xvclJhbmdlICE9IG51bGxcclxuICAgICAgICAgICAgPyBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kVHlwZTogJ2dyYWRpZW50JyxcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0aGlzLnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JOYW1lOiB0aGlzLmNvbG9yTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvckRvbWFpbjogdGhpcy5jb2xvckRvbWFpbixcclxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbmdlOiB0aGlzLmNvbG9yUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIDogW107XHJcbiAgICB9XHJcbiAgICBnZXREYXR1bUlkRnJvbURhdGEobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBgJHtub2RlLmluZGV4fWA7XHJcbiAgICB9XHJcbiAgICBnZXREYXR1bUlkKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXR1bUlkRnJvbURhdGEobm9kZSk7XHJcbiAgICB9XHJcbn1cclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEhpZXJhcmNoeVNlcmllcy5wcm90b3R5cGUsIFwiY2hpbGRyZW5LZXlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfU1RSSU5HKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbl0sIEhpZXJhcmNoeVNlcmllcy5wcm90b3R5cGUsIFwic2l6ZUtleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgSGllcmFyY2h5U2VyaWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9TVFJJTkcpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuXSwgSGllcmFyY2h5U2VyaWVzLnByb3RvdHlwZSwgXCJjb2xvck5hbWVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HX0FSUkFZKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgSGllcmFyY2h5U2VyaWVzLnByb3RvdHlwZSwgXCJmaWxsc1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIFZhbGlkYXRlKE9QVF9DT0xPUl9TVFJJTkdfQVJSQVkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG5dLCBIaWVyYXJjaHlTZXJpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICBWYWxpZGF0ZShPUFRfQ09MT1JfU1RSSU5HX0FSUkFZKSxcclxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuXSwgSGllcmFyY2h5U2VyaWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFBvbGFyQXhpcyBleHRlbmRzIEF4aXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnNoYXBlID0gJ3BvbHlnb24nO1xyXG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXNSYXRpbyA9IDA7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSAyMDtcclxuICAgIH1cclxuICAgIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgVmFsaWRhdGUoTlVNQkVSJDEoMCwgMSkpLFxyXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuXSwgUG9sYXJBeGlzLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1JhdGlvXCIsIHZvaWQgMCk7XG5cbi8qKlxyXG4gKiBJbnRlcm5hbCBVc2UgT25seTogVXNlZCB0byBlbnN1cmUgdGhpcyBmaWxlIGlzIHRyZWF0ZWQgYXMgYSBtb2R1bGUgdW50aWwgd2UgY2FuIHVzZSBtb2R1bGVEZXRlY3Rpb24gZmxhZyBpbiBUcyB2NC43XHJcbiAqL1xyXG5jb25zdCBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT04gPSAwO1xuXG52YXIgbW9kdWxlU3VwcG9ydCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXM6IGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzLFxuICAgIGlzRGVjb3JhdGVkT2JqZWN0OiBpc0RlY29yYXRlZE9iamVjdCxcbiAgICBsaXN0RGVjb3JhdGVkUHJvcGVydGllczogbGlzdERlY29yYXRlZFByb3BlcnRpZXMsXG4gICAgYXNzaWduSnNvbkFwcGx5Q29uc3RydWN0ZWRBcnJheTogYXNzaWduSnNvbkFwcGx5Q29uc3RydWN0ZWRBcnJheSxcbiAgICBNb3Rpb246IGVhc2luZyxcbiAgICByZXNldElkczogcmVzZXRJZHMsXG4gICAgZ2V0IENoYXJ0VXBkYXRlVHlwZSAoKSB7IHJldHVybiBDaGFydFVwZGF0ZVR5cGU7IH0sXG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgbm9ybWFsaXNlZEV4dGVudDogbm9ybWFsaXNlZEV4dGVudCxcbiAgICBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhOiBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhLFxuICAgIGFycmF5c0VxdWFsOiBhcnJheXNFcXVhbCxcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIFZhbGlkYXRlOiBWYWxpZGF0ZSxcbiAgICBwcmVkaWNhdGVXaXRoTWVzc2FnZTogcHJlZGljYXRlV2l0aE1lc3NhZ2UsXG4gICAgT1BUSU9OQUw6IE9QVElPTkFMLFxuICAgIEFSUkFZOiBBUlJBWSxcbiAgICBPUFRfQVJSQVk6IE9QVF9BUlJBWSxcbiAgICBOT05fRU1QVFlfQVJSQVk6IE5PTl9FTVBUWV9BUlJBWSxcbiAgICBPUFRfTk9OX0VNUFRZX0FSUkFZOiBPUFRfTk9OX0VNUFRZX0FSUkFZLFxuICAgIEFORDogQU5ELFxuICAgIE9SOiBPUixcbiAgICBMRVNTX1RIQU46IExFU1NfVEhBTixcbiAgICBHUkVBVEVSX1RIQU46IEdSRUFURVJfVEhBTixcbiAgICBGVU5DVElPTjogRlVOQ1RJT04sXG4gICAgT1BUX0ZVTkNUSU9OOiBPUFRfRlVOQ1RJT04sXG4gICAgQk9PTEVBTjogQk9PTEVBTixcbiAgICBPUFRfQk9PTEVBTjogT1BUX0JPT0xFQU4sXG4gICAgU1RSSU5HOiBTVFJJTkcsXG4gICAgT1BUX1NUUklORzogT1BUX1NUUklORyxcbiAgICBEQVRFOiBEQVRFLFxuICAgIE9QVF9EQVRFOiBPUFRfREFURSxcbiAgICBEQVRFX0FSUkFZOiBEQVRFX0FSUkFZLFxuICAgIERBVEVUSU1FX01TOiBEQVRFVElNRV9NUyxcbiAgICBPUFRfREFURVRJTUVfTVM6IE9QVF9EQVRFVElNRV9NUyxcbiAgICBPUFRfREFURV9PUl9EQVRFVElNRV9NUzogT1BUX0RBVEVfT1JfREFURVRJTUVfTVMsXG4gICAgQ09MT1JfU1RSSU5HOiBDT0xPUl9TVFJJTkcsXG4gICAgT1BUX0NPTE9SX1NUUklORzogT1BUX0NPTE9SX1NUUklORyxcbiAgICBDT0xPUl9TVFJJTkdfQVJSQVk6IENPTE9SX1NUUklOR19BUlJBWSxcbiAgICBPUFRfQ09MT1JfU1RSSU5HX0FSUkFZOiBPUFRfQ09MT1JfU1RSSU5HX0FSUkFZLFxuICAgIE5VTUJFUjogTlVNQkVSJDEsXG4gICAgT1BUX05VTUJFUjogT1BUX05VTUJFUixcbiAgICBOVU1CRVJfT1JfTkFOOiBOVU1CRVJfT1JfTkFOLFxuICAgIE5VTUJFUl9BUlJBWTogTlVNQkVSX0FSUkFZLFxuICAgIE9QVF9OVU1CRVJfQVJSQVk6IE9QVF9OVU1CRVJfQVJSQVksXG4gICAgU1RSSU5HX0FSUkFZOiBTVFJJTkdfQVJSQVksXG4gICAgT1BUX1NUUklOR19BUlJBWTogT1BUX1NUUklOR19BUlJBWSxcbiAgICBTVFJJTkdfVU5JT046IFNUUklOR19VTklPTixcbiAgICBCT09MRUFOX0FSUkFZOiBCT09MRUFOX0FSUkFZLFxuICAgIE9QVF9CT09MRUFOX0FSUkFZOiBPUFRfQk9PTEVBTl9BUlJBWSxcbiAgICBGT05UX1NUWUxFOiBGT05UX1NUWUxFLFxuICAgIE9QVF9GT05UX1NUWUxFOiBPUFRfRk9OVF9TVFlMRSxcbiAgICBGT05UX1dFSUdIVDogRk9OVF9XRUlHSFQsXG4gICAgT1BUX0ZPTlRfV0VJR0hUOiBPUFRfRk9OVF9XRUlHSFQsXG4gICAgTElORV9EQVNIOiBMSU5FX0RBU0gsXG4gICAgT1BUX0xJTkVfREFTSDogT1BUX0xJTkVfREFTSCxcbiAgICBMSU5FX0NBUDogTElORV9DQVAsXG4gICAgT1BUX0xJTkVfQ0FQOiBPUFRfTElORV9DQVAsXG4gICAgTElORV9KT0lOOiBMSU5FX0pPSU4sXG4gICAgT1BUX0xJTkVfSk9JTjogT1BUX0xJTkVfSk9JTixcbiAgICBQT1NJVElPTjogUE9TSVRJT04sXG4gICAgSU5URVJBQ1RJT05fUkFOR0U6IElOVEVSQUNUSU9OX1JBTkdFLFxuICAgIFRFWFRfV1JBUDogVEVYVF9XUkFQLFxuICAgIE9WRVJGTE9XX1NUUkFURUdZOiBPVkVSRkxPV19TVFJBVEVHWSxcbiAgICBURVhUX0FMSUdOOiBURVhUX0FMSUdOLFxuICAgIFZFUlRJQ0FMX0FMSUdOOiBWRVJUSUNBTF9BTElHTixcbiAgICBESVJFQ1RJT046IERJUkVDVElPTixcbiAgICBPUFRfRElSRUNUSU9OOiBPUFRfRElSRUNUSU9OLFxuICAgIERlZmF1bHQ6IERlZmF1bHQsXG4gICAgaW5qZWN0U3R5bGU6IGluamVjdFN0eWxlLFxuICAgIGNsYW1wOiBjbGFtcCxcbiAgICBpc0VxdWFsOiBpc0VxdWFsLFxuICAgIGlzTmVnYXRpdmU6IGlzTmVnYXRpdmUsXG4gICAgcm91bmQ6IHJvdW5kJDEsXG4gICAgdG9GaXhlZDogdG9GaXhlZCxcbiAgICBtb2Q6IG1vZCxcbiAgICBkZWVwTWVyZ2U6IGRlZXBNZXJnZSxcbiAgICBtZXJnZURlZmF1bHRzOiBtZXJnZURlZmF1bHRzLFxuICAgIHBhcnRpYWxBc3NpZ246IHBhcnRpYWxBc3NpZ24sXG4gICAgUHJveHlPbldyaXRlOiBQcm94eU9uV3JpdGUsXG4gICAgUHJveHlQcm9wZXJ0eU9uV3JpdGU6IFByb3h5UHJvcGVydHlPbldyaXRlLFxuICAgIEFjdGlvbk9uU2V0OiBBY3Rpb25PblNldCxcbiAgICBpbnZlcnRTaGFwZURpcmVjdGlvbjogaW52ZXJ0U2hhcGVEaXJlY3Rpb24sXG4gICAgc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5LFxuICAgIG1hcmtlclBhbGV0dGVGYWN0b3J5OiBtYXJrZXJQYWxldHRlRmFjdG9yeSxcbiAgICBCYXNlTW9kdWxlSW5zdGFuY2U6IEJhc2VNb2R1bGVJbnN0YW5jZSxcbiAgICBSRUdJU1RFUkVEX01PRFVMRVM6IFJFR0lTVEVSRURfTU9EVUxFUyxcbiAgICByZWdpc3Rlck1vZHVsZTogcmVnaXN0ZXJNb2R1bGUsXG4gICAgaGFzUmVnaXN0ZXJlZEVudGVycHJpc2VNb2R1bGVzOiBoYXNSZWdpc3RlcmVkRW50ZXJwcmlzZU1vZHVsZXMsXG4gICAgTU9EVUxFX0NPTkZMSUNUUzogTU9EVUxFX0NPTkZMSUNUUyxcbiAgICByZWdpc3Rlck1vZHVsZUNvbmZsaWN0czogcmVnaXN0ZXJNb2R1bGVDb25mbGljdHMsXG4gICAgZW50ZXJwcmlzZU1vZHVsZTogZW50ZXJwcmlzZU1vZHVsZSxcbiAgICBCYWNrZ3JvdW5kOiBCYWNrZ3JvdW5kLFxuICAgIEJhY2tncm91bmRNb2R1bGU6IEJhY2tncm91bmRNb2R1bGUsXG4gICAgZ2V0IENoYXJ0QXhpc0RpcmVjdGlvbiAoKSB7IHJldHVybiBDaGFydEF4aXNEaXJlY3Rpb247IH0sXG4gICAgcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0OiBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQsXG4gICAgcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnM6IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zLFxuICAgIHJlc2V0QXhpc0dyb3VwRm46IHJlc2V0QXhpc0dyb3VwRm4sXG4gICAgcmVzZXRBeGlzU2VsZWN0aW9uRm46IHJlc2V0QXhpc1NlbGVjdGlvbkZuLFxuICAgIHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm46IHJlc2V0QXhpc0xhYmVsU2VsZWN0aW9uRm4sXG4gICAgcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuOiByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm4sXG4gICAgZml4TnVtZXJpY0V4dGVudDogZml4TnVtZXJpY0V4dGVudCxcbiAgICBEYXRhTW9kZWw6IERhdGFNb2RlbCxcbiAgICBEYXRhQ29udHJvbGxlcjogRGF0YUNvbnRyb2xsZXIsXG4gICAgU01BTExFU1RfS0VZX0lOVEVSVkFMOiBTTUFMTEVTVF9LRVlfSU5URVJWQUwsXG4gICAgQUdHX1ZBTFVFU19FWFRFTlQ6IEFHR19WQUxVRVNfRVhURU5ULFxuICAgIFNPUlRfRE9NQUlOX0dST1VQUzogU09SVF9ET01BSU5fR1JPVVBTLFxuICAgIG5vcm1hbGlzZUdyb3VwVG86IG5vcm1hbGlzZUdyb3VwVG8sXG4gICAgbm9ybWFsaXNlUHJvcGVydHlUbzogbm9ybWFsaXNlUHJvcGVydHlUbyxcbiAgICBhbmltYXRpb25WYWxpZGF0aW9uOiBhbmltYXRpb25WYWxpZGF0aW9uLFxuICAgIGFjY3VtdWxhdGVHcm91cDogYWNjdW11bGF0ZUdyb3VwLFxuICAgIGRpZmY6IGRpZmYsXG4gICAgY3JlYXRlRGF0dW1JZDogY3JlYXRlRGF0dW1JZCxcbiAgICBzdW06IHN1bSxcbiAgICBncm91cFN1bTogZ3JvdXBTdW0sXG4gICAgcmFuZ2U6IHJhbmdlLFxuICAgIGNvdW50OiBjb3VudCxcbiAgICBncm91cENvdW50OiBncm91cENvdW50LFxuICAgIGF2ZXJhZ2U6IGF2ZXJhZ2UsXG4gICAgZ3JvdXBBdmVyYWdlOiBncm91cEF2ZXJhZ2UsXG4gICAgYXJlYTogYXJlYSxcbiAgICBhY2N1bXVsYXRlZFZhbHVlOiBhY2N1bXVsYXRlZFZhbHVlLFxuICAgIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZTogdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlLFxuICAgIFVwZGF0ZVNlcnZpY2U6IFVwZGF0ZVNlcnZpY2UsXG4gICAgTGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBBbmltYXRpb25NYW5hZ2VyOiBBbmltYXRpb25NYW5hZ2VyLFxuICAgIENoYXJ0RXZlbnRNYW5hZ2VyOiBDaGFydEV2ZW50TWFuYWdlcixcbiAgICBDdXJzb3JNYW5hZ2VyOiBDdXJzb3JNYW5hZ2VyLFxuICAgIEhpZ2hsaWdodE1hbmFnZXI6IEhpZ2hsaWdodE1hbmFnZXIsXG4gICAgSW50ZXJhY3Rpb25NYW5hZ2VyOiBJbnRlcmFjdGlvbk1hbmFnZXIsXG4gICAgVG9vbHRpcE1hbmFnZXI6IFRvb2x0aXBNYW5hZ2VyLFxuICAgIFpvb21NYW5hZ2VyOiBab29tTWFuYWdlcixcbiAgICBnZXQgTGF5ZXJzICgpIHsgcmV0dXJuIExheWVyczsgfSxcbiAgICBnZXQgU2VyaWVzTm9kZVBpY2tNb2RlICgpIHsgcmV0dXJuIFNlcmllc05vZGVQaWNrTW9kZTsgfSxcbiAgICBrZXlQcm9wZXJ0eToga2V5UHJvcGVydHksXG4gICAgdmFsdWVQcm9wZXJ0eTogdmFsdWVQcm9wZXJ0eSxcbiAgICByYW5nZWRWYWx1ZVByb3BlcnR5OiByYW5nZWRWYWx1ZVByb3BlcnR5LFxuICAgIHRyYWlsaW5nVmFsdWVQcm9wZXJ0eTogdHJhaWxpbmdWYWx1ZVByb3BlcnR5LFxuICAgIHRyYWlsaW5nVmFsdWU6IHRyYWlsaW5nVmFsdWUsXG4gICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eTogYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eSxcbiAgICB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWVQcm9wZXJ0eTogdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHksXG4gICAgZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5OiBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHksXG4gICAgU2VyaWVzTm9kZUNsaWNrRXZlbnQ6IFNlcmllc05vZGVDbGlja0V2ZW50LFxuICAgIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZTogU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLFxuICAgIEhpZ2hsaWdodFN0eWxlOiBIaWdobGlnaHRTdHlsZSxcbiAgICBTZXJpZXM6IFNlcmllcyxcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbjogc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24sXG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uOiBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24sXG4gICAgcmVzZXRMYWJlbEZuOiByZXNldExhYmVsRm4sXG4gICAgU2VyaWVzTWFya2VyOiBTZXJpZXNNYXJrZXIsXG4gICAgU2VyaWVzVG9vbHRpcDogU2VyaWVzVG9vbHRpcCxcbiAgICBBYnN0cmFjdEJhclNlcmllczogQWJzdHJhY3RCYXJTZXJpZXMsXG4gICAgQ2FydGVzaWFuU2VyaWVzTm9kZUNsaWNrRXZlbnQ6IENhcnRlc2lhblNlcmllc05vZGVDbGlja0V2ZW50LFxuICAgIENhcnRlc2lhblNlcmllczogQ2FydGVzaWFuU2VyaWVzLFxuICAgIHBhaXJDb250aW51b3VzRGF0YTogcGFpckNvbnRpbnVvdXNEYXRhLFxuICAgIHBhaXJDYXRlZ29yeURhdGE6IHBhaXJDYXRlZ29yeURhdGEsXG4gICAgZGV0ZXJtaW5lUGF0aFN0YXR1czogZGV0ZXJtaW5lUGF0aFN0YXR1cyxcbiAgICBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnM6IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZucyxcbiAgICBwcmVwYXJlTGluZVBhdGhBbmltYXRpb246IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbixcbiAgICB1cGRhdGVSZWN0OiB1cGRhdGVSZWN0LFxuICAgIGdldFJlY3RDb25maWc6IGdldFJlY3RDb25maWcsXG4gICAgY2hlY2tDcmlzcDogY2hlY2tDcmlzcCxcbiAgICBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uOiBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uLFxuICAgIG1pZHBvaW50U3RhcnRpbmdCYXJQb3NpdGlvbjogbWlkcG9pbnRTdGFydGluZ0JhclBvc2l0aW9uLFxuICAgIHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnM6IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMsXG4gICAgcmVzZXRCYXJTZWxlY3Rpb25zRm46IHJlc2V0QmFyU2VsZWN0aW9uc0ZuLFxuICAgIGdldCBBcmVhU2VyaWVzVGFnICgpIHsgcmV0dXJuIEFyZWFTZXJpZXNUYWc7IH0sXG4gICAgcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uOiBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb24sXG4gICAgbWFya2VyRmFkZUluQW5pbWF0aW9uOiBtYXJrZXJGYWRlSW5BbmltYXRpb24sXG4gICAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbjogbWFya2VyU2NhbGVJbkFuaW1hdGlvbixcbiAgICBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb246IG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbixcbiAgICByZXNldE1hcmtlckZuOiByZXNldE1hcmtlckZuLFxuICAgIHJlc2V0TWFya2VyUG9zaXRpb25GbjogcmVzZXRNYXJrZXJQb3NpdGlvbkZuLFxuICAgIHByZXBhcmVNYXJrZXJBbmltYXRpb246IHByZXBhcmVNYXJrZXJBbmltYXRpb24sXG4gICAgdXBkYXRlTGFiZWxOb2RlOiB1cGRhdGVMYWJlbE5vZGUsXG4gICAgYWRqdXN0TGFiZWxQbGFjZW1lbnQ6IGFkanVzdExhYmVsUGxhY2VtZW50LFxuICAgIG1pbk1heDogbWluTWF4LFxuICAgIGJhY2tmaWxsUGF0aFBvaW50RGF0YTogYmFja2ZpbGxQYXRoUG9pbnREYXRhLFxuICAgIHJlbmRlclBhcnRpYWxQYXRoOiByZW5kZXJQYXJ0aWFsUGF0aCxcbiAgICBwYXRoU3dpcGVJbkFuaW1hdGlvbjogcGF0aFN3aXBlSW5BbmltYXRpb24sXG4gICAgcGF0aEZhZGVJbkFuaW1hdGlvbjogcGF0aEZhZGVJbkFuaW1hdGlvbixcbiAgICBwYXRoRmFkZU91dEFuaW1hdGlvbjogcGF0aEZhZGVPdXRBbmltYXRpb24sXG4gICAgYnVpbGRSZXNldFBhdGhGbjogYnVpbGRSZXNldFBhdGhGbixcbiAgICBQb2xhclNlcmllczogUG9sYXJTZXJpZXMsXG4gICAgSGllcmFyY2h5Tm9kZTogSGllcmFyY2h5Tm9kZSxcbiAgICBIaWVyYXJjaHlTZXJpZXM6IEhpZXJhcmNoeVNlcmllcyxcbiAgICBnZXQgVGFncyAoKSB7IHJldHVybiBUYWdzOyB9LFxuICAgIEF4aXM6IEF4aXMsXG4gICAgQXhpc0xhYmVsOiBBeGlzTGFiZWwsXG4gICAgQXhpc1RpY2s6IEF4aXNUaWNrLFxuICAgIFBvbGFyQXhpczogUG9sYXJBeGlzLFxuICAgIENhdGVnb3J5QXhpczogQ2F0ZWdvcnlBeGlzLFxuICAgIF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTjogX19GT1JDRV9NT0RVTEVfREVURUNUSU9OLFxuICAgIFFVSUNLX1RSQU5TSVRJT046IFFVSUNLX1RSQU5TSVRJT04sXG4gICAgSU5JVElBTF9MT0FEOiBJTklUSUFMX0xPQUQsXG4gICAgUkVNT1ZFX1BIQVNFOiBSRU1PVkVfUEhBU0UsXG4gICAgVVBEQVRFX1BIQVNFOiBVUERBVEVfUEhBU0UsXG4gICAgQUREX1BIQVNFOiBBRERfUEhBU0UsXG4gICAgTEFCRUxfUEhBU0U6IExBQkVMX1BIQVNFLFxuICAgIGdldCBSZXBlYXRUeXBlICgpIHsgcmV0dXJuIFJlcGVhdFR5cGU7IH0sXG4gICAgaXNOb2RlQXJyYXk6IGlzTm9kZUFycmF5LFxuICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgIFN0YXRlTWFjaGluZTogU3RhdGVNYWNoaW5lLFxuICAgIHJlc2V0TW90aW9uOiByZXNldE1vdGlvbixcbiAgICBOT0RFX1VQREFURV9QSEFTRVM6IE5PREVfVVBEQVRFX1BIQVNFUyxcbiAgICBGUk9NX1RPX01JWElOUzogRlJPTV9UT19NSVhJTlMsXG4gICAgZnJvbVRvTW90aW9uOiBmcm9tVG9Nb3Rpb24sXG4gICAgc3RhdGljRnJvbVRvTW90aW9uOiBzdGF0aWNGcm9tVG9Nb3Rpb25cbn0pO1xuXG5jb25zdCBTRVJJRVNfRkFDVE9SSUVTID0ge307XHJcbmNvbnN0IFNFUklFU19ERUZBVUxUUyA9IHt9O1xyXG5jb25zdCBTRVJJRVNfVEhFTUVfVEVNUExBVEVTID0ge307XHJcbmNvbnN0IEVOVEVSUFJJU0VfU0VSSUVTX1RIRU1FX1RFTVBMQVRFUyA9IHt9O1xyXG5jb25zdCBTRVJJRVNfUEFMRVRURV9GQUNUT1JJRVMgPSB7fTtcclxuY29uc3QgU09MT19TRVJJRVNfVFlQRVMgPSBuZXcgU2V0KCk7XHJcbmNvbnN0IFNUQUNLQUJMRV9TRVJJRVNfVFlQRVMgPSBuZXcgU2V0KCk7XHJcbmNvbnN0IEdST1VQQUJMRV9TRVJJRVNfVFlQRVMgPSBuZXcgU2V0KCk7XHJcbmNvbnN0IFNUQUNLRURfQllfREVGQVVMVF9TRVJJRVNfVFlQRVMgPSBuZXcgU2V0KCk7XHJcbmNvbnN0IFNXQVBfREVGQVVMVF9BWEVTX0NPTkRJVElPTlMgPSB7fTtcclxuY29uc3QgQ1VTVE9NX0RFRkFVTFRTX0ZVTkNUSU9OUyA9IHt9O1xyXG5mdW5jdGlvbiByZWdpc3RlclNlcmllcyhzZXJpZXNUeXBlLCBjaGFydFR5cGUsIGNzdHIsIGRlZmF1bHRzLCB0aGVtZSwgZW50ZXJwcmlzZVRoZW1lLCBwYWxldHRlRmFjdG9yeSwgc29sbywgc3RhY2thYmxlLCBncm91cGFibGUsIHN0YWNrZWRCeURlZmF1bHQsIHN3YXBEZWZhdWx0QXhlc0NvbmRpdGlvbiwgY3VzdG9tRGVmYXVsdHNGdW5jdGlvbikge1xyXG4gICAgU0VSSUVTX0ZBQ1RPUklFU1tzZXJpZXNUeXBlXSA9IGNzdHI7XHJcbiAgICBTRVJJRVNfREVGQVVMVFNbc2VyaWVzVHlwZV0gPSBkZWZhdWx0cztcclxuICAgIHJlZ2lzdGVyU2VyaWVzVGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlLCB0aGVtZSwgZW50ZXJwcmlzZVRoZW1lKTtcclxuICAgIGlmIChwYWxldHRlRmFjdG9yeSkge1xyXG4gICAgICAgIGFkZFNlcmllc1BhbGV0dGVGYWN0b3J5KHNlcmllc1R5cGUsIHBhbGV0dGVGYWN0b3J5KTtcclxuICAgIH1cclxuICAgIGlmIChzb2xvKSB7XHJcbiAgICAgICAgYWRkU29sb1Nlcmllc1R5cGUoc2VyaWVzVHlwZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhY2thYmxlKSB7XHJcbiAgICAgICAgYWRkU3RhY2thYmxlU2VyaWVzVHlwZShzZXJpZXNUeXBlKTtcclxuICAgIH1cclxuICAgIGlmIChncm91cGFibGUpIHtcclxuICAgICAgICBhZGRHcm91cGFibGVTZXJpZXNUeXBlKHNlcmllc1R5cGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YWNrZWRCeURlZmF1bHQpIHtcclxuICAgICAgICBhZGRTdGFja2VkQnlEZWZhdWx0U2VyaWVzVHlwZShzZXJpZXNUeXBlKTtcclxuICAgIH1cclxuICAgIGlmIChzd2FwRGVmYXVsdEF4ZXNDb25kaXRpb24pIHtcclxuICAgICAgICBhZGRTd2FwRGVmYXVsdEF4ZXNDb25kaXRpb24oc2VyaWVzVHlwZSwgc3dhcERlZmF1bHRBeGVzQ29uZGl0aW9uKTtcclxuICAgIH1cclxuICAgIGlmIChjdXN0b21EZWZhdWx0c0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgYWRkQ3VzdG9tRGVmYXVsdHNGdW5jdGlvbnMoc2VyaWVzVHlwZSwgY3VzdG9tRGVmYXVsdHNGdW5jdGlvbik7XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckNoYXJ0U2VyaWVzVHlwZShzZXJpZXNUeXBlLCBjaGFydFR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyU2VyaWVzVGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlLCB0aGVtZVRlbXBsYXRlLCBlbnRlcnByaXNlVGhlbWVUZW1wbGF0ZSA9IHt9KSB7XHJcbiAgICBjb25zdCBleGlzdGluZ1RlbXBsYXRlID0gU0VSSUVTX1RIRU1FX1RFTVBMQVRFU1tzZXJpZXNUeXBlXTtcclxuICAgIFNFUklFU19USEVNRV9URU1QTEFURVNbc2VyaWVzVHlwZV0gPSBqc29uTWVyZ2UoW2V4aXN0aW5nVGVtcGxhdGUsIHRoZW1lVGVtcGxhdGVdKTtcclxuICAgIEVOVEVSUFJJU0VfU0VSSUVTX1RIRU1FX1RFTVBMQVRFU1tzZXJpZXNUeXBlXSA9IGpzb25NZXJnZShbXHJcbiAgICAgICAgZXhpc3RpbmdUZW1wbGF0ZSxcclxuICAgICAgICB0aGVtZVRlbXBsYXRlLFxyXG4gICAgICAgIGVudGVycHJpc2VUaGVtZVRlbXBsYXRlLFxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VyaWVzKGNoYXJ0VHlwZSwgbW9kdWxlQ3R4KSB7XHJcbiAgICBjb25zdCBzZXJpZXNDb25zdHJ1Y3RvciA9IFNFUklFU19GQUNUT1JJRVNbY2hhcnRUeXBlXTtcclxuICAgIGlmIChzZXJpZXNDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgc2VyaWVzQ29uc3RydWN0b3IobW9kdWxlQ3R4KTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBzZXJpZXMgdHlwZTogJHtjaGFydFR5cGV9YCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VyaWVzRGVmYXVsdHMoY2hhcnRUeXBlKSB7XHJcbiAgICByZXR1cm4gU0VSSUVTX0RFRkFVTFRTW2NoYXJ0VHlwZV07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VyaWVzVGhlbWVUZW1wbGF0ZShjaGFydFR5cGUpIHtcclxuICAgIGlmIChoYXNSZWdpc3RlcmVkRW50ZXJwcmlzZU1vZHVsZXMoKSkge1xyXG4gICAgICAgIHJldHVybiBFTlRFUlBSSVNFX1NFUklFU19USEVNRV9URU1QTEFURVNbY2hhcnRUeXBlXTtcclxuICAgIH1cclxuICAgIHJldHVybiBTRVJJRVNfVEhFTUVfVEVNUExBVEVTW2NoYXJ0VHlwZV07XHJcbn1cclxuZnVuY3Rpb24gYWRkU2VyaWVzUGFsZXR0ZUZhY3Rvcnkoc2VyaWVzVHlwZSwgZmFjdG9yeSkge1xyXG4gICAgU0VSSUVTX1BBTEVUVEVfRkFDVE9SSUVTW3Nlcmllc1R5cGVdID0gZmFjdG9yeTtcclxufVxyXG5mdW5jdGlvbiBnZXRTZXJpZXNQYWxldHRlRmFjdG9yeShzZXJpZXNUeXBlKSB7XHJcbiAgICByZXR1cm4gU0VSSUVTX1BBTEVUVEVfRkFDVE9SSUVTW3Nlcmllc1R5cGVdO1xyXG59XHJcbmZ1bmN0aW9uIGlzU29sb1NlcmllcyhzZXJpZXNUeXBlKSB7XHJcbiAgICByZXR1cm4gU09MT19TRVJJRVNfVFlQRVMuaGFzKHNlcmllc1R5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RhY2thYmxlU2VyaWVzKHNlcmllc1R5cGUpIHtcclxuICAgIHJldHVybiBTVEFDS0FCTEVfU0VSSUVTX1RZUEVTLmhhcyhzZXJpZXNUeXBlKTtcclxufVxyXG5mdW5jdGlvbiBpc0dyb3VwYWJsZVNlcmllcyhzZXJpZXNUeXBlKSB7XHJcbiAgICByZXR1cm4gR1JPVVBBQkxFX1NFUklFU19UWVBFUy5oYXMoc2VyaWVzVHlwZSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTZXJpZXNTdGFja2VkQnlEZWZhdWx0KHNlcmllc1R5cGUpIHtcclxuICAgIHJldHVybiBTVEFDS0VEX0JZX0RFRkFVTFRfU0VSSUVTX1RZUEVTLmhhcyhzZXJpZXNUeXBlKTtcclxufVxyXG5mdW5jdGlvbiBhZGRHcm91cGFibGVTZXJpZXNUeXBlKHNlcmllc1R5cGUpIHtcclxuICAgIEdST1VQQUJMRV9TRVJJRVNfVFlQRVMuYWRkKHNlcmllc1R5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFNvbG9TZXJpZXNUeXBlKHNlcmllc1R5cGUpIHtcclxuICAgIFNPTE9fU0VSSUVTX1RZUEVTLmFkZChzZXJpZXNUeXBlKTtcclxufVxyXG5mdW5jdGlvbiBhZGRTdGFja2FibGVTZXJpZXNUeXBlKHNlcmllc1R5cGUpIHtcclxuICAgIFNUQUNLQUJMRV9TRVJJRVNfVFlQRVMuYWRkKHNlcmllc1R5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFN0YWNrZWRCeURlZmF1bHRTZXJpZXNUeXBlKHNlcmllc1R5cGUpIHtcclxuICAgIFNUQUNLRURfQllfREVGQVVMVF9TRVJJRVNfVFlQRVMuYWRkKHNlcmllc1R5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFN3YXBEZWZhdWx0QXhlc0NvbmRpdGlvbihzZXJpZXNUeXBlLCBwcmVkaWNhdGUpIHtcclxuICAgIFNXQVBfREVGQVVMVF9BWEVTX0NPTkRJVElPTlNbc2VyaWVzVHlwZV0gPSBwcmVkaWNhdGU7XHJcbn1cclxuZnVuY3Rpb24gYWRkQ3VzdG9tRGVmYXVsdHNGdW5jdGlvbnMoc2VyaWVzVHlwZSwgcHJlZGljYXRlKSB7XHJcbiAgICBDVVNUT01fREVGQVVMVFNfRlVOQ1RJT05TW3Nlcmllc1R5cGVdID0gcHJlZGljYXRlO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVmYXVsdEF4aXNTd2FwTmVlZGVkKG9wdHMpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgKF9hID0gb3B0cy5zZXJpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlID0gJ2xpbmUnIH0gPSBzZXJpZXM7XHJcbiAgICAgICAgY29uc3QgaXNEZWZhdWx0QXhpc1N3YXBwZWQgPSAoX2IgPSBTV0FQX0RFRkFVTFRfQVhFU19DT05ESVRJT05TW3R5cGVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChTV0FQX0RFRkFVTFRfQVhFU19DT05ESVRJT05TLCBzZXJpZXMpO1xyXG4gICAgICAgIGlmIChpc0RlZmF1bHRBeGlzU3dhcHBlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCAmJiByZXN1bHQgIT0gaXNEZWZhdWx0QXhpc1N3YXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQUcgQ2hhcnRzIC0gVGhlIHByb3ZpZGVkIHNlcmllcyBoYXZlIGluY29tcGF0aWJsZSBkaXJlY3Rpb25zJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gaXNEZWZhdWx0QXhpc1N3YXBwZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBleGVjdXRlQ3VzdG9tRGVmYXVsdHNGdW5jdGlvbnMob3B0cywgaW5pdGlhbERlZmF1bHRzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgcmVzdWx0ID0gaW5pdGlhbERlZmF1bHRzO1xyXG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgKF9hID0gb3B0cy5zZXJpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBzZXJpZXM7XHJcbiAgICAgICAgY29uc3QgZm4gPSB0eXBlICE9IG51bGwgPyBDVVNUT01fREVGQVVMVFNfRlVOQ1RJT05TW3R5cGVdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChmbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KSwgZm4oc2VyaWVzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG5mdW5jdGlvbiBzZXR1cE1vZHVsZXMoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBmb3IgKGNvbnN0IG0gb2YgUkVHSVNURVJFRF9NT0RVTEVTKSB7XHJcbiAgICAgICAgaWYgKG0ucGFja2FnZVR5cGUgPT09ICdlbnRlcnByaXNlJyAmJiAhdmVyaWZ5SWZNb2R1bGVFeHBlY3RlZChtKSkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3JPbmNlKCdVbmV4cGVjdGVkIGVudGVycHJpc2UgbW9kdWxlIHJlZ2lzdGVyZWQ6ICcgKyBtLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSlNPTl9BUFBMWV9QTFVHSU5TLmNvbnN0cnVjdG9ycyAhPSBudWxsICYmIG0ub3B0aW9uQ29uc3RydWN0b3JzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihKU09OX0FQUExZX1BMVUdJTlMuY29uc3RydWN0b3JzLCBtLm9wdGlvbkNvbnN0cnVjdG9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtLnR5cGUgPT09ICdyb290JyAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFydFR5cGUgb2YgbS5jaGFydFR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZWdpc3RlckNoYXJ0RGVmYXVsdHMoY2hhcnRUeXBlLCBtLnRoZW1lVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtLnR5cGUgPT09ICdyb290JyAmJiAoKF9hID0gbS5jb25mbGljdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyTW9kdWxlQ29uZmxpY3RzKG0ub3B0aW9uc0tleSwgbS5jb25mbGljdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobS50eXBlID09PSAnc2VyaWVzJykge1xyXG4gICAgICAgICAgICBpZiAobS5jaGFydFR5cGVzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FHIENoYXJ0cyAtIE1vZHVsZSBkZWZpbml0aW9uIGVycm9yOiAnICsgbS5pZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgcmVnaXN0ZXJTZXJpZXMobS5pZGVudGlmaWVyLCBtLmNoYXJ0VHlwZXNbMF0sIG0uaW5zdGFuY2VDb25zdHJ1Y3RvciwgbS5zZXJpZXNEZWZhdWx0cywgbS50aGVtZVRlbXBsYXRlLCBtLmVudGVycHJpc2VUaGVtZVRlbXBsYXRlLCBtLnBhbGV0dGVGYWN0b3J5LCBtLnNvbG8sIG0uc3RhY2thYmxlLCBtLmdyb3VwYWJsZSwgbS5zdGFja2VkQnlEZWZhdWx0LCBtLnN3YXBEZWZhdWx0QXhlc0NvbmRpdGlvbiwgbS5jdXN0b21EZWZhdWx0c0Z1bmN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ3Nlcmllcy1vcHRpb24nICYmIG0udGhlbWVUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUgb2YgbS5zZXJpZXNUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJTZXJpZXNUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUsIG0udGhlbWVUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ2F4aXMtb3B0aW9uJyAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBtLmF4aXNUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXhpc1R5cGVUaGVtZSA9IG0udGhlbWVUZW1wbGF0ZVtheGlzVHlwZV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aGVtZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbS50aGVtZVRlbXBsYXRlKSwgKHR5cGVvZiBheGlzVHlwZVRoZW1lID09PSAnb2JqZWN0JyA/IGF4aXNUeXBlVGhlbWUgOiB7fSkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBtLmF4aXNUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGVtZVtheGlzVHlwZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWdpc3RlckF4aXNUaGVtZVRlbXBsYXRlKGF4aXNUeXBlLCB0aGVtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ2F4aXMnKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyQXhpcyhtLmlkZW50aWZpZXIsIG0uaW5zdGFuY2VDb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChtLnRoZW1lVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQXhpc1RoZW1lVGVtcGxhdGUobS5pZGVudGlmaWVyLCBtLnRoZW1lVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtLnR5cGUgPT09ICdsZWdlbmQnKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyTGVnZW5kKG0uaWRlbnRpZmllciwgbS5vcHRpb25zS2V5LCBtLmluc3RhbmNlQ29uc3RydWN0b3IsIG0udGhlbWVUZW1wbGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhc1JlZ2lzdGVyZWRFbnRlcnByaXNlTW9kdWxlcygpKSB7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRCdXRVbnVzZWQgPSBnZXRVbnVzZWRFeHBlY3RlZE1vZHVsZXMoKTtcclxuICAgICAgICBpZiAoZXhwZWN0ZWRCdXRVbnVzZWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3JPbmNlKCdFbnRlcnByaXNlIG1vZHVsZXMgZXhwZWN0ZWQgYnV0IG5vdCByZWdpc3RlcmVkOiAnLCBleHBlY3RlZEJ1dFVudXNlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEhpZXJhcmNoeUNoYXJ0IGV4dGVuZHMgQ2hhcnQge1xyXG4gICAgY29uc3RydWN0b3Ioc3BlY2lhbE92ZXJyaWRlcywgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgc3VwZXIoc3BlY2lhbE92ZXJyaWRlcywgcmVzb3VyY2VzKTtcclxuICAgICAgICB0aGlzLl9kYXRhID0ge307XHJcbiAgICB9XHJcbiAgICBwZXJmb3JtTGF5b3V0KCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBwZXJmb3JtTGF5b3V0OiB7IGdldDogKCkgPT4gc3VwZXIucGVyZm9ybUxheW91dCB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hyaW5rUmVjdCA9IHlpZWxkIF9zdXBlci5wZXJmb3JtTGF5b3V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2VyaWVzQXJlYTogeyBwYWRkaW5nIH0sIHNlcmllc1Jvb3QsIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsU2VyaWVzUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcclxuICAgICAgICAgICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5sZWZ0LCAnbGVmdCcpO1xyXG4gICAgICAgICAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnRvcCwgJ3RvcCcpO1xyXG4gICAgICAgICAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnJpZ2h0LCAncmlnaHQnKTtcclxuICAgICAgICAgICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5ib3R0b20sICdib3R0b20nKTtcclxuICAgICAgICAgICAgdGhpcy5zZXJpZXNSZWN0ID0gc2hyaW5rUmVjdDtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25SZWN0ID0gc2hyaW5rUmVjdDtcclxuICAgICAgICAgICAgdGhpcy5ob3ZlclJlY3QgPSBzaHJpbmtSZWN0O1xyXG4gICAgICAgICAgICBzZXJpZXNSb290LnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3Ioc2hyaW5rUmVjdC54KTtcclxuICAgICAgICAgICAgc2VyaWVzUm9vdC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHNocmlua1JlY3QueSk7XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRoaXMuc2VyaWVzLm1hcCgoc2VyaWVzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBzZXJpZXMudXBkYXRlKHsgc2VyaWVzUmVjdDogc2hyaW5rUmVjdCB9KTsgLy8gdGhpcyBoYXMgdG8gaGFwcGVuIGFmdGVyIHRoZSBgdXBkYXRlQXhlc2AgY2FsbFxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgICBzZXJpZXNSb290LnZpc2libGUgPSB0aGlzLnNlcmllc1swXS52aXNpYmxlO1xyXG4gICAgICAgICAgICBzZXJpZXNSb290LnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShuZXcgQkJveChzaHJpbmtSZWN0LngsIHNocmlua1JlY3QueSwgc2hyaW5rUmVjdC53aWR0aCwgc2hyaW5rUmVjdC5oZWlnaHQpKTtcclxuICAgICAgICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoTGF5b3V0Q29tcGxldGUoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xheW91dC1jb21wbGV0ZScsXHJcbiAgICAgICAgICAgICAgICBjaGFydDogeyB3aWR0aDogdGhpcy5zY2VuZS53aWR0aCwgaGVpZ2h0OiB0aGlzLnNjZW5lLmhlaWdodCB9LFxyXG4gICAgICAgICAgICAgICAgY2xpcFNlcmllczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzZXJpZXM6IHsgcmVjdDogZnVsbFNlcmllc1JlY3QsIHBhZGRlZFJlY3Q6IHNocmlua1JlY3QsIHZpc2libGU6IHRydWUgfSxcclxuICAgICAgICAgICAgICAgIGF4ZXM6IFtdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNocmlua1JlY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuSGllcmFyY2h5Q2hhcnQuY2xhc3NOYW1lID0gJ0hpZXJhcmNoeUNoYXJ0JztcclxuSGllcmFyY2h5Q2hhcnQudHlwZSA9ICdoaWVyYXJjaHknO1xuXG5mdW5jdGlvbiByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgY29uc3QgdXNlZE9wdGlvbnMgPSBbXTtcclxuICAgIGNvbnN0IG9wdGlvbnNDaGFydFR5cGUgPSBnZXRDaGFydFR5cGUob3B0aW9uc1R5cGUob3B0aW9ucykpO1xyXG4gICAgZm9yIChjb25zdCB7IHR5cGUsIGNoYXJ0VHlwZXMsIG9wdGlvbnNLZXksIG9wdGlvbnNJbm5lcktleSwgaWRlbnRpZmllciB9IG9mIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUykge1xyXG4gICAgICAgIGlmIChvcHRpb25zQ2hhcnRUeXBlICE9PSAndW5rbm93bicgJiYgIWNoYXJ0VHlwZXMuaW5jbHVkZXMob3B0aW9uc0NoYXJ0VHlwZSkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncm9vdCcgfHwgdHlwZSA9PT0gJ2xlZ2VuZCcpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb25zW29wdGlvbnNLZXldO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNJbm5lcktleSkge1xyXG4gICAgICAgICAgICAgICAgdXNlZE9wdGlvbnMucHVzaChvcHRpb25zS2V5KTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdGlvbnNLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvblZhbHVlW29wdGlvbnNJbm5lcktleV0pIHtcclxuICAgICAgICAgICAgICAgIHVzZWRPcHRpb25zLnB1c2goYCR7b3B0aW9uc0tleX0uJHtvcHRpb25zSW5uZXJLZXl9YCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uVmFsdWVbb3B0aW9uc0lubmVyS2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYXhpcycpIHtcclxuICAgICAgICAgICAgaWYgKCEoJ2F4ZXMnIGluIG9wdGlvbnMpIHx8ICEoKF9hID0gb3B0aW9ucy5heGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoYXhpcykgPT4gYXhpcy50eXBlID09PSBpZGVudGlmaWVyKSkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgdXNlZE9wdGlvbnMucHVzaChgYXhpc1t0eXBlPSR7aWRlbnRpZmllcn1dYCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYXhlcyA9IG9wdGlvbnMuYXhlcy5maWx0ZXIoKGF4aXMpID0+IGF4aXMudHlwZSAhPT0gaWRlbnRpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdheGlzLW9wdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCEoJ2F4ZXMnIGluIG9wdGlvbnMpIHx8ICEoKF9iID0gb3B0aW9ucy5heGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29tZSgoYXhpcykgPT4gYXhpc1tvcHRpb25zS2V5XSkpKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHVzZWRPcHRpb25zLnB1c2goYGF4aXMuJHtvcHRpb25zS2V5fWApO1xyXG4gICAgICAgICAgICBvcHRpb25zLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNbb3B0aW9uc0tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXhpc1tvcHRpb25zS2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzZXJpZXMnKSB7XHJcbiAgICAgICAgICAgIGlmICghKChfYyA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc29tZSgoc2VyaWVzKSA9PiBzZXJpZXMudHlwZSA9PT0gaWRlbnRpZmllcikpKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHVzZWRPcHRpb25zLnB1c2goYHNlcmllc1t0eXBlPSR7aWRlbnRpZmllcn1dYCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWVzID0gb3B0aW9ucy5zZXJpZXMuZmlsdGVyKChzZXJpZXMpID0+IHNlcmllcy50eXBlICE9PSBpZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3Nlcmllcy1vcHRpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICghKChfZCA9IG9wdGlvbnMuc2VyaWVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc29tZSgoc2VyaWVzKSA9PiBzZXJpZXNbb3B0aW9uc0tleV0pKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB1c2VkT3B0aW9ucy5wdXNoKGBzZXJpZXMuJHtvcHRpb25zS2V5fWApO1xyXG4gICAgICAgICAgICBvcHRpb25zLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNbb3B0aW9uc0tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VyaWVzW29wdGlvbnNLZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodXNlZE9wdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIExvZ2dlci53YXJuT25jZShbXHJcbiAgICAgICAgICAgIGB1bmFibGUgdG8gdXNlIHRoZXNlIGVudGVycHJpc2UgZmVhdHVyZXMgYXMgJ2FnLWNoYXJ0cy1lbnRlcnByaXNlJyBoYXMgbm90IGJlZW4gbG9hZGVkOmAsXHJcbiAgICAgICAgICAgIGBgLFxyXG4gICAgICAgICAgICAuLi51c2VkT3B0aW9ucyxcclxuICAgICAgICAgICAgYGAsXHJcbiAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vY2hhcnRzLmFnLWdyaWQuY29tL2phdmFzY3JpcHQvaW5zdGFsbGF0aW9uLycsXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEdyb3VwcyB0aGUgc2VyaWVzIG9wdGlvbnMgb2JqZWN0cyBpZiB0aGV5IGFyZSBvZiB0eXBlIGBjb2x1bW5gIG9yIGBiYXJgIGFuZCBwbGFjZXMgdGhlbSBpbiBhbiBhcnJheSBhdCB0aGUgaW5kZXggd2hlcmUgdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoaXMgc2VyaWVzIHR5cGUgd2FzIGZvdW5kLlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFycmF5cyBjb250YWluaW5nIHRoZSBvcmRlcmVkIGFuZCBncm91cGVkIHNlcmllcyBvcHRpb25zIG9iamVjdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBncm91cFNlcmllc0J5VHlwZShzZXJpZXNPcHRpb25zKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBjb25zdCBncm91cE1hcCA9IHt9O1xyXG4gICAgY29uc3Qgc3RhY2tNYXAgPSB7fTtcclxuICAgIGNvbnN0IGFueVN0YWNrZWQgPSB7fTtcclxuICAgIGNvbnN0IGRlZmF1bHRVbnN0YWNrZWRHcm91cCA9ICdkZWZhdWx0LWFnLWNoYXJ0cy1ncm91cCc7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAoY29uc3QgcyBvZiBzZXJpZXNPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IChfYSA9IHMudHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2xpbmUnO1xyXG4gICAgICAgIGNvbnN0IHN0YWNrYWJsZSA9IGlzU3RhY2thYmxlU2VyaWVzKHR5cGUpO1xyXG4gICAgICAgIGNvbnN0IGdyb3VwYWJsZSA9IGlzR3JvdXBhYmxlU2VyaWVzKHR5cGUpO1xyXG4gICAgICAgIGlmICghc3RhY2thYmxlICYmICFncm91cGFibGUpIHtcclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1c2UgaW5kZXggZm9yIHRoZXNlIGNhc2VzLlxyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICd1bmdyb3VwZWQnLCBvcHRzOiBbc10gfSk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHN0YWNrZWQ6IHNTdGFja2VkLCBzdGFja0dyb3VwOiBzU3RhY2tHcm91cCwgZ3JvdXBlZDogc0dyb3VwZWQgPSB1bmRlZmluZWQsIHhLZXkgfSA9IHM7XHJcbiAgICAgICAgY29uc3Qgc3RhY2tlZCA9IHNTdGFja0dyb3VwICE9IG51bGwgfHwgc1N0YWNrZWQgPT09IHRydWU7XHJcbiAgICAgICAgKF9iID0gYW55U3RhY2tlZFt0eXBlXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKGFueVN0YWNrZWRbdHlwZV0gPSBmYWxzZSk7XHJcbiAgICAgICAgYW55U3RhY2tlZFt0eXBlXSB8fCAoYW55U3RhY2tlZFt0eXBlXSA9IHN0YWNrZWQgJiYgc3RhY2thYmxlKTtcclxuICAgICAgICBjb25zdCBncm91cGVkID0gc0dyb3VwZWQgPT09IHRydWU7XHJcbiAgICAgICAgbGV0IGdyb3VwaW5nS2V5ID0gW3NTdGFja0dyb3VwICE9PSBudWxsICYmIHNTdGFja0dyb3VwICE9PSB2b2lkIDAgPyBzU3RhY2tHcm91cCA6IChzU3RhY2tlZCA9PT0gdHJ1ZSA/ICdzdGFja2VkJyA6IHVuZGVmaW5lZCksIGdyb3VwZWQgPyAnZ3JvdXBlZCcgOiB1bmRlZmluZWRdXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHYpID0+IHYgIT0gbnVsbClcclxuICAgICAgICAgICAgLmpvaW4oJy0nKTtcclxuICAgICAgICBpZiAoIWdyb3VwaW5nS2V5KSB7XHJcbiAgICAgICAgICAgIGdyb3VwaW5nS2V5ID0gZGVmYXVsdFVuc3RhY2tlZEdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmRleEtleSA9IGAke3R5cGV9LSR7eEtleX0tJHtncm91cGluZ0tleX1gO1xyXG4gICAgICAgIGlmIChzdGFja2VkICYmIHN0YWNrYWJsZSkge1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkID0gKChfYyA9IHN0YWNrTWFwW2luZGV4S2V5XSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKHN0YWNrTWFwW2luZGV4S2V5XSA9IHsgdHlwZTogJ3N0YWNrJywgb3B0czogW10gfSkpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlZC5vcHRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVwZGF0ZWQpO1xyXG4gICAgICAgICAgICB1cGRhdGVkLm9wdHMucHVzaChzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZ3JvdXBlZCAmJiBncm91cGFibGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZCA9ICgoX2QgPSBncm91cE1hcFtpbmRleEtleV0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IChncm91cE1hcFtpbmRleEtleV0gPSB7IHR5cGU6ICdncm91cCcsIG9wdHM6IFtdIH0pKTtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZWQub3B0cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1cGRhdGVkKTtcclxuICAgICAgICAgICAgdXBkYXRlZC5vcHRzLnB1c2gocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6ICd1bmdyb3VwZWQnLCBvcHRzOiBbc10gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFPYmplY3QudmFsdWVzKGFueVN0YWNrZWQpLnNvbWUoKHYpID0+IHYpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgcHJvdmlkZWQgc2VyaWVzIG9wdGlvbnMgYXJyYXkgaW50byBhbiBhcnJheSBjb250YWluaW5nIHNlcmllcyBvcHRpb25zIHdoaWNoIGFyZSBjb21wYXRpYmxlIHdpdGggc3RhbmRhbG9uZSBjaGFydHMgc2VyaWVzIG9wdGlvbnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9jZXNzU2VyaWVzT3B0aW9ucyhfb3B0cywgc2VyaWVzT3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCBwcmVwcm9jZXNzZWQgPSBzZXJpZXNPcHRpb25zLm1hcCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIENoYW5nZSB0aGUgZGVmYXVsdCBmb3IgYmFyL2NvbHVtbnMgd2hlbiB5S2V5IGlzIHVzZWQgdG8gYmUgZ3JvdXBlZCByYXRoZXIgdGhhbiBzdGFja2VkLlxyXG4gICAgICAgIGNvbnN0IHNUeXBlID0gKF9hID0gc2VyaWVzLnR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdsaW5lJztcclxuICAgICAgICBjb25zdCBncm91cGFibGUgPSBpc0dyb3VwYWJsZVNlcmllcyhzVHlwZSk7XHJcbiAgICAgICAgY29uc3Qgc3RhY2thYmxlID0gaXNTdGFja2FibGVTZXJpZXMoc1R5cGUpO1xyXG4gICAgICAgIGNvbnN0IHN0YWNrZWRCeURlZmF1bHQgPSBpc1Nlcmllc1N0YWNrZWRCeURlZmF1bHQoc1R5cGUpO1xyXG4gICAgICAgIGlmIChzZXJpZXMuZ3JvdXBlZCAmJiAhZ3JvdXBhYmxlKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci53YXJuT25jZShgdW5zdXBwb3J0ZWQgZ3JvdXBpbmcgb2Ygc2VyaWVzIHR5cGU6ICR7c1R5cGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpZXMuc3RhY2tlZCAmJiAhc3RhY2thYmxlKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci53YXJuT25jZShgdW5zdXBwb3J0ZWQgc3RhY2tpbmcgb2Ygc2VyaWVzIHR5cGU6ICR7c1R5cGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZ3JvdXBhYmxlICYmICFzdGFja2FibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlcmllcztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YWNrZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgZ3JvdXBlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChzZXJpZXMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIHNlcmllcy5ncm91cGVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RhY2tlZCA9IHN0YWNrYWJsZSAmJiBzdGFja2VkQnlEZWZhdWx0O1xyXG4gICAgICAgICAgICBncm91cGVkID0gZ3JvdXBhYmxlICYmICFzdGFja2VkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZXJpZXMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHN0YWNrZWQgPSBzdGFja2FibGUgJiYgc3RhY2tlZEJ5RGVmYXVsdCAmJiAhKHNlcmllcy5ncm91cGVkICYmIGdyb3VwYWJsZSk7XHJcbiAgICAgICAgICAgIGdyb3VwZWQgPSBncm91cGFibGUgJiYgIXN0YWNrZWQgJiYgISFzZXJpZXMuZ3JvdXBlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VyaWVzLmdyb3VwZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdGFja2VkID0gc3RhY2thYmxlICYmIHNlcmllcy5zdGFja2VkO1xyXG4gICAgICAgICAgICBncm91cGVkID0gZ3JvdXBhYmxlICYmICFzdGFja2VkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhY2tlZCA9IHN0YWNrYWJsZSAmJiBzZXJpZXMuc3RhY2tlZDtcclxuICAgICAgICAgICAgZ3JvdXBlZCA9IGdyb3VwYWJsZSAmJiAhc3RhY2tlZCAmJiBzZXJpZXMuZ3JvdXBlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzKSwgeyBzdGFja2VkLCBncm91cGVkIH0pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBncm91cGVkID0gZ3JvdXBTZXJpZXNCeVR5cGUocHJlcHJvY2Vzc2VkKTtcclxuICAgIGNvbnN0IGdyb3VwQ291bnQgPSBncm91cGVkLnJlZHVjZSgocmVzdWx0LCBuZXh0KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAobmV4dC50eXBlID09PSAndW5ncm91cGVkJylcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBjb25zdCBzZXJpZXNUeXBlID0gKF9hID0gbmV4dC5vcHRzWzBdLnR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdsaW5lJztcclxuICAgICAgICAoX2IgPSByZXN1bHRbc2VyaWVzVHlwZV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChyZXN1bHRbc2VyaWVzVHlwZV0gPSAwKTtcclxuICAgICAgICByZXN1bHRbc2VyaWVzVHlwZV0gKz0gbmV4dC50eXBlID09PSAnc3RhY2snID8gMSA6IG5leHQub3B0cy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIHt9KTtcclxuICAgIGNvbnN0IGdyb3VwSWR4ID0ge307XHJcbiAgICBjb25zdCBhZGRTZXJpZXNHcm91cGluZ01ldGEgPSAoZ3JvdXApID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGxldCBzdGFja0lkeCA9IDA7XHJcbiAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IChfYSA9IGdyb3VwLm9wdHNbMF0udHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2xpbmUnO1xyXG4gICAgICAgIChfYiA9IGdyb3VwSWR4W3Nlcmllc1R5cGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoZ3JvdXBJZHhbc2VyaWVzVHlwZV0gPSAwKTtcclxuICAgICAgICBpZiAoZ3JvdXAudHlwZSA9PT0gJ3N0YWNrJykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdHMgb2YgZ3JvdXAub3B0cykge1xyXG4gICAgICAgICAgICAgICAgb3B0cy5zZXJpZXNHcm91cGluZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cElkeFtzZXJpZXNUeXBlXSxcclxuICAgICAgICAgICAgICAgICAgICBncm91cENvdW50OiBncm91cENvdW50W3Nlcmllc1R5cGVdLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrSW5kZXg6IHN0YWNrSWR4KyssXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDb3VudDogZ3JvdXAub3B0cy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyb3VwSWR4W3Nlcmllc1R5cGVdKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRzIG9mIGdyb3VwLm9wdHMpIHtcclxuICAgICAgICAgICAgICAgIG9wdHMuc2VyaWVzR3JvdXBpbmcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJZHhbc2VyaWVzVHlwZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBDb3VudDogZ3JvdXBDb3VudFtzZXJpZXNUeXBlXSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFja0luZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrQ291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBJZHhbc2VyaWVzVHlwZV0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRzIG9mIGdyb3VwLm9wdHMpIHtcclxuICAgICAgICAgICAgICAgIG9wdHMuc2VyaWVzR3JvdXBpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdyb3VwLm9wdHM7XHJcbiAgICB9O1xyXG4gICAgRGVidWcuY3JlYXRlKHRydWUsICdvcHRzJykoJ3Byb2Nlc3NTZXJpZXNPcHRpb25zKCkgLSBzZXJpZXMgZ3JvdXBpbmc6ICcsIGdyb3VwZWQpO1xyXG4gICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cGVkKSB7XHJcbiAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IChfYSA9IGdyb3VwLm9wdHNbMF0udHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2xpbmUnO1xyXG4gICAgICAgIGlmIChpc0dyb3VwYWJsZVNlcmllcyhzZXJpZXNUeXBlKSB8fCBpc1N0YWNrYWJsZVNlcmllcyhzZXJpZXNUeXBlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCguLi5hZGRTZXJpZXNHcm91cGluZ01ldGEoZ3JvdXApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLmdyb3VwLm9wdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwgPSAnd2hpdGUnO1xyXG5jb25zdCBwYWxldHRlJDkgPSB7XHJcbiAgICBmaWxsczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpKSxcclxuICAgIHN0cm9rZXM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhERUZBVUxUX1NUUk9LRVMpKSxcclxufTtcclxuY29uc3QgQ0hBUlRfVFlQRV9DT05GSUcgPSB7XHJcbiAgICBnZXQgY2FydGVzaWFuKCkge1xyXG4gICAgICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBDSEFSVF9UWVBFUy5jYXJ0ZXNpYW5UeXBlcywgY29tbW9uT3B0aW9uczogWyd6b29tJywgJ25hdmlnYXRvciddIH07XHJcbiAgICB9LFxyXG4gICAgZ2V0IHBvbGFyKCkge1xyXG4gICAgICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBDSEFSVF9UWVBFUy5wb2xhclR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xyXG4gICAgfSxcclxuICAgIGdldCBoaWVyYXJjaHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IENIQVJUX1RZUEVTLmhpZXJhcmNoeVR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xyXG4gICAgfSxcclxufTtcclxuY29uc3QgQ0hBUlRfVFlQRV9TUEVDSUZJQ19DT01NT05fT1BUSU9OUyA9IE9iamVjdC52YWx1ZXMoQ0hBUlRfVFlQRV9DT05GSUcpLnJlZHVjZSgociwgeyBjb21tb25PcHRpb25zIH0pID0+IFsuLi5yLCAuLi5jb21tb25PcHRpb25zXSwgW10pO1xyXG5jbGFzcyBDaGFydFRoZW1lIHtcclxuICAgIGdldFBhbGV0dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhbGV0dGUkOTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRBeGlzRGVmYXVsdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9wOiB7fSxcclxuICAgICAgICAgICAgcmlnaHQ6IHt9LFxyXG4gICAgICAgICAgICBib3R0b206IHt9LFxyXG4gICAgICAgICAgICBsZWZ0OiB7fSxcclxuICAgICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJ0F4aXMgVGl0bGUnLFxyXG4gICAgICAgICAgICAgICAgc3BhY2luZzogMjUsXHJcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IE5PUk1BTCxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBGT05UX1NJWkUuTUVESVVNLFxyXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IEZPTlRfU0laRS5TTUFMTCxcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiA1LFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgYXZvaWRDb2xsaXNpb25zOiB0cnVlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaW5lOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aWNrOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ3JpZExpbmU6IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdHlsZTogW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3Jvc3NMaW5lczoge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4xLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogRk9OVF9TSVpFLlNNQUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogNSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0U2VyaWVzRGVmYXVsdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9vbHRpcDoge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIHNob3dJbkxlZ2VuZDogdHJ1ZSxcclxuICAgICAgICAgICAgaGlnaGxpZ2h0U3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGl0ZW06IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAncmdiYSgyNTUsMjU1LDI1NSwgMC4zMyknLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogYHJnYmEoMCwgMCwgMCwgMC40KWAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2VyaWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGltT3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlQ2xpY2tSYW5nZTogJ2V4YWN0JyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldENhcnRlc2lhblNlcmllc01hcmtlckRlZmF1bHRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcclxuICAgICAgICAgICAgc2l6ZTogNyxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXHJcbiAgICAgICAgICAgIGZvcm1hdHRlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0TGVnZW5kSXRlbU1hcmtlckRlZmF1bHRzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNoYXBlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHNpemU6IDE1LFxyXG4gICAgICAgICAgICBwYWRkaW5nOiA4LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0Q2FwdGlvbldyYXBwaW5nRGVmYXVsdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuICdoeXBoZW5hdGUnO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldENoYXJ0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZDoge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGw6IERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcclxuICAgICAgICAgICAgICAgIHRvcDogMjAsXHJcbiAgICAgICAgICAgICAgICByaWdodDogMjAsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IDIwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogMjAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHRleHQ6ICdUaXRsZScsXHJcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IE5PUk1BTCxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBGT05UX1NJWkUuTEFSR0UsXHJcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxyXG4gICAgICAgICAgICAgICAgd3JhcHBpbmc6IENoYXJ0VGhlbWUuZ2V0Q2FwdGlvbldyYXBwaW5nRGVmYXVsdHMoKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3VidGl0bGU6IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJ1N1YnRpdGxlJyxcclxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IDIwLFxyXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogRk9OVF9TSVpFLk1FRElVTSxcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXHJcbiAgICAgICAgICAgICAgICB3cmFwcGluZzogQ2hhcnRUaGVtZS5nZXRDYXB0aW9uV3JhcHBpbmdEZWZhdWx0cygpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmb290bm90ZToge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiAnRm9vdG5vdGUnLFxyXG4gICAgICAgICAgICAgICAgc3BhY2luZzogMjAsXHJcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBGT05UX1NJWkUuTUVESVVNLFxyXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiKDE0MCwgMTQwLCAxNDApJyxcclxuICAgICAgICAgICAgICAgIHdyYXBwaW5nOiBDaGFydFRoZW1lLmdldENhcHRpb25XcmFwcGluZ0RlZmF1bHRzKCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxlZ2VuZDoge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IEJPVFRPTSxcclxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IDMwLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7fSxcclxuICAgICAgICAgICAgICAgIGl0ZW06IHtcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nWDogMTYsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1k6IDgsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiBDaGFydFRoZW1lLmdldExlZ2VuZEl0ZW1NYXJrZXJEZWZhdWx0cygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IEZPTlRfU0laRS5TTUFMTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZXZlcnNlT3JkZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAxMixcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmVTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodFN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2U6ICduZWFyZXN0JyxcclxuICAgICAgICAgICAgICAgIGRlbGF5OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHt9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGRlZXBNZXJnZSh7fSwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xyXG4gICAgICAgIGNvbnN0IHsgb3ZlcnJpZGVzID0gbnVsbCwgcGFsZXR0ZSA9IG51bGwgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSB0aGlzLmNyZWF0ZUNoYXJ0Q29uZmlnUGVyQ2hhcnRUeXBlKHRoaXMuZ2V0RGVmYXVsdHMoKSk7XHJcbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvbW1vbiB9ID0gb3ZlcnJpZGVzO1xyXG4gICAgICAgICAgICBjb25zdCBhcHBseU92ZXJyaWRlcyA9IChzZXJpZXNUeXBlcywgb3ZlcnJpZGVPcHRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW92ZXJyaWRlT3B0cylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2VyaWVzVHlwZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpZXNUeXBlID0gcztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0c1tzZXJpZXNUeXBlXSA9IGRlZXBNZXJnZShkZWZhdWx0c1tzZXJpZXNUeXBlXSwgb3ZlcnJpZGVPcHRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbLCB7IHNlcmllc1R5cGVzLCBjb21tb25PcHRpb25zIH1dIG9mIE9iamVjdC5lbnRyaWVzKENIQVJUX1RZUEVfQ09ORklHKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZENvbW1vbiA9IE9iamVjdC5hc3NpZ24oe30sIGNvbW1vbik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbW1vbktleSBvZiBDSEFSVF9UWVBFX1NQRUNJRklDX0NPTU1PTl9PUFRJT05TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tb25PcHRpb25zLmluY2x1ZGVzKGNvbW1vbktleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNsZWFuZWRDb21tb25bY29tbW9uS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhcHBseU92ZXJyaWRlcyhzZXJpZXNUeXBlcywgY2xlYW5lZENvbW1vbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ0hBUlRfVFlQRVMuc2VyaWVzVHlwZXMuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IHM7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzW3Nlcmllc1R5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHNbc2VyaWVzVHlwZV0gPSBkZWVwTWVyZ2UoZGVmYXVsdHNbc2VyaWVzVHlwZV0sIG92ZXJyaWRlc1tzZXJpZXNUeXBlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhbGV0dGUgPSBwYWxldHRlICE9PSBudWxsICYmIHBhbGV0dGUgIT09IHZvaWQgMCA/IHBhbGV0dGUgOiB0aGlzLmdldFBhbGV0dGUoKTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5mcmVlemUodGhpcy50ZW1wbGF0ZVRoZW1lKGRlZmF1bHRzKSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDaGFydENvbmZpZ1BlckNoYXJ0VHlwZShjb25maWcpIHtcclxuICAgICAgICBPYmplY3QuZW50cmllcyhDSEFSVF9UWVBFX0NPTkZJRykuZm9yRWFjaCgoW25leHRUeXBlLCB7IHNlcmllc1R5cGVzIH1dKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVEZWZhdWx0cyA9IGdldENoYXJ0RGVmYXVsdHMobmV4dFR5cGUpO1xyXG4gICAgICAgICAgICBzZXJpZXNUeXBlcy5mb3JFYWNoKChuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhcyA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZ1thbGlhc10pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWdbYWxpYXNdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcE1lcmdlKGNvbmZpZ1thbGlhc10sIHR5cGVEZWZhdWx0cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBnZXREZWZhdWx0cygpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdHMgPSB7fTtcclxuICAgICAgICBjb25zdCBnZXRDaGFydFR5cGVEZWZhdWx0cyA9IChjaGFydFR5cGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRMZWdlbmRUaGVtZVRlbXBsYXRlcygpKSwgQ2hhcnRUaGVtZS5nZXRDaGFydERlZmF1bHRzKCkpLCBnZXRDaGFydERlZmF1bHRzKGNoYXJ0VHlwZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZ2V0T3ZlcnJpZGVzQnlUeXBlID0gKGNoYXJ0VHlwZSwgc2VyaWVzVHlwZXMpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAgIHZhciBfZDtcclxuICAgICAgICAgICAgY29uc3QgY2hhcnREZWZhdWx0cyA9IGdldENoYXJ0VHlwZURlZmF1bHRzKGNoYXJ0VHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUgb2Ygc2VyaWVzVHlwZXMpIHtcclxuICAgICAgICAgICAgICAgIChfYSA9IHJlc3VsdFtzZXJpZXNUeXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHJlc3VsdFtzZXJpZXNUeXBlXSA9IGRlZXBNZXJnZSh7fSwgY2hhcnREZWZhdWx0cykpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXhlcyA9ICgoX2IgPSAoX2QgPSByZXN1bHRbc2VyaWVzVHlwZV0pLmF4ZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfZC5heGVzID0ge30pKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZ2V0U2VyaWVzVGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtzZXJpZXNUeXBlXS5zZXJpZXMgPSBkZWVwTWVyZ2UocmVzdWx0W3Nlcmllc1R5cGVdLnNlcmllcywgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBBWElTX1RZUEVTLmF4ZXNUeXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZ2V0QXhpc1RoZW1lVGVtcGxhdGUoYXhpc1R5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydFR5cGUgPT09ICdjYXJ0ZXNpYW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ZXNbYXhpc1R5cGVdID0gZGVlcE1lcmdlKGF4ZXNbYXhpc1R5cGVdLCAoX2MgPSBDaGFydFRoZW1lLmNhcnRlc2lhbkF4aXNEZWZhdWx0W2F4aXNUeXBlXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhlc1theGlzVHlwZV0gPSBkZWVwTWVyZ2UoYXhlc1theGlzVHlwZV0sIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGRlZmF1bHRzID0gZGVlcE1lcmdlKGRlZmF1bHRzLCBnZXRPdmVycmlkZXNCeVR5cGUoJ2NhcnRlc2lhbicsIENIQVJUX1RZUEVTLmNhcnRlc2lhblR5cGVzKSk7XHJcbiAgICAgICAgZGVmYXVsdHMgPSBkZWVwTWVyZ2UoZGVmYXVsdHMsIGdldE92ZXJyaWRlc0J5VHlwZSgncG9sYXInLCBDSEFSVF9UWVBFUy5wb2xhclR5cGVzKSk7XHJcbiAgICAgICAgZGVmYXVsdHMgPSBkZWVwTWVyZ2UoZGVmYXVsdHMsIGdldE92ZXJyaWRlc0J5VHlwZSgnaGllcmFyY2h5JywgQ0hBUlRfVFlQRVMuaGllcmFyY2h5VHlwZXMpKTtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XHJcbiAgICB9XHJcbiAgICB0ZW1wbGF0ZVRoZW1lKHRoZW1lVGVtcGxhdGUpIHtcclxuICAgICAgICBjb25zdCB0aGVtZUluc3RhbmNlID0ganNvbk1lcmdlKFt0aGVtZVRlbXBsYXRlXSk7XHJcbiAgICAgICAgY29uc3QgeyBleHRlbnNpb25zLCBwcm9wZXJ0aWVzIH0gPSB0aGlzLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xyXG4gICAgICAgIGpzb25XYWxrKHRoZW1lSW5zdGFuY2UsIChfLCBub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChub2RlWydfX2V4dGVuZHNfXyddKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBub2RlWydfX2V4dGVuZHNfXyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gZXh0ZW5zaW9ucy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQUcgQ2hhcnRzIC0gbm8gdGVtcGxhdGUgdmFyaWFibGUgcHJvdmlkZWQgZm9yOiAnICsga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG5vZGVbJ19fZXh0ZW5kc19fJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGVbJ19fb3ZlcnJpZGVzX18nXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbm9kZVsnX19vdmVycmlkZXNfXyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gZXh0ZW5zaW9ucy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQUcgQ2hhcnRzIC0gbm8gdGVtcGxhdGUgdmFyaWFibGUgcHJvdmlkZWQgZm9yOiAnICsga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obm9kZSwgc291cmNlKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlWydfX292ZXJyaWRlc19fJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IG5vZGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtpXSA9IHByb3BlcnRpZXMuZ2V0KHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlW25hbWVdID0gcHJvcGVydGllcy5nZXQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGVtZUluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBERUZBVUxUX0ZJTExTLkJMVUUsXHJcbiAgICAgICAgICAgIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkJMVUUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogREVGQVVMVF9GSUxMUy5PUkFOR0UsXHJcbiAgICAgICAgICAgIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLk9SQU5HRSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBERUZBVUxUX0ZJTExTLkdSQVksXHJcbiAgICAgICAgICAgIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkdSQVksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGV4dGVuc2lvbnMuc2V0KEVYVEVORFNfQ0hBUlRfREVGQVVMVFMsIENoYXJ0VGhlbWUuZ2V0Q2hhcnREZWZhdWx0cygpKTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChFWFRFTkRTX0FYRVNfREVGQVVMVFMsIENoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKCkpO1xyXG4gICAgICAgIGV4dGVuc2lvbnMuc2V0KEVYVEVORFNfTEVHRU5EX0RFRkFVTFRTLCBDaGFydFRoZW1lLmdldENoYXJ0RGVmYXVsdHMoKS5sZWdlbmQpO1xyXG4gICAgICAgIGV4dGVuc2lvbnMuc2V0KEVYVEVORFNfTEVHRU5EX0lURU1fREVGQVVMVFMsIENoYXJ0VGhlbWUuZ2V0Q2hhcnREZWZhdWx0cygpLmxlZ2VuZC5pdGVtKTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChFWFRFTkRTX0xFR0VORF9JVEVNX01BUktFUl9ERUZBVUxUUywgQ2hhcnRUaGVtZS5nZXRMZWdlbmRJdGVtTWFya2VyRGVmYXVsdHMoKSk7XHJcbiAgICAgICAgZXh0ZW5zaW9ucy5zZXQoRVhURU5EU19BWEVTX0xBQkVMX0RFRkFVTFRTLCBDaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cygpLmxhYmVsKTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChFWFRFTkRTX0FYRVNfTElORV9ERUZBVUxUUywgQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoKS5saW5lKTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChFWFRFTkRTX0FYRVNfVElDS19ERUZBVUxUUywgQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoKS50aWNrKTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChFWFRFTkRTX0FYRVNfR1JJRF9MSU5FX0RFRkFVTFRTLCBDaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cygpLmdyaWRMaW5lKTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChFWFRFTkRTX1NFUklFU19ERUZBVUxUUywgQ2hhcnRUaGVtZS5nZXRTZXJpZXNEZWZhdWx0cygpKTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChPVkVSUklERV9TRVJJRVNfTEFCRUxfREVGQVVMVFMsIHt9KTtcclxuICAgICAgICBleHRlbnNpb25zLnNldChFWFRFTkRTX0NBUlRFU0lBTl9NQVJLRVJfREVGQVVMVFMsIENoYXJ0VGhlbWUuZ2V0Q2FydGVzaWFuU2VyaWVzTWFya2VyRGVmYXVsdHMoKSk7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBwcm9wZXJ0aWVzLnNldChERUZBVUxUX0ZPTlRfRkFNSUxZLCAnVmVyZGFuYSwgc2Fucy1zZXJpZicpO1xyXG4gICAgICAgIHByb3BlcnRpZXMuc2V0KERFRkFVTFRfTEFCRUxfQ09MT1VSLCAncmdiKDcwLCA3MCwgNzApJyk7XHJcbiAgICAgICAgcHJvcGVydGllcy5zZXQoREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVIsICd3aGl0ZScpO1xyXG4gICAgICAgIHByb3BlcnRpZXMuc2V0KERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLCAncmdiKDE0MCwgMTQwLCAxNDApJyk7XHJcbiAgICAgICAgcHJvcGVydGllcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCAncmdiKDIyNCwyMzQsMjQxKScpO1xyXG4gICAgICAgIHByb3BlcnRpZXMuc2V0KERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUiwgJ3JnYigxOTUsIDE5NSwgMTk1KScpO1xyXG4gICAgICAgIHByb3BlcnRpZXMuc2V0KERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLCAncmdiKDcwLCA3MCwgNzApJyk7XHJcbiAgICAgICAgcHJvcGVydGllcy5zZXQoREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUiwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xyXG4gICAgICAgIHByb3BlcnRpZXMuc2V0KERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcclxuICAgICAgICBwcm9wZXJ0aWVzLnNldChERUZBVUxUX1NIQURPV19DT0xPVVIsICdyZ2JhKDAsIDAsIDAsIDAuNSknKTtcclxuICAgICAgICBwcm9wZXJ0aWVzLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXHJcbiAgICAgICAgICAgIERFRkFVTFRfRklMTFMuT1JBTkdFLFxyXG4gICAgICAgICAgICBERUZBVUxUX0ZJTExTLllFTExPVyxcclxuICAgICAgICAgICAgREVGQVVMVF9GSUxMUy5HUkVFTixcclxuICAgICAgICBdKTtcclxuICAgICAgICBwcm9wZXJ0aWVzLnNldChERUZBVUxUX0hJRVJBUkNIWV9GSUxMUywgWycjZmZmZmZmJywgJyNlMGU1ZWEnLCAnI2MxY2NkNScsICcjYTNiNGMxJywgJyM4NTljYWQnXSk7XHJcbiAgICAgICAgcHJvcGVydGllcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUywgWycjZmZmZmZmJywgJyNjNWNiZDEnLCAnI2E0YjFiZCcsICcjODQ5OGE5JywgJyM2NDgwOTYnXSk7XHJcbiAgICAgICAgcHJvcGVydGllcy5zZXQoREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XHJcbiAgICAgICAgcHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlMsIENoYXJ0VGhlbWUuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFBvc2l0aXZlQ29sb3JzKCkpO1xyXG4gICAgICAgIHByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19ORUdBVElWRV9DT0xPVVJTLCBDaGFydFRoZW1lLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHROZWdhdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICBwcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfVE9UQUxfQ09MT1VSUywgQ2hhcnRUaGVtZS5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKSk7XHJcbiAgICAgICAgcHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX0NPTk5FQ1RPUl9MSU5FX1NUUk9LRSwgQ2hhcnRUaGVtZS5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKS5zdHJva2UpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5DaGFydFRoZW1lLmNhcnRlc2lhbkF4aXNEZWZhdWx0ID0ge1xyXG4gICAgbnVtYmVyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIENoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKCkpLCB7IGxpbmU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoKS5saW5lKSwgeyBlbmFibGVkOiBmYWxzZSB9KSB9KSxcclxuICAgIGxvZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBDaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cygpKSwgeyBiYXNlOiAxMCwgbGluZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBDaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cygpLmxpbmUpLCB7IGVuYWJsZWQ6IGZhbHNlIH0pIH0pLFxyXG4gICAgY2F0ZWdvcnk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoKSksIHsgZ3JvdXBQYWRkaW5nSW5uZXI6IDAuMSwgbGFiZWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoKS5sYWJlbCksIHsgYXV0b1JvdGF0ZTogdHJ1ZSB9KSwgZ3JpZExpbmU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoKS5ncmlkTGluZSksIHsgZW5hYmxlZDogZmFsc2UgfSkgfSksXHJcbiAgICAnZ3JvdXBlZC1jYXRlZ29yeSc6IE9iamVjdC5hc3NpZ24oe30sIENoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKCkpLFxyXG4gICAgdGltZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBDaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cygpKSwgeyBncmlkTGluZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBDaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cygpLmdyaWRMaW5lKSwgeyBlbmFibGVkOiBmYWxzZSB9KSB9KSxcclxufTtcblxuY29uc3QgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCA9ICcjMTgyNzMyJztcclxuY29uc3QgREVGQVVMVF9EQVJLX0ZJTExTID0ge1xyXG4gICAgQkxVRTogJyM1MDkwZGMnLFxyXG4gICAgT1JBTkdFOiAnI2ZmYTAzYScsXHJcbiAgICBHUkVFTjogJyM0NTlkNTUnLFxyXG4gICAgQ1lBTjogJyMzNGJmZTEnLFxyXG4gICAgWUVMTE9XOiAnI2UxY2MwMCcsXHJcbiAgICBWSU9MRVQ6ICcjOTY2OWNiJyxcclxuICAgIEdSQVk6ICcjYjViNWI1JyxcclxuICAgIE1BR0VOVEE6ICcjYmQ1YWE3JyxcclxuICAgIEJST1dOOiAnIzhhNjIyNCcsXHJcbiAgICBSRUQ6ICcjZWY1NDUyJyxcclxufTtcclxuY29uc3QgREVGQVVMVF9EQVJLX1NUUk9LRVMgPSB7XHJcbiAgICBCTFVFOiAnIzc0YThlNicsXHJcbiAgICBPUkFOR0U6ICcjZmZiZTcwJyxcclxuICAgIEdSRUVOOiAnIzZjYjE3NicsXHJcbiAgICBDWUFOOiAnIzc1ZDRlZicsXHJcbiAgICBZRUxMT1c6ICcjZjZlNTU5JyxcclxuICAgIFZJT0xFVDogJyNhYTg2ZDgnLFxyXG4gICAgR1JBWTogJyNhMWExYTEnLFxyXG4gICAgTUFHRU5UQTogJyNjZTdhYjknLFxyXG4gICAgQlJPV046ICcjOTk3YjUyJyxcclxuICAgIFJFRDogJyNmZjc4NzInLFxyXG59O1xyXG5jb25zdCBwYWxldHRlJDggPSB7XHJcbiAgICBmaWxsczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKERFRkFVTFRfREFSS19GSUxMUykpLFxyXG4gICAgc3Ryb2tlczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKERFRkFVTFRfREFSS19TVFJPS0VTKSksXHJcbn07XHJcbmNsYXNzIERhcmtUaGVtZSBleHRlbmRzIENoYXJ0VGhlbWUge1xyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuQkxVRSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5CTFVFLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdE5lZ2F0aXZlQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5PUkFOR0UsXHJcbiAgICAgICAgICAgIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuT1JBTkdFLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5HUkFZLFxyXG4gICAgICAgICAgICBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkdSQVksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlMsIERhcmtUaGVtZS5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0UG9zaXRpdmVDb2xvcnMoKSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19ORUdBVElWRV9DT0xPVVJTLCBEYXJrVGhlbWUuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdE5lZ2F0aXZlQ29sb3JzKCkpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfVE9UQUxfQ09MT1VSUywgRGFya1RoZW1lLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX0NPTk5FQ1RPUl9MSU5FX1NUUk9LRSwgRGFya1RoZW1lLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpLnN0cm9rZSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfTEFCRUxfQ09MT1VSLCAnd2hpdGUnKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsICcjN0Q5MUEwJyk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgJyM1NDVBNkUnKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVIsICd3aGl0ZScpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXHJcbiAgICAgICAgICAgIERFRkFVTFRfREFSS19GSUxMUy5PUkFOR0UsXHJcbiAgICAgICAgICAgIERFRkFVTFRfREFSS19GSUxMUy5ZRUxMT1csXHJcbiAgICAgICAgICAgIERFRkFVTFRfREFSS19GSUxMUy5HUkVFTixcclxuICAgICAgICBdKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfRklMTFMsIFsnIzE5MjgzNCcsICcjMjUzNzQ2JywgJyMzMjQ4NTknLCAnIzNmNTk2YycsICcjNGQ2YTgwJ10pO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLCBbJyMxOTI4MzQnLCAnIzNiNTE2NCcsICcjNDk2Mjc1JywgJyM1NzcyODcnLCAnIzY2ODM5OSddKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBnZXRQYWxldHRlKCkge1xyXG4gICAgICAgIHJldHVybiBwYWxldHRlJDg7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgTUFURVJJQUxfREFSS19GSUxMUyA9IHtcclxuICAgIEJMVUU6ICcjMjE5NkYzJyxcclxuICAgIE9SQU5HRTogJyNGRjk4MDAnLFxyXG4gICAgR1JFRU46ICcjNENBRjUwJyxcclxuICAgIENZQU46ICcjMDBCQ0Q0JyxcclxuICAgIFlFTExPVzogJyNGRkVCM0InLFxyXG4gICAgVklPTEVUOiAnIzdFNTdDMicsXHJcbiAgICBHUkFZOiAnIzlFOUU5RScsXHJcbiAgICBNQUdFTlRBOiAnI0YwNjI5MicsXHJcbiAgICBCUk9XTjogJyM3OTU1NDgnLFxyXG4gICAgUkVEOiAnI0Y0NDMzNicsXHJcbn07XHJcbmNvbnN0IE1BVEVSSUFMX0RBUktfU1RST0tFUyA9IHtcclxuICAgIEJMVUU6ICcjOTBDQUY5JyxcclxuICAgIE9SQU5HRTogJyNGRkNDODAnLFxyXG4gICAgR1JFRU46ICcjQTVENkE3JyxcclxuICAgIENZQU46ICcjODBERUVBJyxcclxuICAgIFlFTExPVzogJyNGRkY5QzQnLFxyXG4gICAgVklPTEVUOiAnI0IzOUREQicsXHJcbiAgICBHUkFZOiAnI0UwRTBFMCcsXHJcbiAgICBNQUdFTlRBOiAnI0Y0OEZCMScsXHJcbiAgICBCUk9XTjogJyNBMTg4N0YnLFxyXG4gICAgUkVEOiAnI0VGOUE5QScsXHJcbn07XHJcbmNvbnN0IHBhbGV0dGUkNyA9IHtcclxuICAgIGZpbGxzOiBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoTUFURVJJQUxfREFSS19GSUxMUykpLFxyXG4gICAgc3Ryb2tlczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKE1BVEVSSUFMX0RBUktfU1RST0tFUykpLFxyXG59O1xyXG5jbGFzcyBNYXRlcmlhbERhcmsgZXh0ZW5kcyBEYXJrVGhlbWUge1xyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkJMVUUsXHJcbiAgICAgICAgICAgIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkJMVUUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5SRUQsXHJcbiAgICAgICAgICAgIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLlJFRCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkdSQVksXHJcbiAgICAgICAgICAgIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSQVksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlMsIE1hdGVyaWFsRGFyay5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0UG9zaXRpdmVDb2xvcnMoKSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19ORUdBVElWRV9DT0xPVVJTLCBNYXRlcmlhbERhcmsuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdE5lZ2F0aXZlQ29sb3JzKCkpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfVE9UQUxfQ09MT1VSUywgTWF0ZXJpYWxEYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xyXG4gICAgICAgICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLk9SQU5HRSxcclxuICAgICAgICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5ZRUxMT1csXHJcbiAgICAgICAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuR1JFRU4sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19DT05ORUNUT1JfTElORV9TVFJPS0UsIE1hdGVyaWFsRGFyay5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKS5zdHJva2UpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBnZXRQYWxldHRlKCkge1xyXG4gICAgICAgIHJldHVybiBwYWxldHRlJDc7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgTUFURVJJQUxfTElHSFRfRklMTFMgPSB7XHJcbiAgICBCTFVFOiAnIzIxOTZGMycsXHJcbiAgICBPUkFOR0U6ICcjRkY5ODAwJyxcclxuICAgIEdSRUVOOiAnIzRDQUY1MCcsXHJcbiAgICBDWUFOOiAnIzAwQkNENCcsXHJcbiAgICBZRUxMT1c6ICcjRkZFQjNCJyxcclxuICAgIFZJT0xFVDogJyM3RTU3QzInLFxyXG4gICAgR1JBWTogJyM5RTlFOUUnLFxyXG4gICAgTUFHRU5UQTogJyNGMDYyOTInLFxyXG4gICAgQlJPV046ICcjNzk1NTQ4JyxcclxuICAgIFJFRDogJyNGNDQzMzYnLFxyXG59O1xyXG5jb25zdCBNQVRFUklBTF9MSUdIVF9TVFJPS0VTID0ge1xyXG4gICAgQkxVRTogJyMxNTY1QzAnLFxyXG4gICAgT1JBTkdFOiAnI0U2NTEwMCcsXHJcbiAgICBHUkVFTjogJyMyRTdEMzInLFxyXG4gICAgQ1lBTjogJyMwMDgzOEYnLFxyXG4gICAgWUVMTE9XOiAnI0Y5QTgyNScsXHJcbiAgICBWSU9MRVQ6ICcjNDUyN0EwJyxcclxuICAgIEdSQVk6ICcjNjE2MTYxJyxcclxuICAgIE1BR0VOVEE6ICcjQzIxODVCJyxcclxuICAgIEJST1dOOiAnIzRFMzQyRScsXHJcbiAgICBSRUQ6ICcjQjcxQzFDJyxcclxufTtcclxuY29uc3QgcGFsZXR0ZSQ2ID0ge1xyXG4gICAgZmlsbHM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhNQVRFUklBTF9MSUdIVF9GSUxMUykpLFxyXG4gICAgc3Ryb2tlczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMpKSxcclxufTtcclxuY2xhc3MgTWF0ZXJpYWxMaWdodCBleHRlbmRzIENoYXJ0VGhlbWUge1xyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFLFxyXG4gICAgICAgICAgICBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuQkxVRSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHROZWdhdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRUQsXHJcbiAgICAgICAgICAgIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5SRUQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JBWSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkdSQVksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlMsIE1hdGVyaWFsTGlnaHQuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFBvc2l0aXZlQ29sb3JzKCkpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfTkVHQVRJVkVfQ09MT1VSUywgTWF0ZXJpYWxMaWdodC5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19UT1RBTF9DT0xPVVJTLCBNYXRlcmlhbExpZ2h0LmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xyXG4gICAgICAgICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5PUkFOR0UsXHJcbiAgICAgICAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLllFTExPVyxcclxuICAgICAgICAgICAgTUFURVJJQUxfTElHSFRfRklMTFMuR1JFRU4sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19DT05ORUNUT1JfTElORV9TVFJPS0UsIE1hdGVyaWFsTGlnaHQuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkuc3Ryb2tlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZ2V0UGFsZXR0ZSgpIHtcclxuICAgICAgICByZXR1cm4gcGFsZXR0ZSQ2O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IFBPTFlDSFJPTUFfREFSS19GSUxMUyA9IHtcclxuICAgIEJMVUU6ICcjNDM2ZmY0JyxcclxuICAgIFBVUlBMRTogJyM5YTdiZmYnLFxyXG4gICAgTUFHRU5UQTogJyNkMTY1ZDInLFxyXG4gICAgUElOSzogJyNmMDU5OGInLFxyXG4gICAgUkVEOiAnI2Y0NzM0OCcsXHJcbiAgICBPUkFOR0U6ICcjZjJhNjAyJyxcclxuICAgIFlFTExPVzogJyNlOWUyMDEnLFxyXG4gICAgR1JFRU46ICcjMjFiNDQ4JyxcclxuICAgIENZQU46ICcjMDBiOWEyJyxcclxuICAgIE1PREVSQVRFX0JMVUU6ICcjMDBhZWU0JyxcclxufTtcclxuY29uc3QgUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMgPSB7XHJcbiAgICBCTFVFOiAnIzY2OThmZicsXHJcbiAgICBQVVJQTEU6ICcjYzBhM2ZmJyxcclxuICAgIE1BR0VOVEE6ICcjZmM4ZGZjJyxcclxuICAgIFBJTks6ICcjZmY4MmIxJyxcclxuICAgIFJFRDogJyNmZjliNzAnLFxyXG4gICAgT1JBTkdFOiAnI2ZmY2Y0ZScsXHJcbiAgICBZRUxMT1c6ICcjZmZmZjU4JyxcclxuICAgIEdSRUVOOiAnIzU4ZGQ3MCcsXHJcbiAgICBDWUFOOiAnIzUxZTJjOScsXHJcbiAgICBNT0RFUkFURV9CTFVFOiAnIzRmZDdmZicsXHJcbn07XHJcbmNvbnN0IFBPTFlDSFJPTUFfREFSS19GSUxMX0dSQVkgPSAnI2JiYmJiYic7XHJcbmNvbnN0IFBPTFlDSFJPTUFfREFSS19TVFJPS0VfR1JBWSA9ICcjZWVlZWVlJztcclxuY29uc3QgcGFsZXR0ZSQ1ID0ge1xyXG4gICAgZmlsbHM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhQT0xZQ0hST01BX0RBUktfRklMTFMpKSxcclxuICAgIHN0cm9rZXM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhQT0xZQ0hST01BX0RBUktfU1RST0tFUykpLFxyXG59O1xyXG5jbGFzcyBQb2x5Y2hyb21hRGFyayBleHRlbmRzIERhcmtUaGVtZSB7XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFBvc2l0aXZlQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFLFxyXG4gICAgICAgICAgICBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkJMVUUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRCxcclxuICAgICAgICAgICAgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5SRUQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExfR1JBWSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFX0dSQVksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlMsIFBvbHljaHJvbWFEYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX05FR0FUSVZFX0NPTE9VUlMsIFBvbHljaHJvbWFEYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHROZWdhdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1RPVEFMX0NPTE9VUlMsIFBvbHljaHJvbWFEYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xyXG4gICAgICAgICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSxcclxuICAgICAgICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRCxcclxuICAgICAgICBdKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX0NPTk5FQ1RPUl9MSU5FX1NUUk9LRSwgUG9seWNocm9tYURhcmsuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkuc3Ryb2tlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZ2V0UGFsZXR0ZSgpIHtcclxuICAgICAgICByZXR1cm4gcGFsZXR0ZSQ1O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IFBPTFlDSFJPTUFfTElHSFRfRklMTFMgPSB7XHJcbiAgICBCTFVFOiAnIzQzNmZmNCcsXHJcbiAgICBQVVJQTEU6ICcjOWE3YmZmJyxcclxuICAgIE1BR0VOVEE6ICcjZDE2NWQyJyxcclxuICAgIFBJTks6ICcjZjA1OThiJyxcclxuICAgIFJFRDogJyNmNDczNDgnLFxyXG4gICAgT1JBTkdFOiAnI2YyYTYwMicsXHJcbiAgICBZRUxMT1c6ICcjZTllMjAxJyxcclxuICAgIEdSRUVOOiAnIzIxYjQ0OCcsXHJcbiAgICBDWUFOOiAnIzAwYjlhMicsXHJcbiAgICBNT0RFUkFURV9CTFVFOiAnIzAwYWVlNCcsXHJcbn07XHJcbmNvbnN0IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUyA9IHtcclxuICAgIEJMVUU6ICcjMjM0NmM5JyxcclxuICAgIFBVUlBMRTogJyM3NjUzZDQnLFxyXG4gICAgTUFHRU5UQTogJyNhNzNkYTknLFxyXG4gICAgUElOSzogJyNjMzJkNjYnLFxyXG4gICAgUkVEOiAnI2M4NGIxYycsXHJcbiAgICBPUkFOR0U6ICcjYzg3ZjAwJyxcclxuICAgIFlFTExPVzogJyNjMWI5MDAnLFxyXG4gICAgR1JFRU46ICcjMDA4YzFjJyxcclxuICAgIENZQU46ICcjMDA5MjdjJyxcclxuICAgIE1PREVSQVRFX0JMVUU6ICcjMDA4N2JiJyxcclxufTtcclxuY29uc3QgUE9MWUNIUk9NQV9MSUdIVF9GSUxMX0dSQVkgPSAnI2JiYmJiYic7XHJcbmNvbnN0IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFX0dSQVkgPSAnIzg4ODg4OCc7XHJcbmNvbnN0IHBhbGV0dGUkNCA9IHtcclxuICAgIGZpbGxzOiBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoUE9MWUNIUk9NQV9MSUdIVF9GSUxMUykpLFxyXG4gICAgc3Ryb2tlczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUykpLFxyXG59O1xyXG5jbGFzcyBQb2x5Y2hyb21hTGlnaHQgZXh0ZW5kcyBDaGFydFRoZW1lIHtcclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0UG9zaXRpdmVDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLFxyXG4gICAgICAgICAgICBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5CTFVFLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdE5lZ2F0aXZlQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELFxyXG4gICAgICAgICAgICBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5SRUQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMX0dSQVksXHJcbiAgICAgICAgICAgIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VfR1JBWSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfUE9TSVRJVkVfQ09MT1VSUywgUG9seWNocm9tYUxpZ2h0LmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX05FR0FUSVZFX0NPTE9VUlMsIFBvbHljaHJvbWFMaWdodC5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19UT1RBTF9DT0xPVVJTLCBQb2x5Y2hyb21hTGlnaHQuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXHJcbiAgICAgICAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSxcclxuICAgICAgICAgICAgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRUQsXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19DT05ORUNUT1JfTElORV9TVFJPS0UsIFBvbHljaHJvbWFMaWdodC5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKS5zdHJva2UpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBnZXRQYWxldHRlKCkge1xyXG4gICAgICAgIHJldHVybiBwYWxldHRlJDQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgU0hFRVRTX0RBUktfRklMTFMgPSB7XHJcbiAgICBCTFVFOiAnIzQ0NzJDNCcsXHJcbiAgICBPUkFOR0U6ICcjRUQ3RDMxJyxcclxuICAgIEdSQVk6ICcjQTVBNUE1JyxcclxuICAgIFlFTExPVzogJyNGRkMwMDAnLFxyXG4gICAgTU9ERVJBVEVfQkxVRTogJyM1QjlCRDUnLFxyXG4gICAgR1JFRU46ICcjNzBBRDQ3JyxcclxuICAgIERBUktfR1JBWTogJyM3QjdCN0InLFxyXG4gICAgREFSS19CTFVFOiAnIzI2NDQ3OCcsXHJcbiAgICBWRVJZX0RBUktfR1JBWTogJyM2MzYzNjMnLFxyXG4gICAgREFSS19ZRUxMT1c6ICcjOTk3MzAwJyxcclxufTtcclxuY29uc3QgU0hFRVRTX0RBUktfU1RST0tFUyA9IHtcclxuICAgIEJMVUU6ICcjNjg5OWVlJyxcclxuICAgIE9SQU5HRTogJyNmZmE1NWQnLFxyXG4gICAgR1JBWTogJyNjZGNkY2QnLFxyXG4gICAgWUVMTE9XOiAnI2ZmZWE1MycsXHJcbiAgICBNT0RFUkFURV9CTFVFOiAnIzgyYzNmZicsXHJcbiAgICBHUkVFTjogJyM5NmQ1NmYnLFxyXG4gICAgREFSS19HUkFZOiAnI2ExYTFhMScsXHJcbiAgICBEQVJLX0JMVUU6ICcjNDc2ODlmJyxcclxuICAgIFZFUllfREFSS19HUkFZOiAnIzg3ODc4NycsXHJcbiAgICBEQVJLX1lFTExPVzogJyNjMDk5M2QnLFxyXG59O1xyXG5jb25zdCBwYWxldHRlJDMgPSB7XHJcbiAgICBmaWxsczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFNIRUVUU19EQVJLX0ZJTExTKSksXHJcbiAgICBzdHJva2VzOiBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoU0hFRVRTX0RBUktfU1RST0tFUykpLFxyXG59O1xyXG5jbGFzcyBTaGVldHNEYXJrIGV4dGVuZHMgRGFya1RoZW1lIHtcclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0UG9zaXRpdmVDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuQkxVRSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkJMVUUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLFxyXG4gICAgICAgICAgICBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSQVksXHJcbiAgICAgICAgICAgIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5HUkFZLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19QT1NJVElWRV9DT0xPVVJTLCBTaGVldHNEYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX05FR0FUSVZFX0NPTE9VUlMsIFNoZWV0c0RhcmsuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdE5lZ2F0aXZlQ29sb3JzKCkpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfVE9UQUxfQ09MT1VSUywgU2hlZXRzRGFyay5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcclxuICAgICAgICAgICAgU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLFxyXG4gICAgICAgICAgICBTSEVFVFNfREFSS19GSUxMUy5ZRUxMT1csXHJcbiAgICAgICAgICAgIFNIRUVUU19EQVJLX0ZJTExTLkdSRUVOLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfQ09OTkVDVE9SX0xJTkVfU1RST0tFLCBTaGVldHNEYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpLnN0cm9rZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldFBhbGV0dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhbGV0dGUkMztcclxuICAgIH1cclxufVxuXG5jb25zdCBTSEVFVFNfTElHSFRfRklMTFMgPSB7XHJcbiAgICBCTFVFOiAnIzUyODFkNScsXHJcbiAgICBPUkFOR0U6ICcjZmY4ZDQ0JyxcclxuICAgIEdSQVk6ICcjYjViNWI1JyxcclxuICAgIFlFTExPVzogJyNmZmQwMmYnLFxyXG4gICAgTU9ERVJBVEVfQkxVRTogJyM2YWFiZTYnLFxyXG4gICAgR1JFRU46ICcjN2ZiZDU3JyxcclxuICAgIERBUktfR1JBWTogJyM4YThhOGEnLFxyXG4gICAgREFSS19CTFVFOiAnIzMzNTI4NycsXHJcbiAgICBWRVJZX0RBUktfR1JBWTogJyM3MTcxNzEnLFxyXG4gICAgREFSS19ZRUxMT1c6ICcjYTk4MjIwJyxcclxufTtcclxuY29uc3QgU0hFRVRTX0xJR0hUX1NUUk9LRVMgPSB7XHJcbiAgICBCTFVFOiAnIzIxNGQ5YicsXHJcbiAgICBPUkFOR0U6ICcjYzI1NjAwJyxcclxuICAgIEdSQVk6ICcjN2Y3ZjdmJyxcclxuICAgIFlFTExPVzogJyNkNTk4MDAnLFxyXG4gICAgTU9ERVJBVEVfQkxVRTogJyMzNTc1YWMnLFxyXG4gICAgR1JFRU46ICcjNGI4NjFhJyxcclxuICAgIERBUktfR1JBWTogJyM1NzU3NTcnLFxyXG4gICAgREFSS19CTFVFOiAnIzA2MjI1MycsXHJcbiAgICBWRVJZX0RBUktfR1JBWTogJyM0MTQxNDEnLFxyXG4gICAgREFSS19ZRUxMT1c6ICcjNzM0ZjAwJyxcclxufTtcclxuY29uc3QgcGFsZXR0ZSQyID0ge1xyXG4gICAgZmlsbHM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhTSEVFVFNfTElHSFRfRklMTFMpKSxcclxuICAgIHN0cm9rZXM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhTSEVFVFNfTElHSFRfU1RST0tFUykpLFxyXG59O1xyXG5jbGFzcyBTaGVldHNMaWdodCBleHRlbmRzIENoYXJ0VGhlbWUge1xyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5CTFVFLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdE5lZ2F0aXZlQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UsXHJcbiAgICAgICAgICAgIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuT1JBTkdFLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5HUkFZLFxyXG4gICAgICAgICAgICBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSQVksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlMsIFNoZWV0c0xpZ2h0LmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX05FR0FUSVZFX0NPTE9VUlMsIFNoZWV0c0xpZ2h0LmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHROZWdhdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1RPVEFMX0NPTE9VUlMsIFNoZWV0c0xpZ2h0LmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xyXG4gICAgICAgICAgICBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFLFxyXG4gICAgICAgICAgICBTSEVFVFNfTElHSFRfRklMTFMuWUVMTE9XLFxyXG4gICAgICAgICAgICBTSEVFVFNfTElHSFRfRklMTFMuR1JFRU4sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19DT05ORUNUT1JfTElORV9TVFJPS0UsIFNoZWV0c0xpZ2h0LmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpLnN0cm9rZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldFBhbGV0dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhbGV0dGUkMjtcclxuICAgIH1cclxufVxuXG5jb25zdCBWSVZJRF9EQVJLX0ZJTExTID0ge1xyXG4gICAgQkxVRTogJyMwMDgzZmYnLFxyXG4gICAgT1JBTkdFOiAnI2ZmNjYwMCcsXHJcbiAgICBHUkVFTjogJyMwMGFmMDAnLFxyXG4gICAgQ1lBTjogJyMwMGNjZmYnLFxyXG4gICAgWUVMTE9XOiAnI2Y3YzcwMCcsXHJcbiAgICBWSU9MRVQ6ICcjYWMyNmZmJyxcclxuICAgIEdSQVk6ICcjYTdhN2I3JyxcclxuICAgIE1BR0VOVEE6ICcjZTgwMGM1JyxcclxuICAgIEJST1dOOiAnI2I1NDMwMCcsXHJcbiAgICBSRUQ6ICcjZmYwMDAwJyxcclxufTtcclxuY29uc3QgVklWSURfREFSS19TVFJPS0VTID0ge1xyXG4gICAgQkxVRTogJyM2N2I3ZmYnLFxyXG4gICAgT1JBTkdFOiAnI2ZmYzI0ZCcsXHJcbiAgICBHUkVFTjogJyM1Y2M4NmYnLFxyXG4gICAgQ1lBTjogJyM1NGViZmYnLFxyXG4gICAgVklPTEVUOiAnI2MxOGFmZicsXHJcbiAgICBZRUxMT1c6ICcjZmZmNjUzJyxcclxuICAgIEdSQVk6ICcjYWVhZWFlJyxcclxuICAgIE1BR0VOVEE6ICcjZjA3OGQ0JyxcclxuICAgIEJST1dOOiAnI2JhODQzOCcsXHJcbiAgICBSRUQ6ICcjZmY3MjZlJyxcclxufTtcclxuY29uc3QgcGFsZXR0ZSQxID0ge1xyXG4gICAgZmlsbHM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhWSVZJRF9EQVJLX0ZJTExTKSksXHJcbiAgICBzdHJva2VzOiBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoVklWSURfREFSS19TVFJPS0VTKSksXHJcbn07XHJcbmNsYXNzIFZpdmlkRGFyayBleHRlbmRzIERhcmtUaGVtZSB7XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFBvc2l0aXZlQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IFZJVklEX0RBUktfRklMTFMuQkxVRSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuQkxVRSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHROZWdhdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLk9SQU5HRSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuT1JBTkdFLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpbGw6IFZJVklEX0RBUktfRklMTFMuR1JBWSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JBWSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfUE9TSVRJVkVfQ09MT1VSUywgVml2aWREYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX05FR0FUSVZFX0NPTE9VUlMsIFZpdmlkRGFyay5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19UT1RBTF9DT0xPVVJTLCBWaXZpZERhcmsuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXHJcbiAgICAgICAgICAgIFZJVklEX0RBUktfRklMTFMuT1JBTkdFLFxyXG4gICAgICAgICAgICBWSVZJRF9EQVJLX0ZJTExTLllFTExPVyxcclxuICAgICAgICAgICAgVklWSURfREFSS19GSUxMUy5HUkVFTixcclxuICAgICAgICBdKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX0NPTk5FQ1RPUl9MSU5FX1NUUk9LRSwgVml2aWREYXJrLmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpLnN0cm9rZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGdldFBhbGV0dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhbGV0dGUkMTtcclxuICAgIH1cclxufVxuXG5jb25zdCBWSVZJRF9GSUxMUyA9IHtcclxuICAgIEJMVUU6ICcjMDA4M2ZmJyxcclxuICAgIE9SQU5HRTogJyNmZjY2MDAnLFxyXG4gICAgR1JFRU46ICcjMDBhZjAwJyxcclxuICAgIENZQU46ICcjMDBjY2ZmJyxcclxuICAgIFlFTExPVzogJyNmN2M3MDAnLFxyXG4gICAgVklPTEVUOiAnI2FjMjZmZicsXHJcbiAgICBHUkFZOiAnI2E3YTdiNycsXHJcbiAgICBNQUdFTlRBOiAnI2U4MDBjNScsXHJcbiAgICBCUk9XTjogJyNiNTQzMDAnLFxyXG4gICAgUkVEOiAnI2ZmMDAwMCcsXHJcbn07XHJcbmNvbnN0IFZJVklEX1NUUk9LRVMgPSB7XHJcbiAgICBCTFVFOiAnIzBmNjhjMCcsXHJcbiAgICBPUkFOR0U6ICcjZDQ3MTAwJyxcclxuICAgIEdSRUVOOiAnIzAwNzkyMicsXHJcbiAgICBDWUFOOiAnIzAwOWFjMicsXHJcbiAgICBWSU9MRVQ6ICcjYmNhNDAwJyxcclxuICAgIFlFTExPVzogJyM3NTNjYWMnLFxyXG4gICAgR1JBWTogJyM2NDY0NjQnLFxyXG4gICAgTUFHRU5UQTogJyM5YjI2ODUnLFxyXG4gICAgQlJPV046ICcjNmMzYjAwJyxcclxuICAgIFJFRDogJyNjYjAwMjEnLFxyXG59O1xyXG5jb25zdCBwYWxldHRlID0ge1xyXG4gICAgZmlsbHM6IEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhWSVZJRF9GSUxMUykpLFxyXG4gICAgc3Ryb2tlczogQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFZJVklEX1NUUk9LRVMpKSxcclxufTtcclxuY2xhc3MgVml2aWRMaWdodCBleHRlbmRzIENoYXJ0VGhlbWUge1xyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRQb3NpdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBWSVZJRF9GSUxMUy5CTFVFLFxyXG4gICAgICAgICAgICBzdHJva2U6IFZJVklEX1NUUk9LRVMuQkxVRSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHROZWdhdGl2ZUNvbG9ycygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWxsOiBWSVZJRF9GSUxMUy5PUkFOR0UsXHJcbiAgICAgICAgICAgIHN0cm9rZTogVklWSURfU1RST0tFUy5PUkFOR0UsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0VG90YWxDb2xvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsbDogVklWSURfRklMTFMuR1JBWSxcclxuICAgICAgICAgICAgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkdSQVksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlMsIFZpdmlkTGlnaHQuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFBvc2l0aXZlQ29sb3JzKCkpO1xyXG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzLnNldChERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfTkVHQVRJVkVfQ09MT1VSUywgVml2aWRMaWdodC5nZXRXYXRlcmZhbGxTZXJpZXNEZWZhdWx0TmVnYXRpdmVDb2xvcnMoKSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19UT1RBTF9DT0xPVVJTLCBWaXZpZExpZ2h0LmdldFdhdGVyZmFsbFNlcmllc0RlZmF1bHRUb3RhbENvbG9ycygpKTtcclxuICAgICAgICByZXN1bHQucHJvcGVydGllcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xyXG4gICAgICAgICAgICBWSVZJRF9GSUxMUy5PUkFOR0UsXHJcbiAgICAgICAgICAgIFZJVklEX0ZJTExTLllFTExPVyxcclxuICAgICAgICAgICAgVklWSURfRklMTFMuR1JFRU4sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMuc2V0KERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19DT05ORUNUT1JfTElORV9TVFJPS0UsIFZpdmlkTGlnaHQuZ2V0V2F0ZXJmYWxsU2VyaWVzRGVmYXVsdFRvdGFsQ29sb3JzKCkuc3Ryb2tlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZ2V0UGFsZXR0ZSgpIHtcclxuICAgICAgICByZXR1cm4gcGFsZXR0ZTtcclxuICAgIH1cclxufVxuXG5jb25zdCBsaWdodFRoZW1lID0gKCkgPT4gbmV3IENoYXJ0VGhlbWUoKTtcclxuY29uc3QgZGFya1RoZW1lID0gKCkgPT4gbmV3IERhcmtUaGVtZSgpO1xyXG5jb25zdCBsaWdodFRoZW1lcyA9IHtcclxuICAgIHVuZGVmaW5lZDogbGlnaHRUaGVtZSxcclxuICAgIG51bGw6IGxpZ2h0VGhlbWUsXHJcbiAgICAnYWctZGVmYXVsdCc6IGxpZ2h0VGhlbWUsXHJcbiAgICAnYWctc2hlZXRzJzogKCkgPT4gbmV3IFNoZWV0c0xpZ2h0KCksXHJcbiAgICAnYWctcG9seWNocm9tYSc6ICgpID0+IG5ldyBQb2x5Y2hyb21hTGlnaHQoKSxcclxuICAgICdhZy12aXZpZCc6ICgpID0+IG5ldyBWaXZpZExpZ2h0KCksXHJcbiAgICAnYWctbWF0ZXJpYWwnOiAoKSA9PiBuZXcgTWF0ZXJpYWxMaWdodCgpLFxyXG59O1xyXG5jb25zdCBkYXJrVGhlbWVzID0ge1xyXG4gICAgdW5kZWZpbmVkOiBkYXJrVGhlbWUsXHJcbiAgICBudWxsOiBkYXJrVGhlbWUsXHJcbiAgICAnYWctZGVmYXVsdC1kYXJrJzogZGFya1RoZW1lLFxyXG4gICAgJ2FnLXNoZWV0cy1kYXJrJzogKCkgPT4gbmV3IFNoZWV0c0RhcmsoKSxcclxuICAgICdhZy1wb2x5Y2hyb21hLWRhcmsnOiAoKSA9PiBuZXcgUG9seWNocm9tYURhcmsoKSxcclxuICAgICdhZy12aXZpZC1kYXJrJzogKCkgPT4gbmV3IFZpdmlkRGFyaygpLFxyXG4gICAgJ2FnLW1hdGVyaWFsLWRhcmsnOiAoKSA9PiBuZXcgTWF0ZXJpYWxEYXJrKCksXHJcbn07XHJcbmNvbnN0IHRoZW1lcyQxID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXJrVGhlbWVzKSwgbGlnaHRUaGVtZXMpO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNoYXJ0VGhlbWVPYmplY3QodW5rbm93bk9iamVjdCkge1xyXG4gICAgaWYgKHVua25vd25PYmplY3QgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbGlkID0gdHJ1ZTtcclxuICAgIGNvbnN0IHsgYmFzZVRoZW1lLCBwYWxldHRlLCBvdmVycmlkZXMgfSA9IHVua25vd25PYmplY3Q7XHJcbiAgICBpZiAoYmFzZVRoZW1lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGJhc2VUaGVtZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGJhc2VUaGVtZSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBMb2dnZXIud2FybihgaW52YWxpZCB0aGVtZS5iYXNlVGhlbWUgdHlwZSAke3R5cGVvZiBiYXNlVGhlbWV9LCBleHBlY3RlZCAoc3RyaW5nIHwgb2JqZWN0KS5gKTtcclxuICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG92ZXJyaWRlcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvdmVycmlkZXMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgTG9nZ2VyLndhcm4oYGludmFsaWQgdGhlbWUub3ZlcnJpZGVzIHR5cGUgJHt0eXBlb2Ygb3ZlcnJpZGVzfSwgZXhwZWN0ZWQgb2JqZWN0LmApO1xyXG4gICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHBhbGV0dGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKHBhbGV0dGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBmaWxscywgc3Ryb2tlcyB9ID0gcGFsZXR0ZTtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGxzKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLndhcm4oYHRoZW1lLm92ZXJyaWRlcy5maWxscyBtdXN0IGJlIGEgZGVmaW5lZCBhcnJheWApO1xyXG4gICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3Ryb2tlcykpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci53YXJuKGB0aGVtZS5vdmVycmlkZXMuc3Ryb2tlcyBtdXN0IGJlIGEgZGVmaW5lZCBhcnJheWApO1xyXG4gICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhbGV0dGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIExvZ2dlci53YXJuKGBpbnZhbGlkIHRoZW1lLnBhbGV0dGUgdHlwZSAke3R5cGVvZiBwYWxldHRlfSwgZXhwZWN0ZWQgb2JqZWN0LmApO1xyXG4gICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsaWQpIHtcclxuICAgICAgICByZXR1cm4gdW5rbm93bk9iamVjdDtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDaGFydFRoZW1lKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgQ2hhcnRUaGVtZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQ2hhcnRUaGVtZU9iamVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBMb2dnZXIud2FybihgaW52YWxpZCB0aGVtZSB2YWx1ZSB0eXBlICR7dHlwZW9mIHZhbHVlfSwgZXhwZWN0ZWQgb2JqZWN0LmApO1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBnZXRDaGFydFRoZW1lKHVudmFsaWRhdGVkVmFsdWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIC8vIHVudmFsaWRhdGVkVmFsdWUgaXMgZWl0aGVyIGEgYnVpbHQtaW4gdGhlbWUgKGBzdHJpbmcgfCBDaGFydFRoZW1lYCkgb3IgYSB1c2VyIGRlZmluZWRcclxuICAgIC8vIHRoZW1lIChgQWdDaGFydFRoZW1lYCkuIEluIHRoZSBsYXR0ZXIgY2FzZSwgd2UgY2FuJ3QgbWFrZSBhbnkgYXNzdW1wdGlvbiBhYm91dCB0aGVcclxuICAgIC8vIHByb3BlcnR5IHR5cGVzLCBoZW5jZSB3aHkgdGhlIGlucHV0IHBhcmFtZXRlciBpcyBgdW5rbm93bmAuIFRoaXMgYWJub3JtYWwgdmFsaWRhdGlvblxyXG4gICAgLy8gaXMgdGVjaCBkZWJ0OyB0aGUgaWRlYWwgc29sdXRpb24gd291bGQgYmUgdG8gaW50ZWdyYXRlIHVzZXIgdGhlbWVzIHdpdGggdGhlIEBWYWxpZGF0ZVxyXG4gICAgLy8gZGVjb3JhdG9yIGxpa2Ugb3RoZXIgY2hhcnQgb3B0aW9ucy5cclxuICAgIGxldCB2YWx1ZSA9IHZhbGlkYXRlQ2hhcnRUaGVtZSh1bnZhbGlkYXRlZFZhbHVlKTtcclxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENoYXJ0VGhlbWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvY2tUaGVtZSA9IHRoZW1lcyQxW3ZhbHVlXTtcclxuICAgICAgICBpZiAoc3RvY2tUaGVtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvY2tUaGVtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSB0aGVtZSBbJHt2YWx1ZX1dIGlzIGludmFsaWQsIHVzaW5nIFthZy1kZWZhdWx0XSBpbnN0ZWFkLmApO1xyXG4gICAgICAgIHJldHVybiBsaWdodFRoZW1lKCk7XHJcbiAgICB9XHJcbiAgICAvLyBGbGF0dGVuIHJlY3Vyc2l2ZSB0aGVtZXMuXHJcbiAgICBjb25zdCBvdmVycmlkZXMgPSBbXTtcclxuICAgIGxldCBwYWxldHRlO1xyXG4gICAgd2hpbGUgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBvdmVycmlkZXMucHVzaCgoX2EgPSB2YWx1ZS5vdmVycmlkZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KTtcclxuICAgICAgICAvLyBVc2UgZmlyc3QgcGFsZXR0ZSBmb3VuZCwgdGhleSBjYW4ndCBiZSBtZXJnZWQuXHJcbiAgICAgICAgaWYgKHZhbHVlLnBhbGV0dGUgJiYgcGFsZXR0ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhbGV0dGUgPSB2YWx1ZS5wYWxldHRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmJhc2VUaGVtZTtcclxuICAgIH1cclxuICAgIG92ZXJyaWRlcy5yZXZlcnNlKCk7XHJcbiAgICBjb25zdCBmbGF0dGVuZWRUaGVtZSA9IE9iamVjdC5hc3NpZ24oeyBiYXNlVGhlbWU6IHZhbHVlLCBvdmVycmlkZXM6IGpzb25NZXJnZShvdmVycmlkZXMpIH0sIChwYWxldHRlID8geyBwYWxldHRlIH0gOiB7fSkpO1xyXG4gICAgY29uc3QgYmFzZVRoZW1lID0gZmxhdHRlbmVkVGhlbWUuYmFzZVRoZW1lID8gZ2V0Q2hhcnRUaGVtZShmbGF0dGVuZWRUaGVtZS5iYXNlVGhlbWUpIDogbGlnaHRUaGVtZSgpO1xyXG4gICAgcmV0dXJuIG5ldyBiYXNlVGhlbWUuY29uc3RydWN0b3IoZmxhdHRlbmVkVGhlbWUpO1xyXG59XG5cbmZ1bmN0aW9uIHRha2VDb2xvdXJzKGNvbnRleHQsIGNvbG91cnMsIG1heENvdW50KSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAobGV0IGNvdW50ID0gMDsgY291bnQgPCBtYXhDb3VudDsgY291bnQrKykge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGNvbG91cnNbKGNvdW50ICsgY29udGV4dC5jb2xvdXJJbmRleCkgJSBjb2xvdXJzLmxlbmd0aF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBub0RhdGFDbG9uZU1lcmdlT3B0aW9ucyA9IHtcclxuICAgIGF2b2lkRGVlcENsb25lOiBbJ2RhdGEnXSxcclxufTtcclxuZnVuY3Rpb24gZ2V0R2xvYmFsVG9vbHRpcFBvc2l0aW9uT3B0aW9ucyhwb3NpdGlvbikge1xyXG4gICAgLy8gTm90ZTogd2UgZG8gbm90IG5lZWQgdG8gc2hvdyBhIHdhcm5pbmcgbWVzc2FnZSBpZiB0aGUgdmFsaWRhdGlvbiBmYWlscy4gVGhlc2UgZ2xvYmFsIHRvb2x0aXAgb3B0aW9uc1xyXG4gICAgLy8gYXJlIGFscmVhZHkgcHJvY2Vzc2VkIGF0IHRoZSByb290IG9mIHRoZSBjaGFydCBvcHRpb25zLiBMb2dnaW5nIGEgbWVzc2FnZSBoZXJlIHdvdWxkIHRyaWdnZXIgZHVwbGljYXRlXHJcbiAgICAvLyB2YWxpZGF0aW9uIHdhcm5pbmdzLlxyXG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHBvc2l0aW9uICE9PSAnb2JqZWN0JyB8fCBwb3NpdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgdHlwZSwgeE9mZnNldCwgeU9mZnNldCB9ID0gcG9zaXRpb247XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIGNvbnN0IEFnVG9vbHRpcFBvc2l0aW9uVHlwZU1hcCA9IHsgcG9pbnRlcjogdHJ1ZSwgbm9kZTogdHJ1ZSB9O1xyXG4gICAgY29uc3QgaXNUb29sdGlwUG9zaXRpb25UeXBlID0gKHZhbHVlKSA9PiBPYmplY3Qua2V5cyhBZ1Rvb2x0aXBQb3NpdGlvblR5cGVNYXApLmluY2x1ZGVzKHZhbHVlKTtcclxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgaXNUb29sdGlwUG9zaXRpb25UeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgcmVzdWx0LnR5cGUgPSB0eXBlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB4T2Zmc2V0ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oeE9mZnNldCkgJiYgaXNGaW5pdGUoeE9mZnNldCkpIHtcclxuICAgICAgICByZXN1bHQueE9mZnNldCA9IHhPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHlPZmZzZXQgPT09ICdudW1iZXInICYmICFpc05hTih5T2Zmc2V0KSAmJiBpc0Zpbml0ZSh5T2Zmc2V0KSkge1xyXG4gICAgICAgIHJlc3VsdC55T2Zmc2V0ID0geU9mZnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gcHJlcGFyZU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgc2FuaXR5Q2hlY2tPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgLy8gRGV0ZXJtaW5lIHR5cGUgYW5kIGVuc3VyZSBpdCdzIGV4cGxpY2l0IGluIHRoZSBvcHRpb25zIGNvbmZpZy5cclxuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zVHlwZShvcHRpb25zKTtcclxuICAgIGNvbnN0IGdsb2JhbFRvb2x0aXBQb3NpdGlvbk9wdGlvbnMgPSBnZXRHbG9iYWxUb29sdGlwUG9zaXRpb25PcHRpb25zKChfYSA9IG9wdGlvbnMudG9vbHRpcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc2l0aW9uKTtcclxuICAgIGNvbnN0IGNoZWNrU2VyaWVzVHlwZSA9ICh0eXBlKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGUgIT0gbnVsbCAmJiAhKGlzU2VyaWVzT3B0aW9uVHlwZSh0eXBlKSB8fCBpc0VudGVycHJpc2VTZXJpZXNUeXBlKHR5cGUpIHx8IGdldFNlcmllc0RlZmF1bHRzKHR5cGUpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVua25vd24gc2VyaWVzIHR5cGU6ICR7dHlwZX07IGV4cGVjdGVkIG9uZSBvZjogJHtDSEFSVF9UWVBFUy5zZXJpZXNUeXBlc31gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY2hlY2tTZXJpZXNUeXBlKHR5cGUpO1xyXG4gICAgZm9yIChjb25zdCB7IHR5cGU6IHNlcmllc1R5cGUgfSBvZiAoX2IgPSBvcHRpb25zLnNlcmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcclxuICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PSBudWxsKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjaGVja1Nlcmllc1R5cGUoc2VyaWVzVHlwZSk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zID0gdmFsaWRhdGVTb2xvU2VyaWVzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdHlwZSB9KSk7XHJcbiAgICBsZXQgZGVmYXVsdFNlcmllc1R5cGUgPSAnbGluZSc7XHJcbiAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xyXG4gICAgICAgIGRlZmF1bHRTZXJpZXNUeXBlID0gJ2xpbmUnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xyXG4gICAgICAgIGRlZmF1bHRTZXJpZXNUeXBlID0gJ3RyZWVtYXAnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgZGVmYXVsdFNlcmllc1R5cGUgPSAncGllJztcclxuICAgIH1cclxuICAgIGxldCBkZWZhdWx0T3ZlcnJpZGVzID0gZ2V0U2VyaWVzRGVmYXVsdHModHlwZSk7XHJcbiAgICBpZiAoaXNEZWZhdWx0QXhpc1N3YXBOZWVkZWQob3B0aW9ucykpIHtcclxuICAgICAgICBkZWZhdWx0T3ZlcnJpZGVzID0gc3dhcEF4ZXMoZGVmYXVsdE92ZXJyaWRlcyk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0T3ZlcnJpZGVzID0gZXhlY3V0ZUN1c3RvbURlZmF1bHRzRnVuY3Rpb25zKG9wdGlvbnMsIGRlZmF1bHRPdmVycmlkZXMpO1xyXG4gICAgY29uc3QgY29uZmxpY3RPdmVycmlkZXMgPSByZXNvbHZlTW9kdWxlQ29uZmxpY3RzKG9wdGlvbnMpO1xyXG4gICAgcmVtb3ZlRGlzYWJsZWRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgY29uc3QgeyBjb250ZXh0LCBtZXJnZWRPcHRpb25zLCBheGVzVGhlbWVzLCBzZXJpZXNUaGVtZXMsIHRoZW1lIH0gPSBwcmVwYXJlTWFpbk9wdGlvbnMoZGVmYXVsdE92ZXJyaWRlcywgb3B0aW9ucywgY29uZmxpY3RPdmVycmlkZXMpO1xyXG4gICAgLy8gU3BlY2lhbCBjYXNlcyB3aGVyZSB3ZSBoYXZlIGFycmF5cyBvZiBlbGVtZW50cyB3aGljaCBuZWVkIHRoZWlyIG93biBkZWZhdWx0cy5cclxuICAgIC8vIEFwcGx5IHNlcmllcyB0aGVtZXMgYmVmb3JlIGNhbGxpbmcgcHJvY2Vzc1Nlcmllc09wdGlvbnMoKSBhcyBpdCByZWR1Y2VzIGFuZCByZW5hbWVzIHNvbWVcclxuICAgIC8vIHByb3BlcnRpZXMsIGFuZCBpbiB0aGF0IGNhc2UgdGhlbiBjYW5ub3QgY29ycmVjdGx5IGhhdmUgdGhlbWVzIGFwcGxpZWQuXHJcbiAgICBtZXJnZWRPcHRpb25zLnNlcmllcyA9IHByb2Nlc3NTZXJpZXNPcHRpb25zKG1lcmdlZE9wdGlvbnMsICgoX2MgPSBtZXJnZWRPcHRpb25zLnNlcmllcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pLm1hcCgocykgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB0eXBlID0gKF9hID0gcy50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0U2VyaWVzVHlwZTtcclxuICAgICAgICBjb25zdCBtZXJnZWRTZXJpZXMgPSBtZXJnZVNlcmllc09wdGlvbnMocywgdHlwZSwgc2VyaWVzVGhlbWVzLCBnbG9iYWxUb29sdGlwUG9zaXRpb25PcHRpb25zKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3BpZScpIHtcclxuICAgICAgICAgICAgcHJlcGFyZVBpZU9wdGlvbnMoc2VyaWVzVGhlbWVzLnBpZSwgcywgbWVyZ2VkU2VyaWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlZFNlcmllcztcclxuICAgIH0pKVxyXG4gICAgICAgIC5tYXAoKHMpID0+IHByZXBhcmVTZXJpZXMoY29udGV4dCwgcykpXHJcbiAgICAgICAgLm1hcCgocykgPT4gdGhlbWUudGVtcGxhdGVUaGVtZShzKSk7XHJcbiAgICBjb25zdCBjaGVja0F4aXNUeXBlID0gKHR5cGUpID0+IHtcclxuICAgICAgICBjb25zdCBpc0F4aXNUeXBlID0gaXNBeGlzT3B0aW9uVHlwZSh0eXBlKTtcclxuICAgICAgICBpZiAoIWlzQXhpc1R5cGUpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGB1bmtub3duIGF4aXMgdHlwZTogJHt0eXBlfTsgZXhwZWN0ZWQgb25lIG9mOiAke0FYSVNfVFlQRVMuYXhlc1R5cGVzfSwgaWdub3JpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0F4aXNUeXBlO1xyXG4gICAgfTtcclxuICAgIGlmICgnYXhlcycgaW4gbWVyZ2VkT3B0aW9ucykge1xyXG4gICAgICAgIGxldCB2YWxpZEF4ZXNUeXBlcyA9IHRydWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IHR5cGU6IGF4aXNUeXBlIH0gb2YgKF9kID0gbWVyZ2VkT3B0aW9ucy5heGVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSkge1xyXG4gICAgICAgICAgICB2YWxpZEF4ZXNUeXBlcyAmJiAodmFsaWRBeGVzVHlwZXMgPSBjaGVja0F4aXNUeXBlKGF4aXNUeXBlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF4aXNTb3VyY2UgPSB2YWxpZEF4ZXNUeXBlcyA/IG1lcmdlZE9wdGlvbnMuYXhlcyA6IGRlZmF1bHRPdmVycmlkZXMuYXhlcztcclxuICAgICAgICBtZXJnZWRPcHRpb25zLmF4ZXMgPSBheGlzU291cmNlID09PSBudWxsIHx8IGF4aXNTb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4aXNTb3VyY2UubWFwKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGF4aXNUeXBlID0gYXhpcy50eXBlO1xyXG4gICAgICAgICAgICBsZXQgYXhpc0RlZmF1bHRzO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRBeGVzVHlwZXMpIHtcclxuICAgICAgICAgICAgICAgIGF4aXNEZWZhdWx0cyA9IChfYSA9IGRlZmF1bHRPdmVycmlkZXMuYXhlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKHsgdHlwZSB9KSA9PiB0eXBlID09PSBheGlzVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYXhlc1RoZW1lID0ganNvbk1lcmdlKFtcclxuICAgICAgICAgICAgICAgIChfYiA9IGF4ZXNUaGVtZXNbYXhpc1R5cGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcclxuICAgICAgICAgICAgICAgIChfZSA9IChfYyA9IGF4ZXNUaGVtZXNbYXhpc1R5cGVdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbKF9kID0gYXhpcy5wb3NpdGlvbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJ3Vua25vd24nXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge30sXHJcbiAgICAgICAgICAgICAgICBheGlzRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJlcGFyZUF4aXMoYXhpcywgYXhlc1RoZW1lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcmVwYXJlTGVnZW5kRW5hYmxlZE9wdGlvbihvcHRpb25zLCBtZXJnZWRPcHRpb25zKTtcclxuICAgIH1cclxuICAgIHByZXBhcmVFbmFibGVkT3B0aW9ucyhvcHRpb25zLCBtZXJnZWRPcHRpb25zKTtcclxuICAgIHJldHVybiBtZXJnZWRPcHRpb25zO1xyXG59XHJcbmZ1bmN0aW9uIHNhbml0eUNoZWNrT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBjb25zdCBkZXByZWNhdGVkQXJyYXlQcm9wcyA9IHtcclxuICAgICAgICB5S2V5czogJ3lLZXknLFxyXG4gICAgICAgIHlOYW1lczogJ3lOYW1lJyxcclxuICAgIH07XHJcbiAgICBPYmplY3QuZW50cmllcyhkZXByZWNhdGVkQXJyYXlQcm9wcykuZm9yRWFjaCgoW29sZFByb3AsIG5ld1Byb3BdKSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSBvcHRpb25zLnNlcmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKHMpID0+IHNbb2xkUHJvcF0gIT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKGBQcm9wZXJ0eSBbc2VyaWVzLiR7b2xkUHJvcH1dIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgW3Nlcmllcy4ke25ld1Byb3B9XSBhbmQgbXVsdGlwbGUgc2VyaWVzIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzU29sb1NlcmllcyhvcHRpb25zKSB7XHJcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGlzU29sb1NlcmllcyhzZXJpZXMudHlwZSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlU29sb1NlcmllcyhvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy5zZXJpZXMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNlcmllcy5sZW5ndGggPD0gMSB8fCAhaGFzU29sb1NlcmllcyhvcHRpb25zLnNlcmllcykpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSBmaXJzdCBzZXJpZXMgaXMgYSBzb2xvLXNlcmllcywgcmVtb3ZlIGFsbCB0cmFpbGluZyBzZXJpZXMuXHJcbiAgICAvLyBJZiB0aGUgZnJpc3Qgc2VyaWVzIGlzIG5vdCBhIHNvbG8tc2VyaWVzLCByZW1vdmUgYWxsIHNvbG8tc2VyaWVzLlxyXG4gICAgbGV0IHNlcmllcyA9IFsuLi5vcHRpb25zLnNlcmllc107XHJcbiAgICBpZiAoaXNTb2xvU2VyaWVzKHNlcmllc1swXS50eXBlKSkge1xyXG4gICAgICAgIExvZ2dlci53YXJuKGBzZXJpZXNbMF0gb2YgdHlwZSAnJHtzZXJpZXNbMF0udHlwZX0nIGlzIGluY29tcGF0aWJsZSB3aXRoIG90aGVyIHNlcmllcyB0eXBlcy4gT25seSBwcm9jZXNzaW5nIHNlcmllc1swXWApO1xyXG4gICAgICAgIHNlcmllcyA9IHNlcmllcy5zbGljZSgwLCAxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHJlamVjdHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoc2VyaWVzLmZpbHRlcigocykgPT4gaXNTb2xvU2VyaWVzKHMudHlwZSkpLm1hcCgocykgPT4gcy50eXBlKSkpO1xyXG4gICAgICAgIExvZ2dlci53YXJuT25jZShgVW5hYmxlIHRvIG1peCB0aGVzZSBzZXJpZXMgdHlwZXMgd2l0aCB0aGUgbGVhZCBzZXJpZXMgdHlwZTogJHtyZWplY3RzfWApO1xyXG4gICAgICAgIHNlcmllcyA9IHNlcmllcy5maWx0ZXIoKHMpID0+ICFpc1NvbG9TZXJpZXMocy50eXBlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzZXJpZXMgfSk7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VTZXJpZXNPcHRpb25zKHNlcmllcywgdHlwZSwgc2VyaWVzVGhlbWVzLCBnbG9iYWxUb29sdGlwUG9zaXRpb25PcHRpb25zKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgbWVyZ2VkVG9vbHRpcFBvc2l0aW9uID0ganNvbk1lcmdlKFtPYmplY3QuYXNzaWduKHt9LCBnbG9iYWxUb29sdGlwUG9zaXRpb25PcHRpb25zKSwgKF9hID0gc2VyaWVzLnRvb2x0aXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbl0sIG5vRGF0YUNsb25lTWVyZ2VPcHRpb25zKTtcclxuICAgIHJldHVybiBqc29uTWVyZ2UoW1xyXG4gICAgICAgIChfYiA9IHNlcmllc1RoZW1lc1t0eXBlXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJpZXMpLCB7IHR5cGUsIHRvb2x0aXA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzLnRvb2x0aXApLCB7IHBvc2l0aW9uOiBtZXJnZWRUb29sdGlwUG9zaXRpb24gfSkgfSksXHJcbiAgICBdLCBub0RhdGFDbG9uZU1lcmdlT3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcHJlcGFyZU1haW5PcHRpb25zKGRlZmF1bHRPdmVycmlkZXMsIG9wdGlvbnMsIGNvbmZsaWN0T3ZlcnJpZGVzKSB7XHJcbiAgICBjb25zdCB7IHRoZW1lLCBjbGVhbmVkVGhlbWUsIGF4ZXNUaGVtZXMsIHNlcmllc1RoZW1lcywgdXNlclBhbGV0dGUgfSA9IHByZXBhcmVUaGVtZShvcHRpb25zKTtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7IGNvbG91ckluZGV4OiAwLCBwYWxldHRlOiB0aGVtZS5wYWxldHRlLCB1c2VyUGFsZXR0ZSwgdGhlbWUgfTtcclxuICAgIGRlZmF1bHRPdmVycmlkZXMgPSB0aGVtZS50ZW1wbGF0ZVRoZW1lKGRlZmF1bHRPdmVycmlkZXMpO1xyXG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IGpzb25NZXJnZShbZGVmYXVsdE92ZXJyaWRlcywgY2xlYW5lZFRoZW1lLCBvcHRpb25zLCBjb25mbGljdE92ZXJyaWRlc10sIG5vRGF0YUNsb25lTWVyZ2VPcHRpb25zKTtcclxuICAgIGlmICghZW50ZXJwcmlzZU1vZHVsZS5pc0VudGVycHJpc2UpIHtcclxuICAgICAgICByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnMobWVyZ2VkT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb250ZXh0LCBtZXJnZWRPcHRpb25zLCBheGVzVGhlbWVzLCBzZXJpZXNUaGVtZXMsIHRoZW1lIH07XHJcbn1cclxuZnVuY3Rpb24gcHJlcGFyZVRoZW1lKG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHRoZW1lID0gZ2V0Q2hhcnRUaGVtZShvcHRpb25zLnRoZW1lKTtcclxuICAgIGNvbnN0IHRoZW1lQ29uZmlnID0gdGhlbWUuY29uZmlnW29wdGlvbnNUeXBlKG9wdGlvbnMpXTtcclxuICAgIGNvbnN0IHNlcmllc1RoZW1lcyA9IE9iamVjdC5lbnRyaWVzKHRoZW1lLmNvbmZpZykucmVkdWNlKChyZXN1bHQsIFtzZXJpZXNUeXBlLCB7IHNlcmllcyB9XSkgPT4ge1xyXG4gICAgICAgIHJlc3VsdFtzZXJpZXNUeXBlXSA9IHNlcmllcztcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSwge30pO1xyXG4gICAgY29uc3QgdXNlclRoZW1lID0gb3B0aW9ucy50aGVtZTtcclxuICAgIGNvbnN0IHVzZXJQYWxldHRlID0gdHlwZW9mIHVzZXJUaGVtZSA9PT0gJ29iamVjdCcgJiYgdXNlclRoZW1lLnBhbGV0dGUgPyB1c2VyVGhlbWUucGFsZXR0ZSA6IG51bGw7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRoZW1lLFxyXG4gICAgICAgIGF4ZXNUaGVtZXM6IChfYSA9IHRoZW1lQ29uZmlnID09PSBudWxsIHx8IHRoZW1lQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGVtZUNvbmZpZ1snYXhlcyddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSxcclxuICAgICAgICBzZXJpZXNUaGVtZXM6IHNlcmllc1RoZW1lcyxcclxuICAgICAgICBjbGVhbmVkVGhlbWU6IGpzb25NZXJnZShbdGhlbWVDb25maWcgIT09IG51bGwgJiYgdGhlbWVDb25maWcgIT09IHZvaWQgMCA/IHRoZW1lQ29uZmlnIDoge30sIHsgYXhlczogREVMRVRFLCBzZXJpZXM6IERFTEVURSB9XSksXHJcbiAgICAgICAgdXNlclBhbGV0dGUsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVTZXJpZXMoY29udGV4dCwgaW5wdXQsIC4uLmRlZmF1bHRzKSB7XHJcbiAgICBjb25zdCBwYWxldHRlT3B0aW9ucyA9IGNhbGN1bGF0ZVNlcmllc1BhbGV0dGUoY29udGV4dCwgaW5wdXQpO1xyXG4gICAgLy8gUGFydCBvZiB0aGUgb3B0aW9ucyBpbnRlcmZhY2UsIGJ1dCBub3QgZGlyZWN0bHkgY29uc3VtZWQgYnkgdGhlIHNlcmllcyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICBjb25zdCByZW1vdmVPcHRpb25zID0geyBzdGFja2VkOiBERUxFVEUsIGdyb3VwZWQ6IERFTEVURSB9O1xyXG4gICAgcmV0dXJuIGpzb25NZXJnZShbLi4uZGVmYXVsdHMsIHBhbGV0dGVPcHRpb25zLCBpbnB1dCwgcmVtb3ZlT3B0aW9uc10sIG5vRGF0YUNsb25lTWVyZ2VPcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVTZXJpZXNQYWxldHRlKGNvbnRleHQsIGlucHV0KSB7XHJcbiAgICBjb25zdCBwYWxldHRlRmFjdG9yeSA9IGdldFNlcmllc1BhbGV0dGVGYWN0b3J5KGlucHV0LnR5cGUpO1xyXG4gICAgaWYgKCFwYWxldHRlRmFjdG9yeSkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcGFsZXR0ZTogeyBmaWxscywgc3Ryb2tlcyB9LCB1c2VyUGFsZXR0ZSwgdGhlbWUsIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgY29sb3JzQ291bnQgPSBNYXRoLm1heChmaWxscy5sZW5ndGgsIHN0cm9rZXMubGVuZ3RoKTtcclxuICAgIHJldHVybiBwYWxldHRlRmFjdG9yeSh7XHJcbiAgICAgICAgdXNlclBhbGV0dGUsXHJcbiAgICAgICAgdGhlbWVUZW1wbGF0ZVBhcmFtZXRlcnM6IHRoZW1lLmdldFRlbXBsYXRlUGFyYW1ldGVycygpLFxyXG4gICAgICAgIGNvbG9yc0NvdW50LFxyXG4gICAgICAgIHRha2VDb2xvcnM6IChjb3VudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvcnMgPSB7XHJcbiAgICAgICAgICAgICAgICBmaWxsczogdGFrZUNvbG91cnMoY29udGV4dCwgZmlsbHMsIGNvdW50KSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZXM6IHRha2VDb2xvdXJzKGNvbnRleHQsIHN0cm9rZXMsIGNvdW50KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29udGV4dC5jb2xvdXJJbmRleCArPSBjb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9ycztcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcHJlcGFyZUF4aXMoYXhpcywgYXhpc1RoZW1lKSB7XHJcbiAgICAvLyBSZW1vdmUgcmVkdW5kYW50IHRoZW1lIG92ZXJsb2FkIGtleXMuXHJcbiAgICBjb25zdCByZW1vdmVPcHRpb25zID0geyB0b3A6IERFTEVURSwgYm90dG9tOiBERUxFVEUsIGxlZnQ6IERFTEVURSwgcmlnaHQ6IERFTEVURSB9O1xyXG4gICAgLy8gU3BlY2lhbCBjcm9zcyBsaW5lcyBjYXNlIHdoZXJlIHdlIGhhdmUgYW4gYXJyYXkgb2YgY3Jvc3MgbGluZSBlbGVtZW50cyB3aGljaCBuZWVkIHRoZWlyIG93biBkZWZhdWx0cy5cclxuICAgIGlmIChheGlzLmNyb3NzTGluZXMpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXhpcy5jcm9zc0xpbmVzKSkge1xyXG4gICAgICAgICAgICBMb2dnZXIud2FybignYXhpc1tdLmNyb3NzTGluZXMgc2hvdWxkIGJlIGFuIGFycmF5LicpO1xyXG4gICAgICAgICAgICBheGlzLmNyb3NzTGluZXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBjcm9zc0xpbmVzOiBjcm9zc0xpbmVzVGhlbWUgfSA9IGF4aXNUaGVtZTtcclxuICAgICAgICBheGlzLmNyb3NzTGluZXMgPSBheGlzLmNyb3NzTGluZXMubWFwKChjcm9zc0xpbmUpID0+IGpzb25NZXJnZShbY3Jvc3NMaW5lc1RoZW1lLCBjcm9zc0xpbmVdKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjbGVhblRoZW1lID0geyBjcm9zc0xpbmVzOiBERUxFVEUgfTtcclxuICAgIHJldHVybiBqc29uTWVyZ2UoW2F4aXNUaGVtZSwgY2xlYW5UaGVtZSwgYXhpcywgcmVtb3ZlT3B0aW9uc10sIG5vRGF0YUNsb25lTWVyZ2VPcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVEaXNhYmxlZE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgLy8gUmVtb3ZlIGNvbmZpZ3VyYXRpb25zIGZyb20gYWxsIG9wdGlvbiBvYmplY3RzIHdpdGggYSBgZmFsc2VgIHZhbHVlIGZvciB0aGUgYGVuYWJsZWRgIHByb3BlcnR5LlxyXG4gICAganNvbldhbGsob3B0aW9ucywgKF8sIHZpc2l0aW5nVXNlck9wdHMpID0+IHtcclxuICAgICAgICBpZiAodmlzaXRpbmdVc2VyT3B0cy5lbmFibGVkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2aXNpdGluZ1VzZXJPcHRzKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdlbmFibGVkJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdmlzaXRpbmdVc2VyT3B0c1trZXldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCB7IHNraXA6IFsnZGF0YScsICd0aGVtZSddIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVMZWdlbmRFbmFibGVkT3B0aW9uKG9wdGlvbnMsIG1lcmdlZE9wdGlvbnMpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIC8vIERpc2FibGUgbGVnZW5kIGJ5IGRlZmF1bHQgZm9yIHNpbmdsZSBzZXJpZXMgY2FydGVzaWFuIGNoYXJ0c1xyXG4gICAgaWYgKCgoX2EgPSBvcHRpb25zLmxlZ2VuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuYWJsZWQpICE9PSB1bmRlZmluZWQgfHwgKChfYiA9IG1lcmdlZE9wdGlvbnMubGVnZW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZW5hYmxlZCkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIChfYyA9IG1lcmdlZE9wdGlvbnMubGVnZW5kKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAobWVyZ2VkT3B0aW9ucy5sZWdlbmQgPSB7fSk7XHJcbiAgICBpZiAoKChfZCA9IG9wdGlvbnMuc2VyaWVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSkubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIG1lcmdlZE9wdGlvbnMubGVnZW5kLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIG1lcmdlZE9wdGlvbnMubGVnZW5kLmVuYWJsZWQgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlRW5hYmxlZE9wdGlvbnMob3B0aW9ucywgbWVyZ2VkT3B0aW9ucykge1xyXG4gICAgLy8gU2V0IGBlbmFibGVkOiB0cnVlYCBmb3IgYWxsIG9wdGlvbiBvYmplY3RzIHdoZXJlIHRoZSB1c2VyIGhhcyBwcm92aWRlZCB2YWx1ZXMuXHJcbiAgICBqc29uV2FsayhvcHRpb25zLCAoXywgdmlzaXRpbmdVc2VyT3B0cywgdmlzaXRpbmdNZXJnZWRPcHRzKSA9PiB7XHJcbiAgICAgICAgaWYgKCF2aXNpdGluZ01lcmdlZE9wdHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCB7IF9lbmFibGVkRnJvbVRoZW1lIH0gPSB2aXNpdGluZ01lcmdlZE9wdHM7XHJcbiAgICAgICAgaWYgKF9lbmFibGVkRnJvbVRoZW1lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGFwcGx5IHNwZWNpYWwgaGFuZGxpbmcsIGJhc2UgZW5hYmxlbWVudCBvbiB0aGVtZS5cclxuICAgICAgICAgICAgZGVsZXRlIHZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoJ2VuYWJsZWQnIGluIHZpc2l0aW5nTWVyZ2VkT3B0cykpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoX2VuYWJsZWRGcm9tVGhlbWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAodmlzaXRpbmdVc2VyT3B0cy5lbmFibGVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgdmlzaXRpbmdNZXJnZWRPcHRzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHsgc2tpcDogWydkYXRhJywgJ3RoZW1lJ10gfSwgbWVyZ2VkT3B0aW9ucyk7XHJcbiAgICAvLyBDbGVhbnVwIGFueSBzcGVjaWFsIHByb3BlcnRpZXMuXHJcbiAgICBqc29uV2FsayhtZXJnZWRPcHRpb25zLCAoXywgdmlzaXRpbmdNZXJnZWRPcHRzKSA9PiB7XHJcbiAgICAgICAgaWYgKHZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBhcHBseSBzcGVjaWFsIGhhbmRsaW5nLCBiYXNlIGVuYWJsZW1lbnQgb24gdGhlbWUuXHJcbiAgICAgICAgICAgIGRlbGV0ZSB2aXNpdGluZ01lcmdlZE9wdHMuX2VuYWJsZWRGcm9tVGhlbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgeyBza2lwOiBbJ2RhdGEnLCAndGhlbWUnXSB9KTtcclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlUGllT3B0aW9ucyhwaWVTZXJpZXNUaGVtZSwgc2VyaWVzT3B0aW9ucywgbWVyZ2VkU2VyaWVzKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZXJpZXNPcHRpb25zLmlubmVyTGFiZWxzKSkge1xyXG4gICAgICAgIG1lcmdlZFNlcmllcy5pbm5lckxhYmVscyA9IHNlcmllc09wdGlvbnMuaW5uZXJMYWJlbHMubWFwKChsbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ganNvbk1lcmdlKFtwaWVTZXJpZXNUaGVtZS5pbm5lckxhYmVscywgbG5dKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1lcmdlZFNlcmllcy5pbm5lckxhYmVscyA9IERFTEVURTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQb2xhckNoYXJ0IGV4dGVuZHMgQ2hhcnQge1xyXG4gICAgY29uc3RydWN0b3Ioc3BlY2lhbE92ZXJyaWRlcywgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgc3VwZXIoc3BlY2lhbE92ZXJyaWRlcywgcmVzb3VyY2VzKTtcclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZyg0MCk7XHJcbiAgICAgICAgdGhpcy5heGlzR3JvdXAuekluZGV4ID0gTGF5ZXJzLkFYSVNfRk9SRUdST1VORF9aSU5ERVg7XHJcbiAgICB9XHJcbiAgICBwZXJmb3JtTGF5b3V0KCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBwZXJmb3JtTGF5b3V0OiB7IGdldDogKCkgPT4gc3VwZXIucGVyZm9ybUxheW91dCB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hyaW5rUmVjdCA9IHlpZWxkIF9zdXBlci5wZXJmb3JtTGF5b3V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxTZXJpZXNSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVTZXJpZXNSZWN0KHNocmlua1JlY3QpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbXB1dGVDaXJjbGUoc2hyaW5rUmVjdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiBheGlzLnVwZGF0ZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5ob3ZlclJlY3QgPSBzaHJpbmtSZWN0O1xyXG4gICAgICAgICAgICB0aGlzLmxheW91dFNlcnZpY2UuZGlzcGF0Y2hMYXlvdXRDb21wbGV0ZSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGF5b3V0LWNvbXBsZXRlJyxcclxuICAgICAgICAgICAgICAgIGNoYXJ0OiB7IHdpZHRoOiB0aGlzLnNjZW5lLndpZHRoLCBoZWlnaHQ6IHRoaXMuc2NlbmUuaGVpZ2h0IH0sXHJcbiAgICAgICAgICAgICAgICBjbGlwU2VyaWVzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNlcmllczogeyByZWN0OiBmdWxsU2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogc2hyaW5rUmVjdCwgdmlzaWJsZTogdHJ1ZSB9LFxyXG4gICAgICAgICAgICAgICAgYXhlczogW10sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hyaW5rUmVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUF4ZXMoY3gsIGN5LCByYWRpdXMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlQXhpcyA9IHRoaXMuYXhlcy5maW5kKChheGlzKSA9PiBheGlzLmRpcmVjdGlvbiA9PT0gQ2hhcnRBeGlzRGlyZWN0aW9uLlgpO1xyXG4gICAgICAgIGNvbnN0IHJhZGl1c0F4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IENoYXJ0QXhpc0RpcmVjdGlvbi5ZKTtcclxuICAgICAgICBpZiAoIShhbmdsZUF4aXMgaW5zdGFuY2VvZiBQb2xhckF4aXMpIHx8ICEocmFkaXVzQXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhbmdsZVNjYWxlID0gYW5nbGVBeGlzLnNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlcyA9IChfYSA9IGFuZ2xlU2NhbGUudGlja3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFuZ2xlU2NhbGUpLm1hcCgodmFsdWUpID0+IGFuZ2xlU2NhbGUuY29udmVydCh2YWx1ZSkpO1xyXG4gICAgICAgIGNvbnN0IGlubmVyUmFkaXVzUmF0aW8gPSByYWRpdXNBeGlzLmlubmVyUmFkaXVzUmF0aW87XHJcbiAgICAgICAgYW5nbGVBeGlzLmlubmVyUmFkaXVzUmF0aW8gPSBpbm5lclJhZGl1c1JhdGlvO1xyXG4gICAgICAgIChfYiA9IGFuZ2xlQXhpcy5jb21wdXRlUmFuZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGFuZ2xlQXhpcyk7XHJcbiAgICAgICAgYW5nbGVBeGlzLmdyaWRMZW5ndGggPSByYWRpdXM7XHJcbiAgICAgICAgcmFkaXVzQXhpcy5ncmlkQW5nbGVzID0gYW5nbGVzO1xyXG4gICAgICAgIHJhZGl1c0F4aXMuZ3JpZFJhbmdlID0gYW5nbGVBeGlzLnJhbmdlO1xyXG4gICAgICAgIHJhZGl1c0F4aXMucmFuZ2UgPSBbcmFkaXVzLCByYWRpdXMgKiBpbm5lclJhZGl1c1JhdGlvXTtcclxuICAgICAgICBbYW5nbGVBeGlzLCByYWRpdXNBeGlzXS5mb3JFYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGF4aXMudHJhbnNsYXRpb24ueCA9IGN4O1xyXG4gICAgICAgICAgICBheGlzLnRyYW5zbGF0aW9uLnkgPSBjeTtcclxuICAgICAgICAgICAgYXhpcy5jYWxjdWxhdGVMYXlvdXQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbXB1dGVTZXJpZXNSZWN0KHNocmlua1JlY3QpIHtcclxuICAgICAgICBjb25zdCB7IHNlcmllc0FyZWE6IHsgcGFkZGluZyB9LCB9ID0gdGhpcztcclxuICAgICAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmxlZnQsICdsZWZ0Jyk7XHJcbiAgICAgICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy50b3AsICd0b3AnKTtcclxuICAgICAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnJpZ2h0LCAncmlnaHQnKTtcclxuICAgICAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmJvdHRvbSwgJ2JvdHRvbScpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNocmlua1JlY3Q7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25SZWN0ID0gc2hyaW5rUmVjdDtcclxuICAgIH1cclxuICAgIGNvbXB1dGVDaXJjbGUoc2VyaWVzQm94KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9sYXJTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHNlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcyBpbnN0YW5jZW9mIFBvbGFyU2VyaWVzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcG9sYXJBeGVzID0gdGhpcy5heGVzLmZpbHRlcigoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXMgaW5zdGFuY2VvZiBQb2xhckF4aXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBzZXRTZXJpZXNDaXJjbGUgPSAoY3gsIGN5LCByKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF4ZXMoY3gsIGN5LCByKTtcclxuICAgICAgICAgICAgICAgIHBvbGFyU2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5jZW50ZXJYID0gY3g7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmNlbnRlclkgPSBjeTtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXMucmFkaXVzID0gcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGllU2VyaWVzID0gcG9sYXJTZXJpZXMuZmlsdGVyKChzKSA9PiBzIGluc3RhbmNlb2YgUGllU2VyaWVzKTtcclxuICAgICAgICAgICAgICAgIGlmIChwaWVTZXJpZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyUmFkaWkgPSBwaWVTZXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gc2VyaWVzLmdldElubmVyUmFkaXVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNlcmllcywgaW5uZXJSYWRpdXMgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pbm5lclJhZGl1cyAtIGIuaW5uZXJSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyUmFkaWlbaW5uZXJSYWRpaS5sZW5ndGggLSAxXS5zZXJpZXMuc3Vycm91bmRpbmdSYWRpdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lclJhZGlpLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lclJhZGlpW2ldLnNlcmllcy5zdXJyb3VuZGluZ1JhZGl1cyA9IGlubmVyUmFkaWlbaSArIDFdLmlubmVyUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNlcmllc0JveC54ICsgc2VyaWVzQm94LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IHNlcmllc0JveC55ICsgc2VyaWVzQm94LmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSYWRpdXMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZXJpZXNCb3gud2lkdGgsIHNlcmllc0JveC5oZWlnaHQpIC8gMik7XHJcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSBpbml0aWFsUmFkaXVzO1xyXG4gICAgICAgICAgICBzZXRTZXJpZXNDaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKTtcclxuICAgICAgICAgICAgY29uc3Qgc2hha2UgPSAoeyBoaWRlV2hlbk5lY2Vzc2FyeSA9IGZhbHNlIH0gPSB7fSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxCb3hlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZXJpZXMgb2YgWy4uLnBvbGFyQXhlcywgLi4ucG9sYXJTZXJpZXNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94ID0geWllbGQgc2VyaWVzLmNvbXB1dGVMYWJlbHNCQm94KHsgaGlkZVdoZW5OZWNlc3NhcnkgfSwgc2VyaWVzQm94KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm94KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQm94ZXMucHVzaChib3gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbEJveGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFNlcmllc0NpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBpbml0aWFsUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbEJveCA9IEJCb3gubWVyZ2UobGFiZWxCb3hlcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWZpbmVkID0gdGhpcy5yZWZpbmVDaXJjbGUobGFiZWxCb3gsIHJhZGl1cywgc2VyaWVzQm94KTtcclxuICAgICAgICAgICAgICAgIHNldFNlcmllc0NpcmNsZShyZWZpbmVkLmNlbnRlclgsIHJlZmluZWQuY2VudGVyWSwgcmVmaW5lZC5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZmluZWQucmFkaXVzID09PSByYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByYWRpdXMgPSByZWZpbmVkLnJhZGl1cztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHlpZWxkIHNoYWtlKCk7IC8vIEluaXRpYWwgYXR0ZW1wdFxyXG4gICAgICAgICAgICB5aWVsZCBzaGFrZSgpOyAvLyBQcmVjaXNlIGF0dGVtcHRcclxuICAgICAgICAgICAgeWllbGQgc2hha2UoKTsgLy8gSnVzdCBpbiBjYXNlXHJcbiAgICAgICAgICAgIHlpZWxkIHNoYWtlKHsgaGlkZVdoZW5OZWNlc3Nhcnk6IHRydWUgfSk7IC8vIEhpZGUgdW5uZWNlc3NhcnkgbGFiZWxzXHJcbiAgICAgICAgICAgIHlpZWxkIHNoYWtlKHsgaGlkZVdoZW5OZWNlc3Nhcnk6IHRydWUgfSk7IC8vIEZpbmFsIHJlc3VsdFxyXG4gICAgICAgICAgICByZXR1cm4geyByYWRpdXMsIGNlbnRlclgsIGNlbnRlclkgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlZmluZUNpcmNsZShsYWJlbHNCb3gsIHJhZGl1cywgc2VyaWVzQm94KSB7XHJcbiAgICAgICAgY29uc3QgbWluQ2lyY2xlUmF0aW8gPSAwLjU7IC8vIFByZXZlbnRzIHJlZHVjZWQgY2lyY2xlIHRvIGJlIHRvbyBzbWFsbFxyXG4gICAgICAgIGNvbnN0IGNpcmNsZUxlZnQgPSAtcmFkaXVzO1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZVRvcCA9IC1yYWRpdXM7XHJcbiAgICAgICAgY29uc3QgY2lyY2xlUmlnaHQgPSByYWRpdXM7XHJcbiAgICAgICAgY29uc3QgY2lyY2xlQm90dG9tID0gcmFkaXVzO1xyXG4gICAgICAgIC8vIExhYmVsIHBhZGRpbmcgYXJvdW5kIHRoZSBjaXJjbGVcclxuICAgICAgICBsZXQgcGFkTGVmdCA9IE1hdGgubWF4KDAsIGNpcmNsZUxlZnQgLSBsYWJlbHNCb3gueCk7XHJcbiAgICAgICAgbGV0IHBhZFRvcCA9IE1hdGgubWF4KDAsIGNpcmNsZVRvcCAtIGxhYmVsc0JveC55KTtcclxuICAgICAgICBsZXQgcGFkUmlnaHQgPSBNYXRoLm1heCgwLCBsYWJlbHNCb3gueCArIGxhYmVsc0JveC53aWR0aCAtIGNpcmNsZVJpZ2h0KTtcclxuICAgICAgICBsZXQgcGFkQm90dG9tID0gTWF0aC5tYXgoMCwgbGFiZWxzQm94LnkgKyBsYWJlbHNCb3guaGVpZ2h0IC0gY2lyY2xlQm90dG9tKTtcclxuICAgICAgICBwYWRMZWZ0ID0gcGFkUmlnaHQgPSBNYXRoLm1heChwYWRMZWZ0LCBwYWRSaWdodCk7XHJcbiAgICAgICAgcGFkVG9wID0gcGFkQm90dG9tID0gTWF0aC5tYXgocGFkVG9wLCBwYWRCb3R0b20pO1xyXG4gICAgICAgIC8vIEF2YWlsYWJsZSBhcmVhIGZvciB0aGUgY2lyY2xlIChhZnRlciB0aGUgcGFkZGluZyB3aWxsIGJlIGFwcGxpZWQpXHJcbiAgICAgICAgY29uc3QgYXZhaWxDaXJjbGVXaWR0aCA9IHNlcmllc0JveC53aWR0aCAtIHBhZExlZnQgLSBwYWRSaWdodDtcclxuICAgICAgICBjb25zdCBhdmFpbENpcmNsZUhlaWdodCA9IHNlcmllc0JveC5oZWlnaHQgLSBwYWRUb3AgLSBwYWRCb3R0b207XHJcbiAgICAgICAgbGV0IG5ld1JhZGl1cyA9IE1hdGgubWluKGF2YWlsQ2lyY2xlV2lkdGgsIGF2YWlsQ2lyY2xlSGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgY29uc3QgbWluSG9yaXpvbnRhbFJhZGl1cyA9IChtaW5DaXJjbGVSYXRpbyAqIHNlcmllc0JveC53aWR0aCkgLyAyO1xyXG4gICAgICAgIGNvbnN0IG1pblZlcnRpY2FsUmFkaXVzID0gKG1pbkNpcmNsZVJhdGlvICogc2VyaWVzQm94LmhlaWdodCkgLyAyO1xyXG4gICAgICAgIGNvbnN0IG1pblJhZGl1cyA9IE1hdGgubWluKG1pbkhvcml6b250YWxSYWRpdXMsIG1pblZlcnRpY2FsUmFkaXVzKTtcclxuICAgICAgICBpZiAobmV3UmFkaXVzIDwgbWluUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSByYWRpdXMgaXMgdG9vIHNtYWxsLCByZWR1Y2UgdGhlIGxhYmVsIHBhZGRpbmdcclxuICAgICAgICAgICAgbmV3UmFkaXVzID0gbWluUmFkaXVzO1xyXG4gICAgICAgICAgICBjb25zdCBob3Jpem9udGFsUGFkZGluZyA9IHBhZExlZnQgKyBwYWRSaWdodDtcclxuICAgICAgICAgICAgY29uc3QgdmVydGljYWxQYWRkaW5nID0gcGFkVG9wICsgcGFkQm90dG9tO1xyXG4gICAgICAgICAgICBpZiAoMiAqIG5ld1JhZGl1cyArIHZlcnRpY2FsUGFkZGluZyA+IHNlcmllc0JveC5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhZEhlaWdodCA9IHNlcmllc0JveC5oZWlnaHQgLSAyICogbmV3UmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKHBhZFRvcCwgcGFkQm90dG9tKSAqIDIgPiBwYWRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWRUb3AgPSBwYWRIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZEJvdHRvbSA9IHBhZEhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYWRUb3AgPiBwYWRCb3R0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWRUb3AgPSBwYWRIZWlnaHQgLSBwYWRCb3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWRCb3R0b20gPSBwYWRIZWlnaHQgLSBwYWRUb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKDIgKiBuZXdSYWRpdXMgKyBob3Jpem9udGFsUGFkZGluZyA+IHNlcmllc0JveC53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFkV2lkdGggPSBzZXJpZXNCb3gud2lkdGggLSAyICogbmV3UmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKHBhZExlZnQsIHBhZFJpZ2h0KSAqIDIgPiBwYWRXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZExlZnQgPSBwYWRXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkUmlnaHQgPSBwYWRXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYWRMZWZ0ID4gcGFkUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWRMZWZ0ID0gcGFkV2lkdGggLSBwYWRSaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZFJpZ2h0ID0gcGFkV2lkdGggLSBwYWRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1dpZHRoID0gcGFkTGVmdCArIDIgKiBuZXdSYWRpdXMgKyBwYWRSaWdodDtcclxuICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBwYWRUb3AgKyAyICogbmV3UmFkaXVzICsgcGFkQm90dG9tO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNlbnRlclg6IHNlcmllc0JveC54ICsgKHNlcmllc0JveC53aWR0aCAtIG5ld1dpZHRoKSAvIDIgKyBwYWRMZWZ0ICsgbmV3UmFkaXVzLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBzZXJpZXNCb3gueSArIChzZXJpZXNCb3guaGVpZ2h0IC0gbmV3SGVpZ2h0KSAvIDIgKyBwYWRUb3AgKyBuZXdSYWRpdXMsXHJcbiAgICAgICAgICAgIHJhZGl1czogbmV3UmFkaXVzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuUG9sYXJDaGFydC5jbGFzc05hbWUgPSAnUG9sYXJDaGFydCc7XHJcblBvbGFyQ2hhcnQudHlwZSA9ICdwb2xhcic7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsICdvcHRzJyk7XHJcbmZ1bmN0aW9uIGNoYXJ0VHlwZShvcHRpb25zKSB7XHJcbiAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybiAnY2FydGVzaWFuJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybiAncG9sYXInO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybiAnaGllcmFyY2h5JztcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnQgLSB1bmtub3duIHR5cGUgb2YgY2hhcnQgZm9yIG9wdGlvbnMgd2l0aCB0eXBlOiAke29wdGlvbnMudHlwZX1gKTtcclxufVxyXG4vKipcclxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcgYW5kIHVwZGF0aW5nIGluc3RhbmNlcyBvZiBBZ0NoYXJ0SW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBkb2NzSW50ZXJmYWNlXHJcbiAqL1xyXG5jbGFzcyBBZ0NoYXJ0cyB7XHJcbiAgICBzdGF0aWMgbGljZW5zZUNoZWNrKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBpZiAodGhpcy5saWNlbnNlQ2hlY2tlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMubGljZW5zZU1hbmFnZXIgPSAoX2EgPSBlbnRlcnByaXNlTW9kdWxlLmxpY2Vuc2VNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChlbnRlcnByaXNlTW9kdWxlLCBvcHRpb25zKTtcclxuICAgICAgICAoX2IgPSB0aGlzLmxpY2Vuc2VNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0TGljZW5zZUtleSh0aGlzLmxpY2Vuc2VLZXkpO1xyXG4gICAgICAgIChfYyA9IHRoaXMubGljZW5zZU1hbmFnZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52YWxpZGF0ZUxpY2Vuc2UoKTtcclxuICAgICAgICB0aGlzLmxpY2Vuc2VDaGVja2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzZXRMaWNlbnNlS2V5KGxpY2Vuc2VLZXkpIHtcclxuICAgICAgICB0aGlzLmxpY2Vuc2VLZXkgPSBsaWNlbnNlS2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgYEFnQ2hhcnRJbnN0YW5jZWAgYmFzZWQgdXBvbiB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLmxpY2Vuc2VDaGVjayhvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBjaGFydCA9IEFnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlT3JVcGRhdGUob3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMubGljZW5zZU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rpc3BsYXlXYXRlcm1hcmsoKSkge1xyXG4gICAgICAgICAgICAoX2IgPSBlbnRlcnByaXNlTW9kdWxlLmluamVjdFdhdGVybWFyaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoZW50ZXJwcmlzZU1vZHVsZSwgKF9jID0gb3B0aW9ucy5kb2N1bWVudCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZG9jdW1lbnQsIGNoYXJ0LmNoYXJ0LmVsZW1lbnQsIHRoaXMubGljZW5zZU1hbmFnZXIuZ2V0V2F0ZXJtYXJrTWVzc2FnZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgYW4gZXhpc3RpbmcgYEFnQ2hhcnRJbnN0YW5jZWAuIE9wdGlvbnMgcHJvdmlkZWQgc2hvdWxkIGJlIGNvbXBsZXRlIGFuZCBub3RcclxuICAgICAqIHBhcnRpYWwuXHJcbiAgICAgKlxyXG4gICAgICogX19OT1RFX186IEFzIGVhY2ggY2FsbCBjb3VsZCB0cmlnZ2VyIGEgY2hhcnQgcmVkcmF3LCBtdWx0aXBsZSBjYWxscyB0byB1cGRhdGUgb3B0aW9ucyBpblxyXG4gICAgICogcXVpY2sgc3VjY2Vzc2lvbiBjb3VsZCByZXN1bHQgaW4gdW5kZXNpcmFibGUgZmxpY2tlcmluZywgc28gY2FsbGVycyBzaG91bGQgYmF0Y2ggdXAgYW5kL29yXHJcbiAgICAgKiBkZWJvdW5jZSBjaGFuZ2VzIHRvIGF2b2lkIHVuaW50ZW5kZWQgcGFydGlhbCB1cGRhdGUgcmVuZGVyaW5ncy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVwZGF0ZShjaGFydCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICghQWdDaGFydEluc3RhbmNlUHJveHkuaXNJbnN0YW5jZShjaGFydCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEFnQ2hhcnRzLklOVkFMSURfQ0hBUlRfUkVGX01FU1NBR0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKG9wdGlvbnMsIGNoYXJ0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGBBZ0NoYXJ0SW5zdGFuY2VgIGJ5IGFwcGx5aW5nIGEgcGFydGlhbCBzZXQgb2Ygb3B0aW9uIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogX19OT1RFX186IEFzIGVhY2ggY2FsbCBjb3VsZCB0cmlnZ2VyIGEgY2hhcnQgcmVkcmF3LCBlYWNoIGluZGl2aWR1YWwgZGVsdGEgb3B0aW9ucyB1cGRhdGVcclxuICAgICAqIHNob3VsZCBsZWF2ZSB0aGUgY2hhcnQgaW4gYSB2YWxpZCBvcHRpb25zIHN0YXRlLiBBbHNvLCBtdWx0aXBsZSBjYWxscyB0byB1cGRhdGUgb3B0aW9ucyBpblxyXG4gICAgICogcXVpY2sgc3VjY2Vzc2lvbiBjb3VsZCByZXN1bHQgaW4gdW5kZXNpcmFibGUgZmxpY2tlcmluZywgc28gY2FsbGVycyBzaG91bGQgYmF0Y2ggdXAgYW5kL29yXHJcbiAgICAgKiBkZWJvdW5jZSBjaGFuZ2VzIHRvIGF2b2lkIHVuaW50ZW5kZWQgcGFydGlhbCB1cGRhdGUgcmVuZGVyaW5ncy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVwZGF0ZURlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIUFnQ2hhcnRJbnN0YW5jZVByb3h5LmlzSW5zdGFuY2UoY2hhcnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihBZ0NoYXJ0cy5JTlZBTElEX0NIQVJUX1JFRl9NRVNTQUdFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQWdDaGFydHNJbnRlcm5hbC51cGRhdGVVc2VyRGVsdGEoY2hhcnQsIGRlbHRhT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGJyb3dzZXItYmFzZWQgaW1hZ2UgZG93bmxvYWQgZm9yIHRoZSBnaXZlbiBgQWdDaGFydEluc3RhbmNlYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRvd25sb2FkKGNoYXJ0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCEoY2hhcnQgaW5zdGFuY2VvZiBBZ0NoYXJ0SW5zdGFuY2VQcm94eSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEFnQ2hhcnRzLklOVkFMSURfQ0hBUlRfUkVGX01FU1NBR0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBZ0NoYXJ0c0ludGVybmFsLmRvd25sb2FkKGNoYXJ0LCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJhc2U2NC1lbmNvZGVkIGltYWdlIGRhdGEgVVJMIGZvciB0aGUgZ2l2ZW4gYEFnQ2hhcnRJbnN0YW5jZWAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRJbWFnZURhdGFVUkwoY2hhcnQsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIShjaGFydCBpbnN0YW5jZW9mIEFnQ2hhcnRJbnN0YW5jZVByb3h5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQWdDaGFydHMuSU5WQUxJRF9DSEFSVF9SRUZfTUVTU0FHRSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBBZ0NoYXJ0c0ludGVybmFsLmdldEltYWdlRGF0YVVSTChjaGFydCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuQWdDaGFydHMuSU5WQUxJRF9DSEFSVF9SRUZfTUVTU0FHRSA9ICdBRyBDaGFydHMgLSBpbnZhbGlkIGNoYXJ0IHJlZmVyZW5jZSBwYXNzZWQnO1xyXG5BZ0NoYXJ0cy5saWNlbnNlQ2hlY2tlZCA9IGZhbHNlO1xyXG4vKiogQGRlcHJlY2F0ZWQgdXNlIEFnQ2hhcnRzIGluc3RlYWQgKi9cclxuY2xhc3MgQWdDaGFydCB7XHJcbiAgICBzdGF0aWMgd2FybkRlcHJlY2F0ZWQobWVtYmVyTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IHdhcm5EZXByZWNhdGVkID0gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKCk7XHJcbiAgICAgICAgd2FybkRlcHJlY2F0ZWQoYEFnQ2hhcnQuJHttZW1iZXJOYW1lfWAsIGBVc2UgQWdDaGFydHMuJHttZW1iZXJOYW1lfSBpbnN0ZWFkYCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlKG9wdGlvbnMpIHtcclxuICAgICAgICBBZ0NoYXJ0Lndhcm5EZXByZWNhdGVkKCdjcmVhdGUnKTtcclxuICAgICAgICByZXR1cm4gQWdDaGFydHMuY3JlYXRlKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVwZGF0ZShjaGFydCwgb3B0aW9ucykge1xyXG4gICAgICAgIEFnQ2hhcnQud2FybkRlcHJlY2F0ZWQoJ3VwZGF0ZScpO1xyXG4gICAgICAgIHJldHVybiBBZ0NoYXJ0cy51cGRhdGUoY2hhcnQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVwZGF0ZURlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpIHtcclxuICAgICAgICBBZ0NoYXJ0Lndhcm5EZXByZWNhdGVkKCd1cGRhdGVEZWx0YScpO1xyXG4gICAgICAgIHJldHVybiBBZ0NoYXJ0cy51cGRhdGVEZWx0YShjaGFydCwgZGVsdGFPcHRpb25zKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkb3dubG9hZChjaGFydCwgb3B0aW9ucykge1xyXG4gICAgICAgIEFnQ2hhcnQud2FybkRlcHJlY2F0ZWQoJ2Rvd25sb2FkJyk7XHJcbiAgICAgICAgcmV0dXJuIEFnQ2hhcnRzLmRvd25sb2FkKGNoYXJ0LCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbWFnZURhdGFVUkwoY2hhcnQsIG9wdGlvbnMpIHtcclxuICAgICAgICBBZ0NoYXJ0Lndhcm5EZXByZWNhdGVkKCdnZXRJbWFnZURhdGFVUkwnKTtcclxuICAgICAgICByZXR1cm4gQWdDaGFydHMuZ2V0SW1hZ2VEYXRhVVJMKGNoYXJ0LCBvcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBBZ0NoYXJ0c0ludGVybmFsIHtcclxuICAgIHN0YXRpYyBpbml0aWFsaXNlTW9kdWxlcygpIHtcclxuICAgICAgICBpZiAoQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHJlZ2lzdGVySW5idWlsdE1vZHVsZXMoKTtcclxuICAgICAgICBzZXR1cE1vZHVsZXMoKTtcclxuICAgICAgICBBZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVPclVwZGF0ZSh1c2VyT3B0aW9ucywgcHJveHkpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF9iO1xyXG4gICAgICAgIEFnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZU1vZHVsZXMoKTtcclxuICAgICAgICBkZWJ1ZygnPj4+IEFnQ2hhcnRWMi5jcmVhdGVPclVwZGF0ZSgpIHVzZXIgb3B0aW9ucycsIHVzZXJPcHRpb25zKTtcclxuICAgICAgICBjb25zdCB7IG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbywgZG9jdW1lbnQsIHdpbmRvdzogdXNlcldpbmRvdyB9ID0gdXNlck9wdGlvbnMsIGNoYXJ0T3B0aW9ucyA9IF9fcmVzdCh1c2VyT3B0aW9ucywgW1wib3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvXCIsIFwiZG9jdW1lbnRcIiwgXCJ3aW5kb3dcIl0pO1xyXG4gICAgICAgIGNvbnN0IHNwZWNpYWxPdmVycmlkZXMgPSB7IG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbywgZG9jdW1lbnQsIHdpbmRvdzogdXNlcldpbmRvdyB9O1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZE9wdGlvbnMgPSBwcmVwYXJlT3B0aW9ucyhjaGFydE9wdGlvbnMpO1xyXG4gICAgICAgIGxldCBjaGFydCA9IHByb3h5ID09PSBudWxsIHx8IHByb3h5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm94eS5jaGFydDtcclxuICAgICAgICBpZiAoY2hhcnQgPT0gbnVsbCB8fCBjaGFydFR5cGUoY2hhcnRPcHRpb25zKSAhPT0gY2hhcnRUeXBlKGNoYXJ0LnByb2Nlc3NlZE9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0ID0gQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVDaGFydEluc3RhbmNlKHByb2Nlc3NlZE9wdGlvbnMsIHNwZWNpYWxPdmVycmlkZXMsIGNoYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3h5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJveHkgPSBuZXcgQWdDaGFydEluc3RhbmNlUHJveHkoY2hhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJveHkuY2hhcnQgPSBjaGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKERlYnVnLmNoZWNrKCkgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgKF9hID0gKF9iID0gd2luZG93KS5hZ0NoYXJ0SW5zdGFuY2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IuYWdDaGFydEluc3RhbmNlcyA9IHt9KTtcclxuICAgICAgICAgICAgd2luZG93LmFnQ2hhcnRJbnN0YW5jZXNbY2hhcnQuaWRdID0gY2hhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoYXJ0VG9VcGRhdGUgPSBjaGFydDtcclxuICAgICAgICBjaGFydFRvVXBkYXRlLnF1ZXVlZFVzZXJPcHRpb25zLnB1c2goY2hhcnRPcHRpb25zKTtcclxuICAgICAgICBjb25zdCBkZXF1ZXVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYSBsb3Qgb2YgdXBkYXRlIGNhbGxzLCBgcmVxdWVzdEZhY3RvcnlVcGRhdGUoKWAgbWF5IHNraXAgY2FsbGJhY2tzLFxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBhbGwgcXVldWUgaXRlbXMgdXAgdG8gdGhlIGxhc3Qgc3VjY2Vzc2Z1bGx5IGFwcGxpZWQgaXRlbS5cclxuICAgICAgICAgICAgY29uc3QgcXVldWVkT3B0aW9uc0lkeCA9IGNoYXJ0VG9VcGRhdGUucXVldWVkVXNlck9wdGlvbnMuaW5kZXhPZihjaGFydE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjaGFydFRvVXBkYXRlLnF1ZXVlZFVzZXJPcHRpb25zLnNwbGljZSgwLCBxdWV1ZWRPcHRpb25zSWR4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNoYXJ0VG9VcGRhdGUucmVxdWVzdEZhY3RvcnlVcGRhdGUoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBDaGFydCBkZXN0cm95ZWQsIHNraXAgcHJvY2Vzc2luZy5cclxuICAgICAgICAgICAgaWYgKGNoYXJ0VG9VcGRhdGUuZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBkZWx0YU9wdGlvbnMgPSBqc29uRGlmZihjaGFydFRvVXBkYXRlLnByb2Nlc3NlZE9wdGlvbnMsIHByb2Nlc3NlZE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGFPcHRpb25zID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRlcXVldWUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBBZ0NoYXJ0c0ludGVybmFsLnVwZGF0ZURlbHRhKGNoYXJ0VG9VcGRhdGUsIGRlbHRhT3B0aW9ucywgY2hhcnRPcHRpb25zKTtcclxuICAgICAgICAgICAgZGVxdWV1ZSgpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXBkYXRlVXNlckRlbHRhKHByb3h5LCBkZWx0YU9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgeyBjaGFydCwgY2hhcnQ6IHsgcXVldWVkVXNlck9wdGlvbnMgfSwgfSA9IHByb3h5O1xyXG4gICAgICAgIGNvbnN0IGxhc3RVcGRhdGVPcHRpb25zID0gKF9hID0gcXVldWVkVXNlck9wdGlvbnNbcXVldWVkVXNlck9wdGlvbnMubGVuZ3RoIC0gMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNoYXJ0LnVzZXJPcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IHVzZXJPcHRpb25zID0ganNvbk1lcmdlKFtsYXN0VXBkYXRlT3B0aW9ucywgZGVsdGFPcHRpb25zXSk7XHJcbiAgICAgICAgZGVidWcoJz4+PiBBZ0NoYXJ0VjIudXBkYXRlVXNlckRlbHRhKCkgdXNlciBkZWx0YScsIGRlbHRhT3B0aW9ucyk7XHJcbiAgICAgICAgZGVidWcoJ0FnQ2hhcnRWMi51cGRhdGVVc2VyRGVsdGEoKSAtIGJhc2Ugb3B0aW9ucycsIGxhc3RVcGRhdGVPcHRpb25zKTtcclxuICAgICAgICBBZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKHVzZXJPcHRpb25zLCBwcm94eSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgY2FudmFzIGFzIGFuIGltYWdlLlxyXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGRvd25sb2FkIG9wdGlvbnMgaW5jbHVkaW5nIGB3aWR0aGAgYW5kIGBoZWlnaHRgIG9mIHRoZSBpbWFnZSBhcyB3ZWxsIGFzIGBmaWxlTmFtZWAgYW5kIGBmaWxlRm9ybWF0YC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRvd25sb2FkKHByb3h5LCBvcHRzKSB7XHJcbiAgICAgICAgY29uc3QgYXN5bmNEb3dubG9hZCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF5YmVDbG9uZSA9IHlpZWxkIEFnQ2hhcnRzSW50ZXJuYWwucHJlcGFyZVJlc2l6ZWRDaGFydChwcm94eSwgb3B0cyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhcnQgfSA9IG1heWJlQ2xvbmU7XHJcbiAgICAgICAgICAgIGNoYXJ0LnNjZW5lLmRvd25sb2FkKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5maWxlTmFtZSwgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZpbGVGb3JtYXQpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVDbG9uZSAhPT0gcHJveHkpIHtcclxuICAgICAgICAgICAgICAgIG1heWJlQ2xvbmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXN5bmNEb3dubG9hZCgpLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbWFnZURhdGFVUkwocHJveHksIG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXliZUNsb25lID0geWllbGQgQWdDaGFydHNJbnRlcm5hbC5wcmVwYXJlUmVzaXplZENoYXJ0KHByb3h5LCBvcHRzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBjaGFydCB9ID0gbWF5YmVDbG9uZTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hhcnQuc2NlbmUuY2FudmFzLmdldERhdGFVUkwob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZpbGVGb3JtYXQpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVDbG9uZSAhPT0gcHJveHkpIHtcclxuICAgICAgICAgICAgICAgIG1heWJlQ2xvbmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcHJlcGFyZVJlc2l6ZWRDaGFydChwcm94eSwgb3B0cykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNoYXJ0IH0gPSBwcm94eTtcclxuICAgICAgICAgICAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0cyAhPT0gbnVsbCAmJiBvcHRzICE9PSB2b2lkIDAgPyBvcHRzIDoge307XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IGNoYXJ0LndpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gY2hhcnQuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCB1bmNoYW5nZWQgPSAod2lkdGggPT09IHVuZGVmaW5lZCAmJiBoZWlnaHQgPT09IHVuZGVmaW5lZCkgfHxcclxuICAgICAgICAgICAgICAgIChjaGFydC5zY2VuZS5jYW52YXMucGl4ZWxSYXRpbyA9PT0gMSAmJiBjdXJyZW50V2lkdGggPT09IHdpZHRoICYmIGN1cnJlbnRIZWlnaHQgPT09IGhlaWdodCk7XHJcbiAgICAgICAgICAgIGlmICh1bmNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm94eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aWR0aCAhPT0gbnVsbCAmJiB3aWR0aCAhPT0gdm9pZCAwID8gd2lkdGggOiAod2lkdGggPSBjdXJyZW50V2lkdGgpO1xyXG4gICAgICAgICAgICBoZWlnaHQgIT09IG51bGwgJiYgaGVpZ2h0ICE9PSB2b2lkIDAgPyBoZWlnaHQgOiAoaGVpZ2h0ID0gY3VycmVudEhlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYXJ0LnVzZXJPcHRpb25zKSwgeyBjb250YWluZXI6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodCwgYXV0b1NpemU6IGZhbHNlLCBvdmVycmlkZURldmljZVBpeGVsUmF0aW86IDEgfSk7XHJcbiAgICAgICAgICAgIGlmIChoYXNSZWdpc3RlcmVkRW50ZXJwcmlzZU1vZHVsZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBlbnRlcnByaXNlIGZlYXR1cmVzIHRoYXQgbWF5IGludGVyZmVyZSB3aXRoIGltYWdlIGdlbmVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zLmFuaW1hdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKG9wdGlvbnMuYW5pbWF0aW9uID0ge30pO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hbmltYXRpb24uZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZENoYXJ0ID0gQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZShvcHRpb25zKTtcclxuICAgICAgICAgICAgeWllbGQgY2xvbmVkQ2hhcnQuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkQ2hhcnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlQ2hhcnRJbnN0YW5jZShvcHRpb25zLCBzcGVjaWFsT3ZlcnJpZGVzLCBvbGRDaGFydCkge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZVJlc291cmNlID0gb2xkQ2hhcnQgPT09IG51bGwgfHwgb2xkQ2hhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZENoYXJ0LmRlc3Ryb3koeyBrZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuQ2hhcnQoc3BlY2lhbE92ZXJyaWRlcywgdHJhbnNmZXJhYmxlUmVzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FnSGllcmFyY2h5Q2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGllcmFyY2h5Q2hhcnQoc3BlY2lhbE92ZXJyaWRlcywgdHJhbnNmZXJhYmxlUmVzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FnUG9sYXJDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2xhckNoYXJ0KHNwZWNpYWxPdmVycmlkZXMsIHRyYW5zZmVyYWJsZVJlc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBjb3VsZG4ndCBhcHBseSBjb25maWd1cmF0aW9uLCBjaGVjayBvcHRpb25zIGFyZSBjb3JyZWN0bHkgc3RydWN0dXJlZCBhbmQgc2VyaWVzIHR5cGVzIGFyZSBzcGVjaWZpZWRgKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB1cGRhdGVEZWx0YShjaGFydCwgcHJvY2Vzc2VkT3B0aW9ucywgdXNlck9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZE9wdGlvbnMudHlwZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzZWRPcHRpb25zKSwgeyB0eXBlOiAoX2EgPSBjaGFydC5wcm9jZXNzZWRPcHRpb25zLnR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnNUeXBlKHByb2Nlc3NlZE9wdGlvbnMpIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGRlYnVnKCdBZ0NoYXJ0VjIudXBkYXRlRGVsdGEoKSAtIGFwcGx5aW5nIGRlbHRhJywgcHJvY2Vzc2VkT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGFwcGx5Q2hhcnRPcHRpb25zKGNoYXJ0LCBwcm9jZXNzZWRPcHRpb25zLCB1c2VyT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBhcHBseUNoYXJ0T3B0aW9ucyhjaGFydCwgcHJvY2Vzc2VkT3B0aW9ucywgdXNlck9wdGlvbnMpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIGNvbnN0IGNvbXBsZXRlT3B0aW9ucyA9IGpzb25NZXJnZShbKF9hID0gY2hhcnQucHJvY2Vzc2VkT3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIHByb2Nlc3NlZE9wdGlvbnNdLCBub0RhdGFDbG9uZU1lcmdlT3B0aW9ucyk7XHJcbiAgICBjb25zdCBtb2R1bGVzQ2hhbmdlZCA9IGFwcGx5TW9kdWxlcyhjaGFydCwgY29tcGxldGVPcHRpb25zKTtcclxuICAgIGNvbnN0IHNraXAgPSBbJ3R5cGUnLCAnZGF0YScsICdzZXJpZXMnLCAnbGlzdGVuZXJzJywgJ3RoZW1lJywgJ2xlZ2VuZC5saXN0ZW5lcnMnXTtcclxuICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKHByb2Nlc3NlZE9wdGlvbnMpIHx8IGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zKSkge1xyXG4gICAgICAgIC8vIEFwcGVuZCBheGVzIHRvIGRlZmF1bHRzLlxyXG4gICAgICAgIHNraXAucHVzaCgnYXhlcycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zKSkgO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBjb3VsZG4ndCBhcHBseSBjb25maWd1cmF0aW9uLCBjaGVjayB0eXBlIG9mIG9wdGlvbnMgYW5kIGNoYXJ0OiAke3Byb2Nlc3NlZE9wdGlvbnNbJ3R5cGUnXX1gKTtcclxuICAgIH1cclxuICAgIC8vIE5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlIGFwcGx5aW5nIHRoZSBzZXJpZXMgdG8gZGV0ZWN0IGlmIGEgc2VyaWVzTm9kZVtEb3VibGVdQ2xpY2sgbGlzdGVuZXIgaGFzIGJlZW4gYWRkZWRcclxuICAgIGlmIChwcm9jZXNzZWRPcHRpb25zLmxpc3RlbmVycykge1xyXG4gICAgICAgIHJlZ2lzdGVyTGlzdGVuZXJzKGNoYXJ0LCBwcm9jZXNzZWRPcHRpb25zLmxpc3RlbmVycyk7XHJcbiAgICB9XHJcbiAgICBhcHBseU9wdGlvblZhbHVlcyhjaGFydCwgcHJvY2Vzc2VkT3B0aW9ucywgeyBza2lwIH0pO1xyXG4gICAgbGV0IGZvcmNlTm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XHJcbiAgICBsZXQgc2VyaWVzUmVjcmVhdGVkID0gZmFsc2U7XHJcbiAgICBpZiAocHJvY2Vzc2VkT3B0aW9ucy5zZXJpZXMgJiYgcHJvY2Vzc2VkT3B0aW9ucy5zZXJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHNlcmllc1JlY3JlYXRlZCA9IGFwcGx5U2VyaWVzKGNoYXJ0LCBwcm9jZXNzZWRPcHRpb25zKTtcclxuICAgICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoJ2F4ZXMnIGluIGNvbXBsZXRlT3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KGNvbXBsZXRlT3B0aW9ucy5heGVzKSkge1xyXG4gICAgICAgIGNvbnN0IGF4ZXNQcmVzZW50ID0gYXBwbHlBeGVzKGNoYXJ0LCBjb21wbGV0ZU9wdGlvbnMsIHNlcmllc1JlY3JlYXRlZCk7XHJcbiAgICAgICAgaWYgKGF4ZXNQcmVzZW50KSB7XHJcbiAgICAgICAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJpZXNPcHRzID0gcHJvY2Vzc2VkT3B0aW9ucy5zZXJpZXM7XHJcbiAgICBjb25zdCBzZXJpZXNEYXRhVXBkYXRlID0gISFwcm9jZXNzZWRPcHRpb25zLmRhdGEgfHwgKHNlcmllc09wdHMgPT09IG51bGwgfHwgc2VyaWVzT3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VyaWVzT3B0cy5zb21lKChzKSA9PiBzLmRhdGEgIT0gbnVsbCkpO1xyXG4gICAgY29uc3QgbGVnZW5kS2V5cyA9IGdldExlZ2VuZEtleXMoKTtcclxuICAgIGNvbnN0IG9wdGlvbnNIYXZlTGVnZW5kID0gT2JqZWN0LnZhbHVlcyhsZWdlbmRLZXlzKS5zb21lKChsZWdlbmRLZXkpID0+IHByb2Nlc3NlZE9wdGlvbnNbbGVnZW5kS2V5XSAhPSBudWxsKTtcclxuICAgIGNvbnN0IG90aGVyUmVmcmVzaFVwZGF0ZSA9IHByb2Nlc3NlZE9wdGlvbnMudGl0bGUgIT0gbnVsbCAmJiBwcm9jZXNzZWRPcHRpb25zLnN1YnRpdGxlICE9IG51bGw7XHJcbiAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IGZvcmNlTm9kZURhdGFSZWZyZXNoIHx8IHNlcmllc0RhdGFVcGRhdGUgfHwgb3B0aW9uc0hhdmVMZWdlbmQgfHwgb3RoZXJSZWZyZXNoVXBkYXRlO1xyXG4gICAgaWYgKHByb2Nlc3NlZE9wdGlvbnMuZGF0YSkge1xyXG4gICAgICAgIGNoYXJ0LmRhdGEgPSBwcm9jZXNzZWRPcHRpb25zLmRhdGE7XHJcbiAgICB9XHJcbiAgICBpZiAoKF9iID0gcHJvY2Vzc2VkT3B0aW9ucy5sZWdlbmQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5saXN0ZW5lcnMpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKGNoYXJ0LmxlZ2VuZC5saXN0ZW5lcnMsIChfYyA9IHByb2Nlc3NlZE9wdGlvbnMubGVnZW5kLmxpc3RlbmVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3NlZE9wdGlvbnMubGlzdGVuZXJzKSB7XHJcbiAgICAgICAgY2hhcnQudXBkYXRlQWxsU2VyaWVzTGlzdGVuZXJzKCk7XHJcbiAgICB9XHJcbiAgICBjaGFydC5wcm9jZXNzZWRPcHRpb25zID0gY29tcGxldGVPcHRpb25zO1xyXG4gICAgY2hhcnQudXNlck9wdGlvbnMgPSBqc29uTWVyZ2UoWyhfZCA9IGNoYXJ0LnVzZXJPcHRpb25zKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSwgdXNlck9wdGlvbnNdLCBub0RhdGFDbG9uZU1lcmdlT3B0aW9ucyk7XHJcbiAgICBjb25zdCBtYWpvckNoYW5nZSA9IGZvcmNlTm9kZURhdGFSZWZyZXNoIHx8IG1vZHVsZXNDaGFuZ2VkO1xyXG4gICAgY29uc3QgdXBkYXRlVHlwZSA9IG1ham9yQ2hhbmdlID8gQ2hhcnRVcGRhdGVUeXBlLlBST0NFU1NfREFUQSA6IENoYXJ0VXBkYXRlVHlwZS5QRVJGT1JNX0xBWU9VVDtcclxuICAgIGRlYnVnKCdBZ0NoYXJ0VjIuYXBwbHlDaGFydE9wdGlvbnMoKSAtIHVwZGF0ZSB0eXBlJywgQ2hhcnRVcGRhdGVUeXBlW3VwZGF0ZVR5cGVdKTtcclxuICAgIGNoYXJ0LnVwZGF0ZSh1cGRhdGVUeXBlLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoLCBuZXdBbmltYXRpb25CYXRjaDogdHJ1ZSB9KTtcclxufVxyXG5mdW5jdGlvbiBhcHBseU1vZHVsZXMoY2hhcnQsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG1hdGNoaW5nQ2hhcnRUeXBlID0gKG1vZHVsZSkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKGNoYXJ0IGluc3RhbmNlb2YgQ2FydGVzaWFuQ2hhcnQgJiYgbW9kdWxlLmNoYXJ0VHlwZXMuaW5jbHVkZXMoJ2NhcnRlc2lhbicpKSB8fFxyXG4gICAgICAgICAgICAoY2hhcnQgaW5zdGFuY2VvZiBQb2xhckNoYXJ0ICYmIG1vZHVsZS5jaGFydFR5cGVzLmluY2x1ZGVzKCdwb2xhcicpKSB8fFxyXG4gICAgICAgICAgICAoY2hhcnQgaW5zdGFuY2VvZiBIaWVyYXJjaHlDaGFydCAmJiBtb2R1bGUuY2hhcnRUeXBlcy5pbmNsdWRlcygnaGllcmFyY2h5JykpKTtcclxuICAgIH07XHJcbiAgICBsZXQgbW9kdWxlc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IHByb2Nlc3NNb2R1bGVzID0gKG1vZHVsZVR5cGUsIGFkZCwgcmVtb3ZlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbW9kdWxlcyA9IFJFR0lTVEVSRURfTU9EVUxFUy5maWx0ZXIoKG0pID0+IG0udHlwZSA9PT0gbW9kdWxlVHlwZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBuZXh0IG9mIG1vZHVsZXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQmVFbmFibGVkID0gbWF0Y2hpbmdDaGFydFR5cGUobmV4dCkgJiYgb3B0aW9uc1tuZXh0Lm9wdGlvbnNLZXldICE9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRW5hYmxlZCA9IGNoYXJ0LmlzTW9kdWxlRW5hYmxlZChuZXh0KTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCA9PT0gaXNFbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIG1vZHVsZXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgYWRkKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHByb2Nlc3NNb2R1bGVzKCdyb290JywgKG5leHQpID0+IGNoYXJ0LmFkZE1vZHVsZShuZXh0KSwgKG5leHQpID0+IGNoYXJ0LnJlbW92ZU1vZHVsZShuZXh0KSk7XHJcbiAgICBwcm9jZXNzTW9kdWxlcygnbGVnZW5kJywgKG5leHQpID0+IGNoYXJ0LmFkZExlZ2VuZE1vZHVsZShuZXh0KSwgKG5leHQpID0+IGNoYXJ0LnJlbW92ZUxlZ2VuZE1vZHVsZShuZXh0KSk7XHJcbiAgICByZXR1cm4gbW9kdWxlc0NoYW5nZWQ7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlTZXJpZXMoY2hhcnQsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdFNlcmllcyA9IG9wdGlvbnMuc2VyaWVzO1xyXG4gICAgaWYgKCFvcHRTZXJpZXMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXlzVG9Db25zaWRlciA9IFsndHlwZScsICdkaXJlY3Rpb24nLCAneEtleScsICd5S2V5JywgJ3NpemVLZXknLCAnYW5nbGVLZXknLCAnc3RhY2tlZCcsICdzdGFja0dyb3VwJ107XHJcbiAgICBsZXQgbWF0Y2hpbmdUeXBlcyA9IGNoYXJ0LnNlcmllcy5sZW5ndGggPT09IG9wdFNlcmllcy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJ0LnNlcmllcy5sZW5ndGggJiYgbWF0Y2hpbmdUeXBlczsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c1RvQ29uc2lkZXIpIHtcclxuICAgICAgICAgICAgbWF0Y2hpbmdUeXBlcyAmJiAobWF0Y2hpbmdUeXBlcyA9IGNoYXJ0LnNlcmllc1tpXVtrZXldID09PSBvcHRTZXJpZXNbaV1ba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gVHJ5IHRvIG9wdGltaXNlIHNlcmllcyB1cGRhdGVzIGlmIHNlcmllcyBjb3VudCBhbmQgdHlwZXMgZGlkbid0IGNoYW5nZS5cclxuICAgIGlmIChtYXRjaGluZ1R5cGVzKSB7XHJcbiAgICAgICAgY2hhcnQuc2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c09wdHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBjaGFydC5wcm9jZXNzZWRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VyaWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbaV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9O1xyXG4gICAgICAgICAgICBjb25zdCBzZXJpZXNEaWZmID0ganNvbkRpZmYocHJldmlvdXNPcHRzLCAoX2QgPSBvcHRTZXJpZXNbaV0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9KTtcclxuICAgICAgICAgICAgaWYgKCFzZXJpZXNEaWZmKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVidWcoYEFnQ2hhcnRWMi5hcHBseVNlcmllcygpIC0gYXBwbHlpbmcgc2VyaWVzIGRpZmYgaWR4ICR7aX1gLCBzZXJpZXNEaWZmKTtcclxuICAgICAgICAgICAgYXBwbHlTZXJpZXNWYWx1ZXMocywgc2VyaWVzRGlmZiwgeyBwYXRoOiBgc2VyaWVzWyR7aX1dYCwgaW5kZXg6IGkgfSk7XHJcbiAgICAgICAgICAgIHMubWFya05vZGVEYXRhRGlydHkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhgQWdDaGFydFYyLmFwcGx5U2VyaWVzKCkgLSBjcmVhdGluZyBuZXcgc2VyaWVzIGluc3RhbmNlc2ApO1xyXG4gICAgY2hhcnQuc2VyaWVzID0gY3JlYXRlU2VyaWVzKGNoYXJ0LCBvcHRTZXJpZXMpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlBeGVzKGNoYXJ0LCBvcHRpb25zLCBmb3JjZVJlY3JlYXRlKSB7XHJcbiAgICBjb25zdCBvcHRBeGVzID0gb3B0aW9ucy5heGVzO1xyXG4gICAgaWYgKCFvcHRBeGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWF0Y2hpbmdUeXBlcyA9ICFmb3JjZVJlY3JlYXRlICYmXHJcbiAgICAgICAgY2hhcnQuYXhlcy5sZW5ndGggPT09IG9wdEF4ZXMubGVuZ3RoICYmXHJcbiAgICAgICAgY2hhcnQuYXhlcy5ldmVyeSgoYSwgaSkgPT4gYS50eXBlID09PSBvcHRBeGVzW2ldLnR5cGUpO1xyXG4gICAgLy8gVHJ5IHRvIG9wdGltaXNlIHNlcmllcyB1cGRhdGVzIGlmIHNlcmllcyBjb3VudCBhbmQgdHlwZXMgZGlkbid0IGNoYW5nZS5cclxuICAgIGlmIChtYXRjaGluZ1R5cGVzKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkT3B0cyA9IGNoYXJ0LnByb2Nlc3NlZE9wdGlvbnM7XHJcbiAgICAgICAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob2xkT3B0cykpIHtcclxuICAgICAgICAgICAgY2hhcnQuYXhlcy5mb3JFYWNoKChhLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNPcHRzID0gKF9iID0gKF9hID0gb2xkT3B0cy5heGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbaV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXhpc0RpZmYgPSBqc29uRGlmZihwcmV2aW91c09wdHMsIG9wdEF4ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgZGVidWcoYEFnQ2hhcnRWMi5hcHBseUF4ZXMoKSAtIGFwcGx5aW5nIGF4aXMgZGlmZiBpZHggJHtpfWAsIGF4aXNEaWZmKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBgYXhlc1ske2l9XWA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBza2lwID0gWydheGVzW10udHlwZSddO1xyXG4gICAgICAgICAgICAgICAgYXBwbHlPcHRpb25WYWx1ZXMoYSwgYXhpc0RpZmYsIHsgcGF0aCwgc2tpcCB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNoYXJ0LmF4ZXMgPSBjcmVhdGVBeGlzKGNoYXJ0LCBvcHRBeGVzKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmllcyhjaGFydCwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3Qgc2VyaWVzID0gW107XHJcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gY2hhcnQuZ2V0TW9kdWxlQ29udGV4dCgpO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIGZvciAoY29uc3Qgc2VyaWVzT3B0aW9ucyBvZiBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBbXSkge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBgc2VyaWVzWyR7aW5kZXgrK31dYDtcclxuICAgICAgICBjb25zdCB0eXBlID0gKF9hID0gc2VyaWVzT3B0aW9ucy50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndW5rbm93bic7XHJcbiAgICAgICAgaWYgKGlzRW50ZXJwcmlzZVNlcmllc1R5cGUodHlwZSkgJiYgIWlzRW50ZXJwcmlzZVNlcmllc1R5cGVMb2FkZWQodHlwZSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcmllc0luc3RhbmNlID0gZ2V0U2VyaWVzKHR5cGUsIG1vZHVsZUNvbnRleHQpO1xyXG4gICAgICAgIGFwcGx5U2VyaWVzT3B0aW9uTW9kdWxlcyhzZXJpZXNJbnN0YW5jZSwgc2VyaWVzT3B0aW9ucyk7XHJcbiAgICAgICAgYXBwbHlTZXJpZXNWYWx1ZXMoc2VyaWVzSW5zdGFuY2UsIHNlcmllc09wdGlvbnMsIHsgcGF0aCwgaW5kZXggfSk7XHJcbiAgICAgICAgc2VyaWVzLnB1c2goc2VyaWVzSW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcmllcztcclxufVxyXG5mdW5jdGlvbiBhcHBseVNlcmllc09wdGlvbk1vZHVsZXMoc2VyaWVzLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBzZXJpZXNPcHRpb25Nb2R1bGVzID0gUkVHSVNURVJFRF9NT0RVTEVTLmZpbHRlcigobSkgPT4gbS50eXBlID09PSAnc2VyaWVzLW9wdGlvbicpO1xyXG4gICAgZm9yIChjb25zdCBtb2Qgb2Ygc2VyaWVzT3B0aW9uTW9kdWxlcykge1xyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZFNlcmllc1R5cGVzID0gbW9kLnNlcmllc1R5cGVzO1xyXG4gICAgICAgIGlmIChtb2Qub3B0aW9uc0tleSBpbiBvcHRpb25zICYmIHN1cHBvcnRlZFNlcmllc1R5cGVzLmluY2x1ZGVzKHNlcmllcy50eXBlKSkge1xyXG4gICAgICAgICAgICBzZXJpZXMuZ2V0TW9kdWxlTWFwKCkuYWRkTW9kdWxlKG1vZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUF4aXMoY2hhcnQsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGF4ZXMgPSBbXTtcclxuICAgIGNvbnN0IHNraXAgPSBbJ2F4ZXNbXS50eXBlJ107XHJcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gY2hhcnQuZ2V0TW9kdWxlQ29udGV4dCgpO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIGZvciAoY29uc3QgYXhpc09wdGlvbnMgb2Ygb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogW10pIHtcclxuICAgICAgICBjb25zdCBheGlzID0gZ2V0QXhpcyhheGlzT3B0aW9ucy50eXBlLCBtb2R1bGVDb250ZXh0KTtcclxuICAgICAgICBjb25zdCBwYXRoID0gYGF4ZXNbJHtpbmRleCsrfV1gO1xyXG4gICAgICAgIGFwcGx5QXhpc01vZHVsZXMoYXhpcywgYXhpc09wdGlvbnMpO1xyXG4gICAgICAgIGFwcGx5T3B0aW9uVmFsdWVzKGF4aXMsIGF4aXNPcHRpb25zLCB7IHBhdGgsIHNraXAgfSk7XHJcbiAgICAgICAgYXhlcy5wdXNoKGF4aXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF4ZXM7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlBeGlzTW9kdWxlcyhheGlzLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgbW9kdWxlc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IHJvb3RNb2R1bGVzID0gUkVHSVNURVJFRF9NT0RVTEVTLmZpbHRlcigobSkgPT4gbS50eXBlID09PSAnYXhpcy1vcHRpb24nKTtcclxuICAgIGZvciAoY29uc3QgbmV4dCBvZiByb290TW9kdWxlcykge1xyXG4gICAgICAgIGNvbnN0IHNob3VsZEJlRW5hYmxlZCA9IG9wdGlvbnNbbmV4dC5vcHRpb25zS2V5XSAhPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IG1vZHVsZU1hcCA9IGF4aXMuZ2V0TW9kdWxlTWFwKCk7XHJcbiAgICAgICAgY29uc3QgaXNFbmFibGVkID0gbW9kdWxlTWFwLmlzTW9kdWxlRW5hYmxlZChuZXh0KTtcclxuICAgICAgICBpZiAoc2hvdWxkQmVFbmFibGVkID09PSBpc0VuYWJsZWQpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIG1vZHVsZXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoc2hvdWxkQmVFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIG1vZHVsZU1hcC5hZGRNb2R1bGUobmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb2R1bGVNYXAucmVtb3ZlTW9kdWxlKG5leHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtb2R1bGVzQ2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycyhzb3VyY2UsIGxpc3RlbmVycykge1xyXG4gICAgc291cmNlLmNsZWFyRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhsaXN0ZW5lcnMgIT09IG51bGwgJiYgbGlzdGVuZXJzICE9PSB2b2lkIDAgPyBsaXN0ZW5lcnMgOiB7fSk7XHJcbiAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgbGlzdGVuZXJdIG9mIGVudHJpZXMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihwcm9wZXJ0eSwgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5T3B0aW9uVmFsdWVzKHRhcmdldCwgb3B0aW9ucywgeyBza2lwLCBwYXRoIH0gPSB7fSkge1xyXG4gICAgY29uc3QgYXBwbHlPcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldEpzb25BcHBseU9wdGlvbnMoKSksIHsgc2tpcCB9KSwgKHBhdGggPyB7IHBhdGggfSA6IHt9KSk7XHJcbiAgICByZXR1cm4ganNvbkFwcGx5KHRhcmdldCwgb3B0aW9ucywgYXBwbHlPcHRzKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVNlcmllc1ZhbHVlcyh0YXJnZXQsIG9wdGlvbnMsIHsgcGF0aCwgaW5kZXggfSA9IHt9KSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3Qgc2tpcCA9IFsnc2VyaWVzW10ubGlzdGVuZXJzJywgJ3Nlcmllc1tdLnNlcmllc0dyb3VwaW5nJ107XHJcbiAgICBjb25zdCBqc29uQXBwbHlPcHRpb25zID0gZ2V0SnNvbkFwcGx5T3B0aW9ucygpO1xyXG4gICAgY29uc3QgY3RycyA9IChfYSA9IGpzb25BcHBseU9wdGlvbnMuY29uc3RydWN0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcclxuICAgIGNvbnN0IHNlcmllc1R5cGVPdmVycmlkZXMgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3JzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGN0cnMpLCB7IHRpdGxlOiB0YXJnZXQudHlwZSA9PT0gJ3BpZScgPyBQaWVUaXRsZSA6IGN0cnNbJ3RpdGxlJ10gfSksXHJcbiAgICB9O1xyXG4gICAgY29uc3QgYXBwbHlPcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uQXBwbHlPcHRpb25zKSwgc2VyaWVzVHlwZU92ZXJyaWRlcyksIHsgc2tpcDogWydzZXJpZXNbXS50eXBlJywgLi4uKHNraXAgIT09IG51bGwgJiYgc2tpcCAhPT0gdm9pZCAwID8gc2tpcCA6IFtdKV0gfSksIChwYXRoID8geyBwYXRoIH0gOiB7fSkpLCB7IGlkeDogaW5kZXggIT09IG51bGwgJiYgaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogLTEgfSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBqc29uQXBwbHkodGFyZ2V0LCBvcHRpb25zLCBhcHBseU9wdHMpO1xyXG4gICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGlzdGVuZXJzKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJMaXN0ZW5lcnModGFyZ2V0LCBvcHRpb25zLmxpc3RlbmVycyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHNlcmllc0dyb3VwaW5nIH0gPSBvcHRpb25zO1xyXG4gICAgaWYgKCdzZXJpZXNHcm91cGluZycgaW4gKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KSkge1xyXG4gICAgICAgIGlmIChzZXJpZXNHcm91cGluZykge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2VyaWVzR3JvdXBpbmcgPSBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKChfYiA9IHRhcmdldC5zZXJpZXNHcm91cGluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pKSwgc2VyaWVzR3JvdXBpbmcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXJpZXNHcm91cGluZyA9IHNlcmllc0dyb3VwaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuLy8gRE8gTk9UIFVQREFURSBNQU5VQUxMWTogR2VuZXJhdGVkIGZyb20gc2NyaXB0IGR1cmluZyBidWlsZCB0aW1lXHJcbmNvbnN0IFZFUlNJT04gPSAnOS4wLjEnO1xuXG5jb25zdCB0aGVtZXMgPSBPYmplY3QuZW50cmllcyh0aGVtZXMkMSkucmVkdWNlKChvYmosIFtuYW1lLCBmYWN0b3J5XSkgPT4ge1xyXG4gICAgb2JqW25hbWVdID0gZmFjdG9yeSgpO1xyXG4gICAgcmV0dXJuIG9iajtcclxufSwge30pO1xuXG52YXIgaW50ZWdyYXRlZENoYXJ0c1RoZW1lID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB0aGVtZXM6IHRoZW1lcyxcbiAgICBnZXRDaGFydFRoZW1lOiBnZXRDaGFydFRoZW1lLFxuICAgIENoYXJ0VGhlbWU6IENoYXJ0VGhlbWUsXG4gICAgRVhURU5EU19DSEFSVF9ERUZBVUxUUzogRVhURU5EU19DSEFSVF9ERUZBVUxUUyxcbiAgICBFWFRFTkRTX0xFR0VORF9ERUZBVUxUUzogRVhURU5EU19MRUdFTkRfREVGQVVMVFMsXG4gICAgRVhURU5EU19MRUdFTkRfSVRFTV9ERUZBVUxUUzogRVhURU5EU19MRUdFTkRfSVRFTV9ERUZBVUxUUyxcbiAgICBFWFRFTkRTX0xFR0VORF9JVEVNX01BUktFUl9ERUZBVUxUUzogRVhURU5EU19MRUdFTkRfSVRFTV9NQVJLRVJfREVGQVVMVFMsXG4gICAgRVhURU5EU19BWEVTX0RFRkFVTFRTOiBFWFRFTkRTX0FYRVNfREVGQVVMVFMsXG4gICAgRVhURU5EU19BWEVTX0xBQkVMX0RFRkFVTFRTOiBFWFRFTkRTX0FYRVNfTEFCRUxfREVGQVVMVFMsXG4gICAgRVhURU5EU19BWEVTX0xJTkVfREVGQVVMVFM6IEVYVEVORFNfQVhFU19MSU5FX0RFRkFVTFRTLFxuICAgIEVYVEVORFNfQVhFU19USUNLX0RFRkFVTFRTOiBFWFRFTkRTX0FYRVNfVElDS19ERUZBVUxUUyxcbiAgICBFWFRFTkRTX0FYRVNfR1JJRF9MSU5FX0RFRkFVTFRTOiBFWFRFTkRTX0FYRVNfR1JJRF9MSU5FX0RFRkFVTFRTLFxuICAgIEVYVEVORFNfU0VSSUVTX0RFRkFVTFRTOiBFWFRFTkRTX1NFUklFU19ERUZBVUxUUyxcbiAgICBFWFRFTkRTX0NBUlRFU0lBTl9NQVJLRVJfREVGQVVMVFM6IEVYVEVORFNfQ0FSVEVTSUFOX01BUktFUl9ERUZBVUxUUyxcbiAgICBPVkVSUklERV9TRVJJRVNfTEFCRUxfREVGQVVMVFM6IE9WRVJSSURFX1NFUklFU19MQUJFTF9ERUZBVUxUUyxcbiAgICBERUZBVUxUX0ZPTlRfRkFNSUxZOiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgIERFRkFVTFRfTEFCRUxfQ09MT1VSOiBERUZBVUxUX0xBQkVMX0NPTE9VUixcbiAgICBERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUjogREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVIsXG4gICAgREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUjogREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUixcbiAgICBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUjogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gICAgREVGQVVMVF9BWElTX0dSSURfQ09MT1VSOiBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsXG4gICAgREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSOiBERUZBVUxUX0FYSVNfTElORV9DT0xPVVIsXG4gICAgREVGQVVMVF9DUk9TU19MSU5FU19DT0xPVVI6IERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLFxuICAgIERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVI6IERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIsXG4gICAgREVGQVVMVF9TSEFET1dfQ09MT1VSOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1BPU0lUSVZFX0NPTE9VUlM6IERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19QT1NJVElWRV9DT0xPVVJTLFxuICAgIERFRkFVTFRfV0FURVJGQUxMX1NFUklFU19ORUdBVElWRV9DT0xPVVJTOiBERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfTkVHQVRJVkVfQ09MT1VSUyxcbiAgICBERUZBVUxUX1dBVEVSRkFMTF9TRVJJRVNfVE9UQUxfQ09MT1VSUzogREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX1RPVEFMX0NPTE9VUlMsXG4gICAgREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX0NPTk5FQ1RPUl9MSU5FX1NUUk9LRTogREVGQVVMVF9XQVRFUkZBTExfU0VSSUVTX0NPTk5FQ1RPUl9MSU5FX1NUUk9LRSxcbiAgICBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0U6IERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRSxcbiAgICBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFOiBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLFxuICAgIERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTOiBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUyxcbiAgICBERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTOiBERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLFxuICAgIEZPTlRfU0laRTogRk9OVF9TSVpFLFxuICAgIEJPTEQ6IEJPTEQsXG4gICAgTk9STUFMOiBOT1JNQUwsXG4gICAgQk9UVE9NOiBCT1RUT00sXG4gICAgQ0FSVEVTSUFOX0FYSVNfUE9TSVRJT05TOiBDQVJURVNJQU5fQVhJU19QT1NJVElPTlMsXG4gICAgQ0FSVEVTSUFOX0FYSVNfVFlQRVM6IENBUlRFU0lBTl9BWElTX1RZUEVTLFxuICAgIFBPTEFSX0FYSVNfVFlQRVM6IFBPTEFSX0FYSVNfVFlQRVMsXG4gICAgQ0lSQ0xFOiBDSVJDTEVcbn0pO1xuXG52YXIgc3BhcmtsaW5lc1NjYWxlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBUaW1lU2NhbGU6IFRpbWVTY2FsZSxcbiAgICBCYW5kU2NhbGU6IEJhbmRTY2FsZSxcbiAgICBDb250aW51b3VzU2NhbGU6IENvbnRpbnVvdXNTY2FsZSxcbiAgICBDb2xvclNjYWxlOiBDb2xvclNjYWxlLFxuICAgIExpbmVhclNjYWxlOiBMaW5lYXJTY2FsZVxufSk7XG5cbmV4cG9ydCB7IEFnQ2hhcnQsIEFnQ2hhcnRzLCBBZ0Vycm9yQmFyU3VwcG9ydGVkU2VyaWVzVHlwZXMsIE1hcmtlciwgVkVSU0lPTiwgbW9kdWxlU3VwcG9ydCBhcyBfTW9kdWxlU3VwcG9ydCwgc3BhcmtsaW5lc1NjYWxlIGFzIF9TY2FsZSwgaW50ZWdyYXRlZENoYXJ0c1NjZW5lIGFzIF9TY2VuZSwgaW50ZWdyYXRlZENoYXJ0c1RoZW1lIGFzIF9UaGVtZSwgc3BhcmtsaW5lc1V0aWwgYXMgX1V0aWwsIF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTiQxIGFzIF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTiwgaW5kZXggYXMgdGltZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ag-charts-community/dist/package/main.esm.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CShaye%5COneDrive%5CDesktop%5Ccpoy%5Cevent%5Cpages%5Cdashboard.tsx&page=%2Fdashboard!":
/*!*******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CShaye%5COneDrive%5CDesktop%5Ccpoy%5Cevent%5Cpages%5Cdashboard.tsx&page=%2Fdashboard! ***!
  \*******************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/dashboard\",\n      function () {\n        return __webpack_require__(/*! ./pages/dashboard.tsx */ \"./pages/dashboard.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/dashboard\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNTaGF5ZSU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q2Nwb3klNUNldmVudCU1Q3BhZ2VzJTVDZGFzaGJvYXJkLnRzeCZwYWdlPSUyRmRhc2hib2FyZCEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzVjNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9kYXNoYm9hcmRcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL2Rhc2hib2FyZC50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL2Rhc2hib2FyZFwiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CShaye%5COneDrive%5CDesktop%5Ccpoy%5Cevent%5Cpages%5Cdashboard.tsx&page=%2Fdashboard!\n"));

/***/ }),

/***/ "./pages/dashboard.tsx":
/*!*****************************!*\
  !*** ./pages/dashboard.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var ag_charts_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ag-charts-react */ \"./node_modules/ag-charts-react/dist/index.mjs\");\n/* harmony import */ var _sidebar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sidebar */ \"./pages/sidebar.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Dashboard = ()=>{\n    _s();\n    const [userCount, setUserCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [eventCount, setEventCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [eventData, setEventData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [eventTypeCounts, setEventTypeCounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        Decoration: 0,\n        Catering: 0,\n        Transportation: 0,\n        SpecialGuests: 0,\n        PartyHall: 0,\n        MarriageHall: 0,\n        Entertainment: 0\n    });\n    const [monthlyEventCounts, setMonthlyEventCounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const fetchData = async ()=>{\n            const db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)();\n            // Fetch user data\n            const usersCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"users\");\n            try {\n                const usersSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(usersCollection);\n                setUserCount(usersSnapshot.size);\n                const typeCounts = {\n                    Decoration: 0,\n                    Catering: 0,\n                    Transportation: 0,\n                    SpecialGuests: 0,\n                    PartyHall: 0,\n                    MarriageHall: 0,\n                    Entertainment: 0\n                };\n                usersSnapshot.forEach((userDoc)=>{\n                    const userData = userDoc.data();\n                    if (userData.eventType) {\n                        typeCounts[userData.eventType]++;\n                    }\n                });\n                setEventTypeCounts(typeCounts);\n            } catch (error) {\n                console.error(\"Error fetching user count:\", error);\n            }\n            // Fetch event data\n            const eventsCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"eventuser\");\n            try {\n                const eventsSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(eventsCollection);\n                const eventsData = eventsSnapshot.docs.map((doc)=>doc.data());\n                setEventCount(eventsSnapshot.size);\n                setEventData(eventsData);\n                // Count events for each month\n                const monthlyCounts = {};\n                eventsData.forEach((event)=>{\n                    const eventDate = new Date(event.date);\n                    const monthKey = \"\".concat(eventDate.getFullYear(), \"-\").concat(eventDate.getMonth() + 1);\n                    if (monthlyCounts[monthKey]) {\n                        monthlyCounts[monthKey]++;\n                    } else {\n                        monthlyCounts[monthKey] = 1;\n                    }\n                });\n                setMonthlyEventCounts(monthlyCounts);\n            } catch (error) {\n                console.error(\"Error fetching event data:\", error);\n            }\n        };\n        fetchData();\n    }, []);\n    const userChartOptions = {\n        width: 500,\n        height: 600,\n        data: [\n            {\n                typeCount: eventTypeCounts.Entertainment,\n                typeName: \"Entertainment\"\n            },\n            {\n                typeCount: eventTypeCounts.Decoration,\n                typeName: \"Decoration\"\n            },\n            {\n                typeCount: eventTypeCounts.Catering,\n                typeName: \"Catering\"\n            },\n            {\n                typeCount: eventTypeCounts.SpecialGuests,\n                typeName: \"SpecialGuests\"\n            },\n            {\n                typeCount: eventTypeCounts.Transportation,\n                typeName: \"Transportation\"\n            },\n            {\n                typeCount: eventTypeCounts.PartyHall,\n                typeName: \"Party hall\"\n            },\n            {\n                typeCount: eventTypeCounts.MarriageHall,\n                typeName: \"MarriageHall\"\n            }\n        ],\n        title: {\n            text: \"Users Composition\"\n        },\n        series: [\n            {\n                type: \"pie\",\n                angleKey: \"typeCount\",\n                labelKey: \"typeName\",\n                calloutLabelKey: \"typeName\",\n                sectorLabelKey: \"typeCount\",\n                sectorLabel: {\n                    color: \"white\",\n                    fontWeight: \"bold\"\n                }\n            }\n        ]\n    };\n    const monthlyEventChartOptions = {\n        title: {\n            text: \"Number of Events by Month\"\n        },\n        data: Object.keys(monthlyEventCounts).map((month)=>({\n                month,\n                count: monthlyEventCounts[month]\n            })),\n        series: [\n            {\n                type: \"bar\",\n                xKey: \"month\",\n                yKey: \"count\"\n            }\n        ]\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_sidebar__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                lineNumber: 133,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col items-center justify-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"bg-gray-300 p-10 rounded-md mx-24 mt-6 h-24\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-black text-lg\",\n                                    children: [\n                                        \"Number of Users: \",\n                                        userCount\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                    lineNumber: 139,\n                                    columnNumber: 13\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                lineNumber: 138,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"bg-gray-300 p-10 rounded-md  mx-16  mt-6 h-24\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-black text-lg\",\n                                    children: [\n                                        \"Number of Events: \",\n                                        eventCount\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                    lineNumber: 142,\n                                    columnNumber: 13\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                lineNumber: 141,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                        lineNumber: 137,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-6 flex justify-center items-center\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                    className: \"text-lg font-bold mb-2\",\n                                    children: \"Users Composition\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                    lineNumber: 148,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_charts_react__WEBPACK_IMPORTED_MODULE_3__.AgChartsReact, {\n                                    options: userChartOptions\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                    lineNumber: 149,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                            lineNumber: 147,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                        lineNumber: 146,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-6 flex justify-center items-center\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-center\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                    className: \"text-lg font-bold mb-2\",\n                                    children: \"Monthly Event Counts\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                    lineNumber: 155,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_charts_react__WEBPACK_IMPORTED_MODULE_3__.AgChartsReact, {\n                                    options: monthlyEventChartOptions\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                                    lineNumber: 156,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                            lineNumber: 154,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                        lineNumber: 153,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n                lineNumber: 136,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\dashboard.tsx\",\n        lineNumber: 132,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Dashboard, \"yEgRiY4A4ynk/CcJ/j0+/1uBBYQ=\");\n_c = Dashboard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dashboard);\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJQyxXQUFVOzs4Q0FDYiw4REFBQ0U7b0NBQUdGLFdBQVU7OENBQXlCOzs7Ozs7OENBQ3ZDLDhEQUFDdkUsMERBQWFBO29DQUFDMEUsU0FBUzNCOzs7Ozs7Ozs7Ozs7Ozs7OztrQ0FJNUIsOERBQUN1Qjt3QkFBSUMsV0FBVTtrQ0FDYiw0RUFBQ0Q7NEJBQUlDLFdBQVU7OzhDQUNiLDhEQUFDRTtvQ0FBR0YsV0FBVTs4Q0FBeUI7Ozs7Ozs4Q0FDdkMsOERBQUN2RSwwREFBYUE7b0NBQUMwRSxTQUFTWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPcEM7R0E3Sk03RDtLQUFBQTtBQStKTiwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9kYXNoYm9hcmQudHN4P2Q3ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGdldEZpcmVzdG9yZSwgY29sbGVjdGlvbiwgZ2V0RG9jcyB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcbmltcG9ydCB7IEFnQ2hhcnRzUmVhY3QgfSBmcm9tICdhZy1jaGFydHMtcmVhY3QnO1xyXG5pbXBvcnQgU2lkZWJhciBmcm9tICcuL3NpZGViYXInO1xyXG5cclxuY29uc3QgRGFzaGJvYXJkID0gKCkgPT4ge1xyXG4gIGNvbnN0IFt1c2VyQ291bnQsIHNldFVzZXJDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbZXZlbnRDb3VudCwgc2V0RXZlbnRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbZXZlbnREYXRhLCBzZXRFdmVudERhdGFdID0gdXNlU3RhdGUoW10pO1xyXG4gIGNvbnN0IFtldmVudFR5cGVDb3VudHMsIHNldEV2ZW50VHlwZUNvdW50c10gPSB1c2VTdGF0ZTxhbnk+KHtcclxuICAgIERlY29yYXRpb246IDAsXHJcbiAgICBDYXRlcmluZzogMCxcclxuICAgIFRyYW5zcG9ydGF0aW9uOiAwLFxyXG4gICAgU3BlY2lhbEd1ZXN0czogMCxcclxuICAgIFBhcnR5SGFsbDogMCxcclxuICAgIE1hcnJpYWdlSGFsbDogMCxcclxuICAgIEVudGVydGFpbm1lbnQ6IDAsXHJcbiAgfSk7XHJcbiAgY29uc3QgW21vbnRobHlFdmVudENvdW50cywgc2V0TW9udGhseUV2ZW50Q291bnRzXSA9IHVzZVN0YXRlPGFueT4oe30pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgZmV0Y2hEYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYiA9IGdldEZpcmVzdG9yZSgpO1xyXG5cclxuICAgICAgLy8gRmV0Y2ggdXNlciBkYXRhXHJcbiAgICAgIGNvbnN0IHVzZXJzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICd1c2VycycpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHVzZXJzQ29sbGVjdGlvbik7XHJcbiAgICAgICAgc2V0VXNlckNvdW50KHVzZXJzU25hcHNob3Quc2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHR5cGVDb3VudHM6IGFueSA9IHtcclxuICAgICAgICAgIERlY29yYXRpb246IDAsXHJcbiAgICAgICAgICBDYXRlcmluZzogMCxcclxuICAgICAgICAgIFRyYW5zcG9ydGF0aW9uOiAwLFxyXG4gICAgICAgICAgU3BlY2lhbEd1ZXN0czogMCxcclxuICAgICAgICAgIFBhcnR5SGFsbDogMCxcclxuICAgICAgICAgIE1hcnJpYWdlSGFsbDogMCxcclxuICAgICAgICAgIEVudGVydGFpbm1lbnQ6IDAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdXNlcnNTbmFwc2hvdC5mb3JFYWNoKCh1c2VyRG9jKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IHVzZXJEb2MuZGF0YSgpO1xyXG4gICAgICAgICAgaWYgKHVzZXJEYXRhLmV2ZW50VHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlQ291bnRzW3VzZXJEYXRhLmV2ZW50VHlwZV0rKztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0RXZlbnRUeXBlQ291bnRzKHR5cGVDb3VudHMpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVzZXIgY291bnQ6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGZXRjaCBldmVudCBkYXRhXHJcbiAgICAgIGNvbnN0IGV2ZW50c0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uKGRiLCAnZXZlbnR1c2VyJyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGV2ZW50c0NvbGxlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50c0RhdGE6IGFueSA9IGV2ZW50c1NuYXBzaG90LmRvY3MubWFwKChkb2MpID0+IGRvYy5kYXRhKCkpO1xyXG4gICAgICAgIHNldEV2ZW50Q291bnQoZXZlbnRzU25hcHNob3Quc2l6ZSk7XHJcbiAgICAgICAgc2V0RXZlbnREYXRhKGV2ZW50c0RhdGEpO1xyXG5cclxuICAgICAgICAvLyBDb3VudCBldmVudHMgZm9yIGVhY2ggbW9udGhcclxuICAgICAgICBjb25zdCBtb250aGx5Q291bnRzOiBhbnkgPSB7fTtcclxuICAgICAgICBldmVudHNEYXRhLmZvckVhY2goKGV2ZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGV2ZW50RGF0ZSA9IG5ldyBEYXRlKGV2ZW50LmRhdGUpO1xyXG4gICAgICAgICAgY29uc3QgbW9udGhLZXkgPSBgJHtldmVudERhdGUuZ2V0RnVsbFllYXIoKX0tJHtldmVudERhdGUuZ2V0TW9udGgoKSArIDF9YDtcclxuXHJcbiAgICAgICAgICBpZiAobW9udGhseUNvdW50c1ttb250aEtleV0pIHtcclxuICAgICAgICAgICAgbW9udGhseUNvdW50c1ttb250aEtleV0rKztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1vbnRobHlDb3VudHNbbW9udGhLZXldID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0TW9udGhseUV2ZW50Q291bnRzKG1vbnRobHlDb3VudHMpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGV2ZW50IGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZldGNoRGF0YSgpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgdXNlckNoYXJ0T3B0aW9uczogYW55ID0ge1xyXG4gICAgd2lkdGg6IDUwMCxcclxuICAgIGhlaWdodDogNjAwLFxyXG4gICAgZGF0YTogW1xyXG4gICAgICB7IHR5cGVDb3VudDogZXZlbnRUeXBlQ291bnRzLkVudGVydGFpbm1lbnQsIHR5cGVOYW1lOiAnRW50ZXJ0YWlubWVudCcgfSxcclxuICAgICAgeyB0eXBlQ291bnQ6IGV2ZW50VHlwZUNvdW50cy5EZWNvcmF0aW9uLCB0eXBlTmFtZTogJ0RlY29yYXRpb24nIH0sXHJcbiAgICAgIHsgdHlwZUNvdW50OiBldmVudFR5cGVDb3VudHMuQ2F0ZXJpbmcsIHR5cGVOYW1lOiAnQ2F0ZXJpbmcnIH0sXHJcbiAgICAgIHsgdHlwZUNvdW50OiBldmVudFR5cGVDb3VudHMuU3BlY2lhbEd1ZXN0cywgdHlwZU5hbWU6ICdTcGVjaWFsR3Vlc3RzJyB9LFxyXG4gICAgICB7IHR5cGVDb3VudDogZXZlbnRUeXBlQ291bnRzLlRyYW5zcG9ydGF0aW9uLCB0eXBlTmFtZTogJ1RyYW5zcG9ydGF0aW9uJyB9LFxyXG4gICAgICB7IHR5cGVDb3VudDogZXZlbnRUeXBlQ291bnRzLlBhcnR5SGFsbCwgdHlwZU5hbWU6ICdQYXJ0eSBoYWxsJyB9LFxyXG4gICAgICB7IHR5cGVDb3VudDogZXZlbnRUeXBlQ291bnRzLk1hcnJpYWdlSGFsbCwgdHlwZU5hbWU6ICdNYXJyaWFnZUhhbGwnIH0sXHJcbiAgICBdLFxyXG4gICAgdGl0bGU6IHtcclxuICAgICAgdGV4dDogJ1VzZXJzIENvbXBvc2l0aW9uJyxcclxuICAgIH0sXHJcbiAgICBzZXJpZXM6IFtcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdwaWUnLFxyXG4gICAgICAgIGFuZ2xlS2V5OiAndHlwZUNvdW50JyxcclxuICAgICAgICBsYWJlbEtleTogJ3R5cGVOYW1lJyxcclxuICAgICAgICBjYWxsb3V0TGFiZWxLZXk6ICd0eXBlTmFtZScsXHJcbiAgICAgICAgc2VjdG9yTGFiZWxLZXk6ICd0eXBlQ291bnQnLFxyXG4gICAgICAgIHNlY3RvckxhYmVsOiB7XHJcbiAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICB9O1xyXG5cclxuICBjb25zdCBtb250aGx5RXZlbnRDaGFydE9wdGlvbnM6IGFueSA9IHtcclxuICAgIHRpdGxlOiB7XHJcbiAgICAgIHRleHQ6ICdOdW1iZXIgb2YgRXZlbnRzIGJ5IE1vbnRoJyxcclxuICAgIH0sXHJcbiAgICBkYXRhOiBPYmplY3Qua2V5cyhtb250aGx5RXZlbnRDb3VudHMpLm1hcCgobW9udGgpID0+ICh7XHJcbiAgICAgIG1vbnRoLFxyXG4gICAgICBjb3VudDogbW9udGhseUV2ZW50Q291bnRzW21vbnRoXSxcclxuICAgIH0pKSxcclxuICAgIHNlcmllczogW1xyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogJ2JhcicsXHJcbiAgICAgICAgeEtleTogJ21vbnRoJyxcclxuICAgICAgICB5S2V5OiAnY291bnQnLFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT0nZmxleCc+XHJcbiAgICAgIDxTaWRlYmFyLz5cclxuICAgIFxyXG4gICBcclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTMwMCBwLTEwIHJvdW5kZWQtbWQgbXgtMjQgbXQtNiBoLTI0XCI+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtYmxhY2sgdGV4dC1sZ1wiPk51bWJlciBvZiBVc2Vyczoge3VzZXJDb3VudH08L3A+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS0zMDAgcC0xMCByb3VuZGVkLW1kICBteC0xNiAgbXQtNiBoLTI0XCI+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtYmxhY2sgdGV4dC1sZ1wiPk51bWJlciBvZiBFdmVudHM6IHtldmVudENvdW50fTwvcD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTYgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj5cclxuICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5Vc2VycyBDb21wb3NpdGlvbjwvaDI+XHJcbiAgICAgICAgICAgIDxBZ0NoYXJ0c1JlYWN0IG9wdGlvbnM9e3VzZXJDaGFydE9wdGlvbnN9IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC02IGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+TW9udGhseSBFdmVudCBDb3VudHM8L2gyPlxyXG4gICAgICAgICAgICA8QWdDaGFydHNSZWFjdCBvcHRpb25zPXttb250aGx5RXZlbnRDaGFydE9wdGlvbnN9IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgXHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGFzaGJvYXJkO1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImdldEZpcmVzdG9yZSIsImNvbGxlY3Rpb24iLCJnZXREb2NzIiwiQWdDaGFydHNSZWFjdCIsIlNpZGViYXIiLCJEYXNoYm9hcmQiLCJ1c2VyQ291bnQiLCJzZXRVc2VyQ291bnQiLCJldmVudENvdW50Iiwic2V0RXZlbnRDb3VudCIsImV2ZW50RGF0YSIsInNldEV2ZW50RGF0YSIsImV2ZW50VHlwZUNvdW50cyIsInNldEV2ZW50VHlwZUNvdW50cyIsIkRlY29yYXRpb24iLCJDYXRlcmluZyIsIlRyYW5zcG9ydGF0aW9uIiwiU3BlY2lhbEd1ZXN0cyIsIlBhcnR5SGFsbCIsIk1hcnJpYWdlSGFsbCIsIkVudGVydGFpbm1lbnQiLCJtb250aGx5RXZlbnRDb3VudHMiLCJzZXRNb250aGx5RXZlbnRDb3VudHMiLCJmZXRjaERhdGEiLCJkYiIsInVzZXJzQ29sbGVjdGlvbiIsInVzZXJzU25hcHNob3QiLCJzaXplIiwidHlwZUNvdW50cyIsImZvckVhY2giLCJ1c2VyRG9jIiwidXNlckRhdGEiLCJkYXRhIiwiZXZlbnRUeXBlIiwiZXJyb3IiLCJjb25zb2xlIiwiZXZlbnRzQ29sbGVjdGlvbiIsImV2ZW50c1NuYXBzaG90IiwiZXZlbnRzRGF0YSIsImRvY3MiLCJtYXAiLCJkb2MiLCJtb250aGx5Q291bnRzIiwiZXZlbnQiLCJldmVudERhdGUiLCJEYXRlIiwiZGF0ZSIsIm1vbnRoS2V5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInVzZXJDaGFydE9wdGlvbnMiLCJ3aWR0aCIsImhlaWdodCIsInR5cGVDb3VudCIsInR5cGVOYW1lIiwidGl0bGUiLCJ0ZXh0Iiwic2VyaWVzIiwidHlwZSIsImFuZ2xlS2V5IiwibGFiZWxLZXkiLCJjYWxsb3V0TGFiZWxLZXkiLCJzZWN0b3JMYWJlbEtleSIsInNlY3RvckxhYmVsIiwiY29sb3IiLCJmb250V2VpZ2h0IiwibW9udGhseUV2ZW50Q2hhcnRPcHRpb25zIiwiT2JqZWN0Iiwia2V5cyIsIm1vbnRoIiwiY291bnQiLCJ4S2V5IiwieUtleSIsImRpdiIsImNsYXNzTmFtZSIsInAiLCJoMiIsIm9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/dashboard.tsx\n"));

/***/ }),

/***/ "./pages/sidebar.tsx":
/*!***************************!*\
  !*** ./pages/sidebar.tsx ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst Sidebar = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"bg-gradient-to-b from-blue-700 via-blue-800 to-gray-900  p-3 md:flex md:justify-between min-h-screen relative\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                className: \"md:items-center space-x-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"mx-2 mb-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            href: \"/userstable\",\n                            className: \"text-lg text-white hover:text-cyan-100 duration-500\",\n                            children: \"Users\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\sidebar.tsx\",\n                            lineNumber: 9,\n                            columnNumber: 9\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\sidebar.tsx\",\n                        lineNumber: 8,\n                        columnNumber: 7\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"mx-4 mb-4\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                            href: \"/eventable\",\n                            className: \"text-lg text-white hover:text-cyan-100 duration-500\",\n                            children: \"Events\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\sidebar.tsx\",\n                            lineNumber: 14,\n                            columnNumber: 9\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\sidebar.tsx\",\n                        lineNumber: 13,\n                        columnNumber: 7\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\sidebar.tsx\",\n                lineNumber: 7,\n                columnNumber: 5\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\sidebar.tsx\",\n            lineNumber: 6,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Shaye\\\\OneDrive\\\\Desktop\\\\cpoy\\\\event\\\\pages\\\\sidebar.tsx\",\n        lineNumber: 5,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Sidebar;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Sidebar);\nvar _c;\n$RefreshReg$(_c, \"Sidebar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9zaWRlYmFyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QjtBQUNJO0FBQzdCLE1BQU1FLFVBQVU7SUFDZCxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDZiw0RUFBQ0Q7WUFBSUMsV0FBVTtzQkFDZiw0RUFBQ0M7Z0JBQUdELFdBQVU7O2tDQUNaLDhEQUFDRTt3QkFBR0YsV0FBVTtrQ0FDWiw0RUFBQ0gsa0RBQUlBOzRCQUFDTSxNQUFLOzRCQUFjSCxXQUFVO3NDQUFzRDs7Ozs7Ozs7Ozs7a0NBSTNGLDhEQUFDRTt3QkFBR0YsV0FBVTtrQ0FDWiw0RUFBQ0gsa0RBQUlBOzRCQUFDTSxNQUFLOzRCQUFhSCxXQUFVO3NDQUF1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUWpHO0tBbkJNRjtBQXFCTiwrREFBZUEsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9zaWRlYmFyLnRzeD85NDAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuY29uc3QgU2lkZWJhciA9ICgpID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9J2ZsZXgnPlxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmFkaWVudC10by1iIGZyb20tYmx1ZS03MDAgdmlhLWJsdWUtODAwIHRvLWdyYXktOTAwICBwLTMgbWQ6ZmxleCBtZDpqdXN0aWZ5LWJldHdlZW4gbWluLWgtc2NyZWVuIHJlbGF0aXZlXCI+XHJcbiAgICA8dWwgY2xhc3NOYW1lPVwibWQ6aXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxyXG4gICAgICA8bGkgY2xhc3NOYW1lPVwibXgtMiBtYi00XCI+XHJcbiAgICAgICAgPExpbmsgaHJlZj1cIi91c2Vyc3RhYmxlXCIgY2xhc3NOYW1lPVwidGV4dC1sZyB0ZXh0LXdoaXRlIGhvdmVyOnRleHQtY3lhbi0xMDAgZHVyYXRpb24tNTAwXCI+XHJcbiAgICAgICAgICBVc2Vyc1xyXG4gICAgICAgIDwvTGluaz5cclxuICAgICAgPC9saT5cclxuICAgICAgPGxpIGNsYXNzTmFtZT1cIm14LTQgbWItNFwiPlxyXG4gICAgICAgIDxMaW5rIGhyZWY9XCIvZXZlbnRhYmxlXCIgY2xhc3NOYW1lPVwidGV4dC1sZyB0ZXh0LXdoaXRlIGhvdmVyOnRleHQtY3lhbi0xMDAgZHVyYXRpb24tNTAwXCIgPlxyXG4gICAgICAgICAgRXZlbnRzXHJcbiAgICAgICAgPC9MaW5rPlxyXG4gICAgICA8L2xpPlxyXG4gICAgPC91bD5cclxuICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuICApXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpZGViYXI7Il0sIm5hbWVzIjpbIlJlYWN0IiwiTGluayIsIlNpZGViYXIiLCJkaXYiLCJjbGFzc05hbWUiLCJ1bCIsImxpIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/sidebar.tsx\n"));

/***/ }),

/***/ "./node_modules/ag-charts-react/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/ag-charts-react/dist/index.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgChartsReact: function() { return /* binding */ AgChartsReact; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var ag_charts_community__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-community */ \"./node_modules/ag-charts-community/dist/package/main.esm.js\");\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar AgChartsReact = /*#__PURE__*/function (_Component) {\n  _inherits(AgChartsReact, _Component);\n  var _super = _createSuper(AgChartsReact);\n  function AgChartsReact(props) {\n    var _this;\n    _classCallCheck(this, AgChartsReact);\n    _this = _super.call(this, props);\n    _this.props = props;\n    _this.chart = void 0;\n    _this.chartRef = void 0;\n    _this.chartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    return _this;\n  }\n  _createClass(AgChartsReact, [{\n    key: \"render\",\n    value: function render() {\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)('div', {\n        style: this.createStyleForDiv(),\n        ref: this.chartRef\n      });\n    }\n  }, {\n    key: \"createStyleForDiv\",\n    value: function createStyleForDiv() {\n      var _this$props$container;\n      return _objectSpread2({\n        height: '100%'\n      }, (_this$props$container = this.props.containerStyle) !== null && _this$props$container !== void 0 ? _this$props$container : {});\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n      var options = this.applyContainerIfNotSet(this.props.options);\n      var chart = ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.create(options);\n      this.chart = chart;\n      chart.chart.waitForUpdate().then(function () {\n        var _this2$props$onChartR, _this2$props;\n        return (_this2$props$onChartR = (_this2$props = _this2.props).onChartReady) === null || _this2$props$onChartR === void 0 ? void 0 : _this2$props$onChartR.call(_this2$props, chart);\n      });\n    }\n  }, {\n    key: \"applyContainerIfNotSet\",\n    value: function applyContainerIfNotSet(propsOptions) {\n      if (propsOptions.container) {\n        return propsOptions;\n      }\n      return _objectSpread2(_objectSpread2({}, propsOptions), {}, {\n        container: this.chartRef.current\n      });\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      this.processPropsChanges(this.props, nextProps);\n\n      // we want full control of the dom, as AG Charts doesn't use React internally,\n      // so for performance reasons we tell React we don't need render called after\n      // property changes.\n      return false;\n    }\n  }, {\n    key: \"processPropsChanges\",\n    value: function processPropsChanges(prevProps, nextProps) {\n      if (this.chart) {\n        ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.update(this.chart, this.applyContainerIfNotSet(nextProps.options));\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.chart) {\n        this.chart.destroy();\n        this.chart = undefined;\n      }\n    }\n  }]);\n  return AgChartsReact;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLXJlYWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0RDtBQUNiOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0RBQWE7QUFDMUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrSEFBK0g7QUFDdEk7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseURBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEU7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBUTtBQUNoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLDRDQUFTOztBQUVjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hZy1jaGFydHMtcmVhY3QvZGlzdC9pbmRleC5tanM/MGY4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWYsIGNyZWF0ZUVsZW1lbnQsIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFnQ2hhcnRzIH0gZnJvbSAnYWctY2hhcnRzLWNvbW11bml0eSc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG52YXIgQWdDaGFydHNSZWFjdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQWdDaGFydHNSZWFjdCwgX0NvbXBvbmVudCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWdDaGFydHNSZWFjdCk7XG4gIGZ1bmN0aW9uIEFnQ2hhcnRzUmVhY3QocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFnQ2hhcnRzUmVhY3QpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpO1xuICAgIF90aGlzLnByb3BzID0gcHJvcHM7XG4gICAgX3RoaXMuY2hhcnQgPSB2b2lkIDA7XG4gICAgX3RoaXMuY2hhcnRSZWYgPSB2b2lkIDA7XG4gICAgX3RoaXMuY2hhcnRSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEFnQ2hhcnRzUmVhY3QsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICBzdHlsZTogdGhpcy5jcmVhdGVTdHlsZUZvckRpdigpLFxuICAgICAgICByZWY6IHRoaXMuY2hhcnRSZWZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVTdHlsZUZvckRpdlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdHlsZUZvckRpdigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRjb250YWluZXI7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgfSwgKF90aGlzJHByb3BzJGNvbnRhaW5lciA9IHRoaXMucHJvcHMuY29udGFpbmVyU3R5bGUpICE9PSBudWxsICYmIF90aGlzJHByb3BzJGNvbnRhaW5lciAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkY29udGFpbmVyIDoge30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmFwcGx5Q29udGFpbmVySWZOb3RTZXQodGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICAgIHZhciBjaGFydCA9IEFnQ2hhcnRzLmNyZWF0ZShvcHRpb25zKTtcbiAgICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICAgIGNoYXJ0LmNoYXJ0LndhaXRGb3JVcGRhdGUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzMiRwcm9wcyRvbkNoYXJ0UiwgX3RoaXMyJHByb3BzO1xuICAgICAgICByZXR1cm4gKF90aGlzMiRwcm9wcyRvbkNoYXJ0UiA9IChfdGhpczIkcHJvcHMgPSBfdGhpczIucHJvcHMpLm9uQ2hhcnRSZWFkeSkgPT09IG51bGwgfHwgX3RoaXMyJHByb3BzJG9uQ2hhcnRSID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpczIkcHJvcHMkb25DaGFydFIuY2FsbChfdGhpczIkcHJvcHMsIGNoYXJ0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseUNvbnRhaW5lcklmTm90U2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5Q29udGFpbmVySWZOb3RTZXQocHJvcHNPcHRpb25zKSB7XG4gICAgICBpZiAocHJvcHNPcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gcHJvcHNPcHRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wc09wdGlvbnMpLCB7fSwge1xuICAgICAgICBjb250YWluZXI6IHRoaXMuY2hhcnRSZWYuY3VycmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3VsZENvbXBvbmVudFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICB0aGlzLnByb2Nlc3NQcm9wc0NoYW5nZXModGhpcy5wcm9wcywgbmV4dFByb3BzKTtcblxuICAgICAgLy8gd2Ugd2FudCBmdWxsIGNvbnRyb2wgb2YgdGhlIGRvbSwgYXMgQUcgQ2hhcnRzIGRvZXNuJ3QgdXNlIFJlYWN0IGludGVybmFsbHksXG4gICAgICAvLyBzbyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyB3ZSB0ZWxsIFJlYWN0IHdlIGRvbid0IG5lZWQgcmVuZGVyIGNhbGxlZCBhZnRlclxuICAgICAgLy8gcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Byb3BzQ2hhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzUHJvcHNDaGFuZ2VzKHByZXZQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgICBBZ0NoYXJ0cy51cGRhdGUodGhpcy5jaGFydCwgdGhpcy5hcHBseUNvbnRhaW5lcklmTm90U2V0KG5leHRQcm9wcy5vcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBZ0NoYXJ0c1JlYWN0O1xufShDb21wb25lbnQpO1xuXG5leHBvcnQgeyBBZ0NoYXJ0c1JlYWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ag-charts-react/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CShaye%5COneDrive%5CDesktop%5Ccpoy%5Cevent%5Cpages%5Cdashboard.tsx&page=%2Fdashboard!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);